
project_build/project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .mios32_bsl   00004000  08000000  08000000  00008000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .isr_vector   000001e4  08004000  08004000  0000c000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00005cec  080041e4  080041e4  0000c1e4  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000004d8  08009ed0  08009ed0  00011ed0  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00000058  20000000  0800a3a8  00018000  2**3  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00003088  20000058  0800a400  00018058  2**3  ALLOC
  6 ._usrstack    00000100  200030e0  200030e0  00018058  2**0  CONTENTS
  7 .ARM.attributes 00000031  00000000  00000000  00018158  2**0  CONTENTS, READONLY
  8 .comment      00000011  00000000  00000000  00018189  2**0  CONTENTS, READONLY
  9 .debug_aranges 000021b0  00000000  00000000  000181a0  2**3  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000056d8  00000000  00000000  0001a350  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0001acc6  00000000  00000000  0001fa28  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000062fc  00000000  00000000  0003a6ee  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000c572  00000000  00000000  000409ea  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00004b20  00000000  00000000  0004cf5c  2**2  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00009c2b  00000000  00000000  00051a7c  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f4b4  00000000  00000000  0005b6a7  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubtypes 0000233d  00000000  00000000  0006ab5b  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00002238  00000000  00000000  0006ce98  2**0  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080041e4 <APP_Init>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
{
 80041e4:	b508      	push	{r3, lr}
  // initialize all LEDs
  MIOS32_BOARD_LED_Init(0xffffffff);
 80041e6:	f04f 30ff 	mov.w	r0, #4294967295
 80041ea:	f002 ffe3 	bl	80071b4 <MIOS32_BOARD_LED_Init>
  MIOS32_LCD_Clear();
 80041ee:	f001 f9a1 	bl	8005534 <MIOS32_LCD_Clear>
}
 80041f2:	bd08      	pop	{r3, pc}

080041f4 <APP_Background>:
/////////////////////////////////////////////////////////////////////////////
// This task is running endless in background
/////////////////////////////////////////////////////////////////////////////
void APP_Background(void)
{
}
 80041f4:	4770      	bx	lr
	...

080041f8 <APP_MIDI_NotifyPackage>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a MIDI package has been received
/////////////////////////////////////////////////////////////////////////////
void APP_MIDI_NotifyPackage(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 80041f8:	b538      	push	{r3, r4, r5, lr}
 80041fa:	460c      	mov	r4, r1
 80041fc:	f3c1 4507 	ubfx	r5, r1, #16, #8
  // toggle Status LED on each incoming MIDI package
  MIOS32_BOARD_LED_Set(1, ~MIOS32_BOARD_LED_Get());
 8004200:	f003 f80c 	bl	800721c <MIOS32_BOARD_LED_Get>
 8004204:	43c1      	mvns	r1, r0
 8004206:	2001      	movs	r0, #1
 8004208:	f002 fff4 	bl	80071f4 <MIOS32_BOARD_LED_Set>

  // 1) the LED should be turned on whenever a Note On Event with velocity > 0
  // has been received
  if( midi_package.type == NoteOn && midi_package.velocity > 0 ) {
 800420c:	f004 030f 	and.w	r3, r4, #15
 8004210:	2b09      	cmp	r3, #9
 8004212:	d106      	bne.n	8004222 <APP_MIDI_NotifyPackage+0x2a>
 8004214:	0e23      	lsrs	r3, r4, #24
 8004216:	d006      	beq.n	8004226 <APP_MIDI_NotifyPackage+0x2e>
    // determine pin number (add offset, so that the first LED starts at C-2)
    u8 pin = (midi_package.note - MIDI_STARTNOTE) & 0x7f;
 8004218:	3d18      	subs	r5, #24
    // turn on LED
    MIOS32_DOUT_PinSet(pin, 1);
 800421a:	f005 007f 	and.w	r0, r5, #127	; 0x7f
 800421e:	2101      	movs	r1, #1
 8004220:	e00a      	b.n	8004238 <APP_MIDI_NotifyPackage+0x40>
  }

  // 2) the LED should be turned off whenever a Note Off Event or a Note On
  // event with velocity == 0 has been received (the MIDI spec says, that velocity 0
  // should be handled like Note Off)
  else if( (midi_package.type == NoteOff) ||
 8004222:	2b08      	cmp	r3, #8
 8004224:	d004      	beq.n	8004230 <APP_MIDI_NotifyPackage+0x38>
	   (midi_package.type == NoteOn && midi_package.velocity == 0) ) {
 8004226:	4b06      	ldr	r3, [pc, #24]	; (8004240 <APP_MIDI_NotifyPackage+0x48>)
 8004228:	ea04 0303 	and.w	r3, r4, r3
  }

  // 2) the LED should be turned off whenever a Note Off Event or a Note On
  // event with velocity == 0 has been received (the MIDI spec says, that velocity 0
  // should be handled like Note Off)
  else if( (midi_package.type == NoteOff) ||
 800422c:	2b09      	cmp	r3, #9
 800422e:	d105      	bne.n	800423c <APP_MIDI_NotifyPackage+0x44>
	   (midi_package.type == NoteOn && midi_package.velocity == 0) ) {
    // determine pin number (add offset, so that the first LED starts at C-2)
    u8 pin = (midi_package.note - MIDI_STARTNOTE) & 0x7f;
 8004230:	3d18      	subs	r5, #24
    // turn off LED
    MIOS32_DOUT_PinSet(pin, 0);
 8004232:	f005 007f 	and.w	r0, r5, #127	; 0x7f
 8004236:	2100      	movs	r1, #0
 8004238:	f000 ff5c 	bl	80050f4 <MIOS32_DOUT_PinSet>
  }
}
 800423c:	bd38      	pop	{r3, r4, r5, pc}
 800423e:	bf00      	nop
 8004240:	ff00000f 	.word	0xff00000f

08004244 <APP_SRIO_ServicePrepare>:
/////////////////////////////////////////////////////////////////////////////
// This hook is called before the shift register chain is scanned
/////////////////////////////////////////////////////////////////////////////
void APP_SRIO_ServicePrepare(void)
{
}
 8004244:	4770      	bx	lr

08004246 <APP_SRIO_ServiceFinish>:
/////////////////////////////////////////////////////////////////////////////
// This hook is called after the shift register chain has been scanned
/////////////////////////////////////////////////////////////////////////////
void APP_SRIO_ServiceFinish(void)
{
}
 8004246:	4770      	bx	lr

08004248 <APP_DIN_NotifyToggle>:
/////////////////////////////////////////////////////////////////////////////
// This hook is called when a button has been toggled
// pin_value is 1 when button released, and 0 when button pressed
/////////////////////////////////////////////////////////////////////////////
void APP_DIN_NotifyToggle(u32 pin, u32 pin_value)
{
 8004248:	b510      	push	{r4, lr}
  // toggle Status LED on each DIN pin change
  MIOS32_BOARD_LED_Set(1, ~MIOS32_BOARD_LED_Get());
 800424a:	f002 ffe7 	bl	800721c <MIOS32_BOARD_LED_Get>
 800424e:	43c1      	mvns	r1, r0
 8004250:	2001      	movs	r0, #1
 8004252:	f002 ffcf 	bl	80071f4 <MIOS32_BOARD_LED_Set>
  //MIOS32_LCD_Clear();

  // send MIDI event
  //MIOS32_MIDI_SendNoteOn(DEFAULT, Chn1, (pin + MIDI_STARTNOTE) & 0x7f, pin_value ? 0x00 : 0x7f);
  int value = MIOS32_DIN_SRGet(0);
 8004256:	2000      	movs	r0, #0
 8004258:	f000 fef4 	bl	8005044 <MIOS32_DIN_SRGet>
 800425c:	4604      	mov	r4, r0
  MIOS32_MIDI_SendCC(DEFAULT, Chn1, 0x10, value);
 800425e:	b2c3      	uxtb	r3, r0
 8004260:	2000      	movs	r0, #0
 8004262:	4601      	mov	r1, r0
 8004264:	2210      	movs	r2, #16
 8004266:	f001 fa7a 	bl	800575e <MIOS32_MIDI_SendCC>
  MIOS32_LCD_PrintFormattedString("%02d", value);
 800426a:	4621      	mov	r1, r4
 800426c:	4801      	ldr	r0, [pc, #4]	; (8004274 <APP_DIN_NotifyToggle+0x2c>)
 800426e:	f001 f9c1 	bl	80055f4 <MIOS32_LCD_PrintFormattedString>
}
 8004272:	bd10      	pop	{r4, pc}
 8004274:	08009ed0 	.word	0x08009ed0

08004278 <APP_ENC_NotifyChange>:
// incrementer is positive when encoder has been turned clockwise, else
// it is negative
/////////////////////////////////////////////////////////////////////////////
void APP_ENC_NotifyChange(u32 encoder, s32 incrementer)
{
}
 8004278:	4770      	bx	lr

0800427a <APP_AIN_NotifyChange>:
/////////////////////////////////////////////////////////////////////////////
// This hook is called when a pot has been moved
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
}
 800427a:	4770      	bx	lr

0800427c <SRIO_ServiceFinish>:

/////////////////////////////////////////////////////////////////////////////
// Application Tick Hook (called by FreeRTOS each mS)
/////////////////////////////////////////////////////////////////////////////
void SRIO_ServiceFinish(void)
{
 800427c:	b508      	push	{r3, lr}
#ifndef MIOS32_DONT_USE_SRIO

# ifndef MIOS32_DONT_USE_ENC
  // update encoder states
  MIOS32_ENC_UpdateStates();
 800427e:	f000 ff93 	bl	80051a8 <MIOS32_ENC_UpdateStates>
# endif

  // notify application about finished SRIO scan
  APP_SRIO_ServiceFinish();
 8004282:	f7ff ffe0 	bl	8004246 <APP_SRIO_ServiceFinish>
#endif
}
 8004286:	bd08      	pop	{r3, pc}

08004288 <TASK_MIDI_Hooks>:
// MIDI task (separated from TASK_Hooks() to ensure parallel handling of
// MIDI events if a hook in TASK_Hooks() blocks)
/////////////////////////////////////////////////////////////////////////////
#if !defined(MIOS32_DONT_USE_MIDI)
static void TASK_MIDI_Hooks(void *pvParameters)
{
 8004288:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 800428a:	f000 fa69 	bl	8004760 <xTaskGetTickCount>
 800428e:	ac02      	add	r4, sp, #8
 8004290:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8004294:	2101      	movs	r1, #1
 8004296:	4620      	mov	r0, r4
 8004298:	f000 fb64 	bl	8004964 <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 800429c:	f000 fa60 	bl	8004760 <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 80042a0:	9a01      	ldr	r2, [sp, #4]
 80042a2:	1f43      	subs	r3, r0, #5
 80042a4:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 80042a6:	bf38      	it	cc
 80042a8:	9001      	strcc	r0, [sp, #4]

    // handle timeout/expire counters and USB packages
    MIOS32_MIDI_Periodic_mS();
 80042aa:	f001 fe59 	bl	8005f60 <MIOS32_MIDI_Periodic_mS>

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 80042ae:	4802      	ldr	r0, [pc, #8]	; (80042b8 <TASK_MIDI_Hooks+0x30>)
 80042b0:	f001 fcbc 	bl	8005c2c <MIOS32_MIDI_Receive_Handler>
  }
 80042b4:	e7ee      	b.n	8004294 <TASK_MIDI_Hooks+0xc>
 80042b6:	bf00      	nop
 80042b8:	080041f9 	.word	0x080041f9

080042bc <TASK_Hooks>:

/////////////////////////////////////////////////////////////////////////////
// Remaining application hooks
/////////////////////////////////////////////////////////////////////////////
static void TASK_Hooks(void *pvParameters)
{
 80042bc:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 80042be:	f000 fa4f 	bl	8004760 <xTaskGetTickCount>
 80042c2:	ac02      	add	r4, sp, #8
 80042c4:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 80042c8:	2101      	movs	r1, #1
 80042ca:	4620      	mov	r0, r4
 80042cc:	f000 fb4a 	bl	8004964 <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 80042d0:	f000 fa46 	bl	8004760 <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 80042d4:	9a01      	ldr	r2, [sp, #4]
 80042d6:	1f43      	subs	r3, r0, #5
 80042d8:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 80042da:	bf38      	it	cc
 80042dc:	9001      	strcc	r0, [sp, #4]

#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
    // check for DIN pin changes, call APP_DIN_NotifyToggle on each toggled pin
    MIOS32_DIN_Handler(APP_DIN_NotifyToggle);
 80042de:	4806      	ldr	r0, [pc, #24]	; (80042f8 <TASK_Hooks+0x3c>)
 80042e0:	f000 fed2 	bl	8005088 <MIOS32_DIN_Handler>

    // check for encoder changes, call APP_ENC_NotifyChanged on each change
# ifndef MIOS32_DONT_USE_ENC
    MIOS32_ENC_Handler(APP_ENC_NotifyChange);
 80042e4:	4805      	ldr	r0, [pc, #20]	; (80042fc <TASK_Hooks+0x40>)
 80042e6:	f001 f89d 	bl	8005424 <MIOS32_ENC_Handler>
# endif
#endif

#if !defined(MIOS32_DONT_USE_AIN)
    // check for AIN pin changes, call APP_AIN_NotifyChange on each pin change
    MIOS32_AIN_Handler(APP_AIN_NotifyChange);
 80042ea:	4805      	ldr	r0, [pc, #20]	; (8004300 <TASK_Hooks+0x44>)
 80042ec:	f003 f935 	bl	800755a <MIOS32_AIN_Handler>
#endif

#if !defined(MIOS32_DONT_USE_COM)
    // check for incoming COM messages
    MIOS32_COM_Receive_Handler();
 80042f0:	f001 febd 	bl	800606e <MIOS32_COM_Receive_Handler>
#endif
  }
 80042f4:	e7e8      	b.n	80042c8 <TASK_Hooks+0xc>
 80042f6:	bf00      	nop
 80042f8:	08004249 	.word	0x08004249
 80042fc:	08004279 	.word	0x08004279
 8004300:	0800427b 	.word	0x0800427b

08004304 <main>:

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 8004304:	b530      	push	{r4, r5, lr}
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 8004306:	2000      	movs	r0, #0

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 8004308:	b085      	sub	sp, #20
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 800430a:	f002 f91b 	bl	8006544 <MIOS32_SYS_Init>
#endif
#ifndef MIOS32_DONT_USE_DELAY
  MIOS32_DELAY_Init(0);
 800430e:	2000      	movs	r0, #0
 8004310:	f003 f8f2 	bl	80074f8 <MIOS32_DELAY_Init>
#endif
#ifndef MIOS32_DONT_USE_BOARD
  MIOS32_BOARD_Init(0);
 8004314:	2000      	movs	r0, #0
 8004316:	f002 ff43 	bl	80071a0 <MIOS32_BOARD_Init>
#endif
#ifndef MIOS32_DONT_USE_SPI
  MIOS32_SPI_Init(0);
 800431a:	2000      	movs	r0, #0
 800431c:	f002 fdc0 	bl	8006ea0 <MIOS32_SPI_Init>
#endif
#ifndef MIOS32_DONT_USE_SRIO
  MIOS32_SRIO_Init(0);
 8004320:	2000      	movs	r0, #0
 8004322:	f000 fe03 	bl	8004f2c <MIOS32_SRIO_Init>
#endif
#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DIN_Init(0);
 8004326:	2000      	movs	r0, #0
 8004328:	f000 fe76 	bl	8005018 <MIOS32_DIN_Init>
#endif
#if !defined(MIOS32_DONT_USE_DOUT) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DOUT_Init(0);
 800432c:	2000      	movs	r0, #0
 800432e:	f000 fed3 	bl	80050d8 <MIOS32_DOUT_Init>
#endif
#if !defined(MIOS32_DONT_USE_ENC) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_ENC_Init(0);
 8004332:	2000      	movs	r0, #0
 8004334:	f000 ff0a 	bl	800514c <MIOS32_ENC_Init>
#endif
#if !defined(MIOS32_DONT_USE_MF)
  MIOS32_MF_Init(0);
 8004338:	2000      	movs	r0, #0
 800433a:	f002 f865 	bl	8006408 <MIOS32_MF_Init>
#endif
#if !defined(MIOS32_DONT_USE_AIN)
  MIOS32_AIN_Init(0);
 800433e:	2000      	movs	r0, #0
 8004340:	f003 f908 	bl	8007554 <MIOS32_AIN_Init>
#endif
#ifndef MIOS32_DONT_USE_IIC_BS
  MIOS32_IIC_BS_Init(0);
 8004344:	2000      	movs	r0, #0
 8004346:	f002 f85c 	bl	8006402 <MIOS32_IIC_BS_Init>
#endif
#ifndef MIOS32_DONT_USE_USB
  MIOS32_USB_Init(0);
 800434a:	2000      	movs	r0, #0
 800434c:	f003 fa4e 	bl	80077ec <MIOS32_USB_Init>
#endif
#ifndef MIOS32_DONT_USE_MIDI
  MIOS32_MIDI_Init(0);
 8004350:	2000      	movs	r0, #0
 8004352:	f001 f96b 	bl	800562c <MIOS32_MIDI_Init>
#endif
#ifndef MIOS32_DONT_USE_OSC
  MIOS32_OSC_Init(0);
 8004356:	2000      	movs	r0, #0
 8004358:	f001 fe50 	bl	8005ffc <MIOS32_OSC_Init>
#endif
#ifndef MIOS32_DONT_USE_COM
  MIOS32_COM_Init(0);
 800435c:	2000      	movs	r0, #0
 800435e:	f001 fe53 	bl	8006008 <MIOS32_COM_Init>
#endif
#ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_Init(0);
 8004362:	2000      	movs	r0, #0
 8004364:	f001 f8be 	bl	80054e4 <MIOS32_LCD_Init>
#ifdef MIOS32_USE_I2S
  MIOS32_I2S_Init(0);
#endif

  // call C++ constructors
  __libc_init_array();
 8004368:	f005 fd58 	bl	8009e1c <__libc_init_array>

  // initialize application
  APP_Init();
 800436c:	f7ff ff3a 	bl	80041e4 <APP_Init>

#if MIOS32_LCD_BOOT_MSG_DELAY
  // print boot message
# ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_PrintBootMessage();
 8004370:	f001 f920 	bl	80055b4 <MIOS32_LCD_PrintBootMessage>
 8004374:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
    MIOS32_DELAY_Wait_uS(1000);
 8004378:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800437c:	f003 f8de 	bl	800753c <MIOS32_DELAY_Wait_uS>
# endif

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
 8004380:	f114 34ff 	adds.w	r4, r4, #4294967295
 8004384:	d1f8      	bne.n	8004378 <main+0x74>
    MIOS32_DELAY_Wait_uS(1000);
# endif
#endif

  // start the task which calls the application hooks
  xTaskCreate(TASK_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 8004386:	2503      	movs	r5, #3
 8004388:	4623      	mov	r3, r4
 800438a:	490d      	ldr	r1, [pc, #52]	; (80043c0 <main+0xbc>)
 800438c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004390:	480c      	ldr	r0, [pc, #48]	; (80043c4 <main+0xc0>)
 8004392:	9500      	str	r5, [sp, #0]
 8004394:	9401      	str	r4, [sp, #4]
 8004396:	9402      	str	r4, [sp, #8]
 8004398:	9403      	str	r4, [sp, #12]
 800439a:	f000 f8e7 	bl	800456c <xTaskGenericCreate>
#if !defined(MIOS32_DONT_USE_MIDI)
  xTaskCreate(TASK_MIDI_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 800439e:	4908      	ldr	r1, [pc, #32]	; (80043c0 <main+0xbc>)
 80043a0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80043a4:	4623      	mov	r3, r4
 80043a6:	4808      	ldr	r0, [pc, #32]	; (80043c8 <main+0xc4>)
 80043a8:	9500      	str	r5, [sp, #0]
 80043aa:	9401      	str	r4, [sp, #4]
 80043ac:	9402      	str	r4, [sp, #8]
 80043ae:	9403      	str	r4, [sp, #12]
 80043b0:	f000 f8dc 	bl	800456c <xTaskGenericCreate>
#endif

  // start the scheduler
  vTaskStartScheduler();
 80043b4:	f000 f9a8 	bl	8004708 <vTaskStartScheduler>

  // Will only get here if there was not enough heap space to create the idle task
  return 0;
}
 80043b8:	4620      	mov	r0, r4
 80043ba:	b005      	add	sp, #20
 80043bc:	bd30      	pop	{r4, r5, pc}
 80043be:	bf00      	nop
 80043c0:	08009ed5 	.word	0x08009ed5
 80043c4:	080042bd 	.word	0x080042bd
 80043c8:	08004289 	.word	0x08004289

080043cc <vApplicationTickHook>:
  APP_SRIO_ServiceFinish();
#endif
}

void vApplicationTickHook(void)
{
 80043cc:	b508      	push	{r3, lr}
#if !defined(MIOS32_DONT_USE_SRIO) && !defined(MIOS32_DONT_SERVICE_SRIO_SCAN)
  // notify application about SRIO scan start
  APP_SRIO_ServicePrepare();
 80043ce:	f7ff ff39 	bl	8004244 <APP_SRIO_ServicePrepare>

  // start next SRIO scan - IRQ notification to SRIO_ServiceFinish()
  MIOS32_SRIO_ScanStart(SRIO_ServiceFinish);
 80043d2:	4802      	ldr	r0, [pc, #8]	; (80043dc <vApplicationTickHook+0x10>)
 80043d4:	f000 fdf4 	bl	8004fc0 <MIOS32_SRIO_ScanStart>
#endif
}
 80043d8:	bd08      	pop	{r3, pc}
 80043da:	bf00      	nop
 80043dc:	0800427d 	.word	0x0800427d

080043e0 <vApplicationIdleHook>:

/////////////////////////////////////////////////////////////////////////////
// Idle Hook (called by FreeRTOS when nothing else to do)
/////////////////////////////////////////////////////////////////////////////
void vApplicationIdleHook(void)
{
 80043e0:	b508      	push	{r3, lr}
  // branch endless to application
  while( 1 ) {
    APP_Background();
 80043e2:	f7ff ff07 	bl	80041f4 <APP_Background>
 80043e6:	e7fc      	b.n	80043e2 <vApplicationIdleHook+0x2>

080043e8 <_abort>:
// This function aborts any operations, but keeps MIDI alive (for uploading
// a new firmware)
// If MIDI isn't enabled, the status LED will be flashed
/////////////////////////////////////////////////////////////////////////////
void _abort(void)
{
 80043e8:	b570      	push	{r4, r5, r6, lr}
  // stop other tasks from running
  portENTER_CRITICAL();
 80043ea:	f000 fbc9 	bl	8004b80 <vPortEnterCritical>

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
 80043ee:	2400      	movs	r4, #0
  while( 1 ) {
    ++delay_ctr;

    if( (delay_ctr % 100) == 0 ) {
 80043f0:	2664      	movs	r6, #100	; 0x64
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);

    if( (delay_ctr % 10000) == 0 ) {
 80043f2:	f242 7510 	movw	r5, #10000	; 0x2710

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
  while( 1 ) {
    ++delay_ctr;
 80043f6:	3401      	adds	r4, #1

    if( (delay_ctr % 100) == 0 ) {
 80043f8:	fbb4 f3f6 	udiv	r3, r4, r6
 80043fc:	fb06 4313 	mls	r3, r6, r3, r4
 8004400:	b90b      	cbnz	r3, 8004406 <_abort+0x1e>
      // handle timeout/expire counters and USB packages
      MIOS32_MIDI_Periodic_mS();
 8004402:	f001 fdad 	bl	8005f60 <MIOS32_MIDI_Periodic_mS>
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 8004406:	4808      	ldr	r0, [pc, #32]	; (8004428 <_abort+0x40>)
 8004408:	f001 fc10 	bl	8005c2c <MIOS32_MIDI_Receive_Handler>

    if( (delay_ctr % 10000) == 0 ) {
 800440c:	fbb4 f3f5 	udiv	r3, r4, r5
 8004410:	fb05 4313 	mls	r3, r5, r3, r4
 8004414:	2b00      	cmp	r3, #0
 8004416:	d1ee      	bne.n	80043f6 <_abort+0xe>
      // toggle board LED
      MIOS32_BOARD_LED_Set(1, ~MIOS32_BOARD_LED_Get());
 8004418:	f002 ff00 	bl	800721c <MIOS32_BOARD_LED_Get>
 800441c:	43c1      	mvns	r1, r0
 800441e:	2001      	movs	r0, #1
 8004420:	f002 fee8 	bl	80071f4 <MIOS32_BOARD_LED_Set>
 8004424:	e7e7      	b.n	80043f6 <_abort+0xe>
 8004426:	bf00      	nop
 8004428:	080041f9 	.word	0x080041f9

0800442c <HardFault_Handler_c>:

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 800442c:	b510      	push	{r4, lr}
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 800442e:	6803      	ldr	r3, [r0, #0]

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 8004430:	b088      	sub	sp, #32
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 8004432:	9307      	str	r3, [sp, #28]
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 8004434:	6843      	ldr	r3, [r0, #4]
  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8004436:	4c33      	ldr	r4, [pc, #204]	; (8004504 <HardFault_Handler_c+0xd8>)
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 8004438:	9306      	str	r3, [sp, #24]
  stacked_r2 = ((unsigned long) hardfault_args[2]);
 800443a:	6883      	ldr	r3, [r0, #8]
 800443c:	9305      	str	r3, [sp, #20]
  stacked_r3 = ((unsigned long) hardfault_args[3]);
 800443e:	68c3      	ldr	r3, [r0, #12]
 8004440:	9304      	str	r3, [sp, #16]

  stacked_r12 = ((unsigned long) hardfault_args[4]);
 8004442:	6903      	ldr	r3, [r0, #16]
 8004444:	9303      	str	r3, [sp, #12]
  stacked_lr = ((unsigned long) hardfault_args[5]);
 8004446:	6943      	ldr	r3, [r0, #20]
 8004448:	9302      	str	r3, [sp, #8]
  stacked_pc = ((unsigned long) hardfault_args[6]);
 800444a:	6983      	ldr	r3, [r0, #24]
 800444c:	9301      	str	r3, [sp, #4]
  stacked_psr = ((unsigned long) hardfault_args[7]);
 800444e:	69c3      	ldr	r3, [r0, #28]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8004450:	4620      	mov	r0, r4
  stacked_r3 = ((unsigned long) hardfault_args[3]);

  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
 8004452:	9300      	str	r3, [sp, #0]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8004454:	f001 fa2e 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("!!! HARD FAULT !!!\n");
 8004458:	482b      	ldr	r0, [pc, #172]	; (8004508 <HardFault_Handler_c+0xdc>)
 800445a:	f001 fa2b 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("==================\n");
 800445e:	4620      	mov	r0, r4
 8004460:	f001 fa28 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R0 = %08x\n", stacked_r0);
 8004464:	9907      	ldr	r1, [sp, #28]
 8004466:	4829      	ldr	r0, [pc, #164]	; (800450c <HardFault_Handler_c+0xe0>)
 8004468:	f001 fa24 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R1 = %08x\n", stacked_r1);
 800446c:	9906      	ldr	r1, [sp, #24]
 800446e:	4828      	ldr	r0, [pc, #160]	; (8004510 <HardFault_Handler_c+0xe4>)
 8004470:	f001 fa20 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R2 = %08x\n", stacked_r2);
 8004474:	9905      	ldr	r1, [sp, #20]
 8004476:	4827      	ldr	r0, [pc, #156]	; (8004514 <HardFault_Handler_c+0xe8>)
 8004478:	f001 fa1c 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R3 = %08x\n", stacked_r3);
 800447c:	9904      	ldr	r1, [sp, #16]
 800447e:	4826      	ldr	r0, [pc, #152]	; (8004518 <HardFault_Handler_c+0xec>)
 8004480:	f001 fa18 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R12 = %08x\n", stacked_r12);
 8004484:	9903      	ldr	r1, [sp, #12]
 8004486:	4825      	ldr	r0, [pc, #148]	; (800451c <HardFault_Handler_c+0xf0>)
 8004488:	f001 fa14 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("LR = %08x\n", stacked_lr);
 800448c:	9902      	ldr	r1, [sp, #8]
 800448e:	4824      	ldr	r0, [pc, #144]	; (8004520 <HardFault_Handler_c+0xf4>)
 8004490:	f001 fa10 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PC = %08x\n", stacked_pc);
 8004494:	9901      	ldr	r1, [sp, #4]
 8004496:	4823      	ldr	r0, [pc, #140]	; (8004524 <HardFault_Handler_c+0xf8>)
 8004498:	f001 fa0c 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PSR = %08x\n", stacked_psr);
 800449c:	9900      	ldr	r1, [sp, #0]
 800449e:	4822      	ldr	r0, [pc, #136]	; (8004528 <HardFault_Handler_c+0xfc>)
 80044a0:	f001 fa08 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("BFAR = %08x\n", (*((volatile unsigned long *)(0xE000ED38))));
 80044a4:	4b21      	ldr	r3, [pc, #132]	; (800452c <HardFault_Handler_c+0x100>)
 80044a6:	4822      	ldr	r0, [pc, #136]	; (8004530 <HardFault_Handler_c+0x104>)
 80044a8:	6819      	ldr	r1, [r3, #0]
 80044aa:	f001 fa03 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("CFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED28))));
 80044ae:	4b21      	ldr	r3, [pc, #132]	; (8004534 <HardFault_Handler_c+0x108>)
 80044b0:	4821      	ldr	r0, [pc, #132]	; (8004538 <HardFault_Handler_c+0x10c>)
 80044b2:	6819      	ldr	r1, [r3, #0]
 80044b4:	f001 f9fe 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("HFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED2C))));
 80044b8:	4b20      	ldr	r3, [pc, #128]	; (800453c <HardFault_Handler_c+0x110>)
 80044ba:	4821      	ldr	r0, [pc, #132]	; (8004540 <HardFault_Handler_c+0x114>)
 80044bc:	6819      	ldr	r1, [r3, #0]
 80044be:	f001 f9f9 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("DFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED30))));
 80044c2:	4b20      	ldr	r3, [pc, #128]	; (8004544 <HardFault_Handler_c+0x118>)
 80044c4:	4820      	ldr	r0, [pc, #128]	; (8004548 <HardFault_Handler_c+0x11c>)
 80044c6:	6819      	ldr	r1, [r3, #0]
 80044c8:	f001 f9f4 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("AFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED3C))));
 80044cc:	4b1f      	ldr	r3, [pc, #124]	; (800454c <HardFault_Handler_c+0x120>)
 80044ce:	4820      	ldr	r0, [pc, #128]	; (8004550 <HardFault_Handler_c+0x124>)
 80044d0:	6819      	ldr	r1, [r3, #0]
 80044d2:	f001 f9ef 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>

#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 80044d6:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80044da:	f001 f89e 	bl	800561a <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 80044de:	2000      	movs	r0, #0
 80044e0:	f001 f89f 	bl	8005622 <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 80044e4:	2000      	movs	r0, #0
 80044e6:	f000 ffbd 	bl	8005464 <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 80044ea:	f001 f823 	bl	8005534 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 80044ee:	2000      	movs	r0, #0
 80044f0:	4601      	mov	r1, r0
 80044f2:	f000 ffbd 	bl	8005470 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("!! HARD FAULT !!");
 80044f6:	4817      	ldr	r0, [pc, #92]	; (8004554 <HardFault_Handler_c+0x128>)
 80044f8:	f001 f84e 	bl	8005598 <MIOS32_LCD_PrintString>
#endif

  _abort();
 80044fc:	f7ff ff74 	bl	80043e8 <_abort>
}
 8004500:	b008      	add	sp, #32
 8004502:	bd10      	pop	{r4, pc}
 8004504:	08009f31 	.word	0x08009f31
 8004508:	08009f45 	.word	0x08009f45
 800450c:	08009f59 	.word	0x08009f59
 8004510:	08009f64 	.word	0x08009f64
 8004514:	08009f6f 	.word	0x08009f6f
 8004518:	08009f7a 	.word	0x08009f7a
 800451c:	08009f85 	.word	0x08009f85
 8004520:	08009f91 	.word	0x08009f91
 8004524:	08009f9c 	.word	0x08009f9c
 8004528:	08009fa7 	.word	0x08009fa7
 800452c:	e000ed38 	.word	0xe000ed38
 8004530:	08009fb3 	.word	0x08009fb3
 8004534:	e000ed28 	.word	0xe000ed28
 8004538:	08009fc0 	.word	0x08009fc0
 800453c:	e000ed2c 	.word	0xe000ed2c
 8004540:	08009fcd 	.word	0x08009fcd
 8004544:	e000ed30 	.word	0xe000ed30
 8004548:	08009fda 	.word	0x08009fda
 800454c:	e000ed3c 	.word	0xe000ed3c
 8004550:	08009fe7 	.word	0x08009fe7
 8004554:	08009ff4 	.word	0x08009ff4

08004558 <HardFault_Handler>:


void HardFault_Handler(void)
{
  __asm("TST LR, #4");
 8004558:	f01e 0f04 	tst.w	lr, #4
  __asm("ITE EQ");
 800455c:	bf0c      	ite	eq
  __asm("MRSEQ R0, MSP");
 800455e:	f3ef 8008 	mrseq	r0, MSP
  __asm("MRSNE R0, PSP");
 8004562:	f3ef 8009 	mrsne	r0, PSP
  __asm("B HardFault_Handler_c");
 8004566:	f7ff bf61 	b.w	800442c <HardFault_Handler_c>
}
 800456a:	4770      	bx	lr

0800456c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 800456c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800456e:	b085      	sub	sp, #20
 8004570:	9303      	str	r3, [sp, #12]
 8004572:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004574:	9002      	str	r0, [sp, #8]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8004576:	2048      	movs	r0, #72	; 0x48
 8004578:	9300      	str	r3, [sp, #0]
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 800457a:	460e      	mov	r6, r1
 800457c:	4614      	mov	r4, r2
 800457e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8004580:	f000 fbd4 	bl	8004d2c <pvPortMalloc>

	if( pxNewTCB != NULL )
 8004584:	9b00      	ldr	r3, [sp, #0]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8004586:	4605      	mov	r5, r0

	if( pxNewTCB != NULL )
 8004588:	2800      	cmp	r0, #0
 800458a:	f000 809b 	beq.w	80046c4 <xTaskGenericCreate+0x158>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 800458e:	b91b      	cbnz	r3, 8004598 <xTaskGenericCreate+0x2c>
 8004590:	00a0      	lsls	r0, r4, #2
 8004592:	f000 fbcb 	bl	8004d2c <pvPortMalloc>
 8004596:	4603      	mov	r3, r0
 8004598:	632b      	str	r3, [r5, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 800459a:	b91b      	cbnz	r3, 80045a4 <xTaskGenericCreate+0x38>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 800459c:	4628      	mov	r0, r5
 800459e:	f000 fb8f 	bl	8004cc0 <vPortFree>
 80045a2:	e08f      	b.n	80046c4 <xTaskGenericCreate+0x158>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 80045a4:	00a2      	lsls	r2, r4, #2
 80045a6:	21a5      	movs	r1, #165	; 0xa5
 80045a8:	4618      	mov	r0, r3
 80045aa:	f005 fc66 	bl	8009e7a <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 80045ae:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80045b0:	3c01      	subs	r4, #1
 80045b2:	eb03 0384 	add.w	r3, r3, r4, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 80045b6:	f023 0307 	bic.w	r3, r3, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80045ba:	4631      	mov	r1, r6
 80045bc:	2210      	movs	r2, #16
 80045be:	f105 0034 	add.w	r0, r5, #52	; 0x34
 80045c2:	9300      	str	r3, [sp, #0]
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 80045c4:	2400      	movs	r4, #0
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80045c6:	f005 fc6f 	bl	8009ea8 <strncpy>
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80045ca:	1d2e      	adds	r6, r5, #4
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 80045cc:	2f04      	cmp	r7, #4
 80045ce:	bf34      	ite	cc
 80045d0:	463a      	movcc	r2, r7
 80045d2:	2204      	movcs	r2, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
 80045d4:	62ea      	str	r2, [r5, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 80045d6:	646a      	str	r2, [r5, #68]	; 0x44
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 80045d8:	f885 4043 	strb.w	r4, [r5, #67]	; 0x43
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80045dc:	4630      	mov	r0, r6
 80045de:	9201      	str	r2, [sp, #4]
 80045e0:	f000 fa43 	bl	8004a6a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 80045e4:	f105 0018 	add.w	r0, r5, #24
 80045e8:	f000 fa3f 	bl	8004a6a <vListInitialiseItem>
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80045ec:	9a01      	ldr	r2, [sp, #4]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80045ee:	9b00      	ldr	r3, [sp, #0]
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80045f0:	f1c2 0205 	rsb	r2, r2, #5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80045f4:	4618      	mov	r0, r3
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80045f6:	61aa      	str	r2, [r5, #24]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80045f8:	9902      	ldr	r1, [sp, #8]
 80045fa:	9a03      	ldr	r2, [sp, #12]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80045fc:	612d      	str	r5, [r5, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 80045fe:	626d      	str	r5, [r5, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004600:	f000 fa6d 	bl	8004ade <pxPortInitialiseStack>
 8004604:	6028      	str	r0, [r5, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
 8004606:	f000 fabb 	bl	8004b80 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 800460a:	4b31      	ldr	r3, [pc, #196]	; (80046d0 <xTaskGenericCreate+0x164>)
 800460c:	681a      	ldr	r2, [r3, #0]
 800460e:	3201      	adds	r2, #1
 8004610:	601a      	str	r2, [r3, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 8004612:	681b      	ldr	r3, [r3, #0]
 8004614:	2b01      	cmp	r3, #1
 8004616:	d126      	bne.n	8004666 <xTaskGenericCreate+0xfa>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 8004618:	4b2e      	ldr	r3, [pc, #184]	; (80046d4 <xTaskGenericCreate+0x168>)
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 800461a:	4a2f      	ldr	r2, [pc, #188]	; (80046d8 <xTaskGenericCreate+0x16c>)
		{
			uxCurrentNumberOfTasks++;
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 800461c:	601d      	str	r5, [r3, #0]
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 800461e:	2314      	movs	r3, #20
 8004620:	fb03 2004 	mla	r0, r3, r4, r2

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8004624:	3401      	adds	r4, #1
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8004626:	9201      	str	r2, [sp, #4]
 8004628:	9300      	str	r3, [sp, #0]
 800462a:	f000 fa13 	bl	8004a54 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800462e:	2c05      	cmp	r4, #5
 8004630:	9a01      	ldr	r2, [sp, #4]
 8004632:	9b00      	ldr	r3, [sp, #0]
 8004634:	d1f4      	bne.n	8004620 <xTaskGenericCreate+0xb4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8004636:	4b29      	ldr	r3, [pc, #164]	; (80046dc <xTaskGenericCreate+0x170>)
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8004638:	4c29      	ldr	r4, [pc, #164]	; (80046e0 <xTaskGenericCreate+0x174>)
	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 800463a:	4618      	mov	r0, r3
 800463c:	9300      	str	r3, [sp, #0]
 800463e:	f000 fa09 	bl	8004a54 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8004642:	4620      	mov	r0, r4
 8004644:	f000 fa06 	bl	8004a54 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 8004648:	4826      	ldr	r0, [pc, #152]	; (80046e4 <xTaskGenericCreate+0x178>)
 800464a:	f000 fa03 	bl	8004a54 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 800464e:	4826      	ldr	r0, [pc, #152]	; (80046e8 <xTaskGenericCreate+0x17c>)
 8004650:	f000 fa00 	bl	8004a54 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8004654:	4825      	ldr	r0, [pc, #148]	; (80046ec <xTaskGenericCreate+0x180>)
 8004656:	f000 f9fd 	bl	8004a54 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800465a:	9b00      	ldr	r3, [sp, #0]
 800465c:	4a24      	ldr	r2, [pc, #144]	; (80046f0 <xTaskGenericCreate+0x184>)
 800465e:	6013      	str	r3, [r2, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8004660:	4b24      	ldr	r3, [pc, #144]	; (80046f4 <xTaskGenericCreate+0x188>)
 8004662:	601c      	str	r4, [r3, #0]
 8004664:	e008      	b.n	8004678 <xTaskGenericCreate+0x10c>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8004666:	4b24      	ldr	r3, [pc, #144]	; (80046f8 <xTaskGenericCreate+0x18c>)
 8004668:	681b      	ldr	r3, [r3, #0]
 800466a:	b92b      	cbnz	r3, 8004678 <xTaskGenericCreate+0x10c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 800466c:	4b19      	ldr	r3, [pc, #100]	; (80046d4 <xTaskGenericCreate+0x168>)
 800466e:	681a      	ldr	r2, [r3, #0]
 8004670:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8004672:	42ba      	cmp	r2, r7
					{
						pxCurrentTCB = pxNewTCB;
 8004674:	bf98      	it	ls
 8004676:	601d      	strls	r5, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8004678:	4a20      	ldr	r2, [pc, #128]	; (80046fc <xTaskGenericCreate+0x190>)
 800467a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800467c:	6811      	ldr	r1, [r2, #0]
 800467e:	428b      	cmp	r3, r1
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8004680:	bf88      	it	hi
 8004682:	6013      	strhi	r3, [r2, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 8004684:	4a1e      	ldr	r2, [pc, #120]	; (8004700 <xTaskGenericCreate+0x194>)
 8004686:	6811      	ldr	r1, [r2, #0]
 8004688:	3101      	adds	r1, #1
 800468a:	6011      	str	r1, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 800468c:	4a1d      	ldr	r2, [pc, #116]	; (8004704 <xTaskGenericCreate+0x198>)
 800468e:	6811      	ldr	r1, [r2, #0]
 8004690:	428b      	cmp	r3, r1
 8004692:	bf88      	it	hi
 8004694:	6013      	strhi	r3, [r2, #0]
 8004696:	4a10      	ldr	r2, [pc, #64]	; (80046d8 <xTaskGenericCreate+0x16c>)
 8004698:	2014      	movs	r0, #20
 800469a:	fb00 2003 	mla	r0, r0, r3, r2
 800469e:	4631      	mov	r1, r6
 80046a0:	f000 f9e6 	bl	8004a70 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 80046a4:	f000 fa78 	bl	8004b98 <vPortExitCritical>
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
 80046a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80046aa:	b103      	cbz	r3, 80046ae <xTaskGenericCreate+0x142>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 80046ac:	601d      	str	r5, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
 80046ae:	4b12      	ldr	r3, [pc, #72]	; (80046f8 <xTaskGenericCreate+0x18c>)
 80046b0:	681b      	ldr	r3, [r3, #0]
 80046b2:	b153      	cbz	r3, 80046ca <xTaskGenericCreate+0x15e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 80046b4:	4b07      	ldr	r3, [pc, #28]	; (80046d4 <xTaskGenericCreate+0x168>)
 80046b6:	681b      	ldr	r3, [r3, #0]
 80046b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80046ba:	42bb      	cmp	r3, r7
 80046bc:	d205      	bcs.n	80046ca <xTaskGenericCreate+0x15e>
			{
				portYIELD_WITHIN_API();
 80046be:	f000 fa57 	bl	8004b70 <vPortYieldFromISR>
 80046c2:	e002      	b.n	80046ca <xTaskGenericCreate+0x15e>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80046c4:	f04f 30ff 	mov.w	r0, #4294967295
 80046c8:	e000      	b.n	80046cc <xTaskGenericCreate+0x160>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
 80046ca:	2001      	movs	r0, #1
			}
		}
	}

	return xReturn;
}
 80046cc:	b005      	add	sp, #20
 80046ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80046d0:	20000150 	.word	0x20000150
 80046d4:	200000fc 	.word	0x200000fc
 80046d8:	20000094 	.word	0x20000094
 80046dc:	20000124 	.word	0x20000124
 80046e0:	20000138 	.word	0x20000138
 80046e4:	20000100 	.word	0x20000100
 80046e8:	2000006c 	.word	0x2000006c
 80046ec:	20000080 	.word	0x20000080
 80046f0:	20000060 	.word	0x20000060
 80046f4:	20000118 	.word	0x20000118
 80046f8:	20000064 	.word	0x20000064
 80046fc:	20000154 	.word	0x20000154
 8004700:	20000120 	.word	0x20000120
 8004704:	2000011c 	.word	0x2000011c

08004708 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8004708:	b51f      	push	{r0, r1, r2, r3, r4, lr}
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 800470a:	2400      	movs	r4, #0
 800470c:	4623      	mov	r3, r4
 800470e:	480c      	ldr	r0, [pc, #48]	; (8004740 <vTaskStartScheduler+0x38>)
 8004710:	490c      	ldr	r1, [pc, #48]	; (8004744 <vTaskStartScheduler+0x3c>)
 8004712:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004716:	9400      	str	r4, [sp, #0]
 8004718:	9401      	str	r4, [sp, #4]
 800471a:	9402      	str	r4, [sp, #8]
 800471c:	9403      	str	r4, [sp, #12]
 800471e:	f7ff ff25 	bl	800456c <xTaskGenericCreate>

	if( xReturn == pdPASS )
 8004722:	2801      	cmp	r0, #1
void vTaskStartScheduler( void )
{
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 8004724:	4603      	mov	r3, r0

	if( xReturn == pdPASS )
 8004726:	d109      	bne.n	800473c <vTaskStartScheduler+0x34>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8004728:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800472c:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 8004730:	4a05      	ldr	r2, [pc, #20]	; (8004748 <vTaskStartScheduler+0x40>)
 8004732:	6013      	str	r3, [r2, #0]
		xTickCount = ( portTickType ) 0;
 8004734:	4b05      	ldr	r3, [pc, #20]	; (800474c <vTaskStartScheduler+0x44>)
 8004736:	601c      	str	r4, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 8004738:	f000 f9fa 	bl	8004b30 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
 800473c:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 800473e:	bf00      	nop
 8004740:	080048fd 	.word	0x080048fd
 8004744:	0800a005 	.word	0x0800a005
 8004748:	20000064 	.word	0x20000064
 800474c:	20000114 	.word	0x20000114

08004750 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8004750:	4b02      	ldr	r3, [pc, #8]	; (800475c <vTaskSuspendAll+0xc>)
 8004752:	681a      	ldr	r2, [r3, #0]
 8004754:	3201      	adds	r2, #1
 8004756:	601a      	str	r2, [r3, #0]
}
 8004758:	4770      	bx	lr
 800475a:	bf00      	nop
 800475c:	200000f8 	.word	0x200000f8

08004760 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
 8004760:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
 8004762:	f000 fa0d 	bl	8004b80 <vPortEnterCritical>
	{
		xTicks = xTickCount;
 8004766:	4b03      	ldr	r3, [pc, #12]	; (8004774 <xTaskGetTickCount+0x14>)
 8004768:	681c      	ldr	r4, [r3, #0]
	}
	portEXIT_CRITICAL();
 800476a:	f000 fa15 	bl	8004b98 <vPortExitCritical>

	return xTicks;
}
 800476e:	4620      	mov	r0, r4
 8004770:	bd10      	pop	{r4, pc}
 8004772:	bf00      	nop
 8004774:	20000114 	.word	0x20000114

08004778 <vTaskIncrementTick>:
void vTaskIncrementTick( void )
{
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004778:	4b26      	ldr	r3, [pc, #152]	; (8004814 <vTaskIncrementTick+0x9c>)
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 800477a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800477c:	681b      	ldr	r3, [r3, #0]
 800477e:	2b00      	cmp	r3, #0
 8004780:	d13c      	bne.n	80047fc <vTaskIncrementTick+0x84>
	{
		++xTickCount;
 8004782:	4b25      	ldr	r3, [pc, #148]	; (8004818 <vTaskIncrementTick+0xa0>)
 8004784:	681a      	ldr	r2, [r3, #0]
 8004786:	3201      	adds	r2, #1
 8004788:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
 800478a:	681b      	ldr	r3, [r3, #0]
 800478c:	2b00      	cmp	r3, #0
 800478e:	d128      	bne.n	80047e2 <vTaskIncrementTick+0x6a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004790:	4a22      	ldr	r2, [pc, #136]	; (800481c <vTaskIncrementTick+0xa4>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004792:	4b23      	ldr	r3, [pc, #140]	; (8004820 <vTaskIncrementTick+0xa8>)
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004794:	6811      	ldr	r1, [r2, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004796:	6818      	ldr	r0, [r3, #0]
 8004798:	6010      	str	r0, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
 800479a:	6019      	str	r1, [r3, #0]
			xNumOfOverflows++;
 800479c:	4b21      	ldr	r3, [pc, #132]	; (8004824 <vTaskIncrementTick+0xac>)
 800479e:	681a      	ldr	r2, [r3, #0]
 80047a0:	3201      	adds	r2, #1
 80047a2:	601a      	str	r2, [r3, #0]
 80047a4:	e01d      	b.n	80047e2 <vTaskIncrementTick+0x6a>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 80047a6:	6839      	ldr	r1, [r7, #0]
 80047a8:	685a      	ldr	r2, [r3, #4]
 80047aa:	4291      	cmp	r1, r2
 80047ac:	d32c      	bcc.n	8004808 <vTaskIncrementTick+0x90>
 80047ae:	1d1a      	adds	r2, r3, #4
 80047b0:	4610      	mov	r0, r2
 80047b2:	9201      	str	r2, [sp, #4]
 80047b4:	9300      	str	r3, [sp, #0]
 80047b6:	f000 f982 	bl	8004abe <vListRemove>
 80047ba:	9b00      	ldr	r3, [sp, #0]
 80047bc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80047be:	b122      	cbz	r2, 80047ca <vTaskIncrementTick+0x52>
 80047c0:	f103 0018 	add.w	r0, r3, #24
 80047c4:	f000 f97b 	bl	8004abe <vListRemove>
 80047c8:	9b00      	ldr	r3, [sp, #0]
 80047ca:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80047cc:	6823      	ldr	r3, [r4, #0]
 80047ce:	9901      	ldr	r1, [sp, #4]
 80047d0:	4298      	cmp	r0, r3
 80047d2:	bf88      	it	hi
 80047d4:	6020      	strhi	r0, [r4, #0]
 80047d6:	2314      	movs	r3, #20
 80047d8:	fb03 6000 	mla	r0, r3, r0, r6
 80047dc:	f000 f948 	bl	8004a70 <vListInsertEnd>
 80047e0:	e003      	b.n	80047ea <vTaskIncrementTick+0x72>
 80047e2:	4d0e      	ldr	r5, [pc, #56]	; (800481c <vTaskIncrementTick+0xa4>)
 80047e4:	4f0c      	ldr	r7, [pc, #48]	; (8004818 <vTaskIncrementTick+0xa0>)
 80047e6:	4c10      	ldr	r4, [pc, #64]	; (8004828 <vTaskIncrementTick+0xb0>)
 80047e8:	4e10      	ldr	r6, [pc, #64]	; (800482c <vTaskIncrementTick+0xb4>)
 80047ea:	682b      	ldr	r3, [r5, #0]
 80047ec:	681b      	ldr	r3, [r3, #0]
 80047ee:	b15b      	cbz	r3, 8004808 <vTaskIncrementTick+0x90>
 80047f0:	682b      	ldr	r3, [r5, #0]
 80047f2:	68db      	ldr	r3, [r3, #12]
 80047f4:	68db      	ldr	r3, [r3, #12]
 80047f6:	2b00      	cmp	r3, #0
 80047f8:	d1d5      	bne.n	80047a6 <vTaskIncrementTick+0x2e>
 80047fa:	e005      	b.n	8004808 <vTaskIncrementTick+0x90>
	}
	else
	{
		++uxMissedTicks;
 80047fc:	4b0c      	ldr	r3, [pc, #48]	; (8004830 <vTaskIncrementTick+0xb8>)
 80047fe:	681a      	ldr	r2, [r3, #0]
 8004800:	3201      	adds	r2, #1
 8004802:	601a      	str	r2, [r3, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
 8004804:	f7ff fde2 	bl	80043cc <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
 8004808:	4b09      	ldr	r3, [pc, #36]	; (8004830 <vTaskIncrementTick+0xb8>)
 800480a:	681b      	ldr	r3, [r3, #0]
 800480c:	b90b      	cbnz	r3, 8004812 <vTaskIncrementTick+0x9a>
		{
			vApplicationTickHook();
 800480e:	f7ff fddd 	bl	80043cc <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8004812:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004814:	200000f8 	.word	0x200000f8
 8004818:	20000114 	.word	0x20000114
 800481c:	20000060 	.word	0x20000060
 8004820:	20000118 	.word	0x20000118
 8004824:	2000005c 	.word	0x2000005c
 8004828:	2000011c 	.word	0x2000011c
 800482c:	20000094 	.word	0x20000094
 8004830:	20000058 	.word	0x20000058

08004834 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8004834:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
 8004836:	f000 f9a3 	bl	8004b80 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 800483a:	4b28      	ldr	r3, [pc, #160]	; (80048dc <xTaskResumeAll+0xa8>)
 800483c:	681a      	ldr	r2, [r3, #0]
 800483e:	3a01      	subs	r2, #1
 8004840:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004842:	681d      	ldr	r5, [r3, #0]
 8004844:	2d00      	cmp	r5, #0
 8004846:	d144      	bne.n	80048d2 <xTaskResumeAll+0x9e>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 8004848:	4b25      	ldr	r3, [pc, #148]	; (80048e0 <xTaskResumeAll+0xac>)
 800484a:	681c      	ldr	r4, [r3, #0]
 800484c:	2c00      	cmp	r4, #0
 800484e:	d041      	beq.n	80048d4 <xTaskResumeAll+0xa0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8004850:	4f24      	ldr	r7, [pc, #144]	; (80048e4 <xTaskResumeAll+0xb0>)
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
 8004852:	4e25      	ldr	r6, [pc, #148]	; (80048e8 <xTaskResumeAll+0xb4>)
 8004854:	e01b      	b.n	800488e <xTaskResumeAll+0x5a>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
 8004856:	f104 0018 	add.w	r0, r4, #24
 800485a:	f000 f930 	bl	8004abe <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 800485e:	1d21      	adds	r1, r4, #4
 8004860:	4608      	mov	r0, r1
 8004862:	9101      	str	r1, [sp, #4]
 8004864:	f000 f92b 	bl	8004abe <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8004868:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800486a:	6833      	ldr	r3, [r6, #0]
 800486c:	9901      	ldr	r1, [sp, #4]
 800486e:	4298      	cmp	r0, r3
 8004870:	4b1e      	ldr	r3, [pc, #120]	; (80048ec <xTaskResumeAll+0xb8>)
 8004872:	bf88      	it	hi
 8004874:	6030      	strhi	r0, [r6, #0]
 8004876:	2214      	movs	r2, #20
 8004878:	fb02 3000 	mla	r0, r2, r0, r3
 800487c:	f000 f8f8 	bl	8004a70 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004880:	4a1b      	ldr	r2, [pc, #108]	; (80048f0 <xTaskResumeAll+0xbc>)
 8004882:	6813      	ldr	r3, [r2, #0]
 8004884:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004886:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
 8004888:	429a      	cmp	r2, r3
 800488a:	bf28      	it	cs
 800488c:	2501      	movcs	r5, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 800488e:	683b      	ldr	r3, [r7, #0]
 8004890:	b11b      	cbz	r3, 800489a <xTaskResumeAll+0x66>
 8004892:	68fb      	ldr	r3, [r7, #12]
 8004894:	68dc      	ldr	r4, [r3, #12]
 8004896:	2c00      	cmp	r4, #0
 8004898:	d1dd      	bne.n	8004856 <xTaskResumeAll+0x22>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 800489a:	4c16      	ldr	r4, [pc, #88]	; (80048f4 <xTaskResumeAll+0xc0>)
 800489c:	6823      	ldr	r3, [r4, #0]
 800489e:	b92b      	cbnz	r3, 80048ac <xTaskResumeAll+0x78>
 80048a0:	e008      	b.n	80048b4 <xTaskResumeAll+0x80>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
 80048a2:	f7ff ff69 	bl	8004778 <vTaskIncrementTick>
						--uxMissedTicks;
 80048a6:	6823      	ldr	r3, [r4, #0]
 80048a8:	3b01      	subs	r3, #1
 80048aa:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 80048ac:	6823      	ldr	r3, [r4, #0]
 80048ae:	2b00      	cmp	r3, #0
 80048b0:	d1f7      	bne.n	80048a2 <xTaskResumeAll+0x6e>
 80048b2:	e007      	b.n	80048c4 <xTaskResumeAll+0x90>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 80048b4:	2d01      	cmp	r5, #1
 80048b6:	d005      	beq.n	80048c4 <xTaskResumeAll+0x90>
 80048b8:	4a0f      	ldr	r2, [pc, #60]	; (80048f8 <xTaskResumeAll+0xc4>)
 80048ba:	6812      	ldr	r2, [r2, #0]
 80048bc:	2a01      	cmp	r2, #1
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80048be:	bf18      	it	ne
 80048c0:	461c      	movne	r4, r3
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 80048c2:	d107      	bne.n	80048d4 <xTaskResumeAll+0xa0>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 80048c4:	4b0c      	ldr	r3, [pc, #48]	; (80048f8 <xTaskResumeAll+0xc4>)
 80048c6:	2200      	movs	r2, #0
 80048c8:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 80048ca:	f000 f951 	bl	8004b70 <vPortYieldFromISR>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 80048ce:	2401      	movs	r4, #1
 80048d0:	e000      	b.n	80048d4 <xTaskResumeAll+0xa0>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80048d2:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
 80048d4:	f000 f960 	bl	8004b98 <vPortExitCritical>

	return xAlreadyYielded;
}
 80048d8:	4620      	mov	r0, r4
 80048da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80048dc:	200000f8 	.word	0x200000f8
 80048e0:	20000150 	.word	0x20000150
 80048e4:	20000100 	.word	0x20000100
 80048e8:	2000011c 	.word	0x2000011c
 80048ec:	20000094 	.word	0x20000094
 80048f0:	200000fc 	.word	0x200000fc
 80048f4:	20000058 	.word	0x20000058
 80048f8:	2000014c 	.word	0x2000014c

080048fc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80048fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 80048fe:	4e15      	ldr	r6, [pc, #84]	; (8004954 <prvIdleTask+0x58>)
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004900:	4d15      	ldr	r5, [pc, #84]	; (8004958 <prvIdleTask+0x5c>)

				portENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
 8004902:	4f16      	ldr	r7, [pc, #88]	; (800495c <prvIdleTask+0x60>)
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8004904:	6833      	ldr	r3, [r6, #0]
 8004906:	b1e3      	cbz	r3, 8004942 <prvIdleTask+0x46>
		{
			vTaskSuspendAll();
 8004908:	f7ff ff22 	bl	8004750 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800490c:	682c      	ldr	r4, [r5, #0]
			xTaskResumeAll();
 800490e:	f7ff ff91 	bl	8004834 <xTaskResumeAll>

			if( !xListIsEmpty )
 8004912:	b1b4      	cbz	r4, 8004942 <prvIdleTask+0x46>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
 8004914:	f000 f934 	bl	8004b80 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8004918:	682c      	ldr	r4, [r5, #0]
 800491a:	b10c      	cbz	r4, 8004920 <prvIdleTask+0x24>
 800491c:	68eb      	ldr	r3, [r5, #12]
 800491e:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8004920:	1d20      	adds	r0, r4, #4
 8004922:	f000 f8cc 	bl	8004abe <vListRemove>
					--uxCurrentNumberOfTasks;
 8004926:	683b      	ldr	r3, [r7, #0]
 8004928:	3b01      	subs	r3, #1
 800492a:	603b      	str	r3, [r7, #0]
					--uxTasksDeleted;
 800492c:	6833      	ldr	r3, [r6, #0]
 800492e:	3b01      	subs	r3, #1
 8004930:	6033      	str	r3, [r6, #0]
				}
				portEXIT_CRITICAL();
 8004932:	f000 f931 	bl	8004b98 <vPortExitCritical>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8004936:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004938:	f000 f9c2 	bl	8004cc0 <vPortFree>
		vPortFree( pxTCB );
 800493c:	4620      	mov	r0, r4
 800493e:	f000 f9bf 	bl	8004cc0 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8004942:	4a07      	ldr	r2, [pc, #28]	; (8004960 <prvIdleTask+0x64>)
 8004944:	6813      	ldr	r3, [r2, #0]
 8004946:	2b01      	cmp	r3, #1
 8004948:	d901      	bls.n	800494e <prvIdleTask+0x52>
			{
				taskYIELD();
 800494a:	f000 f911 	bl	8004b70 <vPortYieldFromISR>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 800494e:	f7ff fd47 	bl	80043e0 <vApplicationIdleHook>
		}
		#endif
	}
 8004952:	e7d7      	b.n	8004904 <prvIdleTask+0x8>
 8004954:	20000068 	.word	0x20000068
 8004958:	2000006c 	.word	0x2000006c
 800495c:	20000150 	.word	0x20000150
 8004960:	20000094 	.word	0x20000094

08004964 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8004964:	b538      	push	{r3, r4, r5, lr}
 8004966:	460c      	mov	r4, r1
 8004968:	4605      	mov	r5, r0
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
 800496a:	f7ff fef1 	bl	8004750 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
 800496e:	4a17      	ldr	r2, [pc, #92]	; (80049cc <vTaskDelayUntil+0x68>)
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004970:	682b      	ldr	r3, [r5, #0]

			if( xTickCount < *pxPreviousWakeTime )
 8004972:	6811      	ldr	r1, [r2, #0]
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004974:	18e4      	adds	r4, r4, r3

			if( xTickCount < *pxPreviousWakeTime )
 8004976:	4299      	cmp	r1, r3
 8004978:	d202      	bcs.n	8004980 <vTaskDelayUntil+0x1c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 800497a:	429c      	cmp	r4, r3
 800497c:	d208      	bcs.n	8004990 <vTaskDelayUntil+0x2c>
 800497e:	e001      	b.n	8004984 <vTaskDelayUntil+0x20>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 8004980:	429c      	cmp	r4, r3
 8004982:	d307      	bcc.n	8004994 <vTaskDelayUntil+0x30>
 8004984:	6813      	ldr	r3, [r2, #0]
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8004986:	429c      	cmp	r4, r3
 8004988:	bf94      	ite	ls
 800498a:	2300      	movls	r3, #0
 800498c:	2301      	movhi	r3, #1
 800498e:	e002      	b.n	8004996 <vTaskDelayUntil+0x32>
 8004990:	2300      	movs	r3, #0
 8004992:	e000      	b.n	8004996 <vTaskDelayUntil+0x32>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
 8004994:	2301      	movs	r3, #1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8004996:	602c      	str	r4, [r5, #0]

			if( xShouldDelay )
 8004998:	b18b      	cbz	r3, 80049be <vTaskDelayUntil+0x5a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800499a:	4d0d      	ldr	r5, [pc, #52]	; (80049d0 <vTaskDelayUntil+0x6c>)
 800499c:	6828      	ldr	r0, [r5, #0]
 800499e:	3004      	adds	r0, #4
 80049a0:	f000 f88d 	bl	8004abe <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80049a4:	682b      	ldr	r3, [r5, #0]
 80049a6:	605c      	str	r4, [r3, #4]

				if( xTimeToWake < xTickCount )
 80049a8:	4b08      	ldr	r3, [pc, #32]	; (80049cc <vTaskDelayUntil+0x68>)
 80049aa:	681b      	ldr	r3, [r3, #0]
 80049ac:	429c      	cmp	r4, r3
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80049ae:	bf34      	ite	cc
 80049b0:	4b08      	ldrcc	r3, [pc, #32]	; (80049d4 <vTaskDelayUntil+0x70>)
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80049b2:	4b09      	ldrcs	r3, [pc, #36]	; (80049d8 <vTaskDelayUntil+0x74>)
 80049b4:	6818      	ldr	r0, [r3, #0]
 80049b6:	6829      	ldr	r1, [r5, #0]
 80049b8:	3104      	adds	r1, #4
 80049ba:	f000 f866 	bl	8004a8a <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 80049be:	f7ff ff39 	bl	8004834 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 80049c2:	b908      	cbnz	r0, 80049c8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
 80049c4:	f000 f8d4 	bl	8004b70 <vPortYieldFromISR>
		}
	}
 80049c8:	bd38      	pop	{r3, r4, r5, pc}
 80049ca:	bf00      	nop
 80049cc:	20000114 	.word	0x20000114
 80049d0:	200000fc 	.word	0x200000fc
 80049d4:	20000118 	.word	0x20000118
 80049d8:	20000060 	.word	0x20000060

080049dc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 80049dc:	4b18      	ldr	r3, [pc, #96]	; (8004a40 <vTaskSwitchContext+0x64>)

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80049de:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 80049e0:	681b      	ldr	r3, [r3, #0]
 80049e2:	b133      	cbz	r3, 80049f2 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 80049e4:	2201      	movs	r2, #1
 80049e6:	4b17      	ldr	r3, [pc, #92]	; (8004a44 <vTaskSwitchContext+0x68>)
 80049e8:	e028      	b.n	8004a3c <vTaskSwitchContext+0x60>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
 80049ea:	6818      	ldr	r0, [r3, #0]
 80049ec:	3801      	subs	r0, #1
 80049ee:	6018      	str	r0, [r3, #0]
 80049f0:	e002      	b.n	80049f8 <vTaskSwitchContext+0x1c>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 80049f2:	4b15      	ldr	r3, [pc, #84]	; (8004a48 <vTaskSwitchContext+0x6c>)
 80049f4:	4915      	ldr	r1, [pc, #84]	; (8004a4c <vTaskSwitchContext+0x70>)
 80049f6:	2214      	movs	r2, #20
 80049f8:	f8d3 c000 	ldr.w	ip, [r3]
 80049fc:	4813      	ldr	r0, [pc, #76]	; (8004a4c <vTaskSwitchContext+0x70>)
 80049fe:	fb02 fc0c 	mul.w	ip, r2, ip
 8004a02:	f851 400c 	ldr.w	r4, [r1, ip]
 8004a06:	2c00      	cmp	r4, #0
 8004a08:	d0ef      	beq.n	80049ea <vTaskSwitchContext+0xe>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8004a0a:	4b0f      	ldr	r3, [pc, #60]	; (8004a48 <vTaskSwitchContext+0x6c>)
 8004a0c:	f04f 0c14 	mov.w	ip, #20
 8004a10:	6819      	ldr	r1, [r3, #0]
 8004a12:	fb0c fc01 	mul.w	ip, ip, r1
 8004a16:	eb00 030c 	add.w	r3, r0, ip
 8004a1a:	685a      	ldr	r2, [r3, #4]
 8004a1c:	f10c 0c08 	add.w	ip, ip, #8
 8004a20:	6852      	ldr	r2, [r2, #4]
 8004a22:	4460      	add	r0, ip
 8004a24:	4282      	cmp	r2, r0
 8004a26:	605a      	str	r2, [r3, #4]
 8004a28:	bf04      	itt	eq
 8004a2a:	6852      	ldreq	r2, [r2, #4]
 8004a2c:	605a      	streq	r2, [r3, #4]
 8004a2e:	4b07      	ldr	r3, [pc, #28]	; (8004a4c <vTaskSwitchContext+0x70>)
 8004a30:	2214      	movs	r2, #20
 8004a32:	fb02 3101 	mla	r1, r2, r1, r3
 8004a36:	684b      	ldr	r3, [r1, #4]
 8004a38:	68da      	ldr	r2, [r3, #12]
 8004a3a:	4b05      	ldr	r3, [pc, #20]	; (8004a50 <vTaskSwitchContext+0x74>)
 8004a3c:	601a      	str	r2, [r3, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
 8004a3e:	bd10      	pop	{r4, pc}
 8004a40:	200000f8 	.word	0x200000f8
 8004a44:	2000014c 	.word	0x2000014c
 8004a48:	2000011c 	.word	0x2000011c
 8004a4c:	20000094 	.word	0x20000094
 8004a50:	200000fc 	.word	0x200000fc

08004a54 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004a54:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004a58:	f04f 32ff 	mov.w	r2, #4294967295
 8004a5c:	6082      	str	r2, [r0, #8]
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004a5e:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8004a60:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8004a62:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = 0;
 8004a64:	2300      	movs	r3, #0
 8004a66:	6003      	str	r3, [r0, #0]
}
 8004a68:	4770      	bx	lr

08004a6a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8004a6a:	2300      	movs	r3, #0
 8004a6c:	6103      	str	r3, [r0, #16]
}
 8004a6e:	4770      	bx	lr

08004a70 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8004a70:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004a72:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8004a74:	608b      	str	r3, [r1, #8]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004a76:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004a78:	685a      	ldr	r2, [r3, #4]
 8004a7a:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004a7c:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004a7e:	6803      	ldr	r3, [r0, #0]

	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8004a80:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004a82:	3301      	adds	r3, #1
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004a84:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8004a86:	6003      	str	r3, [r0, #0]
}
 8004a88:	4770      	bx	lr

08004a8a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8004a8a:	680a      	ldr	r2, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004a8c:	f1b2 3fff 	cmp.w	r2, #4294967295
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8004a90:	bf0c      	ite	eq
 8004a92:	6903      	ldreq	r3, [r0, #16]
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004a94:	f100 0308 	addne.w	r3, r0, #8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004a98:	d101      	bne.n	8004a9e <vListInsert+0x14>
 8004a9a:	e006      	b.n	8004aaa <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004a9c:	685b      	ldr	r3, [r3, #4]
 8004a9e:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8004aa2:	f8dc c000 	ldr.w	ip, [ip]
 8004aa6:	4594      	cmp	ip, r2
 8004aa8:	d9f8      	bls.n	8004a9c <vListInsert+0x12>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004aaa:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004aac:	6108      	str	r0, [r1, #16]
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004aae:	6091      	str	r1, [r2, #8]
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004ab0:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004ab2:	6059      	str	r1, [r3, #4]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8004ab4:	608b      	str	r3, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004ab6:	6803      	ldr	r3, [r0, #0]
 8004ab8:	3301      	adds	r3, #1
 8004aba:	6003      	str	r3, [r0, #0]
}
 8004abc:	4770      	bx	lr

08004abe <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004abe:	6843      	ldr	r3, [r0, #4]
 8004ac0:	6882      	ldr	r2, [r0, #8]
 8004ac2:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8004ac4:	6882      	ldr	r2, [r0, #8]
 8004ac6:	6053      	str	r3, [r2, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8004ac8:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8004aca:	6859      	ldr	r1, [r3, #4]
 8004acc:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8004ace:	bf08      	it	eq
 8004ad0:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8004ad2:	2200      	movs	r2, #0
 8004ad4:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8004ad6:	681a      	ldr	r2, [r3, #0]
 8004ad8:	3a01      	subs	r2, #1
 8004ada:	601a      	str	r2, [r3, #0]
}
 8004adc:	4770      	bx	lr

08004ade <pxPortInitialiseStack>:
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8004ade:	1f03      	subs	r3, r0, #4
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8004ae0:	f04f 7c80 	mov.w	ip, #16777216	; 0x1000000
 8004ae4:	f840 cc04 	str.w	ip, [r0, #-4]
	pxTopOfStack--;
 8004ae8:	1f18      	subs	r0, r3, #4
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8004aea:	f843 1c04 	str.w	r1, [r3, #-4]
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
 8004aee:	2100      	movs	r1, #0
 8004af0:	f840 1c04 	str.w	r1, [r0, #-4]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8004af4:	f840 2c18 	str.w	r2, [r0, #-24]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8004af8:	f1a3 003c 	sub.w	r0, r3, #60	; 0x3c

	return pxTopOfStack;
}
 8004afc:	4770      	bx	lr
	...

08004b00 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8004b00:	4b06      	ldr	r3, [pc, #24]	; (8004b1c <pxCurrentTCBConst2>)
 8004b02:	6819      	ldr	r1, [r3, #0]
 8004b04:	6808      	ldr	r0, [r1, #0]
 8004b06:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004b0a:	f380 8809 	msr	PSP, r0
 8004b0e:	f04f 0000 	mov.w	r0, #0
 8004b12:	f380 8811 	msr	BASEPRI, r0
 8004b16:	f04e 0e0d 	orr.w	lr, lr, #13
 8004b1a:	4770      	bx	lr

08004b1c <pxCurrentTCBConst2>:
 8004b1c:	200000fc 	.word	0x200000fc

08004b20 <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8004b20:	4802      	ldr	r0, [pc, #8]	; (8004b2c <vPortStartFirstTask+0xc>)
 8004b22:	6800      	ldr	r0, [r0, #0]
 8004b24:	6800      	ldr	r0, [r0, #0]
 8004b26:	f380 8808 	msr	MSP, r0
 8004b2a:	df00      	svc	0
 8004b2c:	e000ed08 	.word	0xe000ed08

08004b30 <xPortStartScheduler>:
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004b30:	4b0b      	ldr	r3, [pc, #44]	; (8004b60 <xPortStartScheduler+0x30>)

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8004b32:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004b34:	681a      	ldr	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004b36:	2400      	movs	r4, #0
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004b38:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8004b3c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8004b3e:	681a      	ldr	r2, [r3, #0]
 8004b40:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8004b44:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004b46:	4a07      	ldr	r2, [pc, #28]	; (8004b64 <xPortStartScheduler+0x34>)
 8004b48:	4b07      	ldr	r3, [pc, #28]	; (8004b68 <xPortStartScheduler+0x38>)
 8004b4a:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8004b4c:	2207      	movs	r2, #7
 8004b4e:	3b04      	subs	r3, #4
 8004b50:	601a      	str	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004b52:	4b06      	ldr	r3, [pc, #24]	; (8004b6c <xPortStartScheduler+0x3c>)
 8004b54:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8004b56:	f7ff ffe3 	bl	8004b20 <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 8004b5a:	4620      	mov	r0, r4
 8004b5c:	bd10      	pop	{r4, pc}
 8004b5e:	bf00      	nop
 8004b60:	e000ed20 	.word	0xe000ed20
 8004b64:	0001193f 	.word	0x0001193f
 8004b68:	e000e014 	.word	0xe000e014
 8004b6c:	20000000 	.word	0x20000000

08004b70 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004b70:	4b02      	ldr	r3, [pc, #8]	; (8004b7c <vPortYieldFromISR+0xc>)
 8004b72:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004b76:	601a      	str	r2, [r3, #0]
}
 8004b78:	4770      	bx	lr
 8004b7a:	bf00      	nop
 8004b7c:	e000ed04 	.word	0xe000ed04

08004b80 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
 8004b80:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004b84:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8004b88:	4b02      	ldr	r3, [pc, #8]	; (8004b94 <vPortEnterCritical+0x14>)
 8004b8a:	681a      	ldr	r2, [r3, #0]
 8004b8c:	3201      	adds	r2, #1
 8004b8e:	601a      	str	r2, [r3, #0]
}
 8004b90:	4770      	bx	lr
 8004b92:	bf00      	nop
 8004b94:	20000000 	.word	0x20000000

08004b98 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 8004b98:	4a04      	ldr	r2, [pc, #16]	; (8004bac <vPortExitCritical+0x14>)
 8004b9a:	6813      	ldr	r3, [r2, #0]
 8004b9c:	3b01      	subs	r3, #1
 8004b9e:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004ba0:	b91b      	cbnz	r3, 8004baa <vPortExitCritical+0x12>
	{
		portENABLE_INTERRUPTS();
 8004ba2:	f04f 0000 	mov.w	r0, #0
 8004ba6:	f380 8811 	msr	BASEPRI, r0
	}
}
 8004baa:	4770      	bx	lr
 8004bac:	20000000 	.word	0x20000000

08004bb0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8004bb0:	f3ef 8009 	mrs	r0, PSP
 8004bb4:	4b0c      	ldr	r3, [pc, #48]	; (8004be8 <pxCurrentTCBConst>)
 8004bb6:	681a      	ldr	r2, [r3, #0]
 8004bb8:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004bbc:	6010      	str	r0, [r2, #0]
 8004bbe:	e92d 4008 	stmdb	sp!, {r3, lr}
 8004bc2:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004bc6:	f380 8811 	msr	BASEPRI, r0
 8004bca:	f7ff ff07 	bl	80049dc <vTaskSwitchContext>
 8004bce:	f04f 0000 	mov.w	r0, #0
 8004bd2:	f380 8811 	msr	BASEPRI, r0
 8004bd6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8004bda:	6819      	ldr	r1, [r3, #0]
 8004bdc:	6808      	ldr	r0, [r1, #0]
 8004bde:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004be2:	f380 8809 	msr	PSP, r0
 8004be6:	4770      	bx	lr

08004be8 <pxCurrentTCBConst>:
 8004be8:	200000fc 	.word	0x200000fc

08004bec <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8004bec:	b508      	push	{r3, lr}
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004bee:	4b07      	ldr	r3, [pc, #28]	; (8004c0c <xPortSysTickHandler+0x20>)
 8004bf0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004bf4:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8004bf6:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004bfa:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8004bfe:	f7ff fdbb 	bl	8004778 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8004c02:	f04f 0000 	mov.w	r0, #0
 8004c06:	f380 8811 	msr	BASEPRI, r0
}
 8004c0a:	bd08      	pop	{r3, pc}
 8004c0c:	e000ed04 	.word	0xe000ed04

08004c10 <umm_make_new_block>:

// ----------------------------------------------------------------------------

static void umm_make_new_block( unsigned short int c,
                                unsigned short int blocks,
                                unsigned short int freemask ) {
 8004c10:	b5f0      	push	{r4, r5, r6, r7, lr}

     UMM_NBLOCK(c+blocks) = UMM_NBLOCK(c) & UMM_BLOCKNO_MASK;
 8004c12:	240c      	movs	r4, #12
 8004c14:	fb04 fc00 	mul.w	ip, r4, r0
 8004c18:	1809      	adds	r1, r1, r0
 8004c1a:	4b0b      	ldr	r3, [pc, #44]	; (8004c48 <umm_make_new_block+0x38>)
 8004c1c:	fb04 f501 	mul.w	r5, r4, r1
 8004c20:	f833 600c 	ldrh.w	r6, [r3, ip]
 8004c24:	195f      	adds	r7, r3, r5
 8004c26:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
 8004c2a:	535e      	strh	r6, [r3, r5]
     UMM_PBLOCK(c+blocks) = c;
 8004c2c:	8078      	strh	r0, [r7, #2]

     UMM_PBLOCK(UMM_NBLOCK(c) & UMM_BLOCKNO_MASK) = (c+blocks);
 8004c2e:	f833 000c 	ldrh.w	r0, [r3, ip]
 8004c32:	b289      	uxth	r1, r1
 8004c34:	0440      	lsls	r0, r0, #17
 8004c36:	0c40      	lsrs	r0, r0, #17
 8004c38:	fb04 3400 	mla	r4, r4, r0, r3
 8004c3c:	8061      	strh	r1, [r4, #2]
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
 8004c3e:	ea42 0101 	orr.w	r1, r2, r1
 8004c42:	f823 100c 	strh.w	r1, [r3, ip]
}
 8004c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004c48:	2000056c 	.word	0x2000056c

08004c4c <umm_disconnect_from_free_list>:
// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 8004c4c:	210c      	movs	r1, #12
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
}

// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
 8004c4e:	b510      	push	{r4, lr}
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 8004c50:	4348      	muls	r0, r1
 8004c52:	4b0a      	ldr	r3, [pc, #40]	; (8004c7c <umm_disconnect_from_free_list+0x30>)
 8004c54:	181a      	adds	r2, r3, r0
 8004c56:	f8b2 c006 	ldrh.w	ip, [r2, #6]
 8004c5a:	8894      	ldrh	r4, [r2, #4]
 8004c5c:	fb01 3c0c 	mla	ip, r1, ip, r3
 8004c60:	f8ac 4004 	strh.w	r4, [ip, #4]
    UMM_PFREE(UMM_NFREE(c)) = UMM_PFREE(c);
 8004c64:	f8b2 c004 	ldrh.w	ip, [r2, #4]
 8004c68:	88d2      	ldrh	r2, [r2, #6]
 8004c6a:	fb01 310c 	mla	r1, r1, ip, r3
 8004c6e:	80ca      	strh	r2, [r1, #6]

    // And clear the free block indicator

    UMM_NBLOCK(c) &= (~UMM_FREELIST_MASK);
 8004c70:	5a1a      	ldrh	r2, [r3, r0]
 8004c72:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004c76:	521a      	strh	r2, [r3, r0]
}
 8004c78:	bd10      	pop	{r4, pc}
 8004c7a:	bf00      	nop
 8004c7c:	2000056c 	.word	0x2000056c

08004c80 <umm_assimilate_up>:

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 8004c80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 8004c82:	250c      	movs	r5, #12
 8004c84:	fb05 f600 	mul.w	r6, r5, r0
 8004c88:	4c0c      	ldr	r4, [pc, #48]	; (8004cbc <umm_assimilate_up+0x3c>)

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 8004c8a:	4607      	mov	r7, r0

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 8004c8c:	5ba0      	ldrh	r0, [r4, r6]
 8004c8e:	fb05 f300 	mul.w	r3, r5, r0
 8004c92:	5ee3      	ldrsh	r3, [r4, r3]
 8004c94:	2b00      	cmp	r3, #0
 8004c96:	da0f      	bge.n	8004cb8 <umm_assimilate_up+0x38>

    DBG_LOG_DEBUG( "Assimilate up to next block, which is FREE\n" );

    // Disconnect the next block from the FREE list

    umm_disconnect_from_free_list( UMM_NBLOCK(c) );
 8004c98:	f7ff ffd8 	bl	8004c4c <umm_disconnect_from_free_list>

    // Assimilate the next block with this one

    UMM_PBLOCK(UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK) = c;
 8004c9c:	5ba3      	ldrh	r3, [r4, r6]
 8004c9e:	436b      	muls	r3, r5
 8004ca0:	5ae3      	ldrh	r3, [r4, r3]
 8004ca2:	045b      	lsls	r3, r3, #17
 8004ca4:	0c5b      	lsrs	r3, r3, #17
 8004ca6:	fb05 4303 	mla	r3, r5, r3, r4
 8004caa:	805f      	strh	r7, [r3, #2]
    UMM_NBLOCK(c) = UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK;
 8004cac:	5ba3      	ldrh	r3, [r4, r6]
 8004cae:	435d      	muls	r5, r3
 8004cb0:	5b63      	ldrh	r3, [r4, r5]
 8004cb2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8004cb6:	53a3      	strh	r3, [r4, r6]
  } 
}
 8004cb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004cba:	bf00      	nop
 8004cbc:	2000056c 	.word	0x2000056c

08004cc0 <vPortFree>:
    return( UMM_PBLOCK(c) );
}

// ----------------------------------------------------------------------------

void umm_free( void *ptr ) {
 8004cc0:	b570      	push	{r4, r5, r6, lr}
 8004cc2:	4606      	mov	r6, r0

  unsigned short int c;

  // If we're being asked to free a NULL pointer, well that's just silly!

  if( (void *)0 == ptr ) {
 8004cc4:	2800      	cmp	r0, #0
 8004cc6:	d02e      	beq.n	8004d26 <vPortFree+0x66>
  //
  UMM_CRITICAL_ENTRY();

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 8004cc8:	4c17      	ldr	r4, [pc, #92]	; (8004d28 <vPortFree+0x68>)
 8004cca:	250c      	movs	r5, #12
 8004ccc:	1b36      	subs	r6, r6, r4
  // NOTE:  See the new umm_info() function that you can use to see if a ptr is
  //        on the free list!

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 8004cce:	f7ff fd3f 	bl	8004750 <vTaskSuspendAll>

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 8004cd2:	fbb6 f6f5 	udiv	r6, r6, r5
 8004cd6:	b2b6      	uxth	r6, r6

  DBG_LOG_DEBUG( "Freeing block %6d\n", c );

  // Now let's assimilate this block with the next one if possible.

  umm_assimilate_up( c );
 8004cd8:	4630      	mov	r0, r6
 8004cda:	f7ff ffd1 	bl	8004c80 <umm_assimilate_up>

  // Then assimilate with the previous block if possible

  if( UMM_NBLOCK(UMM_PBLOCK(c)) & UMM_FREELIST_MASK ) {
 8004cde:	fb05 f306 	mul.w	r3, r5, r6
 8004ce2:	18e2      	adds	r2, r4, r3
 8004ce4:	8850      	ldrh	r0, [r2, #2]
 8004ce6:	4368      	muls	r0, r5
 8004ce8:	5e21      	ldrsh	r1, [r4, r0]
 8004cea:	2900      	cmp	r1, #0
 8004cec:	da0b      	bge.n	8004d06 <vPortFree+0x46>

// ----------------------------------------------------------------------------

static unsigned short int umm_assimilate_down( unsigned short int c, unsigned short int freemask ) {

    UMM_NBLOCK(UMM_PBLOCK(c)) = UMM_NBLOCK(c) | freemask;
 8004cee:	5ae1      	ldrh	r1, [r4, r3]
 8004cf0:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 8004cf4:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 8004cf8:	5221      	strh	r1, [r4, r0]
    UMM_PBLOCK(UMM_NBLOCK(c)) = UMM_PBLOCK(c);
 8004cfa:	5ae3      	ldrh	r3, [r4, r3]
 8004cfc:	8852      	ldrh	r2, [r2, #2]
 8004cfe:	fb05 4403 	mla	r4, r5, r3, r4
 8004d02:	8062      	strh	r2, [r4, #2]
 8004d04:	e00d      	b.n	8004d22 <vPortFree+0x62>
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 8004d06:	88a1      	ldrh	r1, [r4, #4]
 8004d08:	fb05 4501 	mla	r5, r5, r1, r4
    UMM_NFREE(c)            = UMM_NFREE(0);
 8004d0c:	8091      	strh	r1, [r2, #4]
    UMM_PFREE(c)            = 0;
 8004d0e:	2100      	movs	r1, #0
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 8004d10:	80ee      	strh	r6, [r5, #6]
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
    UMM_NFREE(0)            = c;
 8004d12:	80a6      	strh	r6, [r4, #4]

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
 8004d14:	80d1      	strh	r1, [r2, #6]
    UMM_NFREE(0)            = c;

    UMM_NBLOCK(c)          |= UMM_FREELIST_MASK;
 8004d16:	5ae2      	ldrh	r2, [r4, r3]
 8004d18:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8004d1c:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8004d20:	52e2      	strh	r2, [r4, r3]
  }
#endif

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 8004d22:	f7ff fd87 	bl	8004834 <xTaskResumeAll>
}
 8004d26:	bd70      	pop	{r4, r5, r6, pc}
 8004d28:	2000056c 	.word	0x2000056c

08004d2c <pvPortMalloc>:

// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {
 8004d2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004d2e:	4606      	mov	r6, r0
  // the very first thing we do is figure out if we're being asked to allocate
  // a size of 0 - and if we are we'll simply return a null pointer. if not
  // then reduce the size by 1 byte so that the subsequent calculations on
  // the number of blocks to allocate are easier...

  if( 0 == size ) {
 8004d30:	2800      	cmp	r0, #0
 8004d32:	d07f      	beq.n	8004e34 <pvPortMalloc+0x108>
    return( (void *)NULL );
  }

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 8004d34:	f7ff fd0c 	bl	8004750 <vTaskSuspendAll>
  //
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
 8004d38:	2e08      	cmp	r6, #8
 8004d3a:	d907      	bls.n	8004d4c <pvPortMalloc+0x20>
    return( 1 );

  // If it's for more than that, then we need to figure out the number of
  // additional whole blocks the size of an umm_block are required.

  size -= ( 1 + (sizeof(((umm_block *)0)->body)) );
 8004d3c:	f1a6 0109 	sub.w	r1, r6, #9

  return( 2 + size/(sizeof(umm_block)) );
 8004d40:	230c      	movs	r3, #12
 8004d42:	fbb1 f1f3 	udiv	r1, r1, r3
 8004d46:	3102      	adds	r1, #2
 8004d48:	b289      	uxth	r1, r1
 8004d4a:	e000      	b.n	8004d4e <pvPortMalloc+0x22>
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
    return( 1 );
 8004d4c:	2101      	movs	r1, #1
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 8004d4e:	483a      	ldr	r0, [pc, #232]	; (8004e38 <pvPortMalloc+0x10c>)

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;
 8004d50:	f647 73ff 	movw	r3, #32767	; 0x7fff
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 8004d54:	8884      	ldrh	r4, [r0, #4]
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 8004d56:	2500      	movs	r5, #0
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
 8004d58:	4622      	mov	r2, r4
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 8004d5a:	f04f 0e0c 	mov.w	lr, #12
 8004d5e:	e018      	b.n	8004d92 <pvPortMalloc+0x66>
    blockSize = (UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK) - cf;
 8004d60:	f830 500c 	ldrh.w	r5, [r0, ip]
 8004d64:	046d      	lsls	r5, r5, #17
 8004d66:	ebc4 4555 	rsb	r5, r4, r5, lsr #17
 8004d6a:	b2ad      	uxth	r5, r5
#if defined UMM_FIRST_FIT
    // This is the first block that fits!
    if( (blockSize >= blocks) )
        break;
#elif defined UMM_BEST_FIT
    if( (blockSize >= blocks) && (blockSize < bestSize) ) {
 8004d6c:	428d      	cmp	r5, r1
 8004d6e:	bf34      	ite	cc
 8004d70:	f04f 0c00 	movcc.w	ip, #0
 8004d74:	f04f 0c01 	movcs.w	ip, #1
 8004d78:	429d      	cmp	r5, r3
 8004d7a:	bf2c      	ite	cs
 8004d7c:	f04f 0c00 	movcs.w	ip, #0
 8004d80:	f00c 0c01 	andcc.w	ip, ip, #1
 8004d84:	f1bc 0f00 	cmp.w	ip, #0
 8004d88:	bf18      	it	ne
 8004d8a:	4622      	movne	r2, r4
 8004d8c:	bf18      	it	ne
 8004d8e:	462b      	movne	r3, r5
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 8004d90:	4634      	mov	r4, r6
  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 8004d92:	fb0e fc04 	mul.w	ip, lr, r4
 8004d96:	eb00 060c 	add.w	r6, r0, ip
 8004d9a:	88b6      	ldrh	r6, [r6, #4]
 8004d9c:	2e00      	cmp	r6, #0
 8004d9e:	d1df      	bne.n	8004d60 <pvPortMalloc+0x34>
#endif

    cf = UMM_NFREE(cf);
  }

  if( 0x7FFF != bestSize ) {
 8004da0:	f647 70ff 	movw	r0, #32767	; 0x7fff
 8004da4:	4283      	cmp	r3, r0
 8004da6:	bf18      	it	ne
 8004da8:	461d      	movne	r5, r3
 8004daa:	bf18      	it	ne
 8004dac:	4614      	movne	r4, r2
    cf        = bestBlock;
    blockSize = bestSize;
  }

  if( UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK ) {
 8004dae:	220c      	movs	r2, #12
 8004db0:	4362      	muls	r2, r4
 8004db2:	4b21      	ldr	r3, [pc, #132]	; (8004e38 <pvPortMalloc+0x10c>)
 8004db4:	5a9a      	ldrh	r2, [r3, r2]
 8004db6:	0452      	lsls	r2, r2, #17
 8004db8:	0c56      	lsrs	r6, r2, #17
 8004dba:	b182      	cbz	r2, 8004dde <pvPortMalloc+0xb2>
    // This is an existing block in the memory heap, we just need to split off
    // what we need, unlink it from the free list and mark it as in use, and
    // link the rest of the block back into the freelist as if it was a new
    // block on the free list...

    if( blockSize == blocks ) {
 8004dbc:	428d      	cmp	r5, r1
 8004dbe:	d103      	bne.n	8004dc8 <pvPortMalloc+0x9c>
      // It's an exact fit and we don't neet to split off a block.
      DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - exact\n", blocks, cf );

      // Disconnect this block from the FREE list

      umm_disconnect_from_free_list( cf );
 8004dc0:	4620      	mov	r0, r4
 8004dc2:	f7ff ff43 	bl	8004c4c <umm_disconnect_from_free_list>
 8004dc6:	e02e      	b.n	8004e26 <pvPortMalloc+0xfa>

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 8004dc8:	1a6d      	subs	r5, r5, r1
 8004dca:	b2ad      	uxth	r5, r5
 8004dcc:	4620      	mov	r0, r4
 8004dce:	4629      	mov	r1, r5
 8004dd0:	f44f 4200 	mov.w	r2, #32768	; 0x8000

     cf += blockSize-blocks;
 8004dd4:	192c      	adds	r4, r5, r4

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 8004dd6:	f7ff ff1b 	bl	8004c10 <umm_make_new_block>

     cf += blockSize-blocks;
 8004dda:	b2a4      	uxth	r4, r4
 8004ddc:	e023      	b.n	8004e26 <pvPortMalloc+0xfa>
    // We're at the end of the heap - allocate a new block, but check to see if
    // there's enough memory left for the requested block! Actually, we may need
    // one more than that if we're initializing the umm_heap for the first
    // time, which happens in the next conditional...

    if( UMM_NUMBLOCKS <= cf+blocks+1 ) {
 8004dde:	1862      	adds	r2, r4, r1
 8004de0:	f5b2 7f55 	cmp.w	r2, #852	; 0x354
 8004de4:	db06      	blt.n	8004df4 <pvPortMalloc+0xc8>
      DBG_LOG_WARNING(  "Can't allocate %5d blocks at %5d\n", blocks, cf );
 8004de6:	4622      	mov	r2, r4
 8004de8:	4814      	ldr	r0, [pc, #80]	; (8004e3c <pvPortMalloc+0x110>)
 8004dea:	f000 fd63 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>

      // Release the critical section...
      //
      UMM_CRITICAL_EXIT();
 8004dee:	f7ff fd21 	bl	8004834 <xTaskResumeAll>

      return( (void *)NULL );
 8004df2:	e01f      	b.n	8004e34 <pvPortMalloc+0x108>

    // Now check to see if we need to initialize the free list...this assumes
    // that the BSS is set to 0 on startup. We should rarely get to the end of
    // the free list so this is the "cheapest" place to put the initialization!

    if( 0 == cf ) {
 8004df4:	b91c      	cbnz	r4, 8004dfe <pvPortMalloc+0xd2>
      DBG_LOG_DEBUG( "Initializing malloc free block pointer\n" );
      UMM_NBLOCK(0) = 1;
 8004df6:	2201      	movs	r2, #1
 8004df8:	801a      	strh	r2, [r3, #0]
      UMM_NFREE(0)  = 1;
 8004dfa:	809a      	strh	r2, [r3, #4]
      cf            = 1;
 8004dfc:	3401      	adds	r4, #1
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 8004dfe:	220c      	movs	r2, #12
 8004e00:	fb02 f304 	mul.w	r3, r2, r4
 8004e04:	4e0c      	ldr	r6, [pc, #48]	; (8004e38 <pvPortMalloc+0x10c>)
 8004e06:	1865      	adds	r5, r4, r1
 8004e08:	18f1      	adds	r1, r6, r3
 8004e0a:	88c8      	ldrh	r0, [r1, #6]
 8004e0c:	b2af      	uxth	r7, r5
 8004e0e:	fb02 6000 	mla	r0, r2, r0, r6

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 8004e12:	fb02 6505 	mla	r5, r2, r5, r6
      cf            = 1;
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 8004e16:	8087      	strh	r7, [r0, #4]

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 8004e18:	4628      	mov	r0, r5
 8004e1a:	9301      	str	r3, [sp, #4]
 8004e1c:	f005 f822 	bl	8009e64 <memcpy>

    UMM_NBLOCK(cf)           = cf+blocks;
 8004e20:	9b01      	ldr	r3, [sp, #4]
    UMM_PBLOCK(cf+blocks)    = cf;
 8004e22:	806c      	strh	r4, [r5, #2]

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );

    UMM_NBLOCK(cf)           = cf+blocks;
 8004e24:	52f7      	strh	r7, [r6, r3]
    UMM_PBLOCK(cf+blocks)    = cf;
  }

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 8004e26:	f7ff fd05 	bl	8004834 <xTaskResumeAll>

  return( (void *)&UMM_DATA(cf) );
 8004e2a:	4b03      	ldr	r3, [pc, #12]	; (8004e38 <pvPortMalloc+0x10c>)
 8004e2c:	260c      	movs	r6, #12
 8004e2e:	fb06 3604 	mla	r6, r6, r4, r3
 8004e32:	3604      	adds	r6, #4
}
 8004e34:	4630      	mov	r0, r6
 8004e36:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004e38:	2000056c 	.word	0x2000056c
 8004e3c:	0800a109 	.word	0x0800a109

08004e40 <Reset_Handler>:
 * @param  None
 * @retval : None
*/

void Reset_Handler(void)
{
 8004e40:	4668      	mov	r0, sp
 8004e42:	f020 0107 	bic.w	r1, r0, #7
 8004e46:	468d      	mov	sp, r1
 8004e48:	b501      	push	{r0, lr}
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8004e4a:	4a0a      	ldr	r2, [pc, #40]	; (8004e74 <Reset_Handler+0x34>)
 8004e4c:	4b0a      	ldr	r3, [pc, #40]	; (8004e78 <Reset_Handler+0x38>)
 8004e4e:	490b      	ldr	r1, [pc, #44]	; (8004e7c <Reset_Handler+0x3c>)
 8004e50:	e003      	b.n	8004e5a <Reset_Handler+0x1a>
  {
    *(pulDest++) = *(pulSrc++);
 8004e52:	f852 0b04 	ldr.w	r0, [r2], #4
 8004e56:	f843 0b04 	str.w	r0, [r3], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8004e5a:	428b      	cmp	r3, r1
 8004e5c:	d3f9      	bcc.n	8004e52 <Reset_Handler+0x12>
 8004e5e:	4b08      	ldr	r3, [pc, #32]	; (8004e80 <Reset_Handler+0x40>)
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8004e60:	4908      	ldr	r1, [pc, #32]	; (8004e84 <Reset_Handler+0x44>)
  {
    *(pulDest++) = 0;
 8004e62:	2200      	movs	r2, #0
 8004e64:	e001      	b.n	8004e6a <Reset_Handler+0x2a>
 8004e66:	f843 2b04 	str.w	r2, [r3], #4
  for(pulDest = &_sdata; pulDest < &_edata; )
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8004e6a:	428b      	cmp	r3, r1
 8004e6c:	d3fb      	bcc.n	8004e66 <Reset_Handler+0x26>
  {
    *(pulDest++) = 0;
  }

  /* Call the application's entry point.*/
  main();
 8004e6e:	f7ff fa49 	bl	8004304 <main>
 8004e72:	e7fe      	b.n	8004e72 <Reset_Handler+0x32>
 8004e74:	0800a3a8 	.word	0x0800a3a8
 8004e78:	20000000 	.word	0x20000000
 8004e7c:	20000058 	.word	0x20000058
 8004e80:	20000058 	.word	0x20000058
 8004e84:	200030e0 	.word	0x200030e0

08004e88 <_init>:
}

// dummy for newer gcc versions
void _init()
{
}
 8004e88:	4770      	bx	lr

08004e8a <Default_Handler>:
 * @param  None     
 * @retval : None       
*/

void Default_Handler(void) 
{
 8004e8a:	e7fe      	b.n	8004e8a <Default_Handler>

08004e8c <MIOS32_SRIO_DMA_Callback>:
/////////////////////////////////////////////////////////////////////////////
// DMA callback function is called by MIOS32_SPI driver once the complete SRIO chain
// has been scanned
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_SRIO_DMA_Callback(void)
{
 8004e8c:	b538      	push	{r3, r4, r5, lr}
  // notify that new values have been transfered
  srio_values_transfered = 1;
 8004e8e:	4b20      	ldr	r3, [pc, #128]	; (8004f10 <MIOS32_SRIO_DMA_Callback+0x84>)
 8004e90:	2401      	movs	r4, #1

  // latch DOUT registers by pulsing RCLK: 1->0->1
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004e92:	2100      	movs	r1, #0
// has been scanned
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_SRIO_DMA_Callback(void)
{
  // notify that new values have been transfered
  srio_values_transfered = 1;
 8004e94:	701c      	strb	r4, [r3, #0]

  // latch DOUT registers by pulsing RCLK: 1->0->1
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004e96:	460a      	mov	r2, r1
 8004e98:	4620      	mov	r0, r4
 8004e9a:	f001 fcdf 	bl	800685c <MIOS32_SPI_RC_PinSet>
  MIOS32_DELAY_Wait_uS(1);
 8004e9e:	4620      	mov	r0, r4
 8004ea0:	f002 fb4c 	bl	800753c <MIOS32_DELAY_Wait_uS>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8004ea4:	2100      	movs	r1, #0
 8004ea6:	4622      	mov	r2, r4
 8004ea8:	4620      	mov	r0, r4
 8004eaa:	f001 fcd7 	bl	800685c <MIOS32_SPI_RC_PinSet>

  // copy/or buffered DIN values/changed flags
  int i;
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din_changed[i] |= mios32_srio_din[i] ^ mios32_srio_din_buffer[i];
 8004eae:	4819      	ldr	r0, [pc, #100]	; (8004f14 <MIOS32_SRIO_DMA_Callback+0x88>)
 8004eb0:	4919      	ldr	r1, [pc, #100]	; (8004f18 <MIOS32_SRIO_DMA_Callback+0x8c>)
 8004eb2:	4a1a      	ldr	r2, [pc, #104]	; (8004f1c <MIOS32_SRIO_DMA_Callback+0x90>)
  MIOS32_DELAY_Wait_uS(1);
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value

  // copy/or buffered DIN values/changed flags
  int i;
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8004eb4:	2300      	movs	r3, #0
    mios32_srio_din_changed[i] |= mios32_srio_din[i] ^ mios32_srio_din_buffer[i];
 8004eb6:	5cc4      	ldrb	r4, [r0, r3]
 8004eb8:	f811 c003 	ldrb.w	ip, [r1, r3]
 8004ebc:	5cd5      	ldrb	r5, [r2, r3]
 8004ebe:	ea85 0c0c 	eor.w	ip, r5, ip
 8004ec2:	ea44 0c0c 	orr.w	ip, r4, ip
 8004ec6:	f800 c003 	strb.w	ip, [r0, r3]
    mios32_srio_din[i] = mios32_srio_din_buffer[i];
 8004eca:	f812 c003 	ldrb.w	ip, [r2, r3]
 8004ece:	f801 c003 	strb.w	ip, [r1, r3]
  MIOS32_DELAY_Wait_uS(1);
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value

  // copy/or buffered DIN values/changed flags
  int i;
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8004ed2:	3301      	adds	r3, #1
 8004ed4:	2b10      	cmp	r3, #16
 8004ed6:	d1ee      	bne.n	8004eb6 <MIOS32_SRIO_DMA_Callback+0x2a>

  // call user specific hook if requested
  // it has to be called before button debouncing is handled
  // to ensure that the encoder driver, but also other drivers (e.g. BLM) are working properly
  // regardless if debouncing is enabled or not
  if( srio_scan_finished_hook != NULL )
 8004ed8:	4b11      	ldr	r3, [pc, #68]	; (8004f20 <MIOS32_SRIO_DMA_Callback+0x94>)
 8004eda:	681b      	ldr	r3, [r3, #0]
 8004edc:	b103      	cbz	r3, 8004ee0 <MIOS32_SRIO_DMA_Callback+0x54>
    srio_scan_finished_hook();
 8004ede:	4798      	blx	r3
  // at this time. In order to ensure, that a new final state of a button won't get lost, 
  // the DIN values are XORed with the "changed" flags (yes, this idea is ill, but it works! :)
  // Even the encoder handler (or others which are notified by the scan_finished_hook) still
  // work properly, because they are clearing the appr. "changed" flags, so that the DIN
  // values won't be touched by the XOR operation.
  if( debounce_time && debounce_ctr ) {
 8004ee0:	4b10      	ldr	r3, [pc, #64]	; (8004f24 <MIOS32_SRIO_DMA_Callback+0x98>)
 8004ee2:	781b      	ldrb	r3, [r3, #0]
 8004ee4:	b19b      	cbz	r3, 8004f0e <MIOS32_SRIO_DMA_Callback+0x82>
 8004ee6:	4b10      	ldr	r3, [pc, #64]	; (8004f28 <MIOS32_SRIO_DMA_Callback+0x9c>)
 8004ee8:	781a      	ldrb	r2, [r3, #0]
 8004eea:	b182      	cbz	r2, 8004f0e <MIOS32_SRIO_DMA_Callback+0x82>
    --debounce_ctr;
 8004eec:	3a01      	subs	r2, #1
 8004eee:	701a      	strb	r2, [r3, #0]

    for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
      mios32_srio_din[i] ^= mios32_srio_din_changed[i];
 8004ef0:	4909      	ldr	r1, [pc, #36]	; (8004f18 <MIOS32_SRIO_DMA_Callback+0x8c>)
  // work properly, because they are clearing the appr. "changed" flags, so that the DIN
  // values won't be touched by the XOR operation.
  if( debounce_time && debounce_ctr ) {
    --debounce_ctr;

    for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8004ef2:	2300      	movs	r3, #0
      mios32_srio_din[i] ^= mios32_srio_din_changed[i];
 8004ef4:	4a07      	ldr	r2, [pc, #28]	; (8004f14 <MIOS32_SRIO_DMA_Callback+0x88>)
      mios32_srio_din_changed[i] = 0;
 8004ef6:	4618      	mov	r0, r3
  // values won't be touched by the XOR operation.
  if( debounce_time && debounce_ctr ) {
    --debounce_ctr;

    for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
      mios32_srio_din[i] ^= mios32_srio_din_changed[i];
 8004ef8:	f811 c003 	ldrb.w	ip, [r1, r3]
 8004efc:	5cd4      	ldrb	r4, [r2, r3]
 8004efe:	ea84 0c0c 	eor.w	ip, r4, ip
 8004f02:	f801 c003 	strb.w	ip, [r1, r3]
      mios32_srio_din_changed[i] = 0;
 8004f06:	54d0      	strb	r0, [r2, r3]
  // work properly, because they are clearing the appr. "changed" flags, so that the DIN
  // values won't be touched by the XOR operation.
  if( debounce_time && debounce_ctr ) {
    --debounce_ctr;

    for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8004f08:	3301      	adds	r3, #1
 8004f0a:	2b10      	cmp	r3, #16
 8004f0c:	d1f4      	bne.n	8004ef8 <MIOS32_SRIO_DMA_Callback+0x6c>
      mios32_srio_din_changed[i] = 0;
    }
  }

  // next transfer has to be started with MIOS32_SRIO_ScanStart
}
 8004f0e:	bd38      	pop	{r3, r4, r5, pc}
 8004f10:	2000015d 	.word	0x2000015d
 8004f14:	20002d68 	.word	0x20002d68
 8004f18:	20002d98 	.word	0x20002d98
 8004f1c:	20002d88 	.word	0x20002d88
 8004f20:	20000158 	.word	0x20000158
 8004f24:	2000015c 	.word	0x2000015c
 8004f28:	2000015e 	.word	0x2000015e

08004f2c <MIOS32_SRIO_Init>:
//! Initializes SPI pins and peripheral
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
 8004f2c:	b538      	push	{r3, r4, r5, lr}
  // currently only mode 0 supported
  if( mode != 0 )
 8004f2e:	bb50      	cbnz	r0, 8004f86 <MIOS32_SRIO_Init+0x5a>
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 8004f30:	4b16      	ldr	r3, [pc, #88]	; (8004f8c <MIOS32_SRIO_Init+0x60>)

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 8004f32:	4d17      	ldr	r5, [pc, #92]	; (8004f90 <MIOS32_SRIO_Init+0x64>)
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 8004f34:	f8df e05c 	ldr.w	lr, [pc, #92]	; 8004f94 <MIOS32_SRIO_Init+0x68>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 8004f38:	f8df c05c 	ldr.w	ip, [pc, #92]	; 8004f98 <MIOS32_SRIO_Init+0x6c>
    mios32_srio_din_changed[i] = 0;   // no change
 8004f3c:	4917      	ldr	r1, [pc, #92]	; (8004f9c <MIOS32_SRIO_Init+0x70>)
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 8004f3e:	6018      	str	r0, [r3, #0]

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 8004f40:	4603      	mov	r3, r0
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 8004f42:	22ff      	movs	r2, #255	; 0xff

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 8004f44:	542b      	strb	r3, [r5, r0]
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 8004f46:	f80e 2000 	strb.w	r2, [lr, r0]
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 8004f4a:	f80c 2000 	strb.w	r2, [ip, r0]
    mios32_srio_din_changed[i] = 0;   // no change
 8004f4e:	540b      	strb	r3, [r1, r0]
 8004f50:	3001      	adds	r0, #1

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 8004f52:	2400      	movs	r4, #0
  srio_scan_finished_hook = NULL;

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8004f54:	2810      	cmp	r0, #16
 8004f56:	d1f4      	bne.n	8004f42 <MIOS32_SRIO_Init+0x16>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
    mios32_srio_din_changed[i] = 0;   // no change
  }

  // initial state of RCLK
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8004f58:	2001      	movs	r0, #1
 8004f5a:	4602      	mov	r2, r0
 8004f5c:	4621      	mov	r1, r4
 8004f5e:	f001 fc7d 	bl	800685c <MIOS32_SPI_RC_PinSet>

  // init GPIO structure
  // using 2 MHz instead of 50 MHz to avoid fast transients which can cause flickering!
  // optionally using open drain mode for cheap and sufficient levelshifting from 3.3V to 5V
#if MIOS32_SRIO_OUTPUTS_OD
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8004f62:	2103      	movs	r1, #3
 8004f64:	2001      	movs	r0, #1
 8004f66:	f001 fbc9 	bl	80066fc <MIOS32_SPI_IO_Init>
#else
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK);
#endif

  // init SPI port for baudrate of ca. 2 uS period @ 72 MHz
  MIOS32_SPI_TransferModeInit(MIOS32_SRIO_SPI, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_64);
 8004f6a:	2205      	movs	r2, #5
 8004f6c:	2001      	movs	r0, #1
 8004f6e:	2103      	movs	r1, #3
 8004f70:	f001 ff12 	bl	8006d98 <MIOS32_SPI_TransferModeInit>

  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;
 8004f74:	4b0a      	ldr	r3, [pc, #40]	; (8004fa0 <MIOS32_SRIO_Init+0x74>)
 8004f76:	2201      	movs	r2, #1
 8004f78:	701a      	strb	r2, [r3, #0]

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 8004f7a:	4b0a      	ldr	r3, [pc, #40]	; (8004fa4 <MIOS32_SRIO_Init+0x78>)
  debounce_ctr = 0;
  
  return 0;
 8004f7c:	4620      	mov	r0, r4
  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 8004f7e:	701c      	strb	r4, [r3, #0]
  debounce_ctr = 0;
 8004f80:	4b09      	ldr	r3, [pc, #36]	; (8004fa8 <MIOS32_SRIO_Init+0x7c>)
 8004f82:	701c      	strb	r4, [r3, #0]
  
  return 0;
 8004f84:	e001      	b.n	8004f8a <MIOS32_SRIO_Init+0x5e>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8004f86:	f04f 30ff 	mov.w	r0, #4294967295
  // initial debounce time (debouncing disabled)
  debounce_time = 0;
  debounce_ctr = 0;
  
  return 0;
}
 8004f8a:	bd38      	pop	{r3, r4, r5, pc}
 8004f8c:	20000158 	.word	0x20000158
 8004f90:	20002d78 	.word	0x20002d78
 8004f94:	20002d98 	.word	0x20002d98
 8004f98:	20002d88 	.word	0x20002d88
 8004f9c:	20002d68 	.word	0x20002d68
 8004fa0:	2000015d 	.word	0x2000015d
 8004fa4:	2000015c 	.word	0x2000015c
 8004fa8:	2000015e 	.word	0x2000015e

08004fac <MIOS32_SRIO_DebounceStart>:
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 8004fac:	4b02      	ldr	r3, [pc, #8]	; (8004fb8 <MIOS32_SRIO_DebounceStart+0xc>)
  return 0; // no error
}
 8004fae:	2000      	movs	r0, #0
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 8004fb0:	781a      	ldrb	r2, [r3, #0]
 8004fb2:	4b02      	ldr	r3, [pc, #8]	; (8004fbc <MIOS32_SRIO_DebounceStart+0x10>)
 8004fb4:	701a      	strb	r2, [r3, #0]
  return 0; // no error
}
 8004fb6:	4770      	bx	lr
 8004fb8:	2000015c 	.word	0x2000015c
 8004fbc:	2000015e 	.word	0x2000015e

08004fc0 <MIOS32_SRIO_ScanStart>:
//!     (all DOUT registers written, all DIN registers read)
//!     use NULL if no function should be called
//! \return < 0 if operation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_ScanStart(void *_notify_hook)
{
 8004fc0:	b513      	push	{r0, r1, r4, lr}

  // exit if previous stream hasn't been sent yet (no additional transfer required)
  // THIS IS A FAILSAVE MEASURE ONLY!
  // should never happen if MIOS32_SRIO_ScanStart is called each mS
  // the transfer itself takes ca. 225 uS (if 16 SRIOs are scanned)
  if( !srio_values_transfered )
 8004fc2:	4b10      	ldr	r3, [pc, #64]	; (8005004 <MIOS32_SRIO_ScanStart+0x44>)
 8004fc4:	781a      	ldrb	r2, [r3, #0]
 8004fc6:	b1d2      	cbz	r2, 8004ffe <MIOS32_SRIO_ScanStart+0x3e>
    return -2; // notify this special scenario - we could retry here

  // notify that new values have to be transfered
  srio_values_transfered = 0;
 8004fc8:	2400      	movs	r4, #0
 8004fca:	701c      	strb	r4, [r3, #0]

  // change notification function
  srio_scan_finished_hook = _notify_hook;
 8004fcc:	4b0e      	ldr	r3, [pc, #56]	; (8005008 <MIOS32_SRIO_ScanStart+0x48>)

  // before first byte will be sent:
  // latch DIN registers by pulsing RCLK: 1->0->1
  // TODO: maybe we should disable all IRQs here for higher accuracy
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004fce:	4621      	mov	r1, r4

  // notify that new values have to be transfered
  srio_values_transfered = 0;

  // change notification function
  srio_scan_finished_hook = _notify_hook;
 8004fd0:	6018      	str	r0, [r3, #0]

  // before first byte will be sent:
  // latch DIN registers by pulsing RCLK: 1->0->1
  // TODO: maybe we should disable all IRQs here for higher accuracy
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004fd2:	4622      	mov	r2, r4
 8004fd4:	2001      	movs	r0, #1
 8004fd6:	f001 fc41 	bl	800685c <MIOS32_SPI_RC_PinSet>
  MIOS32_DELAY_Wait_uS(1); // TODO: variable delay for touch sensors
 8004fda:	2001      	movs	r0, #1
 8004fdc:	f002 faae 	bl	800753c <MIOS32_DELAY_Wait_uS>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8004fe0:	2001      	movs	r0, #1
 8004fe2:	4621      	mov	r1, r4
 8004fe4:	4602      	mov	r2, r0
 8004fe6:	f001 fc39 	bl	800685c <MIOS32_SPI_RC_PinSet>

  // start DMA transfer
  MIOS32_SPI_TransferBlock(MIOS32_SRIO_SPI,
 8004fea:	4b08      	ldr	r3, [pc, #32]	; (800500c <MIOS32_SRIO_ScanStart+0x4c>)
 8004fec:	2001      	movs	r0, #1
 8004fee:	9300      	str	r3, [sp, #0]
 8004ff0:	4907      	ldr	r1, [pc, #28]	; (8005010 <MIOS32_SRIO_ScanStart+0x50>)
 8004ff2:	4a08      	ldr	r2, [pc, #32]	; (8005014 <MIOS32_SRIO_ScanStart+0x54>)
 8004ff4:	2310      	movs	r3, #16
 8004ff6:	f002 f82b 	bl	8007050 <MIOS32_SPI_TransferBlock>
			   (u8 *)&mios32_srio_dout[0], (u8 *)&mios32_srio_din_buffer[0],
			   MIOS32_SRIO_NUM_SR,
			   MIOS32_SRIO_DMA_Callback);

  return 0;
 8004ffa:	4620      	mov	r0, r4
 8004ffc:	e001      	b.n	8005002 <MIOS32_SRIO_ScanStart+0x42>
  // exit if previous stream hasn't been sent yet (no additional transfer required)
  // THIS IS A FAILSAVE MEASURE ONLY!
  // should never happen if MIOS32_SRIO_ScanStart is called each mS
  // the transfer itself takes ca. 225 uS (if 16 SRIOs are scanned)
  if( !srio_values_transfered )
    return -2; // notify this special scenario - we could retry here
 8004ffe:	f06f 0001 	mvn.w	r0, #1
			   (u8 *)&mios32_srio_dout[0], (u8 *)&mios32_srio_din_buffer[0],
			   MIOS32_SRIO_NUM_SR,
			   MIOS32_SRIO_DMA_Callback);

  return 0;
}
 8005002:	bd1c      	pop	{r2, r3, r4, pc}
 8005004:	2000015d 	.word	0x2000015d
 8005008:	20000158 	.word	0x20000158
 800500c:	08004e8d 	.word	0x08004e8d
 8005010:	20002d78 	.word	0x20002d78
 8005014:	20002d88 	.word	0x20002d88

08005018 <MIOS32_DIN_Init>:
s32 MIOS32_DIN_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 8005018:	b960      	cbnz	r0, 8005034 <MIOS32_DIN_Init+0x1c>
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 800501a:	f8df c020 	ldr.w	ip, [pc, #32]	; 800503c <MIOS32_DIN_Init+0x24>
    mios32_srio_din_changed[i] = 0;
 800501e:	4a08      	ldr	r2, [pc, #32]	; (8005040 <MIOS32_DIN_Init+0x28>)
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 8005020:	21ff      	movs	r1, #255	; 0xff
    mios32_srio_din_changed[i] = 0;
 8005022:	4603      	mov	r3, r0
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 8005024:	f80c 1000 	strb.w	r1, [ip, r0]
    mios32_srio_din_changed[i] = 0;
 8005028:	5413      	strb	r3, [r2, r0]
 800502a:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 800502c:	2810      	cmp	r0, #16
 800502e:	d1f9      	bne.n	8005024 <MIOS32_DIN_Init+0xc>
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
 8005030:	2000      	movs	r0, #0
 8005032:	e001      	b.n	8005038 <MIOS32_DIN_Init+0x20>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005034:	f04f 30ff 	mov.w	r0, #4294967295
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
}
 8005038:	4770      	bx	lr
 800503a:	bf00      	nop
 800503c:	20002d98 	.word	0x20002d98
 8005040:	20002d68 	.word	0x20002d68

08005044 <MIOS32_DIN_SRGet>:
//! \return -1 if shift register not available
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_SRGet(u32 sr)
{
  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 8005044:	280f      	cmp	r0, #15
    return -1;

  return mios32_srio_din[sr];
 8005046:	bf96      	itet	ls
 8005048:	4b02      	ldrls	r3, [pc, #8]	; (8005054 <MIOS32_DIN_SRGet+0x10>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_SRGet(u32 sr)
{
  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
    return -1;
 800504a:	f04f 30ff 	movhi.w	r0, #4294967295

  return mios32_srio_din[sr];
 800504e:	5c18      	ldrbls	r0, [r3, r0]
}
 8005050:	4770      	bx	lr
 8005052:	bf00      	nop
 8005054:	20002d98 	.word	0x20002d98

08005058 <MIOS32_DIN_SRChangedGetAndClear>:
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 8005058:	280f      	cmp	r0, #15
//! \param[in] mask pin mask (8bit value)
//! \return 8bit value which contains the selected (masked) change flags
//! \return no error status (-1)! - if unavailable SR selected, 0x00 will be returned
/////////////////////////////////////////////////////////////////////////////
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
 800505a:	b570      	push	{r4, r5, r6, lr}
 800505c:	4604      	mov	r4, r0
 800505e:	460e      	mov	r6, r1
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 8005060:	d80c      	bhi.n	800507c <MIOS32_DIN_SRChangedGetAndClear+0x24>
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
 8005062:	f001 faff 	bl	8006664 <MIOS32_IRQ_Disable>
  changed = mios32_srio_din_changed[sr] & mask;
 8005066:	4b07      	ldr	r3, [pc, #28]	; (8005084 <MIOS32_DIN_SRChangedGetAndClear+0x2c>)
 8005068:	5d1d      	ldrb	r5, [r3, r4]
  mios32_srio_din_changed[sr] &= ~mask;
 800506a:	5d1a      	ldrb	r2, [r3, r4]
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
  changed = mios32_srio_din_changed[sr] & mask;
 800506c:	ea06 0505 	and.w	r5, r6, r5
  mios32_srio_din_changed[sr] &= ~mask;
 8005070:	ea22 0606 	bic.w	r6, r2, r6
 8005074:	551e      	strb	r6, [r3, r4]
  MIOS32_IRQ_Enable();
 8005076:	f001 fb0b 	bl	8006690 <MIOS32_IRQ_Enable>

  return changed;
 800507a:	e000      	b.n	800507e <MIOS32_DIN_SRChangedGetAndClear+0x26>
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;
 800507c:	2500      	movs	r5, #0
  changed = mios32_srio_din_changed[sr] & mask;
  mios32_srio_din_changed[sr] &= ~mask;
  MIOS32_IRQ_Enable();

  return changed;
}
 800507e:	4628      	mov	r0, r5
 8005080:	bd70      	pop	{r4, r5, r6, pc}
 8005082:	bf00      	nop
 8005084:	20002d68 	.word	0x20002d68

08005088 <MIOS32_DIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_Handler(void *_callback)
{
 8005088:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800508a:	4606      	mov	r6, r0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
    return -1;
 800508c:	f04f 30ff 	mov.w	r0, #4294967295
#if MIOS32_SRIO_NUM_SR == 0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
 8005090:	b1fe      	cbz	r6, 80050d2 <MIOS32_DIN_Handler+0x4a>
 8005092:	2400      	movs	r4, #0

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
    
    // check if there are pin changes (mask all pins)
    changed = MIOS32_DIN_SRChangedGetAndClear(sr, 0xff);
 8005094:	4620      	mov	r0, r4
 8005096:	21ff      	movs	r1, #255	; 0xff
 8005098:	f7ff ffde 	bl	8005058 <MIOS32_DIN_SRChangedGetAndClear>
 800509c:	4607      	mov	r7, r0

    // any pin change at this SR?
    if( !changed )
 800509e:	b1a0      	cbz	r0, 80050ca <MIOS32_DIN_Handler+0x42>
 80050a0:	2500      	movs	r5, #0

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 80050a2:	00e3      	lsls	r3, r4, #3
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
 80050a4:	fa57 f205 	asrs.w	r2, r7, r5
 80050a8:	f012 0f01 	tst.w	r2, #1
 80050ac:	d00a      	beq.n	80050c4 <MIOS32_DIN_Handler+0x3c>
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 80050ae:	4a09      	ldr	r2, [pc, #36]	; (80050d4 <MIOS32_DIN_Handler+0x4c>)
 80050b0:	18e8      	adds	r0, r5, r3
 80050b2:	5d11      	ldrb	r1, [r2, r4]
 80050b4:	9301      	str	r3, [sp, #4]
 80050b6:	4129      	asrs	r1, r5
 80050b8:	f001 0101 	and.w	r1, r1, #1
 80050bc:	47b0      	blx	r6

	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
 80050be:	f7ff ff75 	bl	8004fac <MIOS32_SRIO_DebounceStart>
 80050c2:	9b01      	ldr	r3, [sp, #4]
    // any pin change at this SR?
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
 80050c4:	3501      	adds	r5, #1
 80050c6:	2d08      	cmp	r5, #8
 80050c8:	d1ec      	bne.n	80050a4 <MIOS32_DIN_Handler+0x1c>
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
 80050ca:	3401      	adds	r4, #1
 80050cc:	2c10      	cmp	r4, #16
 80050ce:	d1e1      	bne.n	8005094 <MIOS32_DIN_Handler+0xc>
	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
      }
  }

  return 0;
 80050d0:	2000      	movs	r0, #0
}
 80050d2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80050d4:	20002d98 	.word	0x20002d98

080050d8 <MIOS32_DOUT_Init>:
s32 MIOS32_DOUT_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 80050d8:	b938      	cbnz	r0, 80050ea <MIOS32_DOUT_Init+0x12>
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
 80050da:	4a05      	ldr	r2, [pc, #20]	; (80050f0 <MIOS32_DOUT_Init+0x18>)
 80050dc:	4603      	mov	r3, r0
 80050de:	5413      	strb	r3, [r2, r0]
 80050e0:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 80050e2:	2810      	cmp	r0, #16
 80050e4:	d1fb      	bne.n	80050de <MIOS32_DOUT_Init+0x6>
    mios32_srio_dout[i] = 0;
  }

  return 0;
 80050e6:	2000      	movs	r0, #0
 80050e8:	e001      	b.n	80050ee <MIOS32_DOUT_Init+0x16>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80050ea:	f04f 30ff 	mov.w	r0, #4294967295
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
  }

  return 0;
}
 80050ee:	4770      	bx	lr
 80050f0:	20002d78 	.word	0x20002d78

080050f4 <MIOS32_DOUT_PinSet>:
//! \return -1 if pin not available
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DOUT_PinSet(u32 pin, u32 value)
{
  // check if pin available
  if( pin/8 >= MIOS32_SRIO_NUM_SR )
 80050f4:	287f      	cmp	r0, #127	; 0x7f
//! \param[in] pin number (0..127)
//! \param[in] value of the pin (0 or 1)
//! \return -1 if pin not available
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DOUT_PinSet(u32 pin, u32 value)
{
 80050f6:	b538      	push	{r3, r4, r5, lr}
 80050f8:	4604      	mov	r4, r0
 80050fa:	460d      	mov	r5, r1
  // check if pin available
  if( pin/8 >= MIOS32_SRIO_NUM_SR )
    return -1;
 80050fc:	bf88      	it	hi
 80050fe:	f04f 30ff 	movhi.w	r0, #4294967295
//! \return -1 if pin not available
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DOUT_PinSet(u32 pin, u32 value)
{
  // check if pin available
  if( pin/8 >= MIOS32_SRIO_NUM_SR )
 8005102:	d81f      	bhi.n	8005144 <MIOS32_DOUT_PinSet+0x50>
    return -1;

  MIOS32_IRQ_Disable(); // this should be atomic
 8005104:	f001 faae 	bl	8006664 <MIOS32_IRQ_Disable>
 8005108:	08e2      	lsrs	r2, r4, #3
 800510a:	4b0f      	ldr	r3, [pc, #60]	; (8005148 <MIOS32_DOUT_PinSet+0x54>)
 800510c:	43e4      	mvns	r4, r4
  if( value )
 800510e:	b15d      	cbz	r5, 8005128 <MIOS32_DOUT_PinSet+0x34>
    mios32_srio_dout[MIOS32_SRIO_NUM_SR - (pin>>3) - 1] |= (u8)(1 << ((pin&7)^7));
 8005110:	f004 0407 	and.w	r4, r4, #7
 8005114:	2001      	movs	r0, #1
 8005116:	fa10 f404 	lsls.w	r4, r0, r4
 800511a:	f1c2 020f 	rsb	r2, r2, #15
 800511e:	5c99      	ldrb	r1, [r3, r2]
 8005120:	ea41 0404 	orr.w	r4, r1, r4
 8005124:	b2e4      	uxtb	r4, r4
 8005126:	e009      	b.n	800513c <MIOS32_DOUT_PinSet+0x48>
  else
    mios32_srio_dout[MIOS32_SRIO_NUM_SR - (pin>>3) - 1] &= ~(u8)(1 << ((pin&7)^7));
 8005128:	f004 0407 	and.w	r4, r4, #7
 800512c:	2001      	movs	r0, #1
 800512e:	fa10 f404 	lsls.w	r4, r0, r4
 8005132:	f1c2 020f 	rsb	r2, r2, #15
 8005136:	5c99      	ldrb	r1, [r3, r2]
 8005138:	ea21 0404 	bic.w	r4, r1, r4
 800513c:	549c      	strb	r4, [r3, r2]
  MIOS32_IRQ_Enable();
 800513e:	f001 faa7 	bl	8006690 <MIOS32_IRQ_Enable>

  return 0;
 8005142:	2000      	movs	r0, #0
}
 8005144:	bd38      	pop	{r3, r4, r5, pc}
 8005146:	bf00      	nop
 8005148:	20002d78 	.word	0x20002d78

0800514c <MIOS32_ENC_Init>:
//! Initializes encoder driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Init(u32 mode)
{
 800514c:	b510      	push	{r4, lr}
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 800514e:	bb20      	cbnz	r0, 800519a <MIOS32_ENC_Init+0x4e>
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 8005150:	4c13      	ldr	r4, [pc, #76]	; (80051a0 <MIOS32_ENC_Init+0x54>)

    enc_state[i].state = 0xf; // all pins released
 8005152:	4914      	ldr	r1, [pc, #80]	; (80051a4 <MIOS32_ENC_Init+0x58>)
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 8005154:	4602      	mov	r2, r0
 8005156:	f804 2020 	strb.w	r2, [r4, r0, lsl #2]

    enc_state[i].state = 0xf; // all pins released
 800515a:	f811 3030 	ldrb.w	r3, [r1, r0, lsl #3]
    enc_state[i].decinc = 0;
 800515e:	f043 030f 	orr.w	r3, r3, #15
 8005162:	f36f 1304 	bfc	r3, #4, #1
 8005166:	f801 3030 	strb.w	r3, [r1, r0, lsl #3]
    enc_state[i].incrementer = 0;
 800516a:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
 800516e:	f893 c003 	ldrb.w	ip, [r3, #3]
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 8005172:	3001      	adds	r0, #1
    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
 8005174:	f00c 0cf0 	and.w	ip, ip, #240	; 0xf0
 8005178:	f36f 1c07 	bfc	ip, #4, #4
 800517c:	f883 c003 	strb.w	ip, [r3, #3]
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 8005180:	f893 c005 	ldrb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 8005184:	2840      	cmp	r0, #64	; 0x40
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 8005186:	f36f 0c03 	bfc	ip, #0, #4
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder

    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
 800518a:	705a      	strb	r2, [r3, #1]
    enc_state[i].accelerator = 0;
 800518c:	709a      	strb	r2, [r3, #2]
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
 800518e:	711a      	strb	r2, [r3, #4]
    enc_state[i].predivider = 0;
 8005190:	f883 c005 	strb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 8005194:	d1df      	bne.n	8005156 <MIOS32_ENC_Init+0xa>
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
 8005196:	2000      	movs	r0, #0
 8005198:	e001      	b.n	800519e <MIOS32_ENC_Init+0x52>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800519a:	f04f 30ff 	mov.w	r0, #4294967295
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
}
 800519e:	bd10      	pop	{r4, pc}
 80051a0:	20002da8 	.word	0x20002da8
 80051a4:	20002ea8 	.word	0x20002ea8

080051a8 <MIOS32_ENC_UpdateStates>:
/////////////////////////////////////////////////////////////////////////////
//! This function has to be called after a SRIO scan to update encoder states
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_UpdateStates(void)
{
 80051a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  // Note: scanning of 64 encoders takes ca. 30 uS @ 72 MHz :-)
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
    mios32_enc_config_t *enc_config_ptr = &enc_config[enc];

    // skip if encoder not configured
    if( enc_config_ptr->cfg.type == DISABLED )
 80051aa:	4e9b      	ldr	r6, [pc, #620]	; (8005418 <MIOS32_ENC_UpdateStates+0x270>)
      continue;

    enc_state_t *enc_state_ptr = &enc_state[enc];

    // decrement accelerator until it is zero (used to determine rotation speed)
    if( enc_state_ptr->accelerator )
 80051ac:	4d9b      	ldr	r5, [pc, #620]	; (800541c <MIOS32_ENC_UpdateStates+0x274>)
/////////////////////////////////////////////////////////////////////////////
//! This function has to be called after a SRIO scan to update encoder states
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_UpdateStates(void)
{
 80051ae:	2400      	movs	r4, #0
  // Note: scanning of 64 encoders takes ca. 30 uS @ 72 MHz :-)
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
    mios32_enc_config_t *enc_config_ptr = &enc_config[enc];

    // skip if encoder not configured
    if( enc_config_ptr->cfg.type == DISABLED )
 80051b0:	f816 3024 	ldrb.w	r3, [r6, r4, lsl #2]
 80051b4:	2b00      	cmp	r3, #0
 80051b6:	f000 8128 	beq.w	800540a <MIOS32_ENC_UpdateStates+0x262>
      continue;

    enc_state_t *enc_state_ptr = &enc_state[enc];

    // decrement accelerator until it is zero (used to determine rotation speed)
    if( enc_state_ptr->accelerator )
 80051ba:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 80051be:	789a      	ldrb	r2, [r3, #2]
 80051c0:	b10a      	cbz	r2, 80051c6 <MIOS32_ENC_UpdateStates+0x1e>
      --enc_state_ptr->accelerator;
 80051c2:	3a01      	subs	r2, #1
 80051c4:	709a      	strb	r2, [r3, #2]

/////////////////////////////////////////////////////////////////////////////
//! This function has to be called after a SRIO scan to update encoder states
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_UpdateStates(void)
 80051c6:	eb06 0384 	add.w	r3, r6, r4, lsl #2
    if( enc_state_ptr->accelerator )
      --enc_state_ptr->accelerator;

    // take over encoder state from SRIO handler if SR != 0
    // (if SR configured with 0 we expect that the state is controlled from application, e.g. by scanning GPIOs)
    if( enc_config_ptr->cfg.sr != 0 ) {
 80051ca:	789f      	ldrb	r7, [r3, #2]
 80051cc:	b317      	cbz	r7, 8005214 <MIOS32_ENC_UpdateStates+0x6c>
      // check if encoder state has been changed, and clear changed flags, so that the changes won't be propagated to DIN handler
      u8 sr = enc_config_ptr->cfg.sr-1;
      u8 pos = enc_config_ptr->cfg.pos;
 80051ce:	785b      	ldrb	r3, [r3, #1]
      u8 changed_mask = 3 << pos; // note: by checking mios32_srio_din_changed[sr] directly, we speed up the scanning of unmoved encoders by factor 3!
 80051d0:	2203      	movs	r2, #3
 80051d2:	095b      	lsrs	r3, r3, #5
 80051d4:	fa12 f103 	lsls.w	r1, r2, r3
      enc_state_ptr->last12 = enc_state_ptr->act12;
 80051d8:	f815 2034 	ldrb.w	r2, [r5, r4, lsl #3]
    // (if SR configured with 0 we expect that the state is controlled from application, e.g. by scanning GPIOs)
    if( enc_config_ptr->cfg.sr != 0 ) {
      // check if encoder state has been changed, and clear changed flags, so that the changes won't be propagated to DIN handler
      u8 sr = enc_config_ptr->cfg.sr-1;
      u8 pos = enc_config_ptr->cfg.pos;
      u8 changed_mask = 3 << pos; // note: by checking mios32_srio_din_changed[sr] directly, we speed up the scanning of unmoved encoders by factor 3!
 80051dc:	9301      	str	r3, [sp, #4]
      enc_state_ptr->last12 = enc_state_ptr->act12;
 80051de:	4613      	mov	r3, r2
 80051e0:	f362 0383 	bfi	r3, r2, #2, #2

    // take over encoder state from SRIO handler if SR != 0
    // (if SR configured with 0 we expect that the state is controlled from application, e.g. by scanning GPIOs)
    if( enc_config_ptr->cfg.sr != 0 ) {
      // check if encoder state has been changed, and clear changed flags, so that the changes won't be propagated to DIN handler
      u8 sr = enc_config_ptr->cfg.sr-1;
 80051e4:	3f01      	subs	r7, #1
      u8 pos = enc_config_ptr->cfg.pos;
      u8 changed_mask = 3 << pos; // note: by checking mios32_srio_din_changed[sr] directly, we speed up the scanning of unmoved encoders by factor 3!
      enc_state_ptr->last12 = enc_state_ptr->act12;
      if( (mios32_srio_din_changed[sr] & changed_mask) && MIOS32_DIN_SRChangedGetAndClear(sr, changed_mask) )
 80051e6:	4a8e      	ldr	r2, [pc, #568]	; (8005420 <MIOS32_ENC_UpdateStates+0x278>)

    // take over encoder state from SRIO handler if SR != 0
    // (if SR configured with 0 we expect that the state is controlled from application, e.g. by scanning GPIOs)
    if( enc_config_ptr->cfg.sr != 0 ) {
      // check if encoder state has been changed, and clear changed flags, so that the changes won't be propagated to DIN handler
      u8 sr = enc_config_ptr->cfg.sr-1;
 80051e8:	b2ff      	uxtb	r7, r7
      u8 pos = enc_config_ptr->cfg.pos;
      u8 changed_mask = 3 << pos; // note: by checking mios32_srio_din_changed[sr] directly, we speed up the scanning of unmoved encoders by factor 3!
      enc_state_ptr->last12 = enc_state_ptr->act12;
 80051ea:	f805 3034 	strb.w	r3, [r5, r4, lsl #3]
      if( (mios32_srio_din_changed[sr] & changed_mask) && MIOS32_DIN_SRChangedGetAndClear(sr, changed_mask) )
 80051ee:	5dd3      	ldrb	r3, [r2, r7]
    // (if SR configured with 0 we expect that the state is controlled from application, e.g. by scanning GPIOs)
    if( enc_config_ptr->cfg.sr != 0 ) {
      // check if encoder state has been changed, and clear changed flags, so that the changes won't be propagated to DIN handler
      u8 sr = enc_config_ptr->cfg.sr-1;
      u8 pos = enc_config_ptr->cfg.pos;
      u8 changed_mask = 3 << pos; // note: by checking mios32_srio_din_changed[sr] directly, we speed up the scanning of unmoved encoders by factor 3!
 80051f0:	b2c9      	uxtb	r1, r1
      enc_state_ptr->last12 = enc_state_ptr->act12;
      if( (mios32_srio_din_changed[sr] & changed_mask) && MIOS32_DIN_SRChangedGetAndClear(sr, changed_mask) )
 80051f2:	4219      	tst	r1, r3
 80051f4:	d00e      	beq.n	8005214 <MIOS32_ENC_UpdateStates+0x6c>
 80051f6:	4638      	mov	r0, r7
 80051f8:	f7ff ff2e 	bl	8005058 <MIOS32_DIN_SRChangedGetAndClear>
 80051fc:	b150      	cbz	r0, 8005214 <MIOS32_ENC_UpdateStates+0x6c>
	enc_state_ptr->act12 = (MIOS32_DIN_SRGet(sr) >> pos) & 3;
 80051fe:	4638      	mov	r0, r7
 8005200:	f7ff ff20 	bl	8005044 <MIOS32_DIN_SRGet>
 8005204:	9b01      	ldr	r3, [sp, #4]
 8005206:	4118      	asrs	r0, r3
 8005208:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 800520c:	f360 0301 	bfi	r3, r0, #0, #2
 8005210:	f805 3034 	strb.w	r3, [r5, r4, lsl #3]
    }

    // new encoder state?
    if( enc_state_ptr->last12 != enc_state_ptr->act12 ) {
 8005214:	f815 1034 	ldrb.w	r1, [r5, r4, lsl #3]
 8005218:	f3c1 0281 	ubfx	r2, r1, #2, #2
 800521c:	f001 0303 	and.w	r3, r1, #3
 8005220:	429a      	cmp	r2, r3
 8005222:	f000 80f2 	beq.w	800540a <MIOS32_ENC_UpdateStates+0x262>
      // INC       ->  ->  ->  ->  
      // ENC_STAT  2   B   D   4
      // Bit N     0   1   2   3 
      // This method is based on ideas from Avogra

      if( (enc_state_ptr->state == 0x01 && (enc_type & (1 << 4))) ||
 8005226:	f001 020f 	and.w	r2, r1, #15
 800522a:	2a01      	cmp	r2, #1
	enc_state_ptr->act12 = (MIOS32_DIN_SRGet(sr) >> pos) & 3;
    }

    // new encoder state?
    if( enc_state_ptr->last12 != enc_state_ptr->act12 ) {
      mios32_enc_type_t enc_type = enc_config_ptr->cfg.type;
 800522c:	f816 3024 	ldrb.w	r3, [r6, r4, lsl #2]
      // INC       ->  ->  ->  ->  
      // ENC_STAT  2   B   D   4
      // Bit N     0   1   2   3 
      // This method is based on ideas from Avogra

      if( (enc_state_ptr->state == 0x01 && (enc_type & (1 << 4))) ||
 8005230:	d102      	bne.n	8005238 <MIOS32_ENC_UpdateStates+0x90>
 8005232:	f013 0f10 	tst.w	r3, #16
 8005236:	e008      	b.n	800524a <MIOS32_ENC_UpdateStates+0xa2>
 8005238:	2a07      	cmp	r2, #7
 800523a:	d102      	bne.n	8005242 <MIOS32_ENC_UpdateStates+0x9a>
	  (enc_state_ptr->state == 0x07 && (enc_type & (1 << 5))) ||
 800523c:	f013 0f20 	tst.w	r3, #32
 8005240:	e003      	b.n	800524a <MIOS32_ENC_UpdateStates+0xa2>
 8005242:	2a0e      	cmp	r2, #14
 8005244:	d102      	bne.n	800524c <MIOS32_ENC_UpdateStates+0xa4>
	  (enc_state_ptr->state == 0x0e && (enc_type & (1 << 6))) ||
 8005246:	f013 0f40 	tst.w	r3, #64	; 0x40
 800524a:	d106      	bne.n	800525a <MIOS32_ENC_UpdateStates+0xb2>
	  (enc_state_ptr->state == 0x08 && (enc_type & (1 << 7))) ) {
 800524c:	2a08      	cmp	r2, #8
 800524e:	bf14      	ite	ne
 8005250:	2000      	movne	r0, #0
 8005252:	2001      	moveq	r0, #1
      // Bit N     0   1   2   3 
      // This method is based on ideas from Avogra

      if( (enc_state_ptr->state == 0x01 && (enc_type & (1 << 4))) ||
	  (enc_state_ptr->state == 0x07 && (enc_type & (1 << 5))) ||
	  (enc_state_ptr->state == 0x0e && (enc_type & (1 << 6))) ||
 8005254:	ea10 10d3 	ands.w	r0, r0, r3, lsr #7
 8005258:	d062      	beq.n	8005320 <MIOS32_ENC_UpdateStates+0x178>
	  (enc_state_ptr->state == 0x08 && (enc_type & (1 << 7))) ) {
	// DEC
	// plausibility check: when accelerator > 0xe0, exit if last event was a INC.
	// if non-detented encoder: only do anything if the state has actually changed
	if( (enc_state_ptr->decinc || enc_state_ptr->accelerator <= 0xe0) && 
 800525a:	f001 0110 	and.w	r1, r1, #16
 800525e:	b2c9      	uxtb	r1, r1
 8005260:	b929      	cbnz	r1, 800526e <MIOS32_ENC_UpdateStates+0xc6>
 8005262:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
 8005266:	7892      	ldrb	r2, [r2, #2]
 8005268:	2ae0      	cmp	r2, #224	; 0xe0
 800526a:	f200 80ce 	bhi.w	800540a <MIOS32_ENC_UpdateStates+0x262>
 800526e:	2bff      	cmp	r3, #255	; 0xff
 8005270:	d10b      	bne.n	800528a <MIOS32_ENC_UpdateStates+0xe2>
	    (enc_type != 0xff || enc_state_ptr->state != enc_state_ptr->prev_state_dec) ) {
 8005272:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 8005276:	f815 2034 	ldrb.w	r2, [r5, r4, lsl #3]
 800527a:	78db      	ldrb	r3, [r3, #3]
 800527c:	f002 020f 	and.w	r2, r2, #15
 8005280:	f003 030f 	and.w	r3, r3, #15
 8005284:	429a      	cmp	r2, r3
 8005286:	f000 80c0 	beq.w	800540a <MIOS32_ENC_UpdateStates+0x262>
	  // memorize DEC
	  enc_state_ptr->decinc = 1;
 800528a:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 800528e:	f043 0310 	orr.w	r3, r3, #16
 8005292:	f805 3034 	strb.w	r3, [r5, r4, lsl #3]

	  // limit maximum increase of accelerator
	  if( (int)enc_state_ptr->accelerator - (int)enc_state_ptr->prev_acc > 20) {
 8005296:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 800529a:	791a      	ldrb	r2, [r3, #4]
 800529c:	7899      	ldrb	r1, [r3, #2]
 800529e:	1a89      	subs	r1, r1, r2
 80052a0:	2914      	cmp	r1, #20
 80052a2:	dd01      	ble.n	80052a8 <MIOS32_ENC_UpdateStates+0x100>
	    enc_state_ptr->accelerator = enc_state_ptr->prev_acc + 20;
 80052a4:	3214      	adds	r2, #20
 80052a6:	709a      	strb	r2, [r3, #2]
	  }

	  // branch depending on speed mode
	  switch( enc_config_ptr->cfg.speed ) {
 80052a8:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 80052ac:	785a      	ldrb	r2, [r3, #1]
 80052ae:	f012 0303 	ands.w	r3, r2, #3
 80052b2:	d010      	beq.n	80052d6 <MIOS32_ENC_UpdateStates+0x12e>
 80052b4:	2b02      	cmp	r3, #2
 80052b6:	ea4f 03c4 	mov.w	r3, r4, lsl #3
 80052ba:	d120      	bne.n	80052fe <MIOS32_ENC_UpdateStates+0x156>
	  case FAST:
	    if( (acc=(enc_state_ptr->accelerator >> (7-enc_config_ptr->cfg.speed_par))) == 0 )
 80052bc:	18eb      	adds	r3, r5, r3
 80052be:	7899      	ldrb	r1, [r3, #2]
 80052c0:	f3c2 0282 	ubfx	r2, r2, #2, #3
 80052c4:	f1c2 0207 	rsb	r2, r2, #7
	      acc = 1;
 80052c8:	fa51 f202 	asrs.w	r2, r1, r2
	    enc_state_ptr->incrementer -= acc;
 80052cc:	7859      	ldrb	r1, [r3, #1]

	  // branch depending on speed mode
	  switch( enc_config_ptr->cfg.speed ) {
	  case FAST:
	    if( (acc=(enc_state_ptr->accelerator >> (7-enc_config_ptr->cfg.speed_par))) == 0 )
	      acc = 1;
 80052ce:	bf08      	it	eq
 80052d0:	2201      	moveq	r2, #1
	    enc_state_ptr->incrementer -= acc;
 80052d2:	1a8a      	subs	r2, r1, r2
 80052d4:	e016      	b.n	8005304 <MIOS32_ENC_UpdateStates+0x15c>
	    break;

	  case SLOW:
	    predivider = enc_state_ptr->predivider - (enc_config_ptr->cfg.speed_par+1);
 80052d6:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 80052da:	7959      	ldrb	r1, [r3, #5]
 80052dc:	f3c2 0282 	ubfx	r2, r2, #2, #3
 80052e0:	43d2      	mvns	r2, r2
 80052e2:	f001 010f 	and.w	r1, r1, #15
	    // increment on 4bit underrun
	    if( predivider < 0 )
 80052e6:	1852      	adds	r2, r2, r1
 80052e8:	d502      	bpl.n	80052f0 <MIOS32_ENC_UpdateStates+0x148>
	      --enc_state_ptr->incrementer;
 80052ea:	7859      	ldrb	r1, [r3, #1]
 80052ec:	3901      	subs	r1, #1
 80052ee:	7059      	strb	r1, [r3, #1]
	    enc_state_ptr->predivider = predivider;
 80052f0:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 80052f4:	7959      	ldrb	r1, [r3, #5]
 80052f6:	f362 0103 	bfi	r1, r2, #0, #4
 80052fa:	7159      	strb	r1, [r3, #5]
	    break;
 80052fc:	e003      	b.n	8005306 <MIOS32_ENC_UpdateStates+0x15e>

	  default: // NORMAL
	    --enc_state_ptr->incrementer;
 80052fe:	18eb      	adds	r3, r5, r3
 8005300:	785a      	ldrb	r2, [r3, #1]
 8005302:	3a01      	subs	r2, #1
 8005304:	705a      	strb	r2, [r3, #1]
	    break;
	  }
	  // save last acceleration value
	  enc_state_ptr->prev_acc = enc_state_ptr->accelerator;
 8005306:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 800530a:	789a      	ldrb	r2, [r3, #2]
 800530c:	711a      	strb	r2, [r3, #4]

	  // set accelerator to max value (will be decremented on each tick, so that the encoder speed can be determined)
	  enc_state_ptr->accelerator = 0xff;
 800530e:	f04f 32ff 	mov.w	r2, #4294967295
 8005312:	709a      	strb	r2, [r3, #2]

	  // save last state to compare whether the state changed in the next run
	  enc_state_ptr->prev_state_dec = enc_state_ptr->state;
 8005314:	f815 1034 	ldrb.w	r1, [r5, r4, lsl #3]
 8005318:	78da      	ldrb	r2, [r3, #3]
 800531a:	f361 0203 	bfi	r2, r1, #0, #4
 800531e:	e073      	b.n	8005408 <MIOS32_ENC_UpdateStates+0x260>
	}
      } else if( (enc_state_ptr->state == 0x02 && (enc_type & (1 << 0))) ||
 8005320:	2a02      	cmp	r2, #2
 8005322:	d102      	bne.n	800532a <MIOS32_ENC_UpdateStates+0x182>
 8005324:	f013 0f01 	tst.w	r3, #1
 8005328:	e00d      	b.n	8005346 <MIOS32_ENC_UpdateStates+0x19e>
 800532a:	2a0b      	cmp	r2, #11
 800532c:	d102      	bne.n	8005334 <MIOS32_ENC_UpdateStates+0x18c>
		 (enc_state_ptr->state == 0x0b && (enc_type & (1 << 1))) ||
 800532e:	f013 0f02 	tst.w	r3, #2
 8005332:	e008      	b.n	8005346 <MIOS32_ENC_UpdateStates+0x19e>
 8005334:	2a0d      	cmp	r2, #13
 8005336:	d102      	bne.n	800533e <MIOS32_ENC_UpdateStates+0x196>
		 (enc_state_ptr->state == 0x0d && (enc_type & (1 << 2))) ||
 8005338:	f013 0f04 	tst.w	r3, #4
 800533c:	e003      	b.n	8005346 <MIOS32_ENC_UpdateStates+0x19e>
 800533e:	2a04      	cmp	r2, #4
 8005340:	d163      	bne.n	800540a <MIOS32_ENC_UpdateStates+0x262>
		 (enc_state_ptr->state == 0x04 && (enc_type & (1 << 3))) ) {
 8005342:	f013 0f08 	tst.w	r3, #8
 8005346:	d060      	beq.n	800540a <MIOS32_ENC_UpdateStates+0x262>
	// INC
	// plausibility check: when accelerator > 0xe0, exit if last event was a DEC
	// if non-detented encoder: only do anything if the state has actually changed
	if( (!enc_state_ptr->decinc || enc_state_ptr->accelerator <= 0xe0) &&
 8005348:	f001 0110 	and.w	r1, r1, #16
 800534c:	b2c9      	uxtb	r1, r1
 800534e:	b121      	cbz	r1, 800535a <MIOS32_ENC_UpdateStates+0x1b2>
 8005350:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
 8005354:	7892      	ldrb	r2, [r2, #2]
 8005356:	2ae0      	cmp	r2, #224	; 0xe0
 8005358:	d857      	bhi.n	800540a <MIOS32_ENC_UpdateStates+0x262>
 800535a:	2bff      	cmp	r3, #255	; 0xff
 800535c:	d109      	bne.n	8005372 <MIOS32_ENC_UpdateStates+0x1ca>
	    (enc_type != 0xff || enc_state_ptr->state != enc_state_ptr->prev_state_inc) ) {
 800535e:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 8005362:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
 8005366:	78d2      	ldrb	r2, [r2, #3]
 8005368:	f003 030f 	and.w	r3, r3, #15
 800536c:	ebb3 1f12 	cmp.w	r3, r2, lsr #4
 8005370:	d04b      	beq.n	800540a <MIOS32_ENC_UpdateStates+0x262>
	  // memorize INC
	  enc_state_ptr->decinc = 0;
 8005372:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 8005376:	f36f 1304 	bfc	r3, #4, #1
 800537a:	f805 3034 	strb.w	r3, [r5, r4, lsl #3]

	  // limit maximum increase of accelerator
	  if( (int)enc_state_ptr->accelerator - (int)enc_state_ptr->prev_acc > 20) {
 800537e:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 8005382:	791a      	ldrb	r2, [r3, #4]
 8005384:	7899      	ldrb	r1, [r3, #2]
 8005386:	1a89      	subs	r1, r1, r2
 8005388:	2914      	cmp	r1, #20
 800538a:	dd01      	ble.n	8005390 <MIOS32_ENC_UpdateStates+0x1e8>
	    enc_state_ptr->accelerator = enc_state_ptr->prev_acc + 20;
 800538c:	3214      	adds	r2, #20
 800538e:	709a      	strb	r2, [r3, #2]
	  }

	  // branch depending on speed mode
	  switch( enc_config_ptr->cfg.speed ) {
 8005390:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 8005394:	785a      	ldrb	r2, [r3, #1]
 8005396:	f012 0303 	ands.w	r3, r2, #3
 800539a:	d010      	beq.n	80053be <MIOS32_ENC_UpdateStates+0x216>
 800539c:	2b02      	cmp	r3, #2
 800539e:	ea4f 03c4 	mov.w	r3, r4, lsl #3
 80053a2:	d121      	bne.n	80053e8 <MIOS32_ENC_UpdateStates+0x240>
	  case FAST:
	    if( (acc=(enc_state_ptr->accelerator >> (7-enc_config_ptr->cfg.speed_par))) == 0 )
 80053a4:	18eb      	adds	r3, r5, r3
 80053a6:	7899      	ldrb	r1, [r3, #2]
 80053a8:	f3c2 0282 	ubfx	r2, r2, #2, #3
 80053ac:	f1c2 0207 	rsb	r2, r2, #7
	      acc = 1;
 80053b0:	fa51 f202 	asrs.w	r2, r1, r2
	    enc_state_ptr->incrementer += acc;
 80053b4:	7859      	ldrb	r1, [r3, #1]

	  // branch depending on speed mode
	  switch( enc_config_ptr->cfg.speed ) {
	  case FAST:
	    if( (acc=(enc_state_ptr->accelerator >> (7-enc_config_ptr->cfg.speed_par))) == 0 )
	      acc = 1;
 80053b6:	bf08      	it	eq
 80053b8:	2201      	moveq	r2, #1
	    enc_state_ptr->incrementer += acc;
 80053ba:	1852      	adds	r2, r2, r1
 80053bc:	e017      	b.n	80053ee <MIOS32_ENC_UpdateStates+0x246>
	    break;

	  case SLOW:
	    predivider = enc_state_ptr->predivider + (enc_config_ptr->cfg.speed_par+1);
 80053be:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 80053c2:	7959      	ldrb	r1, [r3, #5]
 80053c4:	f3c2 0282 	ubfx	r2, r2, #2, #3
 80053c8:	f001 010f 	and.w	r1, r1, #15
 80053cc:	188a      	adds	r2, r1, r2
 80053ce:	3201      	adds	r2, #1
	    // increment on 4bit overrun
	    if( predivider >= 16 )
 80053d0:	2a0f      	cmp	r2, #15
 80053d2:	dd02      	ble.n	80053da <MIOS32_ENC_UpdateStates+0x232>
	      ++enc_state_ptr->incrementer;
 80053d4:	7859      	ldrb	r1, [r3, #1]
 80053d6:	3101      	adds	r1, #1
 80053d8:	7059      	strb	r1, [r3, #1]
	    enc_state_ptr->predivider = predivider;
 80053da:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 80053de:	7959      	ldrb	r1, [r3, #5]
 80053e0:	f362 0103 	bfi	r1, r2, #0, #4
 80053e4:	7159      	strb	r1, [r3, #5]
	    break;
 80053e6:	e003      	b.n	80053f0 <MIOS32_ENC_UpdateStates+0x248>

	  default: // NORMAL
	    ++enc_state_ptr->incrementer;
 80053e8:	18eb      	adds	r3, r5, r3
 80053ea:	785a      	ldrb	r2, [r3, #1]
 80053ec:	3201      	adds	r2, #1
 80053ee:	705a      	strb	r2, [r3, #1]
	    break;
	  }
	  // save last acceleration value
	  enc_state_ptr->prev_acc = enc_state_ptr->accelerator;
 80053f0:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
 80053f4:	789a      	ldrb	r2, [r3, #2]
 80053f6:	711a      	strb	r2, [r3, #4]

	  // set accelerator to max value (will be decremented on each tick, so that the encoder speed can be determined)
	  enc_state_ptr->accelerator = 0xff;
 80053f8:	f04f 32ff 	mov.w	r2, #4294967295
 80053fc:	709a      	strb	r2, [r3, #2]

	  //save last state to compare whether the state changed in the next run
	  enc_state_ptr->prev_state_inc = enc_state_ptr->state;
 80053fe:	f815 1034 	ldrb.w	r1, [r5, r4, lsl #3]
 8005402:	78da      	ldrb	r2, [r3, #3]
 8005404:	f361 1207 	bfi	r2, r1, #4, #4
 8005408:	70da      	strb	r2, [r3, #3]
 800540a:	3401      	adds	r4, #1
{
  u8 enc;

  // check all encoders
  // Note: scanning of 64 encoders takes ca. 30 uS @ 72 MHz :-)
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
 800540c:	2c40      	cmp	r4, #64	; 0x40
 800540e:	f47f aecf 	bne.w	80051b0 <MIOS32_ENC_UpdateStates+0x8>
	}
      }
    }
  }
  return 0; // no error
}
 8005412:	2000      	movs	r0, #0
 8005414:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005416:	bf00      	nop
 8005418:	20002da8 	.word	0x20002da8
 800541c:	20002ea8 	.word	0x20002ea8
 8005420:	20002d68 	.word	0x20002d68

08005424 <MIOS32_ENC_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Handler(void *_callback)
{
 8005424:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005426:	4605      	mov	r5, r0
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
    return -1;
 8005428:	f04f 30ff 	mov.w	r0, #4294967295
  u8 enc;
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
 800542c:	b1bd      	cbz	r5, 800545e <MIOS32_ENC_Handler+0x3a>
 800542e:	2400      	movs	r4, #0
  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
    if( (incrementer = enc_state[enc].incrementer) ) {
 8005430:	4f0b      	ldr	r7, [pc, #44]	; (8005460 <MIOS32_ENC_Handler+0x3c>)
      enc_state[enc].incrementer = 0;
 8005432:	4626      	mov	r6, r4

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
 8005434:	f001 f916 	bl	8006664 <MIOS32_IRQ_Disable>
    if( (incrementer = enc_state[enc].incrementer) ) {
 8005438:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
 800543c:	f993 1001 	ldrsb.w	r1, [r3, #1]
 8005440:	b139      	cbz	r1, 8005452 <MIOS32_ENC_Handler+0x2e>
      enc_state[enc].incrementer = 0;
 8005442:	705e      	strb	r6, [r3, #1]
      MIOS32_IRQ_Enable();
 8005444:	9101      	str	r1, [sp, #4]
 8005446:	f001 f923 	bl	8006690 <MIOS32_IRQ_Enable>

      // call the hook
      callback(enc, incrementer);
 800544a:	4620      	mov	r0, r4
 800544c:	9901      	ldr	r1, [sp, #4]
 800544e:	47a8      	blx	r5
 8005450:	e001      	b.n	8005456 <MIOS32_ENC_Handler+0x32>
    } else {
      MIOS32_IRQ_Enable();
 8005452:	f001 f91d 	bl	8006690 <MIOS32_IRQ_Enable>
 8005456:	3401      	adds	r4, #1
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
 8005458:	2c40      	cmp	r4, #64	; 0x40
 800545a:	d1eb      	bne.n	8005434 <MIOS32_ENC_Handler+0x10>
    } else {
      MIOS32_IRQ_Enable();
    }
  }

  return 0; // no error
 800545c:	2000      	movs	r0, #0
}
 800545e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005460:	20002ea8 	.word	0x20002ea8

08005464 <MIOS32_LCD_DeviceSet>:
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 8005464:	4b01      	ldr	r3, [pc, #4]	; (800546c <MIOS32_LCD_DeviceSet+0x8>)
 8005466:	7018      	strb	r0, [r3, #0]

  return 0; // no error
}
 8005468:	2000      	movs	r0, #0
 800546a:	4770      	bx	lr
 800546c:	2000015f 	.word	0x2000015f

08005470 <MIOS32_LCD_CursorSet>:
//! \param[in] column number
//! \param[in] line number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorSet(u16 column, u16 line)
{
 8005470:	b508      	push	{r3, lr}
  // set character position
  mios32_lcd_column = column;
 8005472:	4b0b      	ldr	r3, [pc, #44]	; (80054a0 <MIOS32_LCD_CursorSet+0x30>)
 8005474:	8018      	strh	r0, [r3, #0]
  mios32_lcd_line = line;
 8005476:	4b0b      	ldr	r3, [pc, #44]	; (80054a4 <MIOS32_LCD_CursorSet+0x34>)
 8005478:	8019      	strh	r1, [r3, #0]

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
  if( font_bitmap.width ) {
 800547a:	4b0b      	ldr	r3, [pc, #44]	; (80054a8 <MIOS32_LCD_CursorSet+0x38>)
 800547c:	889a      	ldrh	r2, [r3, #4]
 800547e:	b112      	cbz	r2, 8005486 <MIOS32_LCD_CursorSet+0x16>
    font_width = font_bitmap.width;
 8005480:	b2d2      	uxtb	r2, r2
    font_height = font_bitmap.height;
 8005482:	799b      	ldrb	r3, [r3, #6]
 8005484:	e001      	b.n	800548a <MIOS32_LCD_CursorSet+0x1a>
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
 8005486:	2308      	movs	r3, #8
  // set character position
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
 8005488:	2206      	movs	r2, #6
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 800548a:	4342      	muls	r2, r0
 800548c:	f8df c01c 	ldr.w	ip, [pc, #28]	; 80054ac <MIOS32_LCD_CursorSet+0x3c>
  mios32_lcd_y = line * font_height;
 8005490:	434b      	muls	r3, r1
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 8005492:	f8ac 2000 	strh.w	r2, [ip]
  mios32_lcd_y = line * font_height;
 8005496:	4a06      	ldr	r2, [pc, #24]	; (80054b0 <MIOS32_LCD_CursorSet+0x40>)
 8005498:	8013      	strh	r3, [r2, #0]

  // forward new cursor position to app driver
  return APP_LCD_CursorSet(column, line);
 800549a:	f004 fc9b 	bl	8009dd4 <APP_LCD_CursorSet>
}
 800549e:	bd08      	pop	{r3, pc}
 80054a0:	200030b6 	.word	0x200030b6
 80054a4:	200030bc 	.word	0x200030bc
 80054a8:	200030a8 	.word	0x200030a8
 80054ac:	200030c0 	.word	0x200030c0
 80054b0:	200030b4 	.word	0x200030b4

080054b4 <MIOS32_LCD_GCursorSet>:
//! \param[in] x position
//! \param[in] y position
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_GCursorSet(u16 x, u16 y)
{
 80054b4:	b508      	push	{r3, lr}
  mios32_lcd_x = x;
 80054b6:	4b03      	ldr	r3, [pc, #12]	; (80054c4 <MIOS32_LCD_GCursorSet+0x10>)
 80054b8:	8018      	strh	r0, [r3, #0]
  mios32_lcd_y = y;
 80054ba:	4b03      	ldr	r3, [pc, #12]	; (80054c8 <MIOS32_LCD_GCursorSet+0x14>)
 80054bc:	8019      	strh	r1, [r3, #0]

  // forward new cursor position to app driver
  return APP_LCD_GCursorSet(x, y);
 80054be:	f004 fc9b 	bl	8009df8 <APP_LCD_GCursorSet>
}
 80054c2:	bd08      	pop	{r3, pc}
 80054c4:	200030c0 	.word	0x200030c0
 80054c8:	200030b4 	.word	0x200030b4

080054cc <MIOS32_LCD_CursorMapSet>:
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
    mios32_lcd_cursor_map[i] = map_table[i];
 80054cc:	4a04      	ldr	r2, [pc, #16]	; (80054e0 <MIOS32_LCD_CursorMapSet+0x14>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 80054ce:	2300      	movs	r3, #0
    mios32_lcd_cursor_map[i] = map_table[i];
 80054d0:	5cc1      	ldrb	r1, [r0, r3]
 80054d2:	5499      	strb	r1, [r3, r2]
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 80054d4:	3301      	adds	r3, #1
 80054d6:	2b04      	cmp	r3, #4
 80054d8:	d1fa      	bne.n	80054d0 <MIOS32_LCD_CursorMapSet+0x4>
    mios32_lcd_cursor_map[i] = map_table[i];

  return 0; // no error
}
 80054da:	2000      	movs	r0, #0
 80054dc:	4770      	bx	lr
 80054de:	bf00      	nop
 80054e0:	200030b8 	.word	0x200030b8

080054e4 <MIOS32_LCD_Init>:
//! Initializes LCD driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Init(u32 mode)
{
 80054e4:	b513      	push	{r0, r1, r4, lr}
 80054e6:	4604      	mov	r4, r0
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80054e8:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_Init(u32 mode)
{
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
 80054ec:	b9d4      	cbnz	r4, 8005524 <MIOS32_LCD_Init+0x40>
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 80054ee:	4b0e      	ldr	r3, [pc, #56]	; (8005528 <MIOS32_LCD_Init+0x44>)

  // disable font bitmap
  font_bitmap.width = 0;

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 80054f0:	a802      	add	r0, sp, #8
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 80054f2:	701c      	strb	r4, [r3, #0]

  // disable font bitmap
  font_bitmap.width = 0;
 80054f4:	4b0d      	ldr	r3, [pc, #52]	; (800552c <MIOS32_LCD_Init+0x48>)
 80054f6:	809c      	strh	r4, [r3, #4]

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 80054f8:	4b0d      	ldr	r3, [pc, #52]	; (8005530 <MIOS32_LCD_Init+0x4c>)
 80054fa:	681b      	ldr	r3, [r3, #0]
 80054fc:	f840 3d04 	str.w	r3, [r0, #-4]!
  MIOS32_LCD_CursorMapSet(cursor_map);
 8005500:	f7ff ffe4 	bl	80054cc <MIOS32_LCD_CursorMapSet>
  // note: this has to be done before APP_LCD_Init() is called, so that
  // the driver is able to modify the default cursor mapping
  // usage example: "dog" LCDs

  // call application specific init function
  if( (ret=APP_LCD_Init(mode)) < 0 )
 8005504:	4620      	mov	r0, r4
 8005506:	f004 fbf7 	bl	8009cf8 <APP_LCD_Init>
 800550a:	2800      	cmp	r0, #0
 800550c:	db0a      	blt.n	8005524 <MIOS32_LCD_Init+0x40>
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
  // -> forward to app_lcd
  return APP_LCD_Clear();
 800550e:	f004 fc5b 	bl	8009dc8 <APP_LCD_Clear>

  // clear screen
  MIOS32_LCD_Clear();

  // set character and graphical cursor to initial position
  MIOS32_LCD_CursorSet(0, 0);
 8005512:	4621      	mov	r1, r4
 8005514:	4620      	mov	r0, r4
 8005516:	f7ff ffab 	bl	8005470 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_GCursorSet(0, 0);
 800551a:	4620      	mov	r0, r4
 800551c:	4621      	mov	r1, r4
 800551e:	f7ff ffc9 	bl	80054b4 <MIOS32_LCD_GCursorSet>

  return 0; // no error
 8005522:	4620      	mov	r0, r4
}
 8005524:	bd1c      	pop	{r2, r3, r4, pc}
 8005526:	bf00      	nop
 8005528:	200030be 	.word	0x200030be
 800552c:	200030a8 	.word	0x200030a8
 8005530:	0800a12c 	.word	0x0800a12c

08005534 <MIOS32_LCD_Clear>:
/////////////////////////////////////////////////////////////////////////////
//! Clear Screen
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
 8005534:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_Clear();
 8005536:	f004 fc47 	bl	8009dc8 <APP_LCD_Clear>
}
 800553a:	bd08      	pop	{r3, pc}

0800553c <MIOS32_LCD_PrintChar>:
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 800553c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 800553e:	4b13      	ldr	r3, [pc, #76]	; (800558c <MIOS32_LCD_PrintChar+0x50>)
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 8005540:	4684      	mov	ip, r0
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 8005542:	781b      	ldrb	r3, [r3, #0]
 8005544:	2b01      	cmp	r3, #1
 8005546:	d117      	bne.n	8005578 <MIOS32_LCD_PrintChar+0x3c>
    if( !font_bitmap.width )
 8005548:	4b11      	ldr	r3, [pc, #68]	; (8005590 <MIOS32_LCD_PrintChar+0x54>)
      return -1;    // font not initialized yet!
 800554a:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_PrintChar(char c)
{
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
 800554e:	889a      	ldrh	r2, [r3, #4]
 8005550:	b1d2      	cbz	r2, 8005588 <MIOS32_LCD_PrintChar+0x4c>
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 8005552:	f10d 0e04 	add.w	lr, sp, #4
 8005556:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800555a:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
 800555e:	88da      	ldrh	r2, [r3, #6]
 8005560:	8919      	ldrh	r1, [r3, #8]
 8005562:	08d2      	lsrs	r2, r2, #3
 8005564:	434a      	muls	r2, r1
 8005566:	fb0c 0c02 	mla	ip, ip, r2, r0

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 800556a:	f8cd c004 	str.w	ip, [sp, #4]
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
    status = APP_LCD_BitmapPrint(bitmap);
 800556e:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 8005572:	f004 fc4a 	bl	8009e0a <APP_LCD_BitmapPrint>
 8005576:	e001      	b.n	800557c <MIOS32_LCD_PrintChar+0x40>
  } else {
    status = APP_LCD_Data(c);
 8005578:	f004 fb5a 	bl	8009c30 <APP_LCD_Data>
  }

  if( status >= 0 ) {
 800557c:	2800      	cmp	r0, #0
 800557e:	db03      	blt.n	8005588 <MIOS32_LCD_PrintChar+0x4c>
    // increment cursor
    ++mios32_lcd_column;
 8005580:	4b04      	ldr	r3, [pc, #16]	; (8005594 <MIOS32_LCD_PrintChar+0x58>)
 8005582:	881a      	ldrh	r2, [r3, #0]
 8005584:	3201      	adds	r2, #1
 8005586:	801a      	strh	r2, [r3, #0]
  }

  return status;
}
 8005588:	b005      	add	sp, #20
 800558a:	bd00      	pop	{pc}
 800558c:	200030be 	.word	0x200030be
 8005590:	200030a8 	.word	0x200030a8
 8005594:	200030b6 	.word	0x200030b6

08005598 <MIOS32_LCD_PrintString>:
//! Prints a \\0 (zero) terminated string
//! \param[in] str pointer to string
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
 8005598:	b538      	push	{r3, r4, r5, lr}
 800559a:	4605      	mov	r5, r0
  s32 status = 0;
 800559c:	2400      	movs	r4, #0

  while( *str != '\0' )
 800559e:	e002      	b.n	80055a6 <MIOS32_LCD_PrintString+0xe>
    status |= MIOS32_LCD_PrintChar(*str++);
 80055a0:	f7ff ffcc 	bl	800553c <MIOS32_LCD_PrintChar>
 80055a4:	4304      	orrs	r4, r0
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
  s32 status = 0;

  while( *str != '\0' )
 80055a6:	f815 0b01 	ldrb.w	r0, [r5], #1
 80055aa:	2800      	cmp	r0, #0
 80055ac:	d1f8      	bne.n	80055a0 <MIOS32_LCD_PrintString+0x8>
    status |= MIOS32_LCD_PrintChar(*str++);

  return status;
}
 80055ae:	4620      	mov	r0, r4
 80055b0:	bd38      	pop	{r3, r4, r5, pc}
	...

080055b4 <MIOS32_LCD_PrintBootMessage>:
//! The message is automatically print by the programming model after each reset.<BR>
//! It will also be returned on a SysEx query.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintBootMessage(void)
{
 80055b4:	b538      	push	{r3, r4, r5, lr}
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 80055b6:	4b0c      	ldr	r3, [pc, #48]	; (80055e8 <MIOS32_LCD_PrintBootMessage+0x34>)
 80055b8:	2400      	movs	r4, #0
 80055ba:	701c      	strb	r4, [r3, #0]
s32 MIOS32_LCD_PrintBootMessage(void)
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
 80055bc:	4621      	mov	r1, r4
 80055be:	4620      	mov	r0, r4
 80055c0:	f7ff ff56 	bl	8005470 <MIOS32_LCD_CursorSet>
 80055c4:	4605      	mov	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 80055c6:	4809      	ldr	r0, [pc, #36]	; (80055ec <MIOS32_LCD_PrintBootMessage+0x38>)
 80055c8:	f7ff ffe6 	bl	8005598 <MIOS32_LCD_PrintString>
  status |= MIOS32_LCD_CursorSet(0, 1);
 80055cc:	2101      	movs	r1, #1
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 80055ce:	ea40 0505 	orr.w	r5, r0, r5
  status |= MIOS32_LCD_CursorSet(0, 1);
 80055d2:	4620      	mov	r0, r4
 80055d4:	f7ff ff4c 	bl	8005470 <MIOS32_LCD_CursorSet>
 80055d8:	4305      	orrs	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE2);
 80055da:	4805      	ldr	r0, [pc, #20]	; (80055f0 <MIOS32_LCD_PrintBootMessage+0x3c>)
 80055dc:	f7ff ffdc 	bl	8005598 <MIOS32_LCD_PrintString>
 80055e0:	ea45 0000 	orr.w	r0, r5, r0

  return status;
}
 80055e4:	bd38      	pop	{r3, r4, r5, pc}
 80055e6:	bf00      	nop
 80055e8:	2000015f 	.word	0x2000015f
 80055ec:	0800a130 	.word	0x0800a130
 80055f0:	0800a13e 	.word	0x0800a13e

080055f4 <MIOS32_LCD_PrintFormattedString>:
//! \param[in] *format zero-terminated format string - 64 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
 80055f4:	b40f      	push	{r0, r1, r2, r3}
 80055f6:	b510      	push	{r4, lr}
 80055f8:	b092      	sub	sp, #72	; 0x48
 80055fa:	aa14      	add	r2, sp, #80	; 0x50
 80055fc:	f852 1b04 	ldr.w	r1, [r2], #4
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
  vsprintf((char *)buffer, format, args);
 8005600:	ac01      	add	r4, sp, #4
 8005602:	4620      	mov	r0, r4
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
 8005604:	9211      	str	r2, [sp, #68]	; 0x44
  vsprintf((char *)buffer, format, args);
 8005606:	f002 ffe0 	bl	80085ca <vsprintf>
  return MIOS32_LCD_PrintString(buffer);
 800560a:	4620      	mov	r0, r4
 800560c:	f7ff ffc4 	bl	8005598 <MIOS32_LCD_PrintString>
}
 8005610:	b012      	add	sp, #72	; 0x48
 8005612:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8005616:	b004      	add	sp, #16
 8005618:	4770      	bx	lr

0800561a <MIOS32_LCD_BColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_BColourSet(u32 rgb)
{
 800561a:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_BColourSet(rgb);
 800561c:	f004 fbef 	bl	8009dfe <APP_LCD_BColourSet>
}
 8005620:	bd08      	pop	{r3, pc}

08005622 <MIOS32_LCD_FColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_FColourSet(u32 rgb)
{
 8005622:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_FColourSet(rgb);
 8005624:	f004 fbee 	bl	8009e04 <APP_LCD_FColourSet>
}
 8005628:	bd08      	pop	{r3, pc}
	...

0800562c <MIOS32_MIDI_Init>:
//! Initializes MIDI layer
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
 800562c:	b538      	push	{r3, r4, r5, lr}
 800562e:	4604      	mov	r4, r0
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005630:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 8005634:	2c00      	cmp	r4, #0
 8005636:	d12c      	bne.n	8005692 <MIOS32_MIDI_Init+0x66>
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
 8005638:	4a16      	ldr	r2, [pc, #88]	; (8005694 <MIOS32_MIDI_Init+0x68>)
 800563a:	2310      	movs	r3, #16
 800563c:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 800563e:	4a16      	ldr	r2, [pc, #88]	; (8005698 <MIOS32_MIDI_Init+0x6c>)
  timeout_callback_func = NULL;
  debug_command_callback_func = NULL;

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 8005640:	4620      	mov	r0, r4
  if( mode != 0 )
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 8005642:	7013      	strb	r3, [r2, #0]

  // disable callback functions
  direct_rx_callback_func = NULL;
 8005644:	4b15      	ldr	r3, [pc, #84]	; (800569c <MIOS32_MIDI_Init+0x70>)
 8005646:	601c      	str	r4, [r3, #0]
  direct_tx_callback_func = NULL;
 8005648:	4b15      	ldr	r3, [pc, #84]	; (80056a0 <MIOS32_MIDI_Init+0x74>)
 800564a:	601c      	str	r4, [r3, #0]
  sysex_callback_func = NULL;
 800564c:	4b15      	ldr	r3, [pc, #84]	; (80056a4 <MIOS32_MIDI_Init+0x78>)
 800564e:	601c      	str	r4, [r3, #0]
  timeout_callback_func = NULL;
 8005650:	4b15      	ldr	r3, [pc, #84]	; (80056a8 <MIOS32_MIDI_Init+0x7c>)
 8005652:	601c      	str	r4, [r3, #0]
  debug_command_callback_func = NULL;
 8005654:	4b15      	ldr	r3, [pc, #84]	; (80056ac <MIOS32_MIDI_Init+0x80>)
 8005656:	601c      	str	r4, [r3, #0]

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 8005658:	f002 fa2a 	bl	8007ab0 <MIOS32_USB_MIDI_Init>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;
 800565c:	0fc5      	lsrs	r5, r0, #31
  if( MIOS32_USB_MIDI_Init(0) < 0 )
    ret |= (1 << 0);
#endif

#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
 800565e:	4620      	mov	r0, r4
 8005660:	f000 fd26 	bl	80060b0 <MIOS32_UART_MIDI_Init>
 8005664:	2800      	cmp	r0, #0
    ret |= (1 << 1);
 8005666:	bfb8      	it	lt
 8005668:	f045 0502 	orrlt.w	r5, r5, #2
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 800566c:	2000      	movs	r0, #0
 800566e:	f000 febd 	bl	80063ec <MIOS32_IIC_MIDI_Init>
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
 8005672:	4a0f      	ldr	r2, [pc, #60]	; (80056b0 <MIOS32_MIDI_Init+0x84>)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
    ret |= (1 << 1);
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 8005674:	2800      	cmp	r0, #0
    ret |= (1 << 2);
 8005676:	bfb8      	it	lt
 8005678:	f045 0504 	orrlt.w	r5, r5, #4
#endif

  last_sysex_port = DEFAULT;
 800567c:	2300      	movs	r3, #0
 800567e:	7013      	strb	r3, [r2, #0]
  sysex_state.ALL = 0;
 8005680:	4a0c      	ldr	r2, [pc, #48]	; (80056b4 <MIOS32_MIDI_Init+0x88>)

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
  sysex_timeout_ctr_flags.ALL = 0;

  return -ret;
 8005682:	4268      	negs	r0, r5
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
  sysex_state.ALL = 0;
 8005684:	7013      	strb	r3, [r2, #0]

  // TODO: allow to change device ID (read from flash, resp. BSL based EEPROM emulation)
  sysex_device_id = 0x00;
 8005686:	4a0c      	ldr	r2, [pc, #48]	; (80056b8 <MIOS32_MIDI_Init+0x8c>)
 8005688:	7013      	strb	r3, [r2, #0]

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
 800568a:	4a0c      	ldr	r2, [pc, #48]	; (80056bc <MIOS32_MIDI_Init+0x90>)
 800568c:	8013      	strh	r3, [r2, #0]
  sysex_timeout_ctr_flags.ALL = 0;
 800568e:	4a0c      	ldr	r2, [pc, #48]	; (80056c0 <MIOS32_MIDI_Init+0x94>)
 8005690:	6013      	str	r3, [r2, #0]

  return -ret;
}
 8005692:	bd38      	pop	{r3, r4, r5, pc}
 8005694:	20000004 	.word	0x20000004
 8005698:	20000005 	.word	0x20000005
 800569c:	20000168 	.word	0x20000168
 80056a0:	20000160 	.word	0x20000160
 80056a4:	20000184 	.word	0x20000184
 80056a8:	20000188 	.word	0x20000188
 80056ac:	2000017c 	.word	0x2000017c
 80056b0:	2000016c 	.word	0x2000016c
 80056b4:	20000174 	.word	0x20000174
 80056b8:	2000016d 	.word	0x2000016d
 80056bc:	2000016e 	.word	0x2000016e
 80056c0:	20000180 	.word	0x20000180

080056c4 <MIOS32_MIDI_SendPackage>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 80056c4:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] package MIDI package
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
 80056c8:	b570      	push	{r4, r5, r6, lr}
 80056ca:	4605      	mov	r5, r0
 80056cc:	460c      	mov	r4, r1
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 80056ce:	d104      	bne.n	80056da <MIOS32_MIDI_SendPackage+0x16>
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
 80056d0:	2801      	cmp	r0, #1
 80056d2:	bf0c      	ite	eq
 80056d4:	4b16      	ldreq	r3, [pc, #88]	; (8005730 <MIOS32_MIDI_SendPackage+0x6c>)
 80056d6:	4b17      	ldrne	r3, [pc, #92]	; (8005734 <MIOS32_MIDI_SendPackage+0x70>)
 80056d8:	781d      	ldrb	r5, [r3, #0]

  // insert subport number into package
  package.cable = port & 0xf;

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 80056da:	4b17      	ldr	r3, [pc, #92]	; (8005738 <MIOS32_MIDI_SendPackage+0x74>)
  if( !(port & 0xf0) ) {
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
  }

  // insert subport number into package
  package.cable = port & 0xf;
 80056dc:	f005 060f 	and.w	r6, r5, #15

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 80056e0:	681b      	ldr	r3, [r3, #0]
 80056e2:	b12b      	cbz	r3, 80056f0 <MIOS32_MIDI_SendPackage+0x2c>
 80056e4:	f366 1407 	bfi	r4, r6, #4, #4
    s32 status;
    if( (status=direct_tx_callback_func(port, package)) )
 80056e8:	4628      	mov	r0, r5
 80056ea:	4621      	mov	r1, r4
 80056ec:	4798      	blx	r3
 80056ee:	b9e8      	cbnz	r0, 800572c <MIOS32_MIDI_SendPackage+0x68>
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 80056f0:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 80056f4:	2d20      	cmp	r5, #32
 80056f6:	d00c      	beq.n	8005712 <MIOS32_MIDI_SendPackage+0x4e>
 80056f8:	2d30      	cmp	r5, #48	; 0x30
 80056fa:	d011      	beq.n	8005720 <MIOS32_MIDI_SendPackage+0x5c>
 80056fc:	2d10      	cmp	r5, #16
      return -1; // IIC_MIDI has been disabled
#endif
      
    default:
      // invalid port
      return -1;
 80056fe:	bf18      	it	ne
 8005700:	f04f 30ff 	movne.w	r0, #4294967295
    if( (status=direct_tx_callback_func(port, package)) )
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 8005704:	d112      	bne.n	800572c <MIOS32_MIDI_SendPackage+0x68>
 8005706:	f366 1407 	bfi	r4, r6, #4, #4
    case USB0://..15
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      return MIOS32_USB_MIDI_PackageSend(package);
 800570a:	4620      	mov	r0, r4
 800570c:	f002 fa42 	bl	8007b94 <MIOS32_USB_MIDI_PackageSend>
 8005710:	e00c      	b.n	800572c <MIOS32_MIDI_SendPackage+0x68>
 8005712:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // USB has been disabled
#endif

    case UART0://..15
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
      return MIOS32_UART_MIDI_PackageSend(package.cable, package);
 8005716:	4630      	mov	r0, r6
 8005718:	4621      	mov	r1, r4
 800571a:	f000 fd83 	bl	8006224 <MIOS32_UART_MIDI_PackageSend>
 800571e:	e005      	b.n	800572c <MIOS32_MIDI_SendPackage+0x68>
 8005720:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // UART_MIDI has been disabled
#endif

    case IIC0://..15
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      return MIOS32_IIC_MIDI_PackageSend(package.cable, package);
 8005724:	4630      	mov	r0, r6
 8005726:	4621      	mov	r1, r4
 8005728:	f000 fe65 	bl	80063f6 <MIOS32_IIC_MIDI_PackageSend>
      
    default:
      // invalid port
      return -1;
  }
}
 800572c:	bd70      	pop	{r4, r5, r6, pc}
 800572e:	bf00      	nop
 8005730:	20000005 	.word	0x20000005
 8005734:	20000004 	.word	0x20000004
 8005738:	20000160 	.word	0x20000160

0800573c <MIOS32_MIDI_SendEvent>:
//! \param[in] evnt2 third MIDI byte
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendEvent(mios32_midi_port_t port, u8 evnt0, u8 evnt1, u8 evnt2)
{
 800573c:	b508      	push	{r3, lr}

  // MEMO: don't optimize this function by calling MIOS32_MIDI_SendSpecialEvent
  // from here, because the 4 * u8 parameter list of this function leads
  // to best compile results (4*u8 combined to a single u32)

  package.type  = evnt0 >> 4;
 800573e:	f04f 0c00 	mov.w	ip, #0
 8005742:	ea4f 1e11 	mov.w	lr, r1, lsr #4
 8005746:	f36e 0c03 	bfi	ip, lr, #0, #4
  package.evnt0 = evnt0;
 800574a:	f361 2c0f 	bfi	ip, r1, #8, #8
  package.evnt1 = evnt1;
 800574e:	f362 4c17 	bfi	ip, r2, #16, #8
  package.evnt2 = evnt2;
 8005752:	f363 6c1f 	bfi	ip, r3, #24, #8
  return MIOS32_MIDI_SendPackage(port, package);
 8005756:	4661      	mov	r1, ip
 8005758:	f7ff ffb4 	bl	80056c4 <MIOS32_MIDI_SendPackage>
}
 800575c:	bd08      	pop	{r3, pc}

0800575e <MIOS32_MIDI_SendCC>:

s32 MIOS32_MIDI_SendPolyPressure(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xa0 | chn, note, val); }

s32 MIOS32_MIDI_SendCC(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 cc_number, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xb0 | chn, cc_number,   val); }
 800575e:	b508      	push	{r3, lr}
 8005760:	f041 01b0 	orr.w	r1, r1, #176	; 0xb0
 8005764:	f7ff ffea 	bl	800573c <MIOS32_MIDI_SendEvent>
 8005768:	bd08      	pop	{r3, pc}

0800576a <MIOS32_MIDI_SendSysEx>:
//! \param[in] count number of bytes
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendSysEx(mios32_midi_port_t port, u8 *stream, u32 count)
{
 800576a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800576c:	b085      	sub	sp, #20
 800576e:	4617      	mov	r7, r2
 8005770:	9003      	str	r0, [sp, #12]
 8005772:	460d      	mov	r5, r1
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 8005774:	2600      	movs	r6, #0
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 8005776:	2306      	movs	r3, #6
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 8005778:	2207      	movs	r2, #7
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 800577a:	f04f 0c04 	mov.w	ip, #4
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 800577e:	e040      	b.n	8005802 <MIOS32_MIDI_SendSysEx+0x98>
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 8005780:	1bb9      	subs	r1, r7, r6
 8005782:	2902      	cmp	r1, #2
 8005784:	d014      	beq.n	80057b0 <MIOS32_MIDI_SendSysEx+0x46>
 8005786:	2903      	cmp	r1, #3
 8005788:	d01f      	beq.n	80057ca <MIOS32_MIDI_SendSysEx+0x60>
 800578a:	2901      	cmp	r1, #1
 800578c:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 800578e:	bf18      	it	ne
 8005790:	f36c 0403 	bfine	r4, ip, #0, #4
 8005794:	f106 0601 	add.w	r6, r6, #1
	package.evnt0 = stream[offset++];
 8005798:	bf18      	it	ne
 800579a:	f361 240f 	bfine	r4, r1, #8, #8

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 800579e:	d11a      	bne.n	80057d6 <MIOS32_MIDI_SendSysEx+0x6c>
      case 1: 
	package.type = 0x5; // SysEx ends with following single byte. 
 80057a0:	2005      	movs	r0, #5
 80057a2:	f360 0403 	bfi	r4, r0, #0, #4
	package.evnt0 = stream[offset++];
 80057a6:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = 0x00;
 80057aa:	f36f 4417 	bfc	r4, #16, #8
 80057ae:	e009      	b.n	80057c4 <MIOS32_MIDI_SendSysEx+0x5a>
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
	package.evnt0 = stream[offset++];
 80057b0:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 80057b2:	f363 0403 	bfi	r4, r3, #0, #4
	package.evnt0 = stream[offset++];
 80057b6:	3601      	adds	r6, #1
 80057b8:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = stream[offset++];
 80057bc:	5da9      	ldrb	r1, [r5, r6]
 80057be:	3601      	adds	r6, #1
 80057c0:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = 0x00;
 80057c4:	f36f 641f 	bfc	r4, #24, #8
	break;
 80057c8:	e00d      	b.n	80057e6 <MIOS32_MIDI_SendSysEx+0x7c>
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
	package.evnt0 = stream[offset++];
 80057ca:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 80057cc:	f362 0403 	bfi	r4, r2, #0, #4
	package.evnt0 = stream[offset++];
 80057d0:	f361 240f 	bfi	r4, r1, #8, #8
 80057d4:	3601      	adds	r6, #1
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
 80057d6:	5da9      	ldrb	r1, [r5, r6]
 80057d8:	3601      	adds	r6, #1
 80057da:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = stream[offset++];
 80057de:	5da9      	ldrb	r1, [r5, r6]
 80057e0:	3601      	adds	r6, #1
 80057e2:	f361 641f 	bfi	r4, r1, #24, #8
    }

    res=MIOS32_MIDI_SendPackage(port, package);
 80057e6:	9803      	ldr	r0, [sp, #12]
 80057e8:	4621      	mov	r1, r4
 80057ea:	9201      	str	r2, [sp, #4]
 80057ec:	9302      	str	r3, [sp, #8]
 80057ee:	f8cd c000 	str.w	ip, [sp]
 80057f2:	f7ff ff67 	bl	80056c4 <MIOS32_MIDI_SendPackage>

    // expection? (e.g., port not available)
    if( res < 0 )
 80057f6:	2800      	cmp	r0, #0
 80057f8:	9a01      	ldr	r2, [sp, #4]
 80057fa:	9b02      	ldr	r3, [sp, #8]
 80057fc:	f8dd c000 	ldr.w	ip, [sp]
 8005800:	db02      	blt.n	8005808 <MIOS32_MIDI_SendSysEx+0x9e>
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 8005802:	42be      	cmp	r6, r7
 8005804:	d3bc      	bcc.n	8005780 <MIOS32_MIDI_SendSysEx+0x16>
    // expection? (e.g., port not available)
    if( res < 0 )
      return res;
  }

  return 0;
 8005806:	2000      	movs	r0, #0
}
 8005808:	b005      	add	sp, #20
 800580a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800580c <MIOS32_MIDI_SYSEX_SendAckStr>:

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 800580c:	b510      	push	{r4, lr}
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 800580e:	23f0      	movs	r3, #240	; 0xf0

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 8005810:	b0a0      	sub	sp, #128	; 0x80
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005812:	f88d 3000 	strb.w	r3, [sp]
 8005816:	2300      	movs	r3, #0
 8005818:	f88d 3001 	strb.w	r3, [sp, #1]
 800581c:	f88d 3002 	strb.w	r3, [sp, #2]
 8005820:	337e      	adds	r3, #126	; 0x7e
 8005822:	f88d 3003 	strb.w	r3, [sp, #3]
 8005826:	2332      	movs	r3, #50	; 0x32
 8005828:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 800582c:	4b0e      	ldr	r3, [pc, #56]	; (8005868 <MIOS32_MIDI_SYSEX_SendAckStr+0x5c>)
}

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
 800582e:	f10d 0c6b 	add.w	ip, sp, #107	; 0x6b

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005832:	781b      	ldrb	r3, [r3, #0]
 8005834:	f88d 3005 	strb.w	r3, [sp, #5]

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;
 8005838:	230f      	movs	r3, #15
 800583a:	f88d 3006 	strb.w	r3, [sp, #6]
 800583e:	466b      	mov	r3, sp
 8005840:	1dda      	adds	r2, r3, #7
 8005842:	e003      	b.n	800584c <MIOS32_MIDI_SYSEX_SendAckStr+0x40>

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
    *sysex_buffer_ptr++ = str[i];
 8005844:	f802 4b01 	strb.w	r4, [r2], #1

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
 8005848:	4562      	cmp	r2, ip
 800584a:	d003      	beq.n	8005854 <MIOS32_MIDI_SYSEX_SendAckStr+0x48>
 800584c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8005850:	2c00      	cmp	r4, #0
 8005852:	d1f7      	bne.n	8005844 <MIOS32_MIDI_SYSEX_SendAckStr+0x38>
    *sysex_buffer_ptr++ = str[i];

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005854:	21f7      	movs	r1, #247	; 0xf7
 8005856:	f802 1b01 	strb.w	r1, [r2], #1

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 800585a:	1ad2      	subs	r2, r2, r3
 800585c:	4669      	mov	r1, sp
 800585e:	f7ff ff84 	bl	800576a <MIOS32_MIDI_SendSysEx>
}
 8005862:	b020      	add	sp, #128	; 0x80
 8005864:	bd10      	pop	{r4, pc}
 8005866:	bf00      	nop
 8005868:	2000016d 	.word	0x2000016d

0800586c <MIOS32_MIDI_SYSEX_SendAck>:
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 800586c:	b500      	push	{lr}
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 800586e:	23f0      	movs	r3, #240	; 0xf0
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 8005870:	b089      	sub	sp, #36	; 0x24
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005872:	f88d 3000 	strb.w	r3, [sp]
 8005876:	2300      	movs	r3, #0
 8005878:	f88d 3001 	strb.w	r3, [sp, #1]
 800587c:	f88d 3002 	strb.w	r3, [sp, #2]
 8005880:	337e      	adds	r3, #126	; 0x7e
 8005882:	f88d 3003 	strb.w	r3, [sp, #3]
 8005886:	2332      	movs	r3, #50	; 0x32
 8005888:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 800588c:	4b08      	ldr	r3, [pc, #32]	; (80058b0 <MIOS32_MIDI_SYSEX_SendAck+0x44>)

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
 800588e:	f88d 1006 	strb.w	r1, [sp, #6]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005892:	781b      	ldrb	r3, [r3, #0]

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;
 8005894:	f88d 2007 	strb.w	r2, [sp, #7]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005898:	f88d 3005 	strb.w	r3, [sp, #5]

  // send footer
  *sysex_buffer_ptr++ = 0xf7;

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 800589c:	4669      	mov	r1, sp
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 800589e:	23f7      	movs	r3, #247	; 0xf7

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80058a0:	2209      	movs	r2, #9
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 80058a2:	f88d 3008 	strb.w	r3, [sp, #8]

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80058a6:	f7ff ff60 	bl	800576a <MIOS32_MIDI_SendSysEx>
}
 80058aa:	b009      	add	sp, #36	; 0x24
 80058ac:	bd00      	pop	{pc}
 80058ae:	bf00      	nop
 80058b0:	2000016d 	.word	0x2000016d

080058b4 <MIOS32_MIDI_SendDebugMessage>:
//! \param[in] *format zero-terminated format string - 128 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendDebugMessage(char *format, ...)
{
 80058b4:	b40f      	push	{r0, r1, r2, r3}
 80058b6:	b530      	push	{r4, r5, lr}
 80058b8:	b0a5      	sub	sp, #148	; 0x94
 80058ba:	9c28      	ldr	r4, [sp, #160]	; 0xa0

  // failsave: if format string is longer than 100 chars, break here
  // note that this is a weak protection: if %s is used, or a lot of other format tokens,
  // the resulting string could still lead to a buffer overflow
  // other the other hand we don't want to allocate too many byte for buffer[] to save stack
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
 80058bc:	ad02      	add	r5, sp, #8
  if( strlen(format) > 100 ) {
 80058be:	4620      	mov	r0, r4
 80058c0:	f004 faea 	bl	8009e98 <strlen>
 80058c4:	2864      	cmp	r0, #100	; 0x64
 80058c6:	d91e      	bls.n	8005906 <MIOS32_MIDI_SendDebugMessage+0x52>
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
 80058c8:	4628      	mov	r0, r5
 80058ca:	4920      	ldr	r1, [pc, #128]	; (800594c <MIOS32_MIDI_SendDebugMessage+0x98>)
 80058cc:	f004 fadd 	bl	8009e8a <strcpy>
    vsprintf(str, format, args);
  }

  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 80058d0:	23f0      	movs	r3, #240	; 0xf0
 80058d2:	f88d 3000 	strb.w	r3, [sp]
 80058d6:	2300      	movs	r3, #0
 80058d8:	f88d 3001 	strb.w	r3, [sp, #1]
 80058dc:	f88d 3002 	strb.w	r3, [sp, #2]
 80058e0:	337e      	adds	r3, #126	; 0x7e
 80058e2:	f88d 3003 	strb.w	r3, [sp, #3]
 80058e6:	2332      	movs	r3, #50	; 0x32
 80058e8:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80058ec:	4b18      	ldr	r3, [pc, #96]	; (8005950 <MIOS32_MIDI_SendDebugMessage+0x9c>)

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
 80058ee:	2208      	movs	r2, #8
  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80058f0:	781b      	ldrb	r3, [r3, #0]
 80058f2:	f88d 3005 	strb.w	r3, [sp, #5]

  // debug message: ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_DEBUG;
 80058f6:	230d      	movs	r3, #13
 80058f8:	f88d 3006 	strb.w	r3, [sp, #6]

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string
 80058fc:	3333      	adds	r3, #51	; 0x33
 80058fe:	f88d 3007 	strb.w	r3, [sp, #7]
 8005902:	ab02      	add	r3, sp, #8
 8005904:	e00f      	b.n	8005926 <MIOS32_MIDI_SendDebugMessage+0x72>
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 8005906:	aa29      	add	r2, sp, #164	; 0xa4
    vsprintf(str, format, args);
 8005908:	4628      	mov	r0, r5
 800590a:	4621      	mov	r1, r4
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 800590c:	9223      	str	r2, [sp, #140]	; 0x8c
    vsprintf(str, format, args);
 800590e:	f002 fe5c 	bl	80085ca <vsprintf>
 8005912:	e7dd      	b.n	80058d0 <MIOS32_MIDI_SendDebugMessage+0x1c>

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
 8005914:	3201      	adds	r2, #1
 8005916:	b292      	uxth	r2, r2
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 8005918:	f000 007f 	and.w	r0, r0, #127	; 0x7f
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 800591c:	2a88      	cmp	r2, #136	; 0x88
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 800591e:	f803 0c01 	strb.w	r0, [r3, #-1]
 8005922:	4619      	mov	r1, r3
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 8005924:	d004      	beq.n	8005930 <MIOS32_MIDI_SendDebugMessage+0x7c>
 8005926:	4619      	mov	r1, r3
 8005928:	f813 0b01 	ldrb.w	r0, [r3], #1
 800592c:	2800      	cmp	r0, #0
 800592e:	d1f1      	bne.n	8005914 <MIOS32_MIDI_SendDebugMessage+0x60>
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005930:	23f7      	movs	r3, #247	; 0xf7
 8005932:	700b      	strb	r3, [r1, #0]
  ++len;

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 8005934:	4b07      	ldr	r3, [pc, #28]	; (8005954 <MIOS32_MIDI_SendDebugMessage+0xa0>)
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
  ++len;
 8005936:	3201      	adds	r2, #1

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 8005938:	7818      	ldrb	r0, [r3, #0]
 800593a:	b292      	uxth	r2, r2
 800593c:	4669      	mov	r1, sp
 800593e:	f7ff ff14 	bl	800576a <MIOS32_MIDI_SendSysEx>
}
 8005942:	b025      	add	sp, #148	; 0x94
 8005944:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8005948:	b004      	add	sp, #16
 800594a:	4770      	bx	lr
 800594c:	0800a170 	.word	0x0800a170
 8005950:	2000016d 	.word	0x2000016d
 8005954:	20000005 	.word	0x20000005

08005958 <MIOS32_MIDI_SYSEX_Cmd>:

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 8005958:	b530      	push	{r4, r5, lr}
 800595a:	460b      	mov	r3, r1
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 800595c:	4959      	ldr	r1, [pc, #356]	; (8005ac4 <MIOS32_MIDI_SYSEX_Cmd+0x16c>)

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 800595e:	b08b      	sub	sp, #44	; 0x2c
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 8005960:	7809      	ldrb	r1, [r1, #0]

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 8005962:	4604      	mov	r4, r0
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 8005964:	290d      	cmp	r1, #13
 8005966:	d05e      	beq.n	8005a26 <MIOS32_MIDI_SYSEX_Cmd+0xce>
 8005968:	d801      	bhi.n	800596e <MIOS32_MIDI_SYSEX_Cmd+0x16>
 800596a:	b139      	cbz	r1, 800597c <MIOS32_MIDI_SYSEX_Cmd+0x24>
 800596c:	e09d      	b.n	8005aaa <MIOS32_MIDI_SYSEX_Cmd+0x152>
 800596e:	290e      	cmp	r1, #14
 8005970:	f000 80a5 	beq.w	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
 8005974:	290f      	cmp	r1, #15
 8005976:	f040 8098 	bne.w	8005aaa <MIOS32_MIDI_SYSEX_Cmd+0x152>
 800597a:	e08a      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x13a>
static s32 MIOS32_MIDI_SYSEX_Cmd_Query(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 query_req = 0;
  char str_buffer[40];

  switch( cmd_state ) {
 800597c:	b11b      	cbz	r3, 8005986 <MIOS32_MIDI_SYSEX_Cmd+0x2e>
 800597e:	2b01      	cmp	r3, #1
 8005980:	4b51      	ldr	r3, [pc, #324]	; (8005ac8 <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 8005982:	d102      	bne.n	800598a <MIOS32_MIDI_SYSEX_Cmd+0x32>
 8005984:	e056      	b.n	8005a34 <MIOS32_MIDI_SYSEX_Cmd+0xdc>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      query_req = 0;
 8005986:	4a50      	ldr	r2, [pc, #320]	; (8005ac8 <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 8005988:	e098      	b.n	8005abc <MIOS32_MIDI_SYSEX_Cmd+0x164>
    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      query_req = midi_in;
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      switch( query_req ) {
 800598a:	781b      	ldrb	r3, [r3, #0]
 800598c:	2b05      	cmp	r3, #5
 800598e:	d025      	beq.n	80059dc <MIOS32_MIDI_SYSEX_Cmd+0x84>
 8005990:	d80a      	bhi.n	80059a8 <MIOS32_MIDI_SYSEX_Cmd+0x50>
 8005992:	2b02      	cmp	r3, #2
 8005994:	d017      	beq.n	80059c6 <MIOS32_MIDI_SYSEX_Cmd+0x6e>
 8005996:	d802      	bhi.n	800599e <MIOS32_MIDI_SYSEX_Cmd+0x46>
 8005998:	2b01      	cmp	r3, #1
 800599a:	d140      	bne.n	8005a1e <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 800599c:	e011      	b.n	80059c2 <MIOS32_MIDI_SYSEX_Cmd+0x6a>
 800599e:	2b03      	cmp	r3, #3
 80059a0:	d013      	beq.n	80059ca <MIOS32_MIDI_SYSEX_Cmd+0x72>
 80059a2:	2b04      	cmp	r3, #4
 80059a4:	d13b      	bne.n	8005a1e <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80059a6:	e012      	b.n	80059ce <MIOS32_MIDI_SYSEX_Cmd+0x76>
 80059a8:	2b08      	cmp	r3, #8
 80059aa:	d02f      	beq.n	8005a0c <MIOS32_MIDI_SYSEX_Cmd+0xb4>
 80059ac:	d804      	bhi.n	80059b8 <MIOS32_MIDI_SYSEX_Cmd+0x60>
 80059ae:	2b06      	cmp	r3, #6
 80059b0:	d01e      	beq.n	80059f0 <MIOS32_MIDI_SYSEX_Cmd+0x98>
 80059b2:	2b07      	cmp	r3, #7
 80059b4:	d133      	bne.n	8005a1e <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80059b6:	e01e      	b.n	80059f6 <MIOS32_MIDI_SYSEX_Cmd+0x9e>
 80059b8:	2b09      	cmp	r3, #9
 80059ba:	d029      	beq.n	8005a10 <MIOS32_MIDI_SYSEX_Cmd+0xb8>
 80059bc:	2b7f      	cmp	r3, #127	; 0x7f
 80059be:	d12e      	bne.n	8005a1e <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80059c0:	e02a      	b.n	8005a18 <MIOS32_MIDI_SYSEX_Cmd+0xc0>
        case 0x01: // operating system
	  MIOS32_MIDI_SYSEX_SendAckStr(port, "MIOS32");
 80059c2:	4942      	ldr	r1, [pc, #264]	; (8005acc <MIOS32_MIDI_SYSEX_Cmd+0x174>)
 80059c4:	e025      	b.n	8005a12 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x02: // Board
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_BOARD_STR);
 80059c6:	4942      	ldr	r1, [pc, #264]	; (8005ad0 <MIOS32_MIDI_SYSEX_Cmd+0x178>)
 80059c8:	e023      	b.n	8005a12 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x03: // Core Family
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_FAMILY_STR);
 80059ca:	4942      	ldr	r1, [pc, #264]	; (8005ad4 <MIOS32_MIDI_SYSEX_Cmd+0x17c>)
 80059cc:	e021      	b.n	8005a12 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
 80059ce:	f000 fd5b 	bl	8006488 <MIOS32_SYS_ChipIDGet>
 80059d2:	466d      	mov	r5, sp
 80059d4:	4602      	mov	r2, r0
 80059d6:	4940      	ldr	r1, [pc, #256]	; (8005ad8 <MIOS32_MIDI_SYSEX_Cmd+0x180>)
 80059d8:	4668      	mov	r0, sp
 80059da:	e012      	b.n	8005a02 <MIOS32_MIDI_SYSEX_Cmd+0xaa>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 80059dc:	4668      	mov	r0, sp
 80059de:	f000 fd69 	bl	80064b4 <MIOS32_SYS_SerialNumberGet>
 80059e2:	2800      	cmp	r0, #0
 80059e4:	466d      	mov	r5, sp
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
 80059e6:	bfbc      	itt	lt
 80059e8:	4620      	movlt	r0, r4
 80059ea:	493c      	ldrlt	r1, [pc, #240]	; (8005adc <MIOS32_MIDI_SYSEX_Cmd+0x184>)
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 80059ec:	da0b      	bge.n	8005a06 <MIOS32_MIDI_SYSEX_Cmd+0xae>
 80059ee:	e010      	b.n	8005a12 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
	  break;
        case 0x06: // Flash Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_FlashSizeGet());
 80059f0:	f000 fd50 	bl	8006494 <MIOS32_SYS_FlashSizeGet>
 80059f4:	e001      	b.n	80059fa <MIOS32_MIDI_SYSEX_Cmd+0xa2>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  break;
        case 0x07: // RAM Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_RAMSizeGet());
 80059f6:	f000 fd55 	bl	80064a4 <MIOS32_SYS_RAMSizeGet>
 80059fa:	4939      	ldr	r1, [pc, #228]	; (8005ae0 <MIOS32_MIDI_SYSEX_Cmd+0x188>)
 80059fc:	4602      	mov	r2, r0
 80059fe:	466d      	mov	r5, sp
 8005a00:	4668      	mov	r0, sp
 8005a02:	f002 fdd3 	bl	80085ac <sprintf>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
 8005a06:	4620      	mov	r0, r4
 8005a08:	4669      	mov	r1, sp
 8005a0a:	e002      	b.n	8005a12 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x08: // Application Name Line #1
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE1);
 8005a0c:	4935      	ldr	r1, [pc, #212]	; (8005ae4 <MIOS32_MIDI_SYSEX_Cmd+0x18c>)
 8005a0e:	e000      	b.n	8005a12 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x09: // Application Name Line #2
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE2);
 8005a10:	4935      	ldr	r1, [pc, #212]	; (8005ae8 <MIOS32_MIDI_SYSEX_Cmd+0x190>)
 8005a12:	f7ff fefb 	bl	800580c <MIOS32_MIDI_SYSEX_SendAckStr>
 8005a16:	e052      	b.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
#if MIOS32_MIDI_BSL_ENHANCEMENTS
	  // release halt state (or sending upload request) instead of reseting the core
	  BSL_SYSEX_ReleaseHaltState();
#else
	  // reset core (this will send an upload request)
	  MIOS32_SYS_Reset();
 8005a18:	f000 fcfa 	bl	8006410 <MIOS32_SYS_Reset>
 8005a1c:	e04f      	b.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  // but other core families could contain an empty stumb!
#endif
	  break;
        default: 
	  // unknown query
	  MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNKNOWN_QUERY);
 8005a1e:	4620      	mov	r0, r4
 8005a20:	210e      	movs	r1, #14
 8005a22:	220d      	movs	r2, #13
 8005a24:	e03e      	b.n	8005aa4 <MIOS32_MIDI_SYSEX_Cmd+0x14c>
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Debug(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 debug_req = 0xff;

  switch( cmd_state ) {
 8005a26:	b11b      	cbz	r3, 8005a30 <MIOS32_MIDI_SYSEX_Cmd+0xd8>
 8005a28:	2b01      	cmp	r3, #1
 8005a2a:	4d30      	ldr	r5, [pc, #192]	; (8005aec <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 8005a2c:	d114      	bne.n	8005a58 <MIOS32_MIDI_SYSEX_Cmd+0x100>
 8005a2e:	e003      	b.n	8005a38 <MIOS32_MIDI_SYSEX_Cmd+0xe0>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
 8005a30:	4b2e      	ldr	r3, [pc, #184]	; (8005aec <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 8005a32:	22ff      	movs	r2, #255	; 0xff
 8005a34:	701a      	strb	r2, [r3, #0]
 8005a36:	e042      	b.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005a38:	782b      	ldrb	r3, [r5, #0]
 8005a3a:	2bff      	cmp	r3, #255	; 0xff
	debug_req = midi_in;
 8005a3c:	bf08      	it	eq
 8005a3e:	702a      	strbeq	r2, [r5, #0]
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005a40:	d03d      	beq.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
	debug_req = midi_in;
      } else {
	switch( debug_req ) {
 8005a42:	2b00      	cmp	r3, #0
 8005a44:	d13b      	bne.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  case 0x00: // input string
	    if( debug_command_callback_func != NULL )
 8005a46:	4b2a      	ldr	r3, [pc, #168]	; (8005af0 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 8005a48:	681b      	ldr	r3, [r3, #0]
 8005a4a:	2b00      	cmp	r3, #0
 8005a4c:	d037      	beq.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
	      debug_command_callback_func(last_sysex_port, (char)midi_in);
 8005a4e:	4929      	ldr	r1, [pc, #164]	; (8005af4 <MIOS32_MIDI_SYSEX_Cmd+0x19c>)
 8005a50:	7808      	ldrb	r0, [r1, #0]
 8005a52:	4611      	mov	r1, r2
 8005a54:	4798      	blx	r3
 8005a56:	e032      	b.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
	}
      }
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      if( debug_req == 0x00 ) {
 8005a58:	782a      	ldrb	r2, [r5, #0]
 8005a5a:	b9ba      	cbnz	r2, 8005a8c <MIOS32_MIDI_SYSEX_Cmd+0x134>
	// send acknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8005a5c:	210f      	movs	r1, #15
 8005a5e:	f7ff ff05 	bl	800586c <MIOS32_MIDI_SYSEX_SendAck>

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
 8005a62:	782b      	ldrb	r3, [r5, #0]
 8005a64:	2b00      	cmp	r3, #0
 8005a66:	d12a      	bne.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
 8005a68:	4b21      	ldr	r3, [pc, #132]	; (8005af0 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 8005a6a:	681b      	ldr	r3, [r3, #0]
 8005a6c:	2b00      	cmp	r3, #0
 8005a6e:	d126      	bne.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 8005a70:	4b21      	ldr	r3, [pc, #132]	; (8005af8 <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 8005a72:	2c01      	cmp	r4, #1
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 8005a74:	781d      	ldrb	r5, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 8005a76:	4821      	ldr	r0, [pc, #132]	; (8005afc <MIOS32_MIDI_SYSEX_Cmd+0x1a4>)
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
    return -1;

  debug_port = port;
 8005a78:	bf18      	it	ne
 8005a7a:	701c      	strbne	r4, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 8005a7c:	4621      	mov	r1, r4
 8005a7e:	f7ff ff19 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 8005a82:	2d01      	cmp	r5, #1
    return -1;

  debug_port = port;
 8005a84:	bf1c      	itt	ne
 8005a86:	4b1c      	ldrne	r3, [pc, #112]	; (8005af8 <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
 8005a88:	701d      	strbne	r5, [r3, #0]
 8005a8a:	e018      	b.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  MIOS32_MIDI_DebugPortSet(prev_debug_port);
	}

      } else {
	// send disacknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNSUPPORTED_DEBUG);
 8005a8c:	210e      	movs	r1, #14
 8005a8e:	2210      	movs	r2, #16
 8005a90:	e008      	b.n	8005aa4 <MIOS32_MIDI_SYSEX_Cmd+0x14c>
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
 8005a92:	4a1b      	ldr	r2, [pc, #108]	; (8005b00 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
/////////////////////////////////////////////////////////////////////////////
// Command 0F: Ping (just send back acknowledge if no additional byte has been received)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {
 8005a94:	b113      	cbz	r3, 8005a9c <MIOS32_MIDI_SYSEX_Cmd+0x144>
 8005a96:	2b01      	cmp	r3, #1
 8005a98:	4a19      	ldr	r2, [pc, #100]	; (8005b00 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 8005a9a:	d101      	bne.n	8005aa0 <MIOS32_MIDI_SYSEX_Cmd+0x148>
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      sysex_state.PING_BYTE_RECEIVED = 1;
 8005a9c:	6053      	str	r3, [r2, #4]
 8005a9e:	e00e      	b.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      // TODO: send 0xf7 if merger enabled

      // send acknowledge if no additional byte has been received
      // to avoid feedback loop if two cores are directly connected
      if( !sysex_state.PING_BYTE_RECEIVED )
 8005aa0:	6852      	ldr	r2, [r2, #4]
 8005aa2:	b962      	cbnz	r2, 8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8005aa4:	f7ff fee2 	bl	800586c <MIOS32_MIDI_SYSEX_SendAck>
 8005aa8:	e009      	b.n	8005abe <MIOS32_MIDI_SYSEX_Cmd+0x166>
      MIOS32_MIDI_SYSEX_Cmd_Ping(port, cmd_state, midi_in);
      break;
    default:
      // unknown command
      // TODO: send 0xf7 if merger enabled
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
 8005aaa:	210e      	movs	r1, #14
 8005aac:	460a      	mov	r2, r1
 8005aae:	4620      	mov	r0, r4
 8005ab0:	f7ff fedc 	bl	800586c <MIOS32_MIDI_SYSEX_SendAck>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005ab4:	4a12      	ldr	r2, [pc, #72]	; (8005b00 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 8005ab6:	2300      	movs	r3, #0
 8005ab8:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005aba:	4a02      	ldr	r2, [pc, #8]	; (8005ac4 <MIOS32_MIDI_SYSEX_Cmd+0x16c>)
 8005abc:	7013      	strb	r3, [r2, #0]
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
      MIOS32_MIDI_SYSEX_CmdFinished();      
  }

  return 0; // no error
}
 8005abe:	2000      	movs	r0, #0
 8005ac0:	b00b      	add	sp, #44	; 0x2c
 8005ac2:	bd30      	pop	{r4, r5, pc}
 8005ac4:	20000164 	.word	0x20000164
 8005ac8:	20000170 	.word	0x20000170
 8005acc:	0800a1c3 	.word	0x0800a1c3
 8005ad0:	0800a1ca 	.word	0x0800a1ca
 8005ad4:	0800a1da 	.word	0x0800a1da
 8005ad8:	0800a1e4 	.word	0x0800a1e4
 8005adc:	0800a1e9 	.word	0x0800a1e9
 8005ae0:	0800a1eb 	.word	0x0800a1eb
 8005ae4:	0800a130 	.word	0x0800a130
 8005ae8:	0800a13e 	.word	0x0800a13e
 8005aec:	20000006 	.word	0x20000006
 8005af0:	2000017c 	.word	0x2000017c
 8005af4:	2000016c 	.word	0x2000016c
 8005af8:	20000005 	.word	0x20000005
 8005afc:	0800a1ee 	.word	0x0800a1ee
 8005b00:	20000174 	.word	0x20000174

08005b04 <MIOS32_MIDI_SYSEX_Parser>:
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005b04:	29f7      	cmp	r1, #247	; 0xf7

/////////////////////////////////////////////////////////////////////////////
// This function parses an incoming sysex stream for MIOS32 commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
 8005b06:	b510      	push	{r4, lr}
 8005b08:	460a      	mov	r2, r1
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005b0a:	d85c      	bhi.n	8005bc6 <MIOS32_MIDI_SYSEX_Parser+0xc2>
    return 0;

  // TODO: here we could send an error notification, that multiple devices are trying to access the device
  if( sysex_state.MY_SYSEX && port != last_sysex_port )
 8005b0c:	4b2f      	ldr	r3, [pc, #188]	; (8005bcc <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b0e:	781c      	ldrb	r4, [r3, #0]
 8005b10:	f004 0308 	and.w	r3, r4, #8
 8005b14:	b2db      	uxtb	r3, r3
 8005b16:	b11b      	cbz	r3, 8005b20 <MIOS32_MIDI_SYSEX_Parser+0x1c>
 8005b18:	492d      	ldr	r1, [pc, #180]	; (8005bd0 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005b1a:	7809      	ldrb	r1, [r1, #0]
 8005b1c:	4281      	cmp	r1, r0
 8005b1e:	d14f      	bne.n	8005bc0 <MIOS32_MIDI_SYSEX_Parser+0xbc>
  // USB upload is only allowed via USB0
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
 8005b20:	f1a0 0111 	sub.w	r1, r0, #17
 8005b24:	b2c9      	uxtb	r1, r1
 8005b26:	2906      	cmp	r1, #6
 8005b28:	d94a      	bls.n	8005bc0 <MIOS32_MIDI_SYSEX_Parser+0xbc>
    return -1;

  last_sysex_port = port;
 8005b2a:	4929      	ldr	r1, [pc, #164]	; (8005bd0 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005b2c:	7008      	strb	r0, [r1, #0]

  // branch depending on state
  if( !sysex_state.MY_SYSEX ) {
 8005b2e:	bb0b      	cbnz	r3, 8005b74 <MIOS32_MIDI_SYSEX_Parser+0x70>
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
 8005b30:	4b26      	ldr	r3, [pc, #152]	; (8005bcc <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b32:	781b      	ldrb	r3, [r3, #0]
 8005b34:	f003 0307 	and.w	r3, r3, #7
 8005b38:	2b04      	cmp	r3, #4
 8005b3a:	d803      	bhi.n	8005b44 <MIOS32_MIDI_SYSEX_Parser+0x40>
 8005b3c:	4925      	ldr	r1, [pc, #148]	; (8005bd4 <MIOS32_MIDI_SYSEX_Parser+0xd0>)
 8005b3e:	5cc9      	ldrb	r1, [r1, r3]
 8005b40:	4291      	cmp	r1, r2
 8005b42:	d123      	bne.n	8005b8c <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005b44:	f004 0407 	and.w	r4, r4, #7
 8005b48:	2c05      	cmp	r4, #5
 8005b4a:	d103      	bne.n	8005b54 <MIOS32_MIDI_SYSEX_Parser+0x50>
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
 8005b4c:	4922      	ldr	r1, [pc, #136]	; (8005bd8 <MIOS32_MIDI_SYSEX_Parser+0xd4>)
 8005b4e:	7809      	ldrb	r1, [r1, #0]
 8005b50:	4291      	cmp	r1, r2
 8005b52:	d11b      	bne.n	8005b8c <MIOS32_MIDI_SYSEX_Parser+0x88>
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005b54:	3301      	adds	r3, #1
 8005b56:	f003 0207 	and.w	r2, r3, #7
 8005b5a:	4b1c      	ldr	r3, [pc, #112]	; (8005bcc <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b5c:	2a05      	cmp	r2, #5
 8005b5e:	7819      	ldrb	r1, [r3, #0]
 8005b60:	f362 0102 	bfi	r1, r2, #0, #3
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005b64:	bf84      	itt	hi
 8005b66:	b2ca      	uxtbhi	r2, r1
 8005b68:	f042 0208 	orrhi.w	r2, r2, #8
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005b6c:	7019      	strb	r1, [r3, #0]
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005b6e:	bf88      	it	hi
 8005b70:	701a      	strbhi	r2, [r3, #0]
 8005b72:	e028      	b.n	8005bc6 <MIOS32_MIDI_SYSEX_Parser+0xc2>
      }
    }
  } else {
    // check for end of SysEx message or invalid status byte
    if( midi_in >= 0x80 ) {
 8005b74:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005b78:	d00e      	beq.n	8005b98 <MIOS32_MIDI_SYSEX_Parser+0x94>
      if( midi_in == 0xf7 && sysex_state.CMD ) {
 8005b7a:	2af7      	cmp	r2, #247	; 0xf7
 8005b7c:	d106      	bne.n	8005b8c <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005b7e:	f004 0410 	and.w	r4, r4, #16
 8005b82:	b2e4      	uxtb	r4, r4
 8005b84:	b114      	cbz	r4, 8005b8c <MIOS32_MIDI_SYSEX_Parser+0x88>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
 8005b86:	2102      	movs	r1, #2
 8005b88:	f7ff fee6 	bl	8005958 <MIOS32_MIDI_SYSEX_Cmd>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005b8c:	4b0f      	ldr	r3, [pc, #60]	; (8005bcc <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b8e:	2000      	movs	r0, #0
 8005b90:	7018      	strb	r0, [r3, #0]
  sysex_cmd = 0;
 8005b92:	4b12      	ldr	r3, [pc, #72]	; (8005bdc <MIOS32_MIDI_SYSEX_Parser+0xd8>)
 8005b94:	7018      	strb	r0, [r3, #0]
 8005b96:	e017      	b.n	8005bc8 <MIOS32_MIDI_SYSEX_Parser+0xc4>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
      }
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
 8005b98:	f004 0410 	and.w	r4, r4, #16
 8005b9c:	b2e4      	uxtb	r4, r4
 8005b9e:	b95c      	cbnz	r4, 8005bb8 <MIOS32_MIDI_SYSEX_Parser+0xb4>
	sysex_state.CMD = 1;
 8005ba0:	4b0a      	ldr	r3, [pc, #40]	; (8005bcc <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005ba2:	7819      	ldrb	r1, [r3, #0]
 8005ba4:	f041 0110 	orr.w	r1, r1, #16
 8005ba8:	7019      	strb	r1, [r3, #0]
	sysex_cmd = midi_in;
 8005baa:	4b0c      	ldr	r3, [pc, #48]	; (8005bdc <MIOS32_MIDI_SYSEX_Parser+0xd8>)
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005bac:	4621      	mov	r1, r4
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
 8005bae:	701a      	strb	r2, [r3, #0]
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005bb0:	f7ff fed2 	bl	8005958 <MIOS32_MIDI_SYSEX_Cmd>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005bb4:	4620      	mov	r0, r4
 8005bb6:	e007      	b.n	8005bc8 <MIOS32_MIDI_SYSEX_Parser+0xc4>
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
      }
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
 8005bb8:	2101      	movs	r1, #1
 8005bba:	f7ff fecd 	bl	8005958 <MIOS32_MIDI_SYSEX_Cmd>
 8005bbe:	e002      	b.n	8005bc6 <MIOS32_MIDI_SYSEX_Parser+0xc2>
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
    return -1;
 8005bc0:	f04f 30ff 	mov.w	r0, #4294967295
 8005bc4:	e000      	b.n	8005bc8 <MIOS32_MIDI_SYSEX_Parser+0xc4>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005bc6:	2000      	movs	r0, #0
}
 8005bc8:	bd10      	pop	{r4, pc}
 8005bca:	bf00      	nop
 8005bcc:	20000174 	.word	0x20000174
 8005bd0:	2000016c 	.word	0x2000016c
 8005bd4:	0800a28c 	.word	0x0800a28c
 8005bd8:	2000016d 	.word	0x2000016d
 8005bdc:	20000164 	.word	0x20000164

08005be0 <MIOS32_MIDI_TimeOut>:

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005be0:	b510      	push	{r4, lr}
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005be2:	4a0d      	ldr	r2, [pc, #52]	; (8005c18 <MIOS32_MIDI_TimeOut+0x38>)

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005be4:	4604      	mov	r4, r0
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005be6:	7813      	ldrb	r3, [r2, #0]
 8005be8:	f003 0308 	and.w	r3, r3, #8
 8005bec:	b2db      	uxtb	r3, r3
 8005bee:	b13b      	cbz	r3, 8005c00 <MIOS32_MIDI_TimeOut+0x20>
 8005bf0:	4b0a      	ldr	r3, [pc, #40]	; (8005c1c <MIOS32_MIDI_TimeOut+0x3c>)
 8005bf2:	781b      	ldrb	r3, [r3, #0]
 8005bf4:	4283      	cmp	r3, r0
 8005bf6:	d103      	bne.n	8005c00 <MIOS32_MIDI_TimeOut+0x20>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005bf8:	2300      	movs	r3, #0
 8005bfa:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005bfc:	4a08      	ldr	r2, [pc, #32]	; (8005c20 <MIOS32_MIDI_TimeOut+0x40>)
 8005bfe:	7013      	strb	r3, [r2, #0]
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
    MIOS32_MIDI_SYSEX_CmdFinished();

  // optional hook to application
  if( timeout_callback_func != NULL )
 8005c00:	4b08      	ldr	r3, [pc, #32]	; (8005c24 <MIOS32_MIDI_TimeOut+0x44>)
 8005c02:	681b      	ldr	r3, [r3, #0]
 8005c04:	b10b      	cbz	r3, 8005c0a <MIOS32_MIDI_TimeOut+0x2a>
    timeout_callback_func(port);
 8005c06:	4620      	mov	r0, r4
 8005c08:	4798      	blx	r3

#if 1
  // this debug message should always be active, so that common users are informed about the exception
  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_Receive_Handler] Timeout on port 0x%02x\n", port);
 8005c0a:	4621      	mov	r1, r4
 8005c0c:	4806      	ldr	r0, [pc, #24]	; (8005c28 <MIOS32_MIDI_TimeOut+0x48>)
 8005c0e:	f7ff fe51 	bl	80058b4 <MIOS32_MIDI_SendDebugMessage>
#endif

  return 0; // no error
}
 8005c12:	2000      	movs	r0, #0
 8005c14:	bd10      	pop	{r4, pc}
 8005c16:	bf00      	nop
 8005c18:	20000174 	.word	0x20000174
 8005c1c:	2000016c 	.word	0x2000016c
 8005c20:	20000164 	.word	0x20000164
 8005c24:	20000188 	.word	0x20000188
 8005c28:	0800a23c 	.word	0x0800a23c

08005c2c <MIOS32_MIDI_Receive_Handler>:
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c2c:	b5f0      	push	{r4, r5, r6, r7, lr}

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005c2e:	2200      	movs	r2, #0
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c30:	b089      	sub	sp, #36	; 0x24
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005c32:	2101      	movs	r1, #1
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c34:	4605      	mov	r5, r0
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005c36:	9104      	str	r1, [sp, #16]

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005c38:	9201      	str	r2, [sp, #4]
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
 8005c3a:	9203      	str	r2, [sp, #12]
  u8 port;
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
 8005c3c:	4613      	mov	r3, r2
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005c3e:	4fc5      	ldr	r7, [pc, #788]	; (8005f54 <MIOS32_MIDI_Receive_Handler+0x328>)
 8005c40:	e000      	b.n	8005c44 <MIOS32_MIDI_Receive_Handler+0x18>

      MIOS32_MIDI_TimeOut(timeout_port);
      sysex_timeout_ctr_flags.ALL = 0;
      again = 0;
    }
  } while( again );
 8005c42:	9b05      	ldr	r3, [sp, #20]
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8005c44:	1c5a      	adds	r2, r3, #1
 8005c46:	b2d2      	uxtb	r2, r2
 8005c48:	9205      	str	r2, [sp, #20]
 8005c4a:	2b0b      	cmp	r3, #11
 8005c4c:	d851      	bhi.n	8005cf2 <MIOS32_MIDI_Receive_Handler+0xc6>
 8005c4e:	e8df f003 	tbb	[pc, r3]
 8005c52:	0e06      	.short	0x0e06
 8005c54:	26201a14 	.word	0x26201a14
 8005c58:	3e38322c 	.word	0x3e38322c
 8005c5c:	4a44      	.short	0x4a44
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      case 0: status = MIOS32_USB_MIDI_PackageReceive(&package); port = USB0 + package.cable; break;
 8005c5e:	a807      	add	r0, sp, #28
 8005c60:	f001 ffb2 	bl	8007bc8 <MIOS32_USB_MIDI_PackageReceive>
 8005c64:	9c07      	ldr	r4, [sp, #28]
 8005c66:	f3c4 1403 	ubfx	r4, r4, #4, #4
 8005c6a:	3410      	adds	r4, #16
 8005c6c:	e052      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 0: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART0_ASSIGNMENT == 1
      case 1: status = MIOS32_UART_MIDI_PackageReceive(0, &package); port = UART0; break;
 8005c6e:	2000      	movs	r0, #0
 8005c70:	a907      	add	r1, sp, #28
 8005c72:	f000 fae3 	bl	800623c <MIOS32_UART_MIDI_PackageReceive>
 8005c76:	2420      	movs	r4, #32
 8005c78:	e04c      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 1: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART1_ASSIGNMENT == 1
      case 2: status = MIOS32_UART_MIDI_PackageReceive(1, &package); port = UART1; break;
 8005c7a:	2001      	movs	r0, #1
 8005c7c:	a907      	add	r1, sp, #28
 8005c7e:	f000 fadd 	bl	800623c <MIOS32_UART_MIDI_PackageReceive>
 8005c82:	2421      	movs	r4, #33	; 0x21
 8005c84:	e046      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 2: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART2_ASSIGNMENT == 1
      case 3: status = MIOS32_UART_MIDI_PackageReceive(2, &package); port = UART2; break;
 8005c86:	2002      	movs	r0, #2
 8005c88:	a907      	add	r1, sp, #28
 8005c8a:	f000 fad7 	bl	800623c <MIOS32_UART_MIDI_PackageReceive>
 8005c8e:	2422      	movs	r4, #34	; 0x22
 8005c90:	e040      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 3: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 4: status = MIOS32_IIC_MIDI_PackageReceive(0, &package); port = IIC0; break;
 8005c92:	2000      	movs	r0, #0
 8005c94:	a907      	add	r1, sp, #28
 8005c96:	f000 fbb1 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005c9a:	2430      	movs	r4, #48	; 0x30
 8005c9c:	e03a      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 4: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 5: status = MIOS32_IIC_MIDI_PackageReceive(1, &package); port = IIC1; break;
 8005c9e:	2001      	movs	r0, #1
 8005ca0:	a907      	add	r1, sp, #28
 8005ca2:	f000 fbab 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005ca6:	2431      	movs	r4, #49	; 0x31
 8005ca8:	e034      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 5: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 6: status = MIOS32_IIC_MIDI_PackageReceive(2, &package); port = IIC2; break;
 8005caa:	2002      	movs	r0, #2
 8005cac:	a907      	add	r1, sp, #28
 8005cae:	f000 fba5 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005cb2:	2432      	movs	r4, #50	; 0x32
 8005cb4:	e02e      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 6: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 7: status = MIOS32_IIC_MIDI_PackageReceive(3, &package); port = IIC3; break;
 8005cb6:	2003      	movs	r0, #3
 8005cb8:	a907      	add	r1, sp, #28
 8005cba:	f000 fb9f 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005cbe:	2433      	movs	r4, #51	; 0x33
 8005cc0:	e028      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 7: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 8: status = MIOS32_IIC_MIDI_PackageReceive(4, &package); port = IIC4; break;
 8005cc2:	2004      	movs	r0, #4
 8005cc4:	a907      	add	r1, sp, #28
 8005cc6:	f000 fb99 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005cca:	2434      	movs	r4, #52	; 0x34
 8005ccc:	e022      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 8: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 9: status = MIOS32_IIC_MIDI_PackageReceive(5, &package); port = IIC5; break;
 8005cce:	2005      	movs	r0, #5
 8005cd0:	a907      	add	r1, sp, #28
 8005cd2:	f000 fb93 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005cd6:	2435      	movs	r4, #53	; 0x35
 8005cd8:	e01c      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 9: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 10: status = MIOS32_IIC_MIDI_PackageReceive(6, &package); port = IIC6; break;
 8005cda:	2006      	movs	r0, #6
 8005cdc:	a907      	add	r1, sp, #28
 8005cde:	f000 fb8d 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005ce2:	2436      	movs	r4, #54	; 0x36
 8005ce4:	e016      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 10: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 11: status = MIOS32_IIC_MIDI_PackageReceive(7, &package); port = IIC7; break;
 8005ce6:	2007      	movs	r0, #7
 8005ce8:	a907      	add	r1, sp, #28
 8005cea:	f000 fb87 	bl	80063fc <MIOS32_IIC_MIDI_PackageReceive>
 8005cee:	2437      	movs	r4, #55	; 0x37
 8005cf0:	e010      	b.n	8005d14 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
 8005cf2:	9a01      	ldr	r2, [sp, #4]
 8005cf4:	9903      	ldr	r1, [sp, #12]
 8005cf6:	1e13      	subs	r3, r2, #0
 8005cf8:	bf18      	it	ne
 8005cfa:	2301      	movne	r3, #1
 8005cfc:	2909      	cmp	r1, #9
 8005cfe:	bf8c      	ite	hi
 8005d00:	2300      	movhi	r3, #0
 8005d02:	f003 0301 	andls.w	r3, r3, #1
 8005d06:	2b00      	cmp	r3, #0
 8005d08:	f000 811f 	beq.w	8005f4a <MIOS32_MIDI_Receive_Handler+0x31e>
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
 8005d0c:	2200      	movs	r2, #0
 8005d0e:	9201      	str	r2, [sp, #4]
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
 8005d10:	9205      	str	r2, [sp, #20]
 8005d12:	e0e8      	b.n	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
	}
	status = -1; // empty round - no message
    }

    // timeout detected by interface?
    if( status == -10 ) {
 8005d14:	f110 0f0a 	cmn.w	r0, #10
 8005d18:	d104      	bne.n	8005d24 <MIOS32_MIDI_Receive_Handler+0xf8>
      MIOS32_MIDI_TimeOut(port);
 8005d1a:	4620      	mov	r0, r4
 8005d1c:	f7ff ff60 	bl	8005be0 <MIOS32_MIDI_TimeOut>
      again = 0;
 8005d20:	2300      	movs	r3, #0
 8005d22:	e112      	b.n	8005f4a <MIOS32_MIDI_Receive_Handler+0x31e>
    } else if( status >= 0 ) { // message received?
 8005d24:	2800      	cmp	r0, #0
 8005d26:	f2c0 80de 	blt.w	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d2a:	9901      	ldr	r1, [sp, #4]
      ++total_packages_forwarded;
 8005d2c:	9a03      	ldr	r2, [sp, #12]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d2e:	1c4b      	adds	r3, r1, #1
 8005d30:	b2db      	uxtb	r3, r3
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d32:	9907      	ldr	r1, [sp, #28]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d34:	9301      	str	r3, [sp, #4]
      ++total_packages_forwarded;
 8005d36:	1c53      	adds	r3, r2, #1
 8005d38:	b2db      	uxtb	r3, r3

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d3a:	f36f 1107 	bfc	r1, #4, #4
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;
 8005d3e:	9303      	str	r3, [sp, #12]

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005d40:	f001 030f 	and.w	r3, r1, #15
 8005d44:	f103 0208 	add.w	r2, r3, #8
 8005d48:	f002 020f 	and.w	r2, r2, #15
 8005d4c:	2a06      	cmp	r2, #6
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d4e:	9107      	str	r1, [sp, #28]

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005d50:	d804      	bhi.n	8005d5c <MIOS32_MIDI_Receive_Handler+0x130>
	if( callback_package != NULL )
	  callback_package(port, package);
 8005d52:	4620      	mov	r0, r4
      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
 8005d54:	2d00      	cmp	r5, #0
 8005d56:	f040 80c5 	bne.w	8005ee4 <MIOS32_MIDI_Receive_Handler+0x2b8>
 8005d5a:	e0c4      	b.n	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;

	switch( package.type ) {
 8005d5c:	1e9a      	subs	r2, r3, #2
 8005d5e:	2a0d      	cmp	r2, #13
 8005d60:	f200 80c1 	bhi.w	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005d64:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005d68:	00710071 	.word	0x00710071
 8005d6c:	006d000e 	.word	0x006d000e
 8005d70:	00740074 	.word	0x00740074
 8005d74:	00bf00bf 	.word	0x00bf00bf
 8005d78:	00bf00bf 	.word	0x00bf00bf
 8005d7c:	00bf00bf 	.word	0x00bf00bf
 8005d80:	000e00bf 	.word	0x000e00bf
	    break;

	  case 0x4: // SysEx starts or continues (3 bytes)
	  case 0xf: // Single byte is interpreted as SysEx as well (I noticed that portmidi sometimes sends single bytes!)

	    if( package.evnt0 >= 0xf8 ) { // relevant for package type 0xf
 8005d84:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005d88:	29f7      	cmp	r1, #247	; 0xf7
 8005d8a:	d85e      	bhi.n	8005e4a <MIOS32_MIDI_Receive_Handler+0x21e>
	      if( callback_package != NULL )
		callback_package(port, package); // -> realtime event is forwarded as event
	      break;
	    }

	    if( package.evnt0 == 0xf0 ) {
 8005d8c:	29f0      	cmp	r1, #240	; 0xf0
 8005d8e:	d11c      	bne.n	8005dca <MIOS32_MIDI_Receive_Handler+0x19e>
	      // cheap timeout mechanism - see comments above the sysex_timeout_ctr declaration
	      if( !sysex_timeout_ctr_flags.ALL ) {
 8005d90:	4a71      	ldr	r2, [pc, #452]	; (8005f58 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005d92:	6813      	ldr	r3, [r2, #0]
 8005d94:	b9cb      	cbnz	r3, 8005dca <MIOS32_MIDI_Receive_Handler+0x19e>
		switch( port & 0xf0 ) {
 8005d96:	f004 02f0 	and.w	r2, r4, #240	; 0xf0
 8005d9a:	2a10      	cmp	r2, #16
 8005d9c:	d002      	beq.n	8005da4 <MIOS32_MIDI_Receive_Handler+0x178>
 8005d9e:	2a30      	cmp	r2, #48	; 0x30
 8005da0:	d113      	bne.n	8005dca <MIOS32_MIDI_Receive_Handler+0x19e>
 8005da2:	e009      	b.n	8005db8 <MIOS32_MIDI_Receive_Handler+0x18c>
		  case USB0://..15
		    sysex_timeout_ctr = 0;
 8005da4:	4a6d      	ldr	r2, [pc, #436]	; (8005f5c <MIOS32_MIDI_Receive_Handler+0x330>)
 8005da6:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.usb_receives = (1 << (port & 0xf));
 8005da8:	2201      	movs	r2, #1
 8005daa:	f004 030f 	and.w	r3, r4, #15
 8005dae:	fa12 f303 	lsls.w	r3, r2, r3
 8005db2:	4a69      	ldr	r2, [pc, #420]	; (8005f58 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005db4:	8013      	strh	r3, [r2, #0]
		    break;
 8005db6:	e008      	b.n	8005dca <MIOS32_MIDI_Receive_Handler+0x19e>
		  case UART0://..15
		    // already done in MIOS32_UART_MIDI_PackageReceive()
		    break;
		  case IIC0://..15
		    sysex_timeout_ctr = 0;
 8005db8:	4a68      	ldr	r2, [pc, #416]	; (8005f5c <MIOS32_MIDI_Receive_Handler+0x330>)
 8005dba:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.iic_receives = (1 << (port & 0xf));
 8005dbc:	2201      	movs	r2, #1
 8005dbe:	f004 030f 	and.w	r3, r4, #15
 8005dc2:	fa12 f303 	lsls.w	r3, r2, r3
 8005dc6:	4a64      	ldr	r2, [pc, #400]	; (8005f58 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005dc8:	8053      	strh	r3, [r2, #2]
		    // no timeout protection for remaining interfaces (yet)
		}
	      }
	    }

	    MIOS32_MIDI_SYSEX_Parser(port, package.evnt0); // -> forward to MIOS32 SysEx Parser
 8005dca:	4620      	mov	r0, r4
 8005dcc:	f7ff fe9a 	bl	8005b04 <MIOS32_MIDI_SYSEX_Parser>
	    if( package.type != 0x0f ) {
 8005dd0:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8005dd4:	f003 030f 	and.w	r3, r3, #15
 8005dd8:	2b0f      	cmp	r3, #15
 8005dda:	d009      	beq.n	8005df0 <MIOS32_MIDI_Receive_Handler+0x1c4>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
 8005ddc:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005de0:	4620      	mov	r0, r4
 8005de2:	f7ff fe8f 	bl	8005b04 <MIOS32_MIDI_SYSEX_Parser>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
 8005de6:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005dea:	4620      	mov	r0, r4
 8005dec:	f7ff fe8a 	bl	8005b04 <MIOS32_MIDI_SYSEX_Parser>
	    }

	    if( sysex_callback_func != NULL ) {
 8005df0:	683e      	ldr	r6, [r7, #0]
 8005df2:	b1de      	cbz	r6, 8005e2c <MIOS32_MIDI_Receive_Handler+0x200>
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005df4:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005df8:	4620      	mov	r0, r4
 8005dfa:	47b0      	blx	r6
	      if( package.type != 0x0f ) {
 8005dfc:	f89d 301c 	ldrb.w	r3, [sp, #28]
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005e00:	b2c6      	uxtb	r6, r0
	      if( package.type != 0x0f ) {
 8005e02:	f003 030f 	and.w	r3, r3, #15
 8005e06:	2b0f      	cmp	r3, #15
 8005e08:	d010      	beq.n	8005e2c <MIOS32_MIDI_Receive_Handler+0x200>
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005e0a:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005e0e:	683b      	ldr	r3, [r7, #0]
 8005e10:	4620      	mov	r0, r4
 8005e12:	4798      	blx	r3
 8005e14:	4602      	mov	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005e16:	683b      	ldr	r3, [r7, #0]
 8005e18:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005e1c:	9200      	str	r2, [sp, #0]
 8005e1e:	4620      	mov	r0, r4
 8005e20:	4798      	blx	r3
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
	      if( package.type != 0x0f ) {
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005e22:	9a00      	ldr	r2, [sp, #0]
 8005e24:	4302      	orrs	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005e26:	ea42 0606 	orr.w	r6, r2, r6
 8005e2a:	b2f6      	uxtb	r6, r6
	      }
	    }

	    if( callback_package != NULL && !filter_sysex )
 8005e2c:	1e2b      	subs	r3, r5, #0
 8005e2e:	bf18      	it	ne
 8005e30:	2301      	movne	r3, #1
 8005e32:	2e00      	cmp	r6, #0
 8005e34:	bf14      	ite	ne
 8005e36:	2600      	movne	r6, #0
 8005e38:	f003 0601 	andeq.w	r6, r3, #1
 8005e3c:	2e00      	cmp	r6, #0
 8005e3e:	d052      	beq.n	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005e40:	e04e      	b.n	8005ee0 <MIOS32_MIDI_Receive_Handler+0x2b4>
	      callback_package(port, package);

	    break;

	  case 0x5:   // Single-byte System Common Message or SysEx ends with following single byte. 
	    if( package.evnt0 >= 0xf8 ) {
 8005e42:	f89d 201d 	ldrb.w	r2, [sp, #29]
 8005e46:	2af7      	cmp	r2, #247	; 0xf7
 8005e48:	d902      	bls.n	8005e50 <MIOS32_MIDI_Receive_Handler+0x224>
	      if( callback_package != NULL )
 8005e4a:	2d00      	cmp	r5, #0
 8005e4c:	d148      	bne.n	8005ee0 <MIOS32_MIDI_Receive_Handler+0x2b4>
 8005e4e:	e04a      	b.n	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
	    }
	    // no >= 0xf8 event: continue!

	  case 0x6:   // SysEx ends with following two bytes.
	  case 0x7: { // SysEx ends with following three bytes.
	    u8 num_bytes = package.type - 0x5 + 1;
 8005e50:	3b04      	subs	r3, #4
 8005e52:	b2db      	uxtb	r3, r3
 8005e54:	9302      	str	r3, [sp, #8]
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
 8005e56:	2b00      	cmp	r3, #0
 8005e58:	d079      	beq.n	8005f4e <MIOS32_MIDI_Receive_Handler+0x322>
	      current_byte = package.evnt0;
 8005e5a:	f89d 601d 	ldrb.w	r6, [sp, #29]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005e5e:	4620      	mov	r0, r4
 8005e60:	4631      	mov	r1, r6
 8005e62:	f7ff fe4f 	bl	8005b04 <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005e66:	683b      	ldr	r3, [r7, #0]
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005e68:	461a      	mov	r2, r3
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005e6a:	b11b      	cbz	r3, 8005e74 <MIOS32_MIDI_Receive_Handler+0x248>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005e6c:	4620      	mov	r0, r4
 8005e6e:	4631      	mov	r1, r6
 8005e70:	4798      	blx	r3
 8005e72:	b2c2      	uxtb	r2, r0
	    }

	    if( num_bytes >= 2 ) {
 8005e74:	9b02      	ldr	r3, [sp, #8]
 8005e76:	2b01      	cmp	r3, #1
 8005e78:	d024      	beq.n	8005ec4 <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt1;
 8005e7a:	f89d 601e 	ldrb.w	r6, [sp, #30]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005e7e:	4620      	mov	r0, r4
 8005e80:	4631      	mov	r1, r6
 8005e82:	9200      	str	r2, [sp, #0]
 8005e84:	f7ff fe3e 	bl	8005b04 <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005e88:	683b      	ldr	r3, [r7, #0]
 8005e8a:	9a00      	ldr	r2, [sp, #0]
 8005e8c:	b133      	cbz	r3, 8005e9c <MIOS32_MIDI_Receive_Handler+0x270>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005e8e:	4620      	mov	r0, r4
 8005e90:	4631      	mov	r1, r6
 8005e92:	4798      	blx	r3
 8005e94:	9a00      	ldr	r2, [sp, #0]
 8005e96:	ea40 0202 	orr.w	r2, r0, r2
 8005e9a:	b2d2      	uxtb	r2, r2
	    }

	    if( num_bytes >= 3 ) {
 8005e9c:	9902      	ldr	r1, [sp, #8]
 8005e9e:	2902      	cmp	r1, #2
 8005ea0:	d010      	beq.n	8005ec4 <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt2;
 8005ea2:	f89d 601f 	ldrb.w	r6, [sp, #31]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005ea6:	4620      	mov	r0, r4
 8005ea8:	4631      	mov	r1, r6
 8005eaa:	9200      	str	r2, [sp, #0]
 8005eac:	f7ff fe2a 	bl	8005b04 <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005eb0:	683b      	ldr	r3, [r7, #0]
 8005eb2:	9a00      	ldr	r2, [sp, #0]
 8005eb4:	b133      	cbz	r3, 8005ec4 <MIOS32_MIDI_Receive_Handler+0x298>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005eb6:	4620      	mov	r0, r4
 8005eb8:	4631      	mov	r1, r6
 8005eba:	4798      	blx	r3
 8005ebc:	9a00      	ldr	r2, [sp, #0]
 8005ebe:	ea40 0202 	orr.w	r2, r0, r2
 8005ec2:	b2d2      	uxtb	r2, r2
	    }

	    // reset timeout protection if required
	    if( current_byte == 0xf7 )
 8005ec4:	2ef7      	cmp	r6, #247	; 0xf7
 8005ec6:	d102      	bne.n	8005ece <MIOS32_MIDI_Receive_Handler+0x2a2>
	      sysex_timeout_ctr_flags.ALL = 0;
 8005ec8:	4b23      	ldr	r3, [pc, #140]	; (8005f58 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005eca:	2100      	movs	r1, #0
 8005ecc:	6019      	str	r1, [r3, #0]

	    // forward as package if not filtered
	    if( callback_package != NULL && !filter_sysex )
 8005ece:	1e2b      	subs	r3, r5, #0
 8005ed0:	bf18      	it	ne
 8005ed2:	2301      	movne	r3, #1
 8005ed4:	2a00      	cmp	r2, #0
 8005ed6:	bf14      	ite	ne
 8005ed8:	2300      	movne	r3, #0
 8005eda:	f003 0301 	andeq.w	r3, r3, #1
 8005ede:	b113      	cbz	r3, 8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
	      callback_package(port, package);
 8005ee0:	9907      	ldr	r1, [sp, #28]
 8005ee2:	4620      	mov	r0, r4
 8005ee4:	47a8      	blx	r5
	}	  
      }
    }

    // timeout detected by this handler?
    if( sysex_timeout_ctr_flags.ALL && sysex_timeout_ctr > 1000 ) {
 8005ee6:	4b1c      	ldr	r3, [pc, #112]	; (8005f58 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005ee8:	681a      	ldr	r2, [r3, #0]
 8005eea:	b33a      	cbz	r2, 8005f3c <MIOS32_MIDI_Receive_Handler+0x310>
 8005eec:	491b      	ldr	r1, [pc, #108]	; (8005f5c <MIOS32_MIDI_Receive_Handler+0x330>)
 8005eee:	880a      	ldrh	r2, [r1, #0]
 8005ef0:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 8005ef4:	d922      	bls.n	8005f3c <MIOS32_MIDI_Receive_Handler+0x310>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
 8005ef6:	8819      	ldrh	r1, [r3, #0]
 8005ef8:	b161      	cbz	r1, 8005f14 <MIOS32_MIDI_Receive_Handler+0x2e8>
 8005efa:	2200      	movs	r2, #0
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
 8005efc:	fa51 f302 	asrs.w	r3, r1, r2
 8005f00:	f013 0301 	ands.w	r3, r3, #1
 8005f04:	d103      	bne.n	8005f0e <MIOS32_MIDI_Receive_Handler+0x2e2>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005f06:	3201      	adds	r2, #1
 8005f08:	2a10      	cmp	r2, #16
 8005f0a:	d1f7      	bne.n	8005efc <MIOS32_MIDI_Receive_Handler+0x2d0>
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005f0c:	461a      	mov	r2, r3
	timeout_port = USB0 + i;
 8005f0e:	3210      	adds	r2, #16
 8005f10:	b2d0      	uxtb	r0, r2
 8005f12:	e00d      	b.n	8005f30 <MIOS32_MIDI_Receive_Handler+0x304>
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
 8005f14:	8858      	ldrh	r0, [r3, #2]
 8005f16:	b158      	cbz	r0, 8005f30 <MIOS32_MIDI_Receive_Handler+0x304>
 8005f18:	460b      	mov	r3, r1
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
 8005f1a:	fa50 f203 	asrs.w	r2, r0, r3
 8005f1e:	f012 0201 	ands.w	r2, r2, #1
 8005f22:	d103      	bne.n	8005f2c <MIOS32_MIDI_Receive_Handler+0x300>
	if( i >= 16 ) // failsafe
	  i = 0;
	timeout_port = USB0 + i;
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005f24:	3301      	adds	r3, #1
 8005f26:	2b10      	cmp	r3, #16
 8005f28:	d1f7      	bne.n	8005f1a <MIOS32_MIDI_Receive_Handler+0x2ee>
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005f2a:	4613      	mov	r3, r2
	timeout_port = IIC0 + i;
 8005f2c:	3330      	adds	r3, #48	; 0x30
 8005f2e:	b2d8      	uxtb	r0, r3
      }

      MIOS32_MIDI_TimeOut(timeout_port);
 8005f30:	f7ff fe56 	bl	8005be0 <MIOS32_MIDI_TimeOut>
      sysex_timeout_ctr_flags.ALL = 0;
 8005f34:	4b08      	ldr	r3, [pc, #32]	; (8005f58 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005f36:	2200      	movs	r2, #0
 8005f38:	601a      	str	r2, [r3, #0]
 8005f3a:	e003      	b.n	8005f44 <MIOS32_MIDI_Receive_Handler+0x318>
      again = 0;
    }
  } while( again );
 8005f3c:	9a04      	ldr	r2, [sp, #16]
 8005f3e:	2a00      	cmp	r2, #0
 8005f40:	f47f ae7f 	bne.w	8005c42 <MIOS32_MIDI_Receive_Handler+0x16>

  return 0;
}
 8005f44:	2000      	movs	r0, #0
 8005f46:	b009      	add	sp, #36	; 0x24
 8005f48:	bdf0      	pop	{r4, r5, r6, r7, pc}
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
	} else {
	  again = 0; // no more interfaces to be processed
 8005f4a:	9304      	str	r3, [sp, #16]
 8005f4c:	e7cb      	b.n	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2ba>
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005f4e:	9a02      	ldr	r2, [sp, #8]
 8005f50:	e7bd      	b.n	8005ece <MIOS32_MIDI_Receive_Handler+0x2a2>
 8005f52:	bf00      	nop
 8005f54:	20000184 	.word	0x20000184
 8005f58:	20000180 	.word	0x20000180
 8005f5c:	2000016e 	.word	0x2000016e

08005f60 <MIOS32_MIDI_Periodic_mS>:
//! by a task in the programming model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Periodic_mS(void)
{
 8005f60:	b510      	push	{r4, lr}
  s32 status = 0;

#ifndef MIOS32_DONT_USE_USB_MIDI
  status |= MIOS32_USB_MIDI_Periodic_mS();
 8005f62:	f001 fe5d 	bl	8007c20 <MIOS32_USB_MIDI_Periodic_mS>
 8005f66:	4604      	mov	r4, r0
#endif

#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
 8005f68:	f000 f8ca 	bl	8006100 <MIOS32_UART_MIDI_Periodic_mS>
 8005f6c:	ea40 0404 	orr.w	r4, r0, r4
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005f70:	f000 fa3f 	bl	80063f2 <MIOS32_IIC_MIDI_Periodic_mS>
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005f74:	4b05      	ldr	r3, [pc, #20]	; (8005f8c <MIOS32_MIDI_Periodic_mS+0x2c>)
 8005f76:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005f7a:	881a      	ldrh	r2, [r3, #0]
#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005f7c:	ea44 0000 	orr.w	r0, r4, r0
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005f80:	428a      	cmp	r2, r1
 8005f82:	d001      	beq.n	8005f88 <MIOS32_MIDI_Periodic_mS+0x28>
    ++sysex_timeout_ctr;
 8005f84:	3201      	adds	r2, #1
 8005f86:	801a      	strh	r2, [r3, #0]

  return status;
}
 8005f88:	bd10      	pop	{r4, pc}
 8005f8a:	bf00      	nop
 8005f8c:	2000016e 	.word	0x2000016e

08005f90 <MIOS32_MIDI_SendByteToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_byte received MIDI byte
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendByteToRxCallback(mios32_midi_port_t port, u8 midi_byte)
{
 8005f90:	b508      	push	{r3, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL )
 8005f92:	4b03      	ldr	r3, [pc, #12]	; (8005fa0 <MIOS32_MIDI_SendByteToRxCallback+0x10>)
 8005f94:	681b      	ldr	r3, [r3, #0]
 8005f96:	b10b      	cbz	r3, 8005f9c <MIOS32_MIDI_SendByteToRxCallback+0xc>
    return direct_rx_callback_func(port, midi_byte);
 8005f98:	4798      	blx	r3
 8005f9a:	e000      	b.n	8005f9e <MIOS32_MIDI_SendByteToRxCallback+0xe>
  return 0; // no error
 8005f9c:	4618      	mov	r0, r3
}
 8005f9e:	bd08      	pop	{r3, pc}
 8005fa0:	20000168 	.word	0x20000168

08005fa4 <MIOS32_MIDI_SendPackageToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005fa4:	b5f0      	push	{r4, r5, r6, r7, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005fa6:	4e13      	ldr	r6, [pc, #76]	; (8005ff4 <MIOS32_MIDI_SendPackageToRxCallback+0x50>)
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005fa8:	b085      	sub	sp, #20
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005faa:	6834      	ldr	r4, [r6, #0]
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005fac:	4607      	mov	r7, r0
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005fae:	b1ec      	cbz	r4, 8005fec <MIOS32_MIDI_SendPackageToRxCallback+0x48>
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005fb0:	f3c1 6307 	ubfx	r3, r1, #24, #8
 8005fb4:	f88d 300e 	strb.w	r3, [sp, #14]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005fb8:	4b0f      	ldr	r3, [pc, #60]	; (8005ff8 <MIOS32_MIDI_SendPackageToRxCallback+0x54>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005fba:	f3c1 4207 	ubfx	r2, r1, #16, #8
 8005fbe:	f3c1 2007 	ubfx	r0, r1, #8, #8
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
 8005fc2:	2400      	movs	r4, #0
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005fc4:	f001 010f 	and.w	r1, r1, #15
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005fc8:	f88d 200d 	strb.w	r2, [sp, #13]
 8005fcc:	f88d 000c 	strb.w	r0, [sp, #12]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005fd0:	5c5a      	ldrb	r2, [r3, r1]
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005fd2:	4625      	mov	r5, r4
 8005fd4:	e008      	b.n	8005fe8 <MIOS32_MIDI_SendPackageToRxCallback+0x44>
      status |= direct_rx_callback_func(port, buffer[i]);
 8005fd6:	ab03      	add	r3, sp, #12
 8005fd8:	5d59      	ldrb	r1, [r3, r5]
 8005fda:	4638      	mov	r0, r7
 8005fdc:	9201      	str	r2, [sp, #4]
 8005fde:	6833      	ldr	r3, [r6, #0]
 8005fe0:	4798      	blx	r3
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005fe2:	9a01      	ldr	r2, [sp, #4]
      status |= direct_rx_callback_func(port, buffer[i]);
 8005fe4:	4304      	orrs	r4, r0
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005fe6:	3501      	adds	r5, #1
 8005fe8:	4295      	cmp	r5, r2
 8005fea:	dbf4      	blt.n	8005fd6 <MIOS32_MIDI_SendPackageToRxCallback+0x32>
      status |= direct_rx_callback_func(port, buffer[i]);
    return status;
  }
  return 0; // no error
}
 8005fec:	4620      	mov	r0, r4
 8005fee:	b005      	add	sp, #20
 8005ff0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005ff2:	bf00      	nop
 8005ff4:	20000168 	.word	0x20000168
 8005ff8:	0800a160 	.word	0x0800a160

08005ffc <MIOS32_OSC_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_OSC_Init(u32 mode)
{
  if( mode > 0 )
    return -1; // only mode 0 supported yet
 8005ffc:	2800      	cmp	r0, #0
 8005ffe:	bf14      	ite	ne
 8006000:	f04f 30ff 	movne.w	r0, #4294967295
 8006004:	2000      	moveq	r0, #0

  return 0; // no error
}
 8006006:	4770      	bx	lr

08006008 <MIOS32_COM_Init>:
s32 MIOS32_COM_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 8006008:	b938      	cbnz	r0, 800601a <MIOS32_COM_Init+0x12>
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 800600a:	4b05      	ldr	r3, [pc, #20]	; (8006020 <MIOS32_COM_Init+0x18>)

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 800600c:	4a05      	ldr	r2, [pc, #20]	; (8006024 <MIOS32_COM_Init+0x1c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 800600e:	6018      	str	r0, [r3, #0]

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 8006010:	2310      	movs	r3, #16
 8006012:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_COM_DEBUG_PORT;
 8006014:	4a04      	ldr	r2, [pc, #16]	; (8006028 <MIOS32_COM_Init+0x20>)
 8006016:	7013      	strb	r3, [r2, #0]
#if MIOS32_UART0_ASSIGNMENT == 2 || MIOS32_UART1_ASSIGNMENT == 2 || MIOS32_UART2_ASSIGNMENT == 2 || MIOS32_UART3_ASSIGNMENT == 2
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
 8006018:	e001      	b.n	800601e <MIOS32_COM_Init+0x16>
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800601a:	f04f 30ff 	mov.w	r0, #4294967295
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
}
 800601e:	4770      	bx	lr
 8006020:	2000018c 	.word	0x2000018c
 8006024:	20000007 	.word	0x20000007
 8006028:	20000008 	.word	0x20000008

0800602c <MIOS32_COM_SendBuffer>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 800602c:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] len buffer length
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
 8006030:	b508      	push	{r3, lr}
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8006032:	d104      	bne.n	800603e <MIOS32_COM_SendBuffer+0x12>
    port = (port == COM_DEBUG) ? debug_port : default_port;
 8006034:	2801      	cmp	r0, #1
 8006036:	bf0c      	ite	eq
 8006038:	4b06      	ldreq	r3, [pc, #24]	; (8006054 <MIOS32_COM_SendBuffer+0x28>)
 800603a:	4b07      	ldrne	r3, [pc, #28]	; (8006058 <MIOS32_COM_SendBuffer+0x2c>)
 800603c:	7818      	ldrb	r0, [r3, #0]
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 800603e:	0903      	lsrs	r3, r0, #4
 8006040:	2b02      	cmp	r3, #2
    case 1:
#if !defined(MIOS32_DONT_USE_USB) && defined(MIOS32_USE_USB_COM)
      return MIOS32_USB_COM_TxBufferPutMore(port & 0xf, buffer, len);
#else
      return -1; // USB has been disabled
 8006042:	bf18      	it	ne
 8006044:	f04f 30ff 	movne.w	r0, #4294967295
  if( !(port & 0xf0) ) {
    port = (port == COM_DEBUG) ? debug_port : default_port;
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 8006048:	d103      	bne.n	8006052 <MIOS32_COM_SendBuffer+0x26>
      return -1; // USB has been disabled
#endif

    case 2:
#if !defined(MIOS32_DONT_USE_UART)
      return MIOS32_UART_TxBufferPutMore(port & 0xf, buffer, len);
 800604a:	f000 000f 	and.w	r0, r0, #15
 800604e:	f001 ffc5 	bl	8007fdc <MIOS32_UART_TxBufferPutMore>
      
    default:
      // invalid port
      return -1;
  }
}
 8006052:	bd08      	pop	{r3, pc}
 8006054:	20000008 	.word	0x20000008
 8006058:	20000007 	.word	0x20000007

0800605c <MIOS32_COM_SendChar>:
//! \param[in] c character
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendChar(mios32_com_port_t port, char c)
{
 800605c:	b507      	push	{r0, r1, r2, lr}
 800605e:	ab02      	add	r3, sp, #8
 8006060:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return MIOS32_COM_SendBuffer(port, (u8 *)&c, 1);
 8006064:	4619      	mov	r1, r3
 8006066:	2201      	movs	r2, #1
 8006068:	f7ff ffe0 	bl	800602c <MIOS32_COM_SendBuffer>
}
 800606c:	bd0e      	pop	{r1, r2, r3, pc}

0800606e <MIOS32_COM_Receive_Handler>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_Receive_Handler(void)
{
  u8 port = DEFAULT;

  u8 intf = 0; // interface to be checked
 800606e:	2300      	movs	r3, #0
 8006070:	e000      	b.n	8006074 <MIOS32_COM_Receive_Handler+0x6>
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8006072:	4613      	mov	r3, r2
 8006074:	1c5a      	adds	r2, r3, #1
 8006076:	2b04      	cmp	r3, #4
 8006078:	b2d2      	uxtb	r2, r2
 800607a:	d9fa      	bls.n	8006072 <MIOS32_COM_Receive_Handler+0x4>
	receive_callback_func(port, (u8)status);
    }
  } while( again );

  return 0;
}
 800607c:	2000      	movs	r0, #0
 800607e:	4770      	bx	lr

08006080 <MIOS32_UART_MIDI_RS_Reset>:
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 8006080:	2801      	cmp	r0, #1
//! \return -1 if port not available
//! \return < 0 on errors
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
 8006082:	b510      	push	{r4, lr}
 8006084:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
    return -1; // port not available
 8006086:	bf88      	it	hi
 8006088:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 800608c:	d80b      	bhi.n	80060a6 <MIOS32_UART_MIDI_RS_Reset+0x26>
    return -1; // port not available

  MIOS32_IRQ_Disable();
 800608e:	f000 fae9 	bl	8006664 <MIOS32_IRQ_Disable>
  rs_last[uart_port] = 0xff;
 8006092:	4b05      	ldr	r3, [pc, #20]	; (80060a8 <MIOS32_UART_MIDI_RS_Reset+0x28>)
 8006094:	22ff      	movs	r2, #255	; 0xff
 8006096:	551a      	strb	r2, [r3, r4]
  rs_expire_ctr[uart_port] = 0;
 8006098:	4b04      	ldr	r3, [pc, #16]	; (80060ac <MIOS32_UART_MIDI_RS_Reset+0x2c>)
 800609a:	2200      	movs	r2, #0
 800609c:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
  MIOS32_IRQ_Enable();
 80060a0:	f000 faf6 	bl	8006690 <MIOS32_IRQ_Enable>

  return 0;
 80060a4:	2000      	movs	r0, #0
#endif
}
 80060a6:	bd10      	pop	{r4, pc}
 80060a8:	20000190 	.word	0x20000190
 80060ac:	200001b0 	.word	0x200001b0

080060b0 <MIOS32_UART_MIDI_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Init(u32 mode)
{
 80060b0:	b510      	push	{r4, lr}
 80060b2:	4604      	mov	r4, r0
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80060b4:	f04f 30ff 	mov.w	r0, #4294967295
#else
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
 80060b8:	b9ec      	cbnz	r4, 80060f6 <MIOS32_UART_MIDI_Init+0x46>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80060ba:	4b0f      	ldr	r3, [pc, #60]	; (80060f8 <MIOS32_UART_MIDI_Init+0x48>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060bc:	22ff      	movs	r2, #255	; 0xff
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80060be:	601c      	str	r4, [r3, #0]
  midix->running_status = 0x00;
 80060c0:	711c      	strb	r4, [r3, #4]
  midix->expected_bytes = 0x00;
 80060c2:	715c      	strb	r4, [r3, #5]
  midix->wait_bytes = 0x00;
 80060c4:	719c      	strb	r4, [r3, #6]
  midix->sysex_ctr = 0x00;
 80060c6:	71dc      	strb	r4, [r3, #7]
  midix->timeout_ctr = 0;
 80060c8:	811c      	strh	r4, [r3, #8]
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80060ca:	60dc      	str	r4, [r3, #12]
  midix->running_status = 0x00;
 80060cc:	741c      	strb	r4, [r3, #16]
  midix->expected_bytes = 0x00;
 80060ce:	745c      	strb	r4, [r3, #17]
  midix->wait_bytes = 0x00;
 80060d0:	749c      	strb	r4, [r3, #18]
  midix->sysex_ctr = 0x00;
 80060d2:	74dc      	strb	r4, [r3, #19]
  midix->timeout_ctr = 0;
 80060d4:	829c      	strh	r4, [r3, #20]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060d6:	4b09      	ldr	r3, [pc, #36]	; (80060fc <MIOS32_UART_MIDI_Init+0x4c>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 80060d8:	4620      	mov	r0, r4
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060da:	701a      	strb	r2, [r3, #0]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 80060dc:	f7ff ffd0 	bl	8006080 <MIOS32_UART_MIDI_RS_Reset>
 80060e0:	2001      	movs	r0, #1
 80060e2:	f7ff ffcd 	bl	8006080 <MIOS32_UART_MIDI_RS_Reset>

  // if any MIDI assignment:
#if MIOS32_UART0_ASSIGNMENT == 1 || MIOS32_UART1_ASSIGNMENT == 1 || MIOS32_UART2_ASSIGNMENT == 1
  // initialize U(S)ART interface
  if( MIOS32_UART_Init(0) < 0 )
 80060e6:	4620      	mov	r0, r4
 80060e8:	f001 fde2 	bl	8007cb0 <MIOS32_UART_Init>
    return -1; // initialisation of U(S)ART Interface failed
 80060ec:	2800      	cmp	r0, #0
 80060ee:	bfb4      	ite	lt
 80060f0:	f04f 30ff 	movlt.w	r0, #4294967295
 80060f4:	2000      	movge	r0, #0
#endif

  return 0; // no error
#endif
}
 80060f6:	bd10      	pop	{r4, pc}
 80060f8:	20000194 	.word	0x20000194
 80060fc:	200001ac 	.word	0x200001ac

08006100 <MIOS32_UART_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Periodic_mS(void)
{
 8006100:	b508      	push	{r3, lr}
#if MIOS32_UART_NUM
  u8 uart_port;

  MIOS32_IRQ_Disable();
 8006102:	f000 faaf 	bl	8006664 <MIOS32_IRQ_Disable>
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 8006106:	4b12      	ldr	r3, [pc, #72]	; (8006150 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 8006108:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800610c:	881a      	ldrh	r2, [r3, #0]
 800610e:	428a      	cmp	r2, r1
 8006110:	d001      	beq.n	8006116 <MIOS32_UART_MIDI_Periodic_mS+0x16>
      ++rs_expire_ctr[uart_port];
 8006112:	3201      	adds	r2, #1
 8006114:	801a      	strh	r2, [r3, #0]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 8006116:	4b0f      	ldr	r3, [pc, #60]	; (8006154 <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 8006118:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800611c:	891a      	ldrh	r2, [r3, #8]
 800611e:	428a      	cmp	r2, r1
 8006120:	d001      	beq.n	8006126 <MIOS32_UART_MIDI_Periodic_mS+0x26>
      ++midi_rec[uart_port].timeout_ctr;
 8006122:	3201      	adds	r2, #1
 8006124:	811a      	strh	r2, [r3, #8]
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 8006126:	4b0a      	ldr	r3, [pc, #40]	; (8006150 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 8006128:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800612c:	885a      	ldrh	r2, [r3, #2]
 800612e:	428a      	cmp	r2, r1
 8006130:	d001      	beq.n	8006136 <MIOS32_UART_MIDI_Periodic_mS+0x36>
      ++rs_expire_ctr[uart_port];
 8006132:	3201      	adds	r2, #1
 8006134:	805a      	strh	r2, [r3, #2]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 8006136:	4b07      	ldr	r3, [pc, #28]	; (8006154 <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 8006138:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800613c:	8a9a      	ldrh	r2, [r3, #20]
 800613e:	428a      	cmp	r2, r1
 8006140:	d001      	beq.n	8006146 <MIOS32_UART_MIDI_Periodic_mS+0x46>
      ++midi_rec[uart_port].timeout_ctr;
 8006142:	3201      	adds	r2, #1
 8006144:	829a      	strh	r2, [r3, #20]
  }
  MIOS32_IRQ_Enable();
 8006146:	f000 faa3 	bl	8006690 <MIOS32_IRQ_Enable>
  // (atomic operation not required in MIOS32_UART_MIDI_PackageSend_NonBlocking() due to single-byte accesses)
#endif

  return 0; // no error
}
 800614a:	2000      	movs	r0, #0
 800614c:	bd08      	pop	{r3, pc}
 800614e:	bf00      	nop
 8006150:	200001b0 	.word	0x200001b0
 8006154:	20000194 	.word	0x20000194

08006158 <MIOS32_UART_MIDI_PackageSend_NonBlocking>:
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 8006158:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 800615a:	2801      	cmp	r0, #1
 800615c:	f3c1 2607 	ubfx	r6, r1, #8, #8
 8006160:	f001 030f 	and.w	r3, r1, #15
 8006164:	f3c1 4207 	ubfx	r2, r1, #16, #8
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 8006168:	4604      	mov	r4, r0
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 800616a:	b2f7      	uxtb	r7, r6
 800616c:	f3c1 6107 	ubfx	r1, r1, #24, #8
 8006170:	d844      	bhi.n	80061fc <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa4>
 8006172:	e046      	b.n	8006202 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xaa>

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};

    if( rs_expire_ctr[uart_port] > 1000 ) {
 8006174:	4826      	ldr	r0, [pc, #152]	; (8006210 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xb8>)
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 8006176:	f88d 6004 	strb.w	r6, [sp, #4]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 800617a:	f830 c014 	ldrh.w	ip, [r0, r4, lsl #1]
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 800617e:	f88d 2005 	strb.w	r2, [sp, #5]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 8006182:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 8006186:	f88d 1006 	strb.w	r1, [sp, #6]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 800618a:	d903      	bls.n	8006194 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x3c>
      // the current RS is expired each second to ensure that a status byte will be sent
      // if the MIDI cable is (re)connected during runtime
      MIOS32_UART_MIDI_RS_Reset(uart_port);
 800618c:	4620      	mov	r0, r4
 800618e:	f7ff ff77 	bl	8006080 <MIOS32_UART_MIDI_RS_Reset>
 8006192:	e022      	b.n	80061da <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
#if 0
      // for optional monitoring of the optimisation
      MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS 0x%02x expired!\n", uart_port);
#endif
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
 8006194:	f8df c07c 	ldr.w	ip, [pc, #124]	; 8006214 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xbc>
 8006198:	f89c c000 	ldrb.w	ip, [ip]
 800619c:	fa4c fc04 	asr.w	ip, ip, r4
 80061a0:	f01c 0f01 	tst.w	ip, #1
 80061a4:	d019      	beq.n	80061da <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
 80061a6:	2b07      	cmp	r3, #7
 80061a8:	dd17      	ble.n	80061da <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  package.cin >= NoteOff && package.cin <= PitchBend &&
 80061aa:	2b0e      	cmp	r3, #14
 80061ac:	bfcc      	ite	gt
 80061ae:	2300      	movgt	r3, #0
 80061b0:	2301      	movle	r3, #1
 80061b2:	2d01      	cmp	r5, #1
 80061b4:	bf94      	ite	ls
 80061b6:	2300      	movls	r3, #0
 80061b8:	f003 0301 	andhi.w	r3, r3, #1
 80061bc:	b16b      	cbz	r3, 80061da <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
 80061be:	4b16      	ldr	r3, [pc, #88]	; (8006218 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)
 80061c0:	5d1b      	ldrb	r3, [r3, r4]
 80061c2:	42bb      	cmp	r3, r7
 80061c4:	d106      	bne.n	80061d4 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x7c>
	  buffer[0] = package.evnt1;
	  buffer[1] = package.evnt2;
	  --len;
 80061c6:	3d01      	subs	r5, #1
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
	  package.cin >= NoteOff && package.cin <= PitchBend &&
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
	  buffer[0] = package.evnt1;
 80061c8:	f88d 2004 	strb.w	r2, [sp, #4]
	  buffer[1] = package.evnt2;
 80061cc:	f88d 1005 	strb.w	r1, [sp, #5]
	  --len;
 80061d0:	b2ed      	uxtb	r5, r5
 80061d2:	e002      	b.n	80061da <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  // for optional monitoring of the optimisation
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS optimized (%02x) %02x %02x\n", uart_port, package.evnt0, package.evnt1, package.evnt2);
#endif
	} else {
	  // new running status
	  rs_expire_ctr[uart_port] = 0;
 80061d4:	2300      	movs	r3, #0
 80061d6:	f820 3014 	strh.w	r3, [r0, r4, lsl #1]
      }
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
 80061da:	2ff7      	cmp	r7, #247	; 0xf7
      rs_last[uart_port] = package.evnt0;
 80061dc:	bf98      	it	ls
 80061de:	4b0e      	ldrls	r3, [pc, #56]	; (8006218 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80061e0:	4620      	mov	r0, r4
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;
 80061e2:	bf98      	it	ls
 80061e4:	551e      	strbls	r6, [r3, r4]


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80061e6:	a901      	add	r1, sp, #4
 80061e8:	462a      	mov	r2, r5
 80061ea:	f001 fef7 	bl	8007fdc <MIOS32_UART_TxBufferPutMore>
 80061ee:	3002      	adds	r0, #2
 80061f0:	2802      	cmp	r0, #2
 80061f2:	bf9c      	itt	ls
 80061f4:	4b09      	ldrls	r3, [pc, #36]	; (800621c <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc4>)
 80061f6:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
 80061fa:	d901      	bls.n	8006200 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 80061fc:	f04f 30ff 	mov.w	r0, #4294967295

  } else {
    return 0; // no bytes to send -> no error
  }
#endif
}
 8006200:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
 8006202:	4807      	ldr	r0, [pc, #28]	; (8006220 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc8>)
 8006204:	5cc5      	ldrb	r5, [r0, r3]
      case -2: return -2; // buffer full, request retry
      default: return -1; // UART error
    }

  } else {
    return 0; // no bytes to send -> no error
 8006206:	4628      	mov	r0, r5
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
 8006208:	2d00      	cmp	r5, #0
 800620a:	d1b3      	bne.n	8006174 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x1c>
 800620c:	e7f8      	b.n	8006200 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 800620e:	bf00      	nop
 8006210:	200001b0 	.word	0x200001b0
 8006214:	200001ac 	.word	0x200001ac
 8006218:	20000190 	.word	0x20000190
 800621c:	0800a294 	.word	0x0800a294
 8006220:	0800a160 	.word	0x0800a160

08006224 <MIOS32_UART_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: UART_MIDI device not available
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend(u8 uart_port, mios32_midi_package_t package)
{
 8006224:	b538      	push	{r3, r4, r5, lr}
 8006226:	4605      	mov	r5, r0
 8006228:	460c      	mov	r4, r1
  s32 error;

  while( (error=MIOS32_UART_MIDI_PackageSend_NonBlocking(uart_port, package)) == -2);
 800622a:	4628      	mov	r0, r5
 800622c:	4621      	mov	r1, r4
 800622e:	f7ff ff93 	bl	8006158 <MIOS32_UART_MIDI_PackageSend_NonBlocking>
 8006232:	f110 0f02 	cmn.w	r0, #2
 8006236:	d0f8      	beq.n	800622a <MIOS32_UART_MIDI_PackageSend+0x6>

  return error;
}
 8006238:	bd38      	pop	{r3, r4, r5, pc}
	...

0800623c <MIOS32_UART_MIDI_PackageReceive>:
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 800623c:	2801      	cmp	r0, #1
//! \return -1: no package in buffer
//! \return -10: incoming MIDI package timed out (incomplete package received)
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageReceive(u8 uart_port, mios32_midi_package_t *package)
{
 800623e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006240:	4604      	mov	r4, r0
 8006242:	460e      	mov	r6, r1
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled - accordingly no package in buffer
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;
 8006244:	bf88      	it	hi
 8006246:	f04f 30ff 	movhi.w	r0, #4294967295
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 800624a:	f200 80c5 	bhi.w	80063d8 <MIOS32_UART_MIDI_PackageReceive+0x19c>
 800624e:	e09e      	b.n	800638e <MIOS32_UART_MIDI_PackageReceive+0x152>
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
    u8 byte = (u8)status;
 8006250:	b2c0      	uxtb	r0, r0

    if( byte & 0x80 ) { // new MIDI status
 8006252:	f010 0f80 	tst.w	r0, #128	; 0x80
 8006256:	d048      	beq.n	80062ea <MIOS32_UART_MIDI_PackageReceive+0xae>
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
 8006258:	28f7      	cmp	r0, #247	; 0xf7
 800625a:	d908      	bls.n	800626e <MIOS32_UART_MIDI_PackageReceive+0x32>
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
 800625c:	6833      	ldr	r3, [r6, #0]
 800625e:	f043 030f 	orr.w	r3, r3, #15
 8006262:	6033      	str	r3, [r6, #0]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
 8006264:	2300      	movs	r3, #0
    if( byte & 0x80 ) { // new MIDI status
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
	package->evnt0 = byte;
 8006266:	7070      	strb	r0, [r6, #1]
	package->evnt1 = 0x00;
 8006268:	70b3      	strb	r3, [r6, #2]
	package->evnt2 = 0x00;
 800626a:	70f3      	strb	r3, [r6, #3]
 800626c:	e0b5      	b.n	80063da <MIOS32_UART_MIDI_PackageReceive+0x19e>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 800626e:	f3c0 1302 	ubfx	r3, r0, #4, #3
 8006272:	5cfb      	ldrb	r3, [r7, r3]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
 8006274:	7128      	strb	r0, [r5, #4]
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 8006276:	716b      	strb	r3, [r5, #5]

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 8006278:	2b00      	cmp	r3, #0
 800627a:	d12e      	bne.n	80062da <MIOS32_UART_MIDI_PackageReceive+0x9e>
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 800627c:	4958      	ldr	r1, [pc, #352]	; (80063e0 <MIOS32_UART_MIDI_PackageReceive+0x1a4>)
 800627e:	f000 020f 	and.w	r2, r0, #15
 8006282:	5c8a      	ldrb	r2, [r1, r2]

	  if( byte == 0xf0 ) {
 8006284:	28f0      	cmp	r0, #240	; 0xf0
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 8006286:	716a      	strb	r2, [r5, #5]

	  if( byte == 0xf0 ) {
 8006288:	d103      	bne.n	8006292 <MIOS32_UART_MIDI_PackageReceive+0x56>
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
	    midix->sysex_ctr = 0x01;
 800628a:	2201      	movs	r2, #1

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];

	  if( byte == 0xf0 ) {
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
 800628c:	7068      	strb	r0, [r5, #1]
	    midix->sysex_ctr = 0x01;
 800628e:	71ea      	strb	r2, [r5, #7]
 8006290:	e024      	b.n	80062dc <MIOS32_UART_MIDI_PackageReceive+0xa0>
	  } else if( byte == 0xf7 ) {
 8006292:	28f7      	cmp	r0, #247	; 0xf7
 8006294:	d122      	bne.n	80062dc <MIOS32_UART_MIDI_PackageReceive+0xa0>
	    switch( midix->sysex_ctr ) {
 8006296:	79ea      	ldrb	r2, [r5, #7]
 8006298:	b11a      	cbz	r2, 80062a2 <MIOS32_UART_MIDI_PackageReceive+0x66>
 800629a:	2a01      	cmp	r2, #1
 800629c:	782a      	ldrb	r2, [r5, #0]
 800629e:	d110      	bne.n	80062c2 <MIOS32_UART_MIDI_PackageReceive+0x86>
 80062a0:	e008      	b.n	80062b4 <MIOS32_UART_MIDI_PackageReceive+0x78>
 	      case 0:
		midix->package.cin = 5; // 5: SysEx ends with single byte
 80062a2:	782b      	ldrb	r3, [r5, #0]
 80062a4:	2105      	movs	r1, #5
 80062a6:	f361 0303 	bfi	r3, r1, #0, #4
 80062aa:	702b      	strb	r3, [r5, #0]
		midix->package.evnt0 = 0xf7;
 80062ac:	7068      	strb	r0, [r5, #1]
		midix->package.evnt1 = 0x00;
 80062ae:	70aa      	strb	r2, [r5, #2]
		midix->package.evnt2 = 0x00;
 80062b0:	70ea      	strb	r2, [r5, #3]
		break;
 80062b2:	e00c      	b.n	80062ce <MIOS32_UART_MIDI_PackageReceive+0x92>
	      case 1:
		midix->package.cin = 6; // 6: SysEx ends with two bytes
 80062b4:	2106      	movs	r1, #6
 80062b6:	f361 0203 	bfi	r2, r1, #0, #4
 80062ba:	702a      	strb	r2, [r5, #0]
		// midix->package.evnt0 = // already stored
		midix->package.evnt1 = 0xf7;
 80062bc:	70a8      	strb	r0, [r5, #2]
		midix->package.evnt2 = 0x00;
 80062be:	70eb      	strb	r3, [r5, #3]
		break;
 80062c0:	e005      	b.n	80062ce <MIOS32_UART_MIDI_PackageReceive+0x92>
	      default:
		midix->package.cin = 7; // 7: SysEx ends with three bytes
 80062c2:	4613      	mov	r3, r2
 80062c4:	2207      	movs	r2, #7
 80062c6:	f362 0303 	bfi	r3, r2, #0, #4
 80062ca:	702b      	strb	r3, [r5, #0]
		// midix->package.evnt0 = // already stored
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
 80062cc:	70e8      	strb	r0, [r5, #3]
		break;
	    }
	    *package = midix->package;
 80062ce:	682b      	ldr	r3, [r5, #0]
 80062d0:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
 80062d2:	2300      	movs	r3, #0
 80062d4:	71eb      	strb	r3, [r5, #7]
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
		break;
	    }
	    *package = midix->package;
	    package_complete = 1; // -> forward to caller
 80062d6:	3301      	adds	r3, #1
 80062d8:	e000      	b.n	80062dc <MIOS32_UART_MIDI_PackageReceive+0xa0>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 80062da:	2300      	movs	r3, #0
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
	  }
	}

	midix->wait_bytes = midix->expected_bytes;
 80062dc:	796a      	ldrb	r2, [r5, #5]
 80062de:	71aa      	strb	r2, [r5, #6]
	midix->timeout_ctr = 0; // reset timeout counter
 80062e0:	2200      	movs	r2, #0
 80062e2:	812a      	strh	r2, [r5, #8]
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80062e4:	2b00      	cmp	r3, #0
 80062e6:	d057      	beq.n	8006398 <MIOS32_UART_MIDI_PackageReceive+0x15c>
 80062e8:	e077      	b.n	80063da <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 80062ea:	792b      	ldrb	r3, [r5, #4]
 80062ec:	2bf0      	cmp	r3, #240	; 0xf0
 80062ee:	d117      	bne.n	8006320 <MIOS32_UART_MIDI_PackageReceive+0xe4>
	switch( ++midix->sysex_ctr ) {
 80062f0:	79eb      	ldrb	r3, [r5, #7]
 80062f2:	3301      	adds	r3, #1
 80062f4:	b2db      	uxtb	r3, r3
 80062f6:	2b01      	cmp	r3, #1
 80062f8:	71eb      	strb	r3, [r5, #7]
 80062fa:	d002      	beq.n	8006302 <MIOS32_UART_MIDI_PackageReceive+0xc6>
 80062fc:	2b02      	cmp	r3, #2
 80062fe:	d104      	bne.n	800630a <MIOS32_UART_MIDI_PackageReceive+0xce>
 8006300:	e001      	b.n	8006306 <MIOS32_UART_MIDI_PackageReceive+0xca>
  	  case 1:
	    midix->package.evnt0 = byte; 
 8006302:	7068      	strb	r0, [r5, #1]
	    break;
 8006304:	e048      	b.n	8006398 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  case 2: 
	    midix->package.evnt1 = byte; 
 8006306:	70a8      	strb	r0, [r5, #2]
	    break;
 8006308:	e046      	b.n	8006398 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  default: // 3
	    midix->package.evnt2 = byte;

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 800630a:	782b      	ldrb	r3, [r5, #0]
 800630c:	2204      	movs	r2, #4
 800630e:	f362 0303 	bfi	r3, r2, #0, #4
	    break;
	  case 2: 
	    midix->package.evnt1 = byte; 
	    break;
	  default: // 3
	    midix->package.evnt2 = byte;
 8006312:	70e8      	strb	r0, [r5, #3]

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 8006314:	702b      	strb	r3, [r5, #0]
	    *package = midix->package;
 8006316:	682b      	ldr	r3, [r5, #0]
 8006318:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
 800631a:	2300      	movs	r3, #0
 800631c:	71eb      	strb	r3, [r5, #7]
 800631e:	e05c      	b.n	80063da <MIOS32_UART_MIDI_PackageReceive+0x19e>
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
 8006320:	79ab      	ldrb	r3, [r5, #6]
 8006322:	b923      	cbnz	r3, 800632e <MIOS32_UART_MIDI_PackageReceive+0xf2>
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 8006324:	796a      	ldrb	r2, [r5, #5]
	  midix->timeout_ctr = 0; // reset timeout counter
 8006326:	812b      	strh	r3, [r5, #8]
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 8006328:	3a01      	subs	r2, #1
 800632a:	71aa      	strb	r2, [r5, #6]
 800632c:	e001      	b.n	8006332 <MIOS32_UART_MIDI_PackageReceive+0xf6>
	  midix->timeout_ctr = 0; // reset timeout counter
	} else {
	  --midix->wait_bytes;
 800632e:	3b01      	subs	r3, #1
 8006330:	71ab      	strb	r3, [r5, #6]
	}

	if( midix->expected_bytes == 1 ) {
 8006332:	796b      	ldrb	r3, [r5, #5]
 8006334:	2b01      	cmp	r3, #1
 8006336:	d103      	bne.n	8006340 <MIOS32_UART_MIDI_PackageReceive+0x104>
	  midix->package.evnt1 = byte;
	  midix->package.evnt2 = 0x00;
 8006338:	3b01      	subs	r3, #1
	} else {
	  --midix->wait_bytes;
	}

	if( midix->expected_bytes == 1 ) {
	  midix->package.evnt1 = byte;
 800633a:	70a8      	strb	r0, [r5, #2]
	  midix->package.evnt2 = 0x00;
 800633c:	70eb      	strb	r3, [r5, #3]
 800633e:	e004      	b.n	800634a <MIOS32_UART_MIDI_PackageReceive+0x10e>
	} else {
	  if( midix->wait_bytes )
 8006340:	79ab      	ldrb	r3, [r5, #6]
 8006342:	b10b      	cbz	r3, 8006348 <MIOS32_UART_MIDI_PackageReceive+0x10c>
	    midix->package.evnt1 = byte;
 8006344:	70a8      	strb	r0, [r5, #2]
 8006346:	e000      	b.n	800634a <MIOS32_UART_MIDI_PackageReceive+0x10e>
	  else
	    midix->package.evnt2 = byte;
 8006348:	70e8      	strb	r0, [r5, #3]
	}
	
	if( !midix->wait_bytes ) {
 800634a:	79ab      	ldrb	r3, [r5, #6]
 800634c:	bb23      	cbnz	r3, 8006398 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  if( (midix->running_status & 0xf0) != 0xf0 ) {
 800634e:	792b      	ldrb	r3, [r5, #4]
 8006350:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8006354:	2af0      	cmp	r2, #240	; 0xf0
 8006356:	d002      	beq.n	800635e <MIOS32_UART_MIDI_PackageReceive+0x122>
	    midix->package.cin = midix->running_status >> 4; // common MIDI message
 8006358:	091a      	lsrs	r2, r3, #4
 800635a:	782b      	ldrb	r3, [r5, #0]
 800635c:	e00b      	b.n	8006376 <MIOS32_UART_MIDI_PackageReceive+0x13a>
	  } else {
	    switch( midix->expected_bytes ) { // MEMO: == 0 comparison was a bug in original MBHP_USB code
 800635e:	796b      	ldrb	r3, [r5, #5]
 8006360:	b11b      	cbz	r3, 800636a <MIOS32_UART_MIDI_PackageReceive+0x12e>
 8006362:	2b01      	cmp	r3, #1
 8006364:	782b      	ldrb	r3, [r5, #0]
 8006366:	d105      	bne.n	8006374 <MIOS32_UART_MIDI_PackageReceive+0x138>
 8006368:	e002      	b.n	8006370 <MIOS32_UART_MIDI_PackageReceive+0x134>
  	      case 0: 
		midix->package.cin = 5; // 5: SysEx common with one byte
 800636a:	782b      	ldrb	r3, [r5, #0]
 800636c:	2205      	movs	r2, #5
 800636e:	e002      	b.n	8006376 <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      case 1: 
		midix->package.cin = 2; // 2: SysEx common with two bytes
 8006370:	2202      	movs	r2, #2
 8006372:	e000      	b.n	8006376 <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      default: 
		midix->package.cin = 3; // 3: SysEx common with three bytes
 8006374:	2203      	movs	r2, #3
 8006376:	f362 0303 	bfi	r3, r2, #0, #4
 800637a:	702b      	strb	r3, [r5, #0]
		break;
	    }
	  }

	  midix->package.evnt0 = midix->running_status;
 800637c:	230c      	movs	r3, #12
 800637e:	4363      	muls	r3, r4
 8006380:	4a18      	ldr	r2, [pc, #96]	; (80063e4 <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 8006382:	18d1      	adds	r1, r2, r3
 8006384:	7908      	ldrb	r0, [r1, #4]
 8006386:	7048      	strb	r0, [r1, #1]
	  // midix->package.evnt1 = // already stored
	  // midix->package.evnt2 = // already stored
	  *package = midix->package;
 8006388:	58d3      	ldr	r3, [r2, r3]
 800638a:	6033      	str	r3, [r6, #0]
 800638c:	e025      	b.n	80063da <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 800638e:	4b15      	ldr	r3, [pc, #84]	; (80063e4 <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 8006390:	250c      	movs	r5, #12
 8006392:	fb05 3504 	mla	r5, r5, r4, r3
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 8006396:	4f14      	ldr	r7, [pc, #80]	; (80063e8 <MIOS32_UART_MIDI_PackageReceive+0x1ac>)
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 8006398:	4620      	mov	r0, r4
 800639a:	f001 fd2d 	bl	8007df8 <MIOS32_UART_RxBufferGet>
 800639e:	2800      	cmp	r0, #0
 80063a0:	f6bf af56 	bge.w	8006250 <MIOS32_UART_MIDI_PackageReceive+0x14>
 80063a4:	2000      	movs	r0, #0
      }
    }
  }

  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
 80063a6:	230c      	movs	r3, #12
 80063a8:	435c      	muls	r4, r3
 80063aa:	490e      	ldr	r1, [pc, #56]	; (80063e4 <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 80063ac:	190b      	adds	r3, r1, r4
 80063ae:	799a      	ldrb	r2, [r3, #6]
 80063b0:	b16a      	cbz	r2, 80063ce <MIOS32_UART_MIDI_PackageReceive+0x192>
 80063b2:	891a      	ldrh	r2, [r3, #8]
 80063b4:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 80063b8:	d909      	bls.n	80063ce <MIOS32_UART_MIDI_PackageReceive+0x192>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80063ba:	2200      	movs	r2, #0
 80063bc:	510a      	str	r2, [r1, r4]
  midix->running_status = 0x00;
 80063be:	711a      	strb	r2, [r3, #4]
  midix->expected_bytes = 0x00;
 80063c0:	715a      	strb	r2, [r3, #5]
  midix->wait_bytes = 0x00;
 80063c2:	719a      	strb	r2, [r3, #6]
  midix->sysex_ctr = 0x00;
 80063c4:	71da      	strb	r2, [r3, #7]
  midix->timeout_ctr = 0;
 80063c6:	811a      	strh	r2, [r3, #8]
  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
    // stop waiting
    MIOS32_UART_MIDI_RecordReset(uart_port);
    // notify that incomplete package has been received
    return -10;
 80063c8:	f06f 0009 	mvn.w	r0, #9
 80063cc:	e004      	b.n	80063d8 <MIOS32_UART_MIDI_PackageReceive+0x19c>
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 80063ce:	2800      	cmp	r0, #0
 80063d0:	bf0c      	ite	eq
 80063d2:	f04f 30ff 	moveq.w	r0, #4294967295
 80063d6:	2000      	movne	r0, #0
#endif
}
 80063d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80063da:	2001      	movs	r0, #1
 80063dc:	e7e3      	b.n	80063a6 <MIOS32_UART_MIDI_PackageReceive+0x16a>
 80063de:	bf00      	nop
 80063e0:	0800a150 	.word	0x0800a150
 80063e4:	20000194 	.word	0x20000194
 80063e8:	0800a284 	.word	0x0800a284

080063ec <MIOS32_IIC_MIDI_Init>:
  // TODO: send optimisation flag to IIC_MIDI device once it has been scanned!
#endif

  return 0; // no error
#endif
}
 80063ec:	f04f 30ff 	mov.w	r0, #4294967295
 80063f0:	4770      	bx	lr

080063f2 <MIOS32_IIC_MIDI_Periodic_mS>:
s32 MIOS32_IIC_MIDI_Periodic_mS(void)
{
  // currently only a dummy - RS optimisation handled by IIC_MIDI device

  return 0;
}
 80063f2:	2000      	movs	r0, #0
 80063f4:	4770      	bx	lr

080063f6 <MIOS32_IIC_MIDI_PackageSend>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageSend(u8 iic_port, mios32_midi_package_t package)
{
  return _MIOS32_IIC_MIDI_PackageSend(iic_port, package, 0); // blocking mode
}
 80063f6:	f04f 30ff 	mov.w	r0, #4294967295
 80063fa:	4770      	bx	lr

080063fc <MIOS32_IIC_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageReceive(u8 iic_port, mios32_midi_package_t *package)
{
  return _MIOS32_IIC_MIDI_PackageReceive(iic_port, package, 0); // blocking
}
 80063fc:	f04f 30ff 	mov.w	r0, #4294967295
 8006400:	4770      	bx	lr

08006402 <MIOS32_IIC_BS_Init>:
  if( MIOS32_IIC_BS_ScanBankSticks() < 0 )
    return -2; // we don't expect that any other task accesses the IIC port yet!

  return 0; // no error
#endif
}
 8006402:	f04f 30ff 	mov.w	r0, #4294967295
 8006406:	4770      	bx	lr

08006408 <MIOS32_MF_Init>:
    mf_state[i].config.cfg.pwm_duty_cycle_up = 1;
  }

  return 0;
#endif
}
 8006408:	f04f 30ff 	mov.w	r0, #4294967295
 800640c:	4770      	bx	lr
	...

08006410 <MIOS32_SYS_Reset>:
//!   <LI>reset STM32
//! </UL>
//! \return < 0 if reset failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Reset(void)
{
 8006410:	b508      	push	{r3, lr}
  // disable all RTOS tasks
#ifndef MIOS32_DONT_USE_FREERTOS
  portENTER_CRITICAL(); // port specific FreeRTOS function to disable tasks (nested)
 8006412:	f7fe fbb5 	bl	8004b80 <vPortEnterCritical>

  // print reboot message if LCD enabled
#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 8006416:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 800641a:	f7ff f8fe 	bl	800561a <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 800641e:	2000      	movs	r0, #0
 8006420:	f7ff f8ff 	bl	8005622 <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 8006424:	2000      	movs	r0, #0
 8006426:	f7ff f81d 	bl	8005464 <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 800642a:	f7ff f883 	bl	8005534 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 800642e:	2000      	movs	r0, #0
 8006430:	4601      	mov	r1, r0
 8006432:	f7ff f81d 	bl	8005470 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("Bootloader Mode "); // 16 chars
 8006436:	4811      	ldr	r0, [pc, #68]	; (800647c <MIOS32_SYS_Reset+0x6c>)
 8006438:	f7ff f8ae 	bl	8005598 <MIOS32_LCD_PrintString>
#endif

  // wait until all MIDI OUT buffers are empty (TODO)

  // disable all interrupts
  MIOS32_IRQ_Disable();
 800643c:	f000 f912 	bl	8006664 <MIOS32_IRQ_Disable>

  // turn off all board LEDs
  MIOS32_BOARD_LED_Set(0xffffffff, 0x00000000);
 8006440:	2100      	movs	r1, #0
 8006442:	f04f 30ff 	mov.w	r0, #4294967295
 8006446:	f000 fed5 	bl	80071f4 <MIOS32_BOARD_LED_Set>
#else
  //  NVIC_GenerateSystemReset();
#ifdef MIOS32_BOARD_STM32_PRIMER
  RCC_APB2PeriphResetCmd(0xfffffff0, ENABLE); // Primer: don't reset GPIOA/AF + GPIOB due to USB detach pin
#else
  RCC_APB2PeriphResetCmd(0xfffffff8, ENABLE); // MBHP_CORE_STM32: don't reset GPIOA/AF due to USB pins
 800644a:	f06f 0007 	mvn.w	r0, #7
 800644e:	2101      	movs	r1, #1
 8006450:	f002 fc7e 	bl	8008d50 <RCC_APB2PeriphResetCmd>
#endif
  RCC_APB1PeriphResetCmd(0xff7fffff, ENABLE); // don't reset USB, so that the connection can survive!
 8006454:	f46f 0000 	mvn.w	r0, #8388608	; 0x800000
 8006458:	2101      	movs	r1, #1
 800645a:	f002 fc87 	bl	8008d6c <RCC_APB1PeriphResetCmd>
  RCC_APB2PeriphResetCmd(0xffffffff, DISABLE);
 800645e:	f04f 30ff 	mov.w	r0, #4294967295
 8006462:	2100      	movs	r1, #0
 8006464:	f002 fc74 	bl	8008d50 <RCC_APB2PeriphResetCmd>
  RCC_APB1PeriphResetCmd(0xffffffff, DISABLE);
 8006468:	f04f 30ff 	mov.w	r0, #4294967295
 800646c:	2100      	movs	r1, #0
 800646e:	f002 fc7d 	bl	8008d6c <RCC_APB1PeriphResetCmd>
  // not available in v3.0.0 library anymore? - copy from v2.0.1
  SCB->AIRCR = NVIC_AIRCR_VECTKEY | (1 << NVIC_VECTRESET);
#endif
#if 1
  // and this is the code for v3.3.0
  SCB->AIRCR = (0x5fa << SCB_AIRCR_VECTKEY_Pos) | (1 << SCB_AIRCR_VECTRESET_Pos);
 8006472:	4a03      	ldr	r2, [pc, #12]	; (8006480 <MIOS32_SYS_Reset+0x70>)
 8006474:	4b03      	ldr	r3, [pc, #12]	; (8006484 <MIOS32_SYS_Reset+0x74>)
 8006476:	60da      	str	r2, [r3, #12]
 8006478:	e7fe      	b.n	8006478 <MIOS32_SYS_Reset+0x68>
 800647a:	bf00      	nop
 800647c:	0800a2a0 	.word	0x0800a2a0
 8006480:	05fa0001 	.word	0x05fa0001
 8006484:	e000ed00 	.word	0xe000ed00

08006488 <MIOS32_SYS_ChipIDGet>:
//! \return the chip ID
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_ChipIDGet(void)
{
  // stored in DBGMCU_IDCODE register
  return MEM32(0xe0042000);
 8006488:	4b01      	ldr	r3, [pc, #4]	; (8006490 <MIOS32_SYS_ChipIDGet+0x8>)
 800648a:	6818      	ldr	r0, [r3, #0]
}
 800648c:	4770      	bx	lr
 800648e:	bf00      	nop
 8006490:	e0042000 	.word	0xe0042000

08006494 <MIOS32_SYS_FlashSizeGet>:
//! \return the Flash size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_FlashSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e0) * 0x400;
 8006494:	4b02      	ldr	r3, [pc, #8]	; (80064a0 <MIOS32_SYS_FlashSizeGet+0xc>)
 8006496:	8818      	ldrh	r0, [r3, #0]
 8006498:	b280      	uxth	r0, r0
 800649a:	0280      	lsls	r0, r0, #10
}
 800649c:	4770      	bx	lr
 800649e:	bf00      	nop
 80064a0:	1ffff7e0 	.word	0x1ffff7e0

080064a4 <MIOS32_SYS_RAMSizeGet>:
//! \return the RAM size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_RAMSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e2) * 0x400;
 80064a4:	4b02      	ldr	r3, [pc, #8]	; (80064b0 <MIOS32_SYS_RAMSizeGet+0xc>)
 80064a6:	8818      	ldrh	r0, [r3, #0]
 80064a8:	b280      	uxth	r0, r0
 80064aa:	0280      	lsls	r0, r0, #10
}
 80064ac:	4770      	bx	lr
 80064ae:	bf00      	nop
 80064b0:	1ffff7e2 	.word	0x1ffff7e2

080064b4 <MIOS32_SYS_SerialNumberGet>:
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 80064b4:	2300      	movs	r3, #0
    u8 b = MEM8(0x1ffff7e8 + (i/2));
 80064b6:	4a0b      	ldr	r2, [pc, #44]	; (80064e4 <MIOS32_SYS_SerialNumberGet+0x30>)
 80064b8:	1059      	asrs	r1, r3, #1
 80064ba:	188a      	adds	r2, r1, r2
 80064bc:	7812      	ldrb	r2, [r2, #0]
    if( !(i & 1) )
 80064be:	f013 0f01 	tst.w	r3, #1
      b >>= 4;
 80064c2:	bf08      	it	eq
 80064c4:	0912      	lsreq	r2, r2, #4
    b &= 0x0f;
 80064c6:	f002 020f 	and.w	r2, r2, #15

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
 80064ca:	2a09      	cmp	r2, #9
 80064cc:	bf94      	ite	ls
 80064ce:	2130      	movls	r1, #48	; 0x30
 80064d0:	2137      	movhi	r1, #55	; 0x37
 80064d2:	188a      	adds	r2, r1, r2
 80064d4:	54c2      	strb	r2, [r0, r3]
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 80064d6:	3301      	adds	r3, #1
 80064d8:	2b18      	cmp	r3, #24
 80064da:	d1ec      	bne.n	80064b6 <MIOS32_SYS_SerialNumberGet+0x2>
      b >>= 4;
    b &= 0x0f;

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
  }
  str[i] = 0;
 80064dc:	2300      	movs	r3, #0
 80064de:	7603      	strb	r3, [r0, #24]

  return 0; // no error
}
 80064e0:	4618      	mov	r0, r3
 80064e2:	4770      	bx	lr
 80064e4:	1ffff7e8 	.word	0x1ffff7e8

080064e8 <MIOS32_SYS_TimeSet>:
//! Note that this format isn't completely compatible to the NTP timestamp format,
//! as the fraction has only mS accuracy
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_TimeSet(mios32_sys_time_t t)
{
 80064e8:	b507      	push	{r0, r1, r2, lr}
 80064ea:	466b      	mov	r3, sp
 80064ec:	e883 0003 	stmia.w	r3, {r0, r1}
  // taken from STM32 example "RTC/Calendar"
  // adapted to clock RTC via HSE  oscillator

  // Enable PWR and BKP clocks
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 80064f0:	2101      	movs	r1, #1
 80064f2:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 80064f6:	f002 fc1d 	bl	8008d34 <RCC_APB1PeriphClockCmd>

  // Allow access to BKP Domain
  PWR_BackupAccessCmd(ENABLE);
 80064fa:	2001      	movs	r0, #1
 80064fc:	f002 fcd6 	bl	8008eac <PWR_BackupAccessCmd>

  // Reset Backup Domain
  BKP_DeInit();
 8006500:	f002 fccc 	bl	8008e9c <BKP_DeInit>

  // Select HSE (divided by 128) as RTC Clock Source
  RCC_RTCCLKConfig(RCC_RTCCLKSource_HSE_Div128);
 8006504:	f44f 7040 	mov.w	r0, #768	; 0x300
 8006508:	f002 fb96 	bl	8008c38 <RCC_RTCCLKConfig>

  // Enable RTC Clock
  RCC_RTCCLKCmd(ENABLE);
 800650c:	2001      	movs	r0, #1
 800650e:	f002 fb9b 	bl	8008c48 <RCC_RTCCLKCmd>

  // Wait for RTC registers synchronization
  RTC_WaitForSynchro();
 8006512:	f002 fcb5 	bl	8008e80 <RTC_WaitForSynchro>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 8006516:	f002 fcab 	bl	8008e70 <RTC_WaitForLastTask>

  // Enable the RTC Second
  RTC_ITConfig(RTC_IT_SEC, ENABLE);
 800651a:	2001      	movs	r0, #1
 800651c:	4601      	mov	r1, r0
 800651e:	f002 fc65 	bl	8008dec <RTC_ITConfig>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 8006522:	f002 fca5 	bl	8008e70 <RTC_WaitForLastTask>

  // Set RTC prescaler: set RTC period to 1sec
  RTC_SetPrescaler(RTC_PREDIVIDER-1);
 8006526:	4806      	ldr	r0, [pc, #24]	; (8006540 <MIOS32_SYS_TimeSet+0x58>)
 8006528:	f002 fc92 	bl	8008e50 <RTC_SetPrescaler>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800652c:	f002 fca0 	bl	8008e70 <RTC_WaitForLastTask>

  // Change the current time
  // (fraction not taken into account here)
  RTC_SetCounter(t.seconds);
 8006530:	9800      	ldr	r0, [sp, #0]
 8006532:	f002 fc7f 	bl	8008e34 <RTC_SetCounter>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 8006536:	f002 fc9b 	bl	8008e70 <RTC_WaitForLastTask>

  return 0; // no error
}
 800653a:	2000      	movs	r0, #0
 800653c:	bd0e      	pop	{r1, r2, r3, pc}
 800653e:	bf00      	nop
 8006540:	00016e35 	.word	0x00016e35

08006544 <MIOS32_SYS_Init>:
//! </UL>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
 8006544:	b530      	push	{r4, r5, lr}
 8006546:	4605      	mov	r5, r0
 8006548:	b085      	sub	sp, #20
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800654a:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
 800654e:	2d00      	cmp	r5, #0
 8006550:	d177      	bne.n	8006642 <MIOS32_SYS_Init+0xfe>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8006552:	ac03      	add	r4, sp, #12
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
 8006554:	2101      	movs	r1, #1
 8006556:	207d      	movs	r0, #125	; 0x7d
 8006558:	f002 fbde 	bl	8008d18 <RCC_APB2PeriphClockCmd>
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800655c:	4620      	mov	r0, r4
 800655e:	f002 f895 	bl	800868c <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 8006562:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8006564:	4621      	mov	r1, r4
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 8006566:	f88d 300f 	strb.w	r3, [sp, #15]
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800656a:	4837      	ldr	r0, [pc, #220]	; (8006648 <MIOS32_SYS_Init+0x104>)

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
 800656c:	f24e 73ff 	movw	r3, #59391	; 0xe7ff
 8006570:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8006574:	f002 f831 	bl	80085da <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 8006578:	f04f 33ff 	mov.w	r3, #4294967295
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800657c:	4621      	mov	r1, r4
 800657e:	4833      	ldr	r0, [pc, #204]	; (800664c <MIOS32_SYS_Init+0x108>)
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 8006580:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8006584:	f002 f829 	bl	80085da <GPIO_Init>
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 8006588:	4621      	mov	r1, r4
 800658a:	4831      	ldr	r0, [pc, #196]	; (8006650 <MIOS32_SYS_Init+0x10c>)
 800658c:	f002 f825 	bl	80085da <GPIO_Init>
  GPIO_Init(GPIOB, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8006590:	4621      	mov	r1, r4
 8006592:	4830      	ldr	r0, [pc, #192]	; (8006654 <MIOS32_SYS_Init+0x110>)
 8006594:	f002 f821 	bl	80085da <GPIO_Init>
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 8006598:	f002 fb18 	bl	8008bcc <RCC_GetSYSCLKSource>
 800659c:	2808      	cmp	r0, #8
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;
 800659e:	bf08      	it	eq
 80065a0:	462c      	moveq	r4, r5
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 80065a2:	d033      	beq.n	800660c <MIOS32_SYS_Init+0xc8>
    // Start with the clocks in their expected state
    RCC_DeInit();
 80065a4:	f002 fabc 	bl	8008b20 <RCC_DeInit>

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);
 80065a8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80065ac:	f002 fad8 	bl	8008b60 <RCC_HSEConfig>

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 80065b0:	f002 fc06 	bl	8008dc0 <RCC_WaitForHSEStartUp>

    if( HSEStartUpStatus == SUCCESS ) {
 80065b4:	2801      	cmp	r0, #1

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 80065b6:	4604      	mov	r4, r0

    if( HSEStartUpStatus == SUCCESS ) {
 80065b8:	d128      	bne.n	800660c <MIOS32_SYS_Init+0xc8>
      // Enable Prefetch Buffer
      FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 80065ba:	2010      	movs	r0, #16
 80065bc:	f002 f8b2 	bl	8008724 <FLASH_PrefetchBufferCmd>

      // Flash 2 wait state
      FLASH_SetLatency(FLASH_Latency_2);
 80065c0:	2002      	movs	r0, #2
 80065c2:	f002 f8a5 	bl	8008710 <FLASH_SetLatency>

      // HCLK = SYSCLK
      RCC_HCLKConfig(RCC_SYSCLK_Div1);
 80065c6:	4628      	mov	r0, r5
 80065c8:	f002 fb08 	bl	8008bdc <RCC_HCLKConfig>

      // PCLK2 = HCLK
      RCC_PCLK2Config(RCC_HCLK_Div1);
 80065cc:	4628      	mov	r0, r5
 80065ce:	f002 fb19 	bl	8008c04 <RCC_PCLK2Config>

      // PCLK1 = HCLK/2
      RCC_PCLK1Config(RCC_HCLK_Div2);
 80065d2:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80065d6:	f002 fb0b 	bl	8008bf0 <RCC_PCLK1Config>

      // ADCCLK = PCLK2/6
      RCC_ADCCLKConfig(RCC_PCLK2_Div6);
 80065da:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80065de:	f002 fb21 	bl	8008c24 <RCC_ADCCLKConfig>
      // PLL configuration: PLLCLK = (PLL2 / 5) * 9 = 72 MHz
      RCC_PREDIV1Config(RCC_PREDIV1_Source_PLL2, RCC_PREDIV1_Div5);
      RCC_PLLConfig(RCC_PLLSource_PREDIV1, RCC_PLLMul_9);
#else
      // PLLCLK = 12MHz * 6 = 72 MHz
      RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_6);
 80065e2:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80065e6:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 80065ea:	f002 fad5 	bl	8008b98 <RCC_PLLConfig>
#endif

      // Enable PLL
      RCC_PLLCmd(ENABLE);
 80065ee:	4620      	mov	r0, r4
 80065f0:	f002 fadc 	bl	8008bac <RCC_PLLCmd>

      // Wait till PLL is ready
      while( RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET );
 80065f4:	2039      	movs	r0, #57	; 0x39
 80065f6:	f002 fbcd 	bl	8008d94 <RCC_GetFlagStatus>
 80065fa:	2800      	cmp	r0, #0
 80065fc:	d0fa      	beq.n	80065f4 <MIOS32_SYS_Init+0xb0>

      // Select PLL as system clock source
      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 80065fe:	2002      	movs	r0, #2
 8006600:	f002 fada 	bl	8008bb8 <RCC_SYSCLKConfig>

      // Wait till PLL is used as system clock source
      while( RCC_GetSYSCLKSource() != 0x08 );
 8006604:	f002 fae2 	bl	8008bcc <RCC_GetSYSCLKSource>
 8006608:	2808      	cmp	r0, #8
 800660a:	d1fb      	bne.n	8006604 <MIOS32_SYS_Init+0xc0>
    }
  }

  // Set the Vector Table base address as specified in .ld file (-> mios32_sys_isr_vector)
  NVIC_SetVectorTable((u32)&mios32_sys_isr_vector, 0x0);
 800660c:	2100      	movs	r1, #0
 800660e:	4812      	ldr	r0, [pc, #72]	; (8006658 <MIOS32_SYS_Init+0x114>)
 8006610:	f002 fc5c 	bl	8008ecc <NVIC_SetVectorTable>
  NVIC_PriorityGroupConfig(MIOS32_IRQ_PRIGROUP);
 8006614:	f44f 7040 	mov.w	r0, #768	; 0x300
 8006618:	f002 fc4e 	bl	8008eb8 <NVIC_PriorityGroupConfig>

  // Configure HCLK clock as SysTick clock source
  SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );
 800661c:	2004      	movs	r0, #4
 800661e:	f002 fc61 	bl	8008ee4 <SysTick_CLKSourceConfig>

  // configure debug control register DBGMCU_CR (we want to stop timers in CPU HALT mode)
  // flags can be overruled in mios32_config.h
  MEM32(0xe0042004) = MIOS32_SYS_STM32_DBGMCU_CR;
 8006622:	4a0e      	ldr	r2, [pc, #56]	; (800665c <MIOS32_SYS_Init+0x118>)
 8006624:	4b0e      	ldr	r3, [pc, #56]	; (8006660 <MIOS32_SYS_Init+0x11c>)
 8006626:	601a      	str	r2, [r3, #0]

  // initialize system clock
  mios32_sys_time_t t = { .seconds=0, .fraction_ms=0 };
 8006628:	2300      	movs	r3, #0
 800662a:	9301      	str	r3, [sp, #4]
 800662c:	9302      	str	r3, [sp, #8]
  MIOS32_SYS_TimeSet(t);
 800662e:	ab01      	add	r3, sp, #4
 8006630:	e893 0003 	ldmia.w	r3, {r0, r1}
 8006634:	f7ff ff58 	bl	80064e8 <MIOS32_SYS_TimeSet>

  // error during clock configuration?
  return HSEStartUpStatus == SUCCESS ? 0 : -1;
 8006638:	2c01      	cmp	r4, #1
 800663a:	bf14      	ite	ne
 800663c:	f04f 30ff 	movne.w	r0, #4294967295
 8006640:	2000      	moveq	r0, #0
}
 8006642:	b005      	add	sp, #20
 8006644:	bd30      	pop	{r4, r5, pc}
 8006646:	bf00      	nop
 8006648:	40010800 	.word	0x40010800
 800664c:	40011000 	.word	0x40011000
 8006650:	40011400 	.word	0x40011400
 8006654:	40010c00 	.word	0x40010c00
 8006658:	08004000 	.word	0x08004000
 800665c:	001fff00 	.word	0x001fff00
 8006660:	e0042004 	.word	0xe0042004

08006664 <MIOS32_IRQ_Disable>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Disable(void)
{
  // get current priority if nested level == 0
  if( !nested_ctr ) {
 8006664:	4b08      	ldr	r3, [pc, #32]	; (8006688 <MIOS32_IRQ_Disable+0x24>)
 8006666:	681b      	ldr	r3, [r3, #0]
 8006668:	b91b      	cbnz	r3, 8006672 <MIOS32_IRQ_Disable+0xe>
    __asm volatile (			   \
 800666a:	f3ef 8210 	mrs	r2, PRIMASK
 800666e:	4b07      	ldr	r3, [pc, #28]	; (800668c <MIOS32_IRQ_Disable+0x28>)
 8006670:	601a      	str	r2, [r3, #0]
		    : "=r" (prev_primask)  \
		    );
  }

  // disable interrupts
  __asm volatile ( \
 8006672:	f04f 0001 	mov.w	r0, #1
 8006676:	f380 8810 	msr	PRIMASK, r0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 800667a:	4b03      	ldr	r3, [pc, #12]	; (8006688 <MIOS32_IRQ_Disable+0x24>)

  return 0; // no error
}
 800667c:	2000      	movs	r0, #0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 800667e:	681a      	ldr	r2, [r3, #0]
 8006680:	3201      	adds	r2, #1
 8006682:	601a      	str	r2, [r3, #0]

  return 0; // no error
}
 8006684:	4770      	bx	lr
 8006686:	bf00      	nop
 8006688:	200001b8 	.word	0x200001b8
 800668c:	200001b4 	.word	0x200001b4

08006690 <MIOS32_IRQ_Enable>:
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 8006690:	4a06      	ldr	r2, [pc, #24]	; (80066ac <MIOS32_IRQ_Enable+0x1c>)
    return -1; // nesting error
 8006692:	f04f 30ff 	mov.w	r0, #4294967295
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 8006696:	6813      	ldr	r3, [r2, #0]
 8006698:	b13b      	cbz	r3, 80066aa <MIOS32_IRQ_Enable+0x1a>
    return -1; // nesting error

  // decrease nesting level
  --nested_ctr;
 800669a:	3b01      	subs	r3, #1
 800669c:	6013      	str	r3, [r2, #0]

  // set back previous priority once nested level reached 0 again
  if( nested_ctr == 0 ) {
 800669e:	b91b      	cbnz	r3, 80066a8 <MIOS32_IRQ_Enable+0x18>
    __asm volatile ( \
 80066a0:	4b03      	ldr	r3, [pc, #12]	; (80066b0 <MIOS32_IRQ_Enable+0x20>)
 80066a2:	681b      	ldr	r3, [r3, #0]
 80066a4:	f383 8810 	msr	PRIMASK, r3
		    "	msr primask, %0\n" \
		    :: "r" (prev_primask)  \
		    );
  }

  return 0; // no error
 80066a8:	2000      	movs	r0, #0
}
 80066aa:	4770      	bx	lr
 80066ac:	200001b8 	.word	0x200001b8
 80066b0:	200001b4 	.word	0x200001b4

080066b4 <MIOS32_IRQ_Install>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 80066b4:	290f      	cmp	r1, #15
    return -1; // invalid priority
 80066b6:	bf88      	it	hi
 80066b8:	f04f 30ff 	movhi.w	r0, #4294967295
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 80066bc:	d818      	bhi.n	80066f0 <MIOS32_IRQ_Install+0x3c>
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
 80066be:	4b0d      	ldr	r3, [pc, #52]	; (80066f4 <MIOS32_IRQ_Install+0x40>)
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 80066c0:	b242      	sxtb	r2, r0
 80066c2:	68db      	ldr	r3, [r3, #12]
 80066c4:	0952      	lsrs	r2, r2, #5
 80066c6:	43db      	mvns	r3, r3
 80066c8:	f3c3 2302 	ubfx	r3, r3, #8, #3
  u32 tmppre = (4 - tmppriority);
 80066cc:	f1c3 0304 	rsb	r3, r3, #4
  tmppriority = priority << tmppre;
 80066d0:	4099      	lsls	r1, r3
  tmppriority = tmppriority << 4;
  NVIC->IP[IRQn] = tmppriority;
 80066d2:	4b09      	ldr	r3, [pc, #36]	; (80066f8 <MIOS32_IRQ_Install+0x44>)
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
  u32 tmppre = (4 - tmppriority);
  tmppriority = priority << tmppre;
  tmppriority = tmppriority << 4;
 80066d4:	0109      	lsls	r1, r1, #4
  NVIC->IP[IRQn] = tmppriority;
 80066d6:	18c3      	adds	r3, r0, r3
 80066d8:	b2c9      	uxtb	r1, r1
 80066da:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
 80066de:	f000 001f 	and.w	r0, r0, #31
 80066e2:	2301      	movs	r3, #1
 80066e4:	fa13 f000 	lsls.w	r0, r3, r0
 80066e8:	4b03      	ldr	r3, [pc, #12]	; (80066f8 <MIOS32_IRQ_Install+0x44>)
 80066ea:	f843 0022 	str.w	r0, [r3, r2, lsl #2]

  NVIC_EnableIRQ(IRQn);

  return 0; // no error
 80066ee:	2000      	movs	r0, #0
}
 80066f0:	4770      	bx	lr
 80066f2:	bf00      	nop
 80066f4:	e000ed00 	.word	0xe000ed00
 80066f8:	e000e100 	.word	0xe000e100

080066fc <MIOS32_SPI_IO_Init>:
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported pin driver mode
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_IO_Init(u8 spi, mios32_spi_pin_driver_t spi_pin_driver)
{
 80066fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80066fe:	4604      	mov	r4, r0
 8006700:	460d      	mov	r5, r1
  // init GPIO structure
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8006702:	a801      	add	r0, sp, #4
 8006704:	f001 ffc2 	bl	800868c <GPIO_StructInit>

  // select pin driver and output mode
  u32 af_mode;
  u32 gp_mode;

  switch( spi_pin_driver ) {
 8006708:	2d03      	cmp	r5, #3
 800670a:	f200 809e 	bhi.w	800684a <MIOS32_SPI_IO_Init+0x14e>
 800670e:	e8df f005 	tbb	[pc, r5]
 8006712:	0802      	.short	0x0802
 8006714:	140e      	.short	0x140e
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8006716:	2303      	movs	r3, #3
 8006718:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 800671c:	2510      	movs	r5, #16
  u32 gp_mode;

  switch( spi_pin_driver ) {
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_PP;
 800671e:	3315      	adds	r3, #21
      gp_mode = GPIO_Mode_Out_PP;
      break;
 8006720:	e010      	b.n	8006744 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8006722:	2303      	movs	r3, #3
 8006724:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 8006728:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_OD;
 800672a:	3319      	adds	r3, #25
      gp_mode = GPIO_Mode_Out_OD;
      break;
 800672c:	e00a      	b.n	8006744 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800672e:	2302      	movs	r3, #2
 8006730:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 8006734:	2510      	movs	r5, #16
      gp_mode = GPIO_Mode_Out_OD;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_PP;
 8006736:	3316      	adds	r3, #22
      gp_mode = GPIO_Mode_Out_PP;
      break;
 8006738:	e004      	b.n	8006744 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800673a:	2302      	movs	r3, #2
 800673c:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 8006740:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_OD;
 8006742:	331a      	adds	r3, #26

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 8006744:	2c01      	cmp	r4, #1
 8006746:	d030      	beq.n	80067aa <MIOS32_SPI_IO_Init+0xae>
 8006748:	d305      	bcc.n	8006756 <MIOS32_SPI_IO_Init+0x5a>
 800674a:	2c02      	cmp	r4, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 800674c:	bf18      	it	ne
 800674e:	f06f 0001 	mvnne.w	r0, #1

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 8006752:	d17c      	bne.n	800684e <MIOS32_SPI_IO_Init+0x152>
 8006754:	e04c      	b.n	80067f0 <MIOS32_SPI_IO_Init+0xf4>
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 8006756:	ac02      	add	r4, sp, #8
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 8006758:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 800675c:	2320      	movs	r3, #32
 800675e:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
 8006762:	483b      	ldr	r0, [pc, #236]	; (8006850 <MIOS32_SPI_IO_Init+0x154>)
 8006764:	4621      	mov	r1, r4
 8006766:	f001 ff38 	bl	80085da <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 800676a:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 800676c:	4838      	ldr	r0, [pc, #224]	; (8006850 <MIOS32_SPI_IO_Init+0x154>)
 800676e:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 8006770:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 8006774:	f001 ff31 	bl	80085da <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 8006778:	2310      	movs	r3, #16
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 800677a:	4835      	ldr	r0, [pc, #212]	; (8006850 <MIOS32_SPI_IO_Init+0x154>)
 800677c:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 800677e:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 8006782:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 8006786:	f001 ff28 	bl	80085da <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 800678a:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 800678e:	4831      	ldr	r0, [pc, #196]	; (8006854 <MIOS32_SPI_IO_Init+0x158>)
 8006790:	4621      	mov	r1, r4
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 8006792:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 8006796:	f001 ff20 	bl	80085da <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800679a:	2348      	movs	r3, #72	; 0x48
 800679c:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MISO_PIN;
 80067a0:	2340      	movs	r3, #64	; 0x40
 80067a2:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
 80067a6:	482a      	ldr	r0, [pc, #168]	; (8006850 <MIOS32_SPI_IO_Init+0x154>)
 80067a8:	e04a      	b.n	8006840 <MIOS32_SPI_IO_Init+0x144>
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 80067aa:	ac02      	add	r4, sp, #8
    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 80067ac:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 80067b0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80067b4:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 80067b8:	4827      	ldr	r0, [pc, #156]	; (8006858 <MIOS32_SPI_IO_Init+0x15c>)
 80067ba:	4621      	mov	r1, r4
 80067bc:	f001 ff0d 	bl	80085da <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 80067c0:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 80067c4:	4824      	ldr	r0, [pc, #144]	; (8006858 <MIOS32_SPI_IO_Init+0x15c>)
 80067c6:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 80067c8:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 80067cc:	f001 ff05 	bl	80085da <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 80067d0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80067d4:	4820      	ldr	r0, [pc, #128]	; (8006858 <MIOS32_SPI_IO_Init+0x15c>)
 80067d6:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 80067d8:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 80067dc:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80067e0:	f001 fefb 	bl	80085da <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
#endif
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80067e4:	2348      	movs	r3, #72	; 0x48
 80067e6:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MISO_PIN;
 80067ea:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80067ee:	e024      	b.n	800683a <MIOS32_SPI_IO_Init+0x13e>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
 80067f0:	ac02      	add	r4, sp, #8
 80067f2:	2340      	movs	r3, #64	; 0x40
 80067f4:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 80067f8:	4817      	ldr	r0, [pc, #92]	; (8006858 <MIOS32_SPI_IO_Init+0x15c>)
 80067fa:	4621      	mov	r1, r4
    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 80067fc:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 8006800:	f001 feeb 	bl	80085da <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 8006804:	2320      	movs	r3, #32
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 8006806:	4814      	ldr	r0, [pc, #80]	; (8006858 <MIOS32_SPI_IO_Init+0x15c>)
 8006808:	4621      	mov	r1, r4
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 800680a:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 800680e:	f001 fee4 	bl	80085da <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 8006812:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 8006816:	480f      	ldr	r0, [pc, #60]	; (8006854 <MIOS32_SPI_IO_Init+0x158>)
 8006818:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 800681a:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 800681e:	f001 fedc 	bl	80085da <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 8006822:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 8006826:	480b      	ldr	r0, [pc, #44]	; (8006854 <MIOS32_SPI_IO_Init+0x158>)
 8006828:	4621      	mov	r1, r4
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 800682a:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 800682e:	f001 fed4 	bl	80085da <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8006832:	2348      	movs	r3, #72	; 0x48
 8006834:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 8006838:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 800683a:	4807      	ldr	r0, [pc, #28]	; (8006858 <MIOS32_SPI_IO_Init+0x15c>)
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 800683c:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 8006840:	4621      	mov	r1, r4
 8006842:	f001 feca 	bl	80085da <GPIO_Init>

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006846:	2000      	movs	r0, #0
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);

      break;
 8006848:	e001      	b.n	800684e <MIOS32_SPI_IO_Init+0x152>
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
      break;

    default:
      return -3; // unsupported pin driver mode
 800684a:	f06f 0002 	mvn.w	r0, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 800684e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8006850:	40010800 	.word	0x40010800
 8006854:	40011000 	.word	0x40011000
 8006858:	40010c00 	.word	0x40010c00

0800685c <MIOS32_SPI_RC_PinSet>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 800685c:	2801      	cmp	r0, #1
 800685e:	d017      	beq.n	8006890 <MIOS32_SPI_RC_PinSet+0x34>
 8006860:	d305      	bcc.n	800686e <MIOS32_SPI_RC_PinSet+0x12>
 8006862:	2802      	cmp	r0, #2
      }
      break;
#endif

    default:
      return -2; // unsupported SPI port
 8006864:	bf18      	it	ne
 8006866:	f06f 0101 	mvnne.w	r1, #1
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 800686a:	d137      	bne.n	80068dc <MIOS32_SPI_RC_PinSet+0x80>
 800686c:	e01a      	b.n	80068a4 <MIOS32_SPI_RC_PinSet+0x48>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 800686e:	b111      	cbz	r1, 8006876 <MIOS32_SPI_RC_PinSet+0x1a>
 8006870:	2901      	cmp	r1, #1
 8006872:	d131      	bne.n	80068d8 <MIOS32_SPI_RC_PinSet+0x7c>
 8006874:	e006      	b.n	8006884 <MIOS32_SPI_RC_PinSet+0x28>
        case 0:
	  if( pin_value )
 8006876:	b112      	cbz	r2, 800687e <MIOS32_SPI_RC_PinSet+0x22>
	    MIOS32_SPI0_RCLK1_PORT->BSRR = MIOS32_SPI0_RCLK1_PIN;
 8006878:	2210      	movs	r2, #16
 800687a:	4b19      	ldr	r3, [pc, #100]	; (80068e0 <MIOS32_SPI_RC_PinSet+0x84>)
 800687c:	e01a      	b.n	80068b4 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
 800687e:	2110      	movs	r1, #16
 8006880:	4b17      	ldr	r3, [pc, #92]	; (80068e0 <MIOS32_SPI_RC_PinSet+0x84>)
 8006882:	e026      	b.n	80068d2 <MIOS32_SPI_RC_PinSet+0x76>

        case 1:
	  if( pin_value )
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
	  else
	    MIOS32_SPI0_RCLK2_PORT->BRR  = MIOS32_SPI0_RCLK2_PIN;
 8006884:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 8006888:	b312      	cbz	r2, 80068d0 <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
 800688a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800688e:	e01b      	b.n	80068c8 <MIOS32_SPI_RC_PinSet+0x6c>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 8006890:	bb11      	cbnz	r1, 80068d8 <MIOS32_SPI_RC_PinSet+0x7c>
        case 0:
	  if( pin_value )
 8006892:	b11a      	cbz	r2, 800689c <MIOS32_SPI_RC_PinSet+0x40>
	    MIOS32_SPI1_RCLK1_PORT->BSRR = MIOS32_SPI1_RCLK1_PIN;
 8006894:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8006898:	4b12      	ldr	r3, [pc, #72]	; (80068e4 <MIOS32_SPI_RC_PinSet+0x88>)
 800689a:	e00b      	b.n	80068b4 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI1_RCLK1_PORT->BRR  = MIOS32_SPI1_RCLK1_PIN;
 800689c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80068a0:	4b10      	ldr	r3, [pc, #64]	; (80068e4 <MIOS32_SPI_RC_PinSet+0x88>)
 80068a2:	e016      	b.n	80068d2 <MIOS32_SPI_RC_PinSet+0x76>

    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 80068a4:	b111      	cbz	r1, 80068ac <MIOS32_SPI_RC_PinSet+0x50>
 80068a6:	2901      	cmp	r1, #1
 80068a8:	d116      	bne.n	80068d8 <MIOS32_SPI_RC_PinSet+0x7c>
 80068aa:	e008      	b.n	80068be <MIOS32_SPI_RC_PinSet+0x62>
        case 0:
	  if( pin_value )
 80068ac:	b122      	cbz	r2, 80068b8 <MIOS32_SPI_RC_PinSet+0x5c>
	    MIOS32_SPI2_RCLK1_PORT->BSRR = MIOS32_SPI2_RCLK1_PIN;
 80068ae:	4b0e      	ldr	r3, [pc, #56]	; (80068e8 <MIOS32_SPI_RC_PinSet+0x8c>)
 80068b0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80068b4:	611a      	str	r2, [r3, #16]
 80068b6:	e011      	b.n	80068dc <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
 80068b8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80068bc:	e008      	b.n	80068d0 <MIOS32_SPI_RC_PinSet+0x74>

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 80068be:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 80068c2:	b12a      	cbz	r2, 80068d0 <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 80068c4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80068c8:	4b07      	ldr	r3, [pc, #28]	; (80068e8 <MIOS32_SPI_RC_PinSet+0x8c>)

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 80068ca:	2100      	movs	r1, #0
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 80068cc:	611a      	str	r2, [r3, #16]
 80068ce:	e005      	b.n	80068dc <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 80068d0:	4b05      	ldr	r3, [pc, #20]	; (80068e8 <MIOS32_SPI_RC_PinSet+0x8c>)
 80068d2:	6159      	str	r1, [r3, #20]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 80068d4:	4611      	mov	r1, r2
 80068d6:	e001      	b.n	80068dc <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
	  break;

        default:
	  return -3; // unsupported RC pin
 80068d8:	f06f 0102 	mvn.w	r1, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 80068dc:	4608      	mov	r0, r1
 80068de:	4770      	bx	lr
 80068e0:	40010800 	.word	0x40010800
 80068e4:	40010c00 	.word	0x40010c00
 80068e8:	40011000 	.word	0x40011000

080068ec <MIOS32_SPI_TransferByte>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 80068ec:	2801      	cmp	r0, #1
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported SPI mode configured via MIOS32_SPI_TransferModeInit()
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
 80068ee:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 80068f0:	f000 823c 	beq.w	8006d6c <MIOS32_SPI_TransferByte+0x480>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI0_PTR;
 80068f4:	bf38      	it	cc
 80068f6:	f8df 3490 	ldrcc.w	r3, [pc, #1168]	; 8006d88 <MIOS32_SPI_TransferByte+0x49c>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 80068fa:	f0c0 8238 	bcc.w	8006d6e <MIOS32_SPI_TransferByte+0x482>
 80068fe:	2802      	cmp	r0, #2
      return in_data; // END of SW emulation - EXIT here!
#endif
    } break;

    default:
      return -2; // unsupported SPI port
 8006900:	bf18      	it	ne
 8006902:	f06f 0001 	mvnne.w	r0, #1
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 8006906:	f040 823d 	bne.w	8006d84 <MIOS32_SPI_TransferByte+0x498>
#else
    // Software Emulation
    {
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
 800690a:	f8df 3480 	ldr.w	r3, [pc, #1152]	; 8006d8c <MIOS32_SPI_TransferByte+0x4a0>
 800690e:	781b      	ldrb	r3, [r3, #0]
 8006910:	2b03      	cmp	r3, #3
 8006912:	f200 8235 	bhi.w	8006d80 <MIOS32_SPI_TransferByte+0x494>
 8006916:	e8df f013 	tbh	[pc, r3, lsl #1]
 800691a:	0004      	.short	0x0004
 800691c:	01180096 	.word	0x01180096
 8006920:	01a8      	.short	0x01a8
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006922:	f8df 346c 	ldr.w	r3, [pc, #1132]	; 8006d90 <MIOS32_SPI_TransferByte+0x4a4>
 8006926:	f011 0f80 	tst.w	r1, #128	; 0x80
 800692a:	bf0c      	ite	eq
 800692c:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006930:	2220      	movne	r2, #32
 8006932:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006934:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006936:	f011 0f40 	tst.w	r1, #64	; 0x40
 800693a:	bf0c      	ite	eq
 800693c:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006940:	2020      	movne	r0, #32
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006942:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006944:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 8006946:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006948:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 800694a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 800694c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 800694e:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006950:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006952:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006956:	bf18      	it	ne
 8006958:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 800695a:	f011 0f20 	tst.w	r1, #32
 800695e:	bf0c      	ite	eq
 8006960:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006964:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006966:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006968:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 800696a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 800696c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 800696e:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006970:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006972:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006976:	bf18      	it	ne
 8006978:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 800697a:	f011 0f10 	tst.w	r1, #16
 800697e:	bf0c      	ite	eq
 8006980:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006984:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006986:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006988:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 800698a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 800698c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 800698e:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006992:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006994:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006998:	bf18      	it	ne
 800699a:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 800699e:	f011 0f08 	tst.w	r1, #8
 80069a2:	bf0c      	ite	eq
 80069a4:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069a8:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069aa:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069ac:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069ae:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 80069b0:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 80069b2:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 80069b4:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 80069b8:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 80069bc:	bf18      	it	ne
 80069be:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 80069c0:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 80069c4:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 80069c6:	bf0c      	ite	eq
 80069c8:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069cc:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 80069ce:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 80069d0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069d2:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069d4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 80069d6:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 80069d8:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069da:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 80069dc:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 80069e0:	bf18      	it	ne
 80069e2:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 80069e4:	f011 0f02 	tst.w	r1, #2
 80069e8:	bf0c      	ite	eq
 80069ea:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069ee:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069f0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069f2:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069f4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 80069f6:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 80069f8:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069fa:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 80069fc:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006a00:	bf18      	it	ne
 8006a02:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006a04:	f011 0f01 	tst.w	r1, #1
 8006a08:	bf0c      	ite	eq
 8006a0a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006a0e:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a10:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a12:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a14:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006a16:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006a18:	6899      	ldr	r1, [r3, #8]
 8006a1a:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a1e:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006a22:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a24:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006a26:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a2a:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a2e:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006a32:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006a36:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_1;
 8006a3a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006a3c:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a3e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a40:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a42:	615a      	str	r2, [r3, #20]
	  break;
 8006a44:	e19e      	b.n	8006d84 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006a46:	4bd2      	ldr	r3, [pc, #840]	; (8006d90 <MIOS32_SPI_TransferByte+0x4a4>)
 8006a48:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006a4a:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006a4e:	bf0c      	ite	eq
 8006a50:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a54:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a56:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  break;

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006a5a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006a5c:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a5e:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a60:	bf0c      	ite	eq
 8006a62:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a66:	2020      	movne	r0, #32

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006a68:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a6a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a6c:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a6e:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a70:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a72:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a74:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006a78:	bf18      	it	ne
 8006a7a:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006a7c:	f011 0f20 	tst.w	r1, #32
 8006a80:	bf0c      	ite	eq
 8006a82:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a86:	2020      	movne	r0, #32
 8006a88:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a8a:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006a8c:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a8e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006a90:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006a94:	bf18      	it	ne
 8006a96:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006a98:	f011 0f10 	tst.w	r1, #16
 8006a9c:	bf0c      	ite	eq
 8006a9e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006aa2:	2020      	movne	r0, #32
 8006aa4:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006aa6:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006aa8:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006aac:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006aae:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006ab2:	bf18      	it	ne
 8006ab4:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006ab8:	f011 0f08 	tst.w	r1, #8
 8006abc:	bf0c      	ite	eq
 8006abe:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ac2:	2020      	movne	r0, #32
 8006ac4:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ac6:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006ac8:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006aca:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006ace:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006ad2:	bf18      	it	ne
 8006ad4:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006ad6:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006ada:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006adc:	bf0c      	ite	eq
 8006ade:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ae2:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006ae4:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006ae6:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ae8:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006aea:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006aec:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006aee:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006af2:	bf18      	it	ne
 8006af4:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006af6:	f011 0f02 	tst.w	r1, #2
 8006afa:	bf0c      	ite	eq
 8006afc:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b00:	2020      	movne	r0, #32
 8006b02:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b04:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b06:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b08:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b0a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006b0e:	bf18      	it	ne
 8006b10:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006b12:	f011 0f01 	tst.w	r1, #1
 8006b16:	bf0c      	ite	eq
 8006b18:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006b1c:	2120      	movne	r1, #32
 8006b1e:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b20:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006b22:	689b      	ldr	r3, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b24:	9a01      	ldr	r2, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006b26:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b2a:	ea43 0606 	orr.w	r6, r3, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b2e:	ea46 0505 	orr.w	r5, r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006b32:	ea45 0404 	orr.w	r4, r5, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b36:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b3a:	ea4c 0c02 	orr.w	ip, ip, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b3e:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006b42:	ea47 0000 	orr.w	r0, r7, r0
 8006b46:	b2c0      	uxtb	r0, r0
	  break;
 8006b48:	e11c      	b.n	8006d84 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006b4a:	4b91      	ldr	r3, [pc, #580]	; (8006d90 <MIOS32_SPI_TransferByte+0x4a4>)
 8006b4c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006b50:	bf0c      	ite	eq
 8006b52:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006b56:	2220      	movne	r2, #32
 8006b58:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006b5a:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006b5c:	f011 0f40 	tst.w	r1, #64	; 0x40
 8006b60:	bf0c      	ite	eq
 8006b62:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b66:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006b68:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b6a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b6c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006b6e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b70:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006b72:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b74:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b76:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b78:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006b7c:	bf18      	it	ne
 8006b7e:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006b80:	f011 0f20 	tst.w	r1, #32
 8006b84:	bf0c      	ite	eq
 8006b86:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b8a:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006b8c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006b8e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b90:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006b92:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b94:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b96:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b98:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006b9c:	bf18      	it	ne
 8006b9e:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006ba0:	f011 0f10 	tst.w	r1, #16
 8006ba4:	bf0c      	ite	eq
 8006ba6:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006baa:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bac:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bae:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bb0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006bb2:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006bb4:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bb8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006bba:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006bbe:	bf18      	it	ne
 8006bc0:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006bc4:	f011 0f08 	tst.w	r1, #8
 8006bc8:	bf0c      	ite	eq
 8006bca:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006bce:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bd0:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bd2:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bd4:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006bd6:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006bd8:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006bda:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006bde:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006be2:	bf18      	it	ne
 8006be4:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006be6:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006bea:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006bec:	bf0c      	ite	eq
 8006bee:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006bf2:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bf4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bf6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bf8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bfa:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006bfc:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006bfe:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c00:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c02:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006c06:	bf18      	it	ne
 8006c08:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006c0a:	f011 0f02 	tst.w	r1, #2
 8006c0e:	bf0c      	ite	eq
 8006c10:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c14:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c16:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c18:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c1a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006c1c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c1e:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c20:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c22:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006c26:	bf18      	it	ne
 8006c28:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006c2a:	f011 0f01 	tst.w	r1, #1
 8006c2e:	bf0c      	ite	eq
 8006c30:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006c34:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c36:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c38:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c3a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006c3c:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c3e:	6899      	ldr	r1, [r3, #8]
 8006c40:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c44:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006c48:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c4a:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006c4c:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c50:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c54:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c58:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c5c:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_0;
 8006c60:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c62:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c64:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c66:	615a      	str	r2, [r3, #20]
 8006c68:	e07e      	b.n	8006d68 <MIOS32_SPI_TransferByte+0x47c>
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006c6a:	4b49      	ldr	r3, [pc, #292]	; (8006d90 <MIOS32_SPI_TransferByte+0x4a4>)
 8006c6c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006c70:	bf0c      	ite	eq
 8006c72:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006c76:	2220      	movne	r2, #32
 8006c78:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c7a:	2240      	movs	r2, #64	; 0x40
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006c7c:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
 8006c80:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006c82:	bf0c      	ite	eq
 8006c84:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c88:	2020      	movne	r0, #32
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006c8a:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c8c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006c8e:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c90:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c92:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c94:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c96:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006c9a:	bf18      	it	ne
 8006c9c:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006c9e:	f011 0f20 	tst.w	r1, #32
 8006ca2:	bf0c      	ite	eq
 8006ca4:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ca8:	2020      	movne	r0, #32
 8006caa:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006cac:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006cae:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cb0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006cb2:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006cb6:	bf18      	it	ne
 8006cb8:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006cba:	f011 0f10 	tst.w	r1, #16
 8006cbe:	bf0c      	ite	eq
 8006cc0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006cc4:	2020      	movne	r0, #32
 8006cc6:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006cc8:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006cca:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cce:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006cd0:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006cd4:	bf18      	it	ne
 8006cd6:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006cda:	f011 0f08 	tst.w	r1, #8
 8006cde:	bf0c      	ite	eq
 8006ce0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ce4:	2020      	movne	r0, #32
 8006ce6:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ce8:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006cea:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006cec:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006cf0:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006cf4:	bf18      	it	ne
 8006cf6:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006cf8:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006cfc:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006cfe:	bf0c      	ite	eq
 8006d00:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d04:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006d06:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006d08:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d0a:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d0c:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d0e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d10:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006d14:	bf18      	it	ne
 8006d16:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006d18:	f011 0f02 	tst.w	r1, #2
 8006d1c:	bf0c      	ite	eq
 8006d1e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d22:	2020      	movne	r0, #32
 8006d24:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d26:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006d28:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d2a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006d2c:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006d30:	bf18      	it	ne
 8006d32:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006d34:	f011 0f01 	tst.w	r1, #1
 8006d38:	bf0c      	ite	eq
 8006d3a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006d3e:	2120      	movne	r1, #32
 8006d40:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d42:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006d44:	6899      	ldr	r1, [r3, #8]
 8006d46:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006d4a:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006d4e:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006d50:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d54:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d56:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d5a:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006d5e:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006d62:	ea47 0000 	orr.w	r0, r7, r0
 8006d66:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
 8006d68:	611a      	str	r2, [r3, #16]

        default:
	  return -3; // unsupported SPI mode
      }

      return in_data; // END of SW emulation - EXIT here!
 8006d6a:	e00b      	b.n	8006d84 <MIOS32_SPI_TransferByte+0x498>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI1_PTR;
 8006d6c:	4b09      	ldr	r3, [pc, #36]	; (8006d94 <MIOS32_SPI_TransferByte+0x4a8>)
    default:
      return -2; // unsupported SPI port
  }

  // send byte
  spi_ptr->DR = b;
 8006d6e:	8199      	strh	r1, [r3, #12]

  if( spi_ptr->SR ); // dummy read due to undocumented pipelining issue :-/
 8006d70:	891a      	ldrh	r2, [r3, #8]
  // We use a bus access instead of NOPs to avoid any risk for back-to-back transactions
  // over AHB (if SPI1/SPI2 pointers are used, there is still a risk for such a scenario,
  // e.g. if DMA loads the bus!)

  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );
 8006d72:	891a      	ldrh	r2, [r3, #8]
 8006d74:	f012 0f80 	tst.w	r2, #128	; 0x80
 8006d78:	d1fb      	bne.n	8006d72 <MIOS32_SPI_TransferByte+0x486>

  // return received byte
  return spi_ptr->DR;
 8006d7a:	8998      	ldrh	r0, [r3, #12]
 8006d7c:	b280      	uxth	r0, r0
 8006d7e:	e001      	b.n	8006d84 <MIOS32_SPI_TransferByte+0x498>
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        default:
	  return -3; // unsupported SPI mode
 8006d80:	f06f 0002 	mvn.w	r0, #2
  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );

  // return received byte
  return spi_ptr->DR;
}
 8006d84:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8006d86:	bf00      	nop
 8006d88:	40013000 	.word	0x40013000
 8006d8c:	200001c9 	.word	0x200001c9
 8006d90:	40010c00 	.word	0x40010c00
 8006d94:	40003800 	.word	0x40003800

08006d98 <MIOS32_SPI_TransferModeInit>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006d98:	b530      	push	{r4, r5, lr}
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006d9a:	2300      	movs	r3, #0
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006d9c:	b087      	sub	sp, #28
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006d9e:	f8ad 3004 	strh.w	r3, [sp, #4]
  SPI_InitStructure.SPI_Mode          = SPI_Mode_Master;
 8006da2:	f44f 7382 	mov.w	r3, #260	; 0x104
 8006da6:	f8ad 3006 	strh.w	r3, [sp, #6]
  SPI_InitStructure.SPI_DataSize      = SPI_DataSize_8b;
 8006daa:	2300      	movs	r3, #0
 8006dac:	f8ad 3008 	strh.w	r3, [sp, #8]
  SPI_InitStructure.SPI_NSS           = SPI_NSS_Soft;
 8006db0:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006db4:	f8ad 300e 	strh.w	r3, [sp, #14]
  SPI_InitStructure.SPI_FirstBit      = SPI_FirstBit_MSB;
 8006db8:	2300      	movs	r3, #0
 8006dba:	f8ad 3012 	strh.w	r3, [sp, #18]
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 8006dbe:	2307      	movs	r3, #7
 8006dc0:	f8ad 3014 	strh.w	r3, [sp, #20]

  switch( spi_mode ) {
 8006dc4:	2903      	cmp	r1, #3
 8006dc6:	d85f      	bhi.n	8006e88 <MIOS32_SPI_TransferModeInit+0xf0>
 8006dc8:	e8df f001 	tbb	[pc, r1]
 8006dcc:	0d080602 	.word	0x0d080602
    case MIOS32_SPI_MODE_CLK0_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006dd0:	2300      	movs	r3, #0
 8006dd2:	f8ad 300a 	strh.w	r3, [sp, #10]
 8006dd6:	e00a      	b.n	8006dee <MIOS32_SPI_TransferModeInit+0x56>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK0_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006dd8:	2300      	movs	r3, #0
 8006dda:	e005      	b.n	8006de8 <MIOS32_SPI_TransferModeInit+0x50>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006ddc:	2302      	movs	r3, #2
 8006dde:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8006de2:	2300      	movs	r3, #0
 8006de4:	e003      	b.n	8006dee <MIOS32_SPI_TransferModeInit+0x56>
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006de6:	2302      	movs	r3, #2
 8006de8:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006dec:	2301      	movs	r3, #1
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006dee:	2a07      	cmp	r2, #7
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006df0:	f8ad 300c 	strh.w	r3, [sp, #12]
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected
 8006df4:	bf88      	it	hi
 8006df6:	f06f 0002 	mvnhi.w	r0, #2
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006dfa:	d847      	bhi.n	8006e8c <MIOS32_SPI_TransferModeInit+0xf4>
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006dfc:	2801      	cmp	r0, #1
 8006dfe:	d019      	beq.n	8006e34 <MIOS32_SPI_TransferModeInit+0x9c>
 8006e00:	d305      	bcc.n	8006e0e <MIOS32_SPI_TransferModeInit+0x76>
 8006e02:	2802      	cmp	r0, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 8006e04:	bf18      	it	ne
 8006e06:	f06f 0001 	mvnne.w	r0, #1
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006e0a:	d13f      	bne.n	8006e8c <MIOS32_SPI_TransferModeInit+0xf4>
 8006e0c:	e02b      	b.n	8006e66 <MIOS32_SPI_TransferModeInit+0xce>
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e0e:	4c20      	ldr	r4, [pc, #128]	; (8006e90 <MIOS32_SPI_TransferModeInit+0xf8>)
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e10:	f002 0207 	and.w	r2, r2, #7
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e14:	8825      	ldrh	r5, [r4, #0]
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e16:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006e18:	4620      	mov	r0, r4
 8006e1a:	a901      	add	r1, sp, #4
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e1c:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006e20:	f001 fc8c 	bl	800873c <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006e24:	8820      	ldrh	r0, [r4, #0]
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e26:	b2ad      	uxth	r5, r5
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006e28:	4045      	eors	r5, r0
 8006e2a:	f015 0003 	ands.w	r0, r5, #3
 8006e2e:	d02d      	beq.n	8006e8c <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006e30:	2000      	movs	r0, #0
 8006e32:	e014      	b.n	8006e5e <MIOS32_SPI_TransferModeInit+0xc6>

    case 1: {
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e34:	4b16      	ldr	r3, [pc, #88]	; (8006e90 <MIOS32_SPI_TransferModeInit+0xf8>)
 8006e36:	881c      	ldrh	r4, [r3, #0]
 8006e38:	b2a4      	uxth	r4, r4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
 8006e3a:	b11a      	cbz	r2, 8006e44 <MIOS32_SPI_TransferModeInit+0xac>
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006e3c:	f002 0207 	and.w	r2, r2, #7
 8006e40:	3a01      	subs	r2, #1
 8006e42:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006e44:	4813      	ldr	r0, [pc, #76]	; (8006e94 <MIOS32_SPI_TransferModeInit+0xfc>)
 8006e46:	a901      	add	r1, sp, #4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006e48:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006e4c:	f001 fc76 	bl	800873c <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006e50:	4b0f      	ldr	r3, [pc, #60]	; (8006e90 <MIOS32_SPI_TransferModeInit+0xf8>)
 8006e52:	8818      	ldrh	r0, [r3, #0]
 8006e54:	4044      	eors	r4, r0
 8006e56:	f014 0003 	ands.w	r0, r4, #3
 8006e5a:	d017      	beq.n	8006e8c <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006e5c:	2001      	movs	r0, #1
 8006e5e:	21ff      	movs	r1, #255	; 0xff
 8006e60:	f7ff fd44 	bl	80068ec <MIOS32_SPI_TransferByte>
 8006e64:	e00e      	b.n	8006e84 <MIOS32_SPI_TransferModeInit+0xec>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // no clock prescaler for SW emulated SPI
      // remember mode settings
      sw_spi2_mode = spi_mode;
 8006e66:	4b0c      	ldr	r3, [pc, #48]	; (8006e98 <MIOS32_SPI_TransferModeInit+0x100>)
 8006e68:	7019      	strb	r1, [r3, #0]

      // set clock idle level
      switch( sw_spi2_mode ) {
 8006e6a:	2903      	cmp	r1, #3
 8006e6c:	d80c      	bhi.n	8006e88 <MIOS32_SPI_TransferModeInit+0xf0>
 8006e6e:	e8df f001 	tbb	[pc, r1]
 8006e72:	0202      	.short	0x0202
 8006e74:	0606      	.short	0x0606
        case MIOS32_SPI_MODE_CLK0_PHASE0:
        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_0;
 8006e76:	4b09      	ldr	r3, [pc, #36]	; (8006e9c <MIOS32_SPI_TransferModeInit+0x104>)
 8006e78:	2240      	movs	r2, #64	; 0x40
 8006e7a:	615a      	str	r2, [r3, #20]
 8006e7c:	e002      	b.n	8006e84 <MIOS32_SPI_TransferModeInit+0xec>
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006e7e:	4b07      	ldr	r3, [pc, #28]	; (8006e9c <MIOS32_SPI_TransferModeInit+0x104>)
 8006e80:	2240      	movs	r2, #64	; 0x40
 8006e82:	611a      	str	r2, [r3, #16]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006e84:	2000      	movs	r0, #0
	  MIOS32_SPI2_SET_SCLK_0;
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  break;
 8006e86:	e001      	b.n	8006e8c <MIOS32_SPI_TransferModeInit+0xf4>
        default:
	  return -4; // invalid SPI clock/phase mode
 8006e88:	f06f 0003 	mvn.w	r0, #3
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 8006e8c:	b007      	add	sp, #28
 8006e8e:	bd30      	pop	{r4, r5, pc}
 8006e90:	40013000 	.word	0x40013000
 8006e94:	40003800 	.word	0x40003800
 8006e98:	200001c9 	.word	0x200001c9
 8006e9c:	40010c00 	.word	0x40010c00

08006ea0 <MIOS32_SPI_Init>:
//! Initializes SPI pins
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
 8006ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006ea2:	4604      	mov	r4, r0
 8006ea4:	b08f      	sub	sp, #60	; 0x3c
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8006ea6:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8006eaa:	2c00      	cmp	r4, #0
 8006eac:	f040 80bb 	bne.w	8007026 <MIOS32_SPI_Init+0x186>
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006eb0:	ad03      	add	r5, sp, #12
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006eb2:	4f5e      	ldr	r7, [pc, #376]	; (800702c <MIOS32_SPI_Init+0x18c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006eb4:	4628      	mov	r0, r5
 8006eb6:	f001 fd81 	bl	80089bc <DMA_StructInit>

  // disable callback function
  spi_callback[0] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006eba:	2201      	movs	r2, #1
 8006ebc:	4621      	mov	r1, r4
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006ebe:	603c      	str	r4, [r7, #0]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006ec0:	4620      	mov	r0, r4
 8006ec2:	f7ff fccb 	bl	800685c <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(0, 1, 1); // spi, rc_pin, pin_value
 8006ec6:	2101      	movs	r1, #1
 8006ec8:	460a      	mov	r2, r1
 8006eca:	4620      	mov	r0, r4
 8006ecc:	f7ff fcc6 	bl	800685c <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(0, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006ed0:	2103      	movs	r1, #3
 8006ed2:	4620      	mov	r0, r4
 8006ed4:	f7ff fc12 	bl	80066fc <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB2 == high speed)
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 8006ed8:	2101      	movs	r1, #1
 8006eda:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8006ede:	f001 ff1b 	bl	8008d18 <RCC_APB2PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8006ee2:	2001      	movs	r0, #1
 8006ee4:	4601      	mov	r1, r0
 8006ee6:	f001 ff09 	bl	8008cfc <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
 8006eea:	4851      	ldr	r0, [pc, #324]	; (8007030 <MIOS32_SPI_Init+0x190>)
 8006eec:	4621      	mov	r1, r4
 8006eee:	f001 fd72 	bl	80089d6 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006ef2:	4b50      	ldr	r3, [pc, #320]	; (8007034 <MIOS32_SPI_Init+0x194>)
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006ef4:	2680      	movs	r6, #128	; 0x80
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006ef6:	9303      	str	r3, [sp, #12]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006ef8:	484d      	ldr	r0, [pc, #308]	; (8007030 <MIOS32_SPI_Init+0x190>)
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006efa:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006efe:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f00:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f02:	9301      	str	r3, [sp, #4]
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006f04:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8006f06:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006f08:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006f0a:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f0c:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006f0e:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006f10:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8006f12:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8006f14:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f16:	f001 fd26 	bl	8008966 <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
 8006f1a:	4847      	ldr	r0, [pc, #284]	; (8007038 <MIOS32_SPI_Init+0x198>)
 8006f1c:	4621      	mov	r1, r4
 8006f1e:	f001 fd5a 	bl	80089d6 <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006f22:	f04f 0c10 	mov.w	ip, #16
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006f26:	4844      	ldr	r0, [pc, #272]	; (8007038 <MIOS32_SPI_Init+0x198>)
 8006f28:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006f2a:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006f2e:	f8cd c000 	str.w	ip, [sp]
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006f32:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006f34:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f36:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006f38:	f001 fd15 	bl	8008966 <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(0, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8006f3c:	2206      	movs	r2, #6
 8006f3e:	2103      	movs	r1, #3
 8006f40:	4620      	mov	r0, r4
 8006f42:	f7ff ff29 	bl	8006d98 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI0_PTR, ENABLE);
 8006f46:	2101      	movs	r1, #1
 8006f48:	483c      	ldr	r0, [pc, #240]	; (800703c <MIOS32_SPI_Init+0x19c>)
 8006f4a:	f001 fc24 	bl	8008796 <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI0_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8006f4e:	2201      	movs	r2, #1
 8006f50:	2103      	movs	r1, #3
 8006f52:	483a      	ldr	r0, [pc, #232]	; (800703c <MIOS32_SPI_Init+0x19c>)
 8006f54:	f001 fc2c 	bl	80087b0 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI0_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8006f58:	2105      	movs	r1, #5
 8006f5a:	200c      	movs	r0, #12
 8006f5c:	f7ff fbaa 	bl	80066b4 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[1] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006f60:	2001      	movs	r0, #1
 8006f62:	4621      	mov	r1, r4
 8006f64:	4602      	mov	r2, r0
  // SPI1
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI1

  // disable callback function
  spi_callback[1] = NULL;
 8006f66:	607c      	str	r4, [r7, #4]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006f68:	f7ff fc78 	bl	800685c <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(1, 1, 1); // spi, rc_pin, pin_value
 8006f6c:	2001      	movs	r0, #1
 8006f6e:	4602      	mov	r2, r0
 8006f70:	4601      	mov	r1, r0
 8006f72:	f7ff fc73 	bl	800685c <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(1, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006f76:	2103      	movs	r1, #3
 8006f78:	2001      	movs	r0, #1
 8006f7a:	f7ff fbbf 	bl	80066fc <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB1 == slow speed)
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8006f7e:	2101      	movs	r1, #1
 8006f80:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8006f84:	f001 fed6 	bl	8008d34 <RCC_APB1PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8006f88:	2001      	movs	r0, #1
 8006f8a:	4601      	mov	r1, r0
 8006f8c:	f001 feb6 	bl	8008cfc <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
 8006f90:	482b      	ldr	r0, [pc, #172]	; (8007040 <MIOS32_SPI_Init+0x1a0>)
 8006f92:	4621      	mov	r1, r4
 8006f94:	f001 fd1f 	bl	80089d6 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f98:	9b01      	ldr	r3, [sp, #4]
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8006f9a:	4a2a      	ldr	r2, [pc, #168]	; (8007044 <MIOS32_SPI_Init+0x1a4>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8006f9c:	4828      	ldr	r0, [pc, #160]	; (8007040 <MIOS32_SPI_Init+0x1a0>)
 8006f9e:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006fa0:	930c      	str	r3, [sp, #48]	; 0x30
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8006fa2:	9203      	str	r2, [sp, #12]
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006fa4:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8006fa6:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006fa8:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006faa:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006fac:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006fae:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006fb0:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8006fb2:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8006fb4:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8006fb6:	f001 fcd6 	bl	8008966 <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
 8006fba:	4823      	ldr	r0, [pc, #140]	; (8007048 <MIOS32_SPI_Init+0x1a8>)
 8006fbc:	4621      	mov	r1, r4
 8006fbe:	f001 fd0a 	bl	80089d6 <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006fc2:	f8dd c000 	ldr.w	ip, [sp]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8006fc6:	4820      	ldr	r0, [pc, #128]	; (8007048 <MIOS32_SPI_Init+0x1a8>)
 8006fc8:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006fca:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006fce:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006fd0:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006fd2:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8006fd4:	f001 fcc7 	bl	8008966 <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(1, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8006fd8:	2206      	movs	r2, #6
 8006fda:	2103      	movs	r1, #3
 8006fdc:	2001      	movs	r0, #1
 8006fde:	f7ff fedb 	bl	8006d98 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI1_PTR, ENABLE);
 8006fe2:	2101      	movs	r1, #1
 8006fe4:	4819      	ldr	r0, [pc, #100]	; (800704c <MIOS32_SPI_Init+0x1ac>)
 8006fe6:	f001 fbd6 	bl	8008796 <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI1_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8006fea:	2201      	movs	r2, #1
 8006fec:	2103      	movs	r1, #3
 8006fee:	4817      	ldr	r0, [pc, #92]	; (800704c <MIOS32_SPI_Init+0x1ac>)
 8006ff0:	f001 fbde 	bl	80087b0 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI1_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8006ff4:	2105      	movs	r1, #5
 8006ff6:	200e      	movs	r0, #14
 8006ff8:	f7ff fb5c 	bl	80066b4 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[2] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 8006ffc:	2201      	movs	r2, #1
 8006ffe:	2002      	movs	r0, #2
 8007000:	4621      	mov	r1, r4
  // SPI2 (software emulated)
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI2

  // disable callback function
  spi_callback[2] = NULL;
 8007002:	60bc      	str	r4, [r7, #8]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 8007004:	f7ff fc2a 	bl	800685c <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(2, 1, 1); // spi, rc_pin, pin_value
 8007008:	2101      	movs	r1, #1
 800700a:	460a      	mov	r2, r1
 800700c:	2002      	movs	r0, #2
 800700e:	f7ff fc25 	bl	800685c <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(2, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8007012:	2103      	movs	r1, #3
 8007014:	2002      	movs	r0, #2
 8007016:	f7ff fb71 	bl	80066fc <MIOS32_SPI_IO_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(2, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 800701a:	2002      	movs	r0, #2
 800701c:	2103      	movs	r1, #3
 800701e:	2206      	movs	r2, #6
 8007020:	f7ff feba 	bl	8006d98 <MIOS32_SPI_TransferModeInit>

#endif /* MIOS32_DONT_USE_SPI2 */

  return 0; // no error
 8007024:	4620      	mov	r0, r4
}
 8007026:	b00f      	add	sp, #60	; 0x3c
 8007028:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800702a:	bf00      	nop
 800702c:	200001bc 	.word	0x200001bc
 8007030:	4002001c 	.word	0x4002001c
 8007034:	4001300c 	.word	0x4001300c
 8007038:	40020030 	.word	0x40020030
 800703c:	40013000 	.word	0x40013000
 8007040:	40020044 	.word	0x40020044
 8007044:	4000380c 	.word	0x4000380c
 8007048:	40020058 	.word	0x40020058
 800704c:	40003800 	.word	0x40003800

08007050 <MIOS32_SPI_TransferBlock>:
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if function has been called during an ongoing DMA transfer
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferBlock(u8 spi, u8 *send_buffer, u8 *receive_buffer, u16 len, void *callback)
{
 8007050:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  DMA_Channel_TypeDef *dma_tx_ptr, *dma_rx_ptr;

  switch( spi ) {
 8007052:	2801      	cmp	r0, #1
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if function has been called during an ongoing DMA transfer
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferBlock(u8 spi, u8 *send_buffer, u8 *receive_buffer, u16 len, void *callback)
{
 8007054:	461e      	mov	r6, r3
 8007056:	460c      	mov	r4, r1
 8007058:	4615      	mov	r5, r2
 800705a:	9b08      	ldr	r3, [sp, #32]
  DMA_Channel_TypeDef *dma_tx_ptr, *dma_rx_ptr;

  switch( spi ) {
 800705c:	d034      	beq.n	80070c8 <MIOS32_SPI_TransferBlock+0x78>
 800705e:	d330      	bcc.n	80070c2 <MIOS32_SPI_TransferBlock+0x72>
 8007060:	2802      	cmp	r0, #2
      return 0; // END of SW emulation - EXIT here!
    } break;
#endif

    default:
      return -2; // unsupported SPI port
 8007062:	bf18      	it	ne
 8007064:	f06f 0001 	mvnne.w	r0, #1
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferBlock(u8 spi, u8 *send_buffer, u8 *receive_buffer, u16 len, void *callback)
{
  DMA_Channel_TypeDef *dma_tx_ptr, *dma_rx_ptr;

  switch( spi ) {
 8007068:	d172      	bne.n	8007150 <MIOS32_SPI_TransferBlock+0x100>
    // Software Emulation
    {
      u32 pos;

      // we have 4 cases:
      if( receive_buffer != NULL ) {
 800706a:	b1c2      	cbz	r2, 800709e <MIOS32_SPI_TransferBlock+0x4e>
	if( send_buffer != NULL ) {
 800706c:	b1a1      	cbz	r1, 8007098 <MIOS32_SPI_TransferBlock+0x48>
 800706e:	2700      	movs	r7, #0
 8007070:	e007      	b.n	8007082 <MIOS32_SPI_TransferBlock+0x32>
	  for(pos=0; pos<len; ++pos)
	    *receive_buffer++ = MIOS32_SPI_TransferByte(spi, *send_buffer++);
 8007072:	5de1      	ldrb	r1, [r4, r7]
 8007074:	2002      	movs	r0, #2
 8007076:	9301      	str	r3, [sp, #4]
 8007078:	f7ff fc38 	bl	80068ec <MIOS32_SPI_TransferByte>
 800707c:	55e8      	strb	r0, [r5, r7]
      u32 pos;

      // we have 4 cases:
      if( receive_buffer != NULL ) {
	if( send_buffer != NULL ) {
	  for(pos=0; pos<len; ++pos)
 800707e:	9b01      	ldr	r3, [sp, #4]
 8007080:	3701      	adds	r7, #1
 8007082:	42b7      	cmp	r7, r6
 8007084:	d3f5      	bcc.n	8007072 <MIOS32_SPI_TransferBlock+0x22>
 8007086:	e015      	b.n	80070b4 <MIOS32_SPI_TransferBlock+0x64>
	    *receive_buffer++ = MIOS32_SPI_TransferByte(spi, *send_buffer++);
	} else {
	  for(pos=0; pos<len; ++pos)
	    *receive_buffer++ = MIOS32_SPI_TransferByte(spi, 0xff);
 8007088:	2002      	movs	r0, #2
 800708a:	21ff      	movs	r1, #255	; 0xff
 800708c:	9301      	str	r3, [sp, #4]
 800708e:	f7ff fc2d 	bl	80068ec <MIOS32_SPI_TransferByte>
 8007092:	5528      	strb	r0, [r5, r4]
      if( receive_buffer != NULL ) {
	if( send_buffer != NULL ) {
	  for(pos=0; pos<len; ++pos)
	    *receive_buffer++ = MIOS32_SPI_TransferByte(spi, *send_buffer++);
	} else {
	  for(pos=0; pos<len; ++pos)
 8007094:	9b01      	ldr	r3, [sp, #4]
 8007096:	3401      	adds	r4, #1
 8007098:	42b4      	cmp	r4, r6
 800709a:	d3f5      	bcc.n	8007088 <MIOS32_SPI_TransferBlock+0x38>
 800709c:	e00a      	b.n	80070b4 <MIOS32_SPI_TransferBlock+0x64>
	    *receive_buffer++ = MIOS32_SPI_TransferByte(spi, 0xff);
	}
      } else {
	// TODO: we could use an optimized "send only" function to speed up the SW emulation!
	if( send_buffer != NULL ) {
 800709e:	b939      	cbnz	r1, 80070b0 <MIOS32_SPI_TransferBlock+0x60>
 80070a0:	e008      	b.n	80070b4 <MIOS32_SPI_TransferBlock+0x64>
	  for(pos=0; pos<len; ++pos)
	    MIOS32_SPI_TransferByte(spi, *send_buffer++);
 80070a2:	5d61      	ldrb	r1, [r4, r5]
 80070a4:	2002      	movs	r0, #2
 80070a6:	9301      	str	r3, [sp, #4]
 80070a8:	f7ff fc20 	bl	80068ec <MIOS32_SPI_TransferByte>
	    *receive_buffer++ = MIOS32_SPI_TransferByte(spi, 0xff);
	}
      } else {
	// TODO: we could use an optimized "send only" function to speed up the SW emulation!
	if( send_buffer != NULL ) {
	  for(pos=0; pos<len; ++pos)
 80070ac:	9b01      	ldr	r3, [sp, #4]
 80070ae:	3501      	adds	r5, #1
 80070b0:	42b5      	cmp	r5, r6
 80070b2:	d3f6      	bcc.n	80070a2 <MIOS32_SPI_TransferBlock+0x52>
	  // nothing to do...
	}
      }

      // set callback function
      spi_callback[spi] = callback;
 80070b4:	4a27      	ldr	r2, [pc, #156]	; (8007154 <MIOS32_SPI_TransferBlock+0x104>)
      if( spi_callback[spi] != NULL )
	spi_callback[spi]();

      return 0; // END of SW emulation - EXIT here!
 80070b6:	4618      	mov	r0, r3
	  // nothing to do...
	}
      }

      // set callback function
      spi_callback[spi] = callback;
 80070b8:	6093      	str	r3, [r2, #8]
      if( spi_callback[spi] != NULL )
 80070ba:	2b00      	cmp	r3, #0
 80070bc:	d048      	beq.n	8007150 <MIOS32_SPI_TransferBlock+0x100>
	spi_callback[spi]();
 80070be:	4798      	blx	r3
 80070c0:	e039      	b.n	8007136 <MIOS32_SPI_TransferBlock+0xe6>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      dma_tx_ptr = MIOS32_SPI0_DMA_TX_PTR;
      dma_rx_ptr = MIOS32_SPI0_DMA_RX_PTR;
 80070c2:	4a25      	ldr	r2, [pc, #148]	; (8007158 <MIOS32_SPI_TransferBlock+0x108>)
  switch( spi ) {
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      dma_tx_ptr = MIOS32_SPI0_DMA_TX_PTR;
 80070c4:	4925      	ldr	r1, [pc, #148]	; (800715c <MIOS32_SPI_TransferBlock+0x10c>)
 80070c6:	e001      	b.n	80070cc <MIOS32_SPI_TransferBlock+0x7c>
    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      dma_tx_ptr = MIOS32_SPI1_DMA_TX_PTR;
      dma_rx_ptr = MIOS32_SPI1_DMA_RX_PTR;
 80070c8:	4a25      	ldr	r2, [pc, #148]	; (8007160 <MIOS32_SPI_TransferBlock+0x110>)

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      dma_tx_ptr = MIOS32_SPI1_DMA_TX_PTR;
 80070ca:	4926      	ldr	r1, [pc, #152]	; (8007164 <MIOS32_SPI_TransferBlock+0x114>)
    default:
      return -2; // unsupported SPI port
  }

  // exit if ongoing transfer
  if( dma_rx_ptr->CNDTR )
 80070cc:	6857      	ldr	r7, [r2, #4]
 80070ce:	2f00      	cmp	r7, #0
 80070d0:	d13c      	bne.n	800714c <MIOS32_SPI_TransferBlock+0xfc>
    return -3;

  // set callback function
  spi_callback[spi] = callback;
 80070d2:	f8df c080 	ldr.w	ip, [pc, #128]	; 8007154 <MIOS32_SPI_TransferBlock+0x104>
 80070d6:	f84c 3020 	str.w	r3, [ip, r0, lsl #2]

  // configure Rx channel
  // TK: optimization method: read rx_CCR once, write back only when required
  // the channel must be disabled to configure new values
  u32 rx_CCR = dma_rx_ptr->CCR & ~CCR_ENABLE;
 80070da:	6810      	ldr	r0, [r2, #0]
 80070dc:	f020 0c01 	bic.w	ip, r0, #1
  dma_rx_ptr->CCR = rx_CCR;
 80070e0:	f8c2 c000 	str.w	ip, [r2]
  if( receive_buffer != NULL ) {
 80070e4:	b11d      	cbz	r5, 80070ee <MIOS32_SPI_TransferBlock+0x9e>
    // enable memory addr. increment - bytes written into receive buffer
    dma_rx_ptr->CMAR = (u32)receive_buffer;
 80070e6:	60d5      	str	r5, [r2, #12]
    rx_CCR |= DMA_MemoryInc_Enable;
 80070e8:	f04c 0c80 	orr.w	ip, ip, #128	; 0x80
 80070ec:	e008      	b.n	8007100 <MIOS32_SPI_TransferBlock+0xb0>
  } else {
    // disable memory addr. increment - bytes written into dummy buffer
    rx_dummy_byte = 0xff;
 80070ee:	f8df c078 	ldr.w	ip, [pc, #120]	; 8007168 <MIOS32_SPI_TransferBlock+0x118>
 80070f2:	25ff      	movs	r5, #255	; 0xff
 80070f4:	f88c 5000 	strb.w	r5, [ip]
    dma_rx_ptr->CMAR = (u32)&rx_dummy_byte;
 80070f8:	f8c2 c00c 	str.w	ip, [r2, #12]
    rx_CCR &= ~DMA_MemoryInc_Enable;
 80070fc:	f020 0c81 	bic.w	ip, r0, #129	; 0x81
  }
  dma_rx_ptr->CNDTR = len;
 8007100:	6056      	str	r6, [r2, #4]


  // configure Tx channel
  // TK: optimization method: read tx_CCR once, write back only when required
  // the channel must be disabled to configure new values
  u32 tx_CCR = dma_tx_ptr->CCR & ~CCR_ENABLE;
 8007102:	6808      	ldr	r0, [r1, #0]
    rx_dummy_byte = 0xff;
    dma_rx_ptr->CMAR = (u32)&rx_dummy_byte;
    rx_CCR &= ~DMA_MemoryInc_Enable;
  }
  dma_rx_ptr->CNDTR = len;
  rx_CCR |= CCR_ENABLE;
 8007104:	f04c 0c01 	orr.w	ip, ip, #1


  // configure Tx channel
  // TK: optimization method: read tx_CCR once, write back only when required
  // the channel must be disabled to configure new values
  u32 tx_CCR = dma_tx_ptr->CCR & ~CCR_ENABLE;
 8007108:	f020 0501 	bic.w	r5, r0, #1
  dma_tx_ptr->CCR = tx_CCR;
 800710c:	600d      	str	r5, [r1, #0]
  if( send_buffer != NULL ) {
 800710e:	b11c      	cbz	r4, 8007118 <MIOS32_SPI_TransferBlock+0xc8>
    // enable memory addr. increment - bytes read from send buffer
    dma_tx_ptr->CMAR = (u32)send_buffer;
 8007110:	60cc      	str	r4, [r1, #12]
    tx_CCR |= DMA_MemoryInc_Enable;
 8007112:	f045 0080 	orr.w	r0, r5, #128	; 0x80
 8007116:	e005      	b.n	8007124 <MIOS32_SPI_TransferBlock+0xd4>
  } else {
    // disable memory addr. increment - bytes read from dummy buffer
    tx_dummy_byte = 0xff;
 8007118:	4c14      	ldr	r4, [pc, #80]	; (800716c <MIOS32_SPI_TransferBlock+0x11c>)
 800711a:	25ff      	movs	r5, #255	; 0xff
 800711c:	7025      	strb	r5, [r4, #0]
    dma_tx_ptr->CMAR = (u32)&tx_dummy_byte;
 800711e:	60cc      	str	r4, [r1, #12]
    tx_CCR &= ~DMA_MemoryInc_Enable;
 8007120:	f020 0081 	bic.w	r0, r0, #129	; 0x81
  }
  dma_tx_ptr->CNDTR = len;
 8007124:	604e      	str	r6, [r1, #4]
 8007126:	f040 0001 	orr.w	r0, r0, #1

  // enable DMA interrupt if callback function active
  if( callback != NULL ) {
 800712a:	b133      	cbz	r3, 800713a <MIOS32_SPI_TransferBlock+0xea>
    rx_CCR |= DMA_IT_TC;
 800712c:	f04c 0c02 	orr.w	ip, ip, #2
    dma_rx_ptr->CCR = rx_CCR;
 8007130:	f8c2 c000 	str.w	ip, [r2]

    // start DMA transfer
    dma_tx_ptr->CCR = tx_CCR | CCR_ENABLE;
 8007134:	6008      	str	r0, [r1, #0]

    // if no callback: wait until all bytes have been transmitted/received
    while( dma_rx_ptr->CNDTR );
  }

  return 0; // no error;
 8007136:	2000      	movs	r0, #0
 8007138:	e00a      	b.n	8007150 <MIOS32_SPI_TransferBlock+0x100>
    dma_rx_ptr->CCR = rx_CCR;

    // start DMA transfer
    dma_tx_ptr->CCR = tx_CCR | CCR_ENABLE;
  } else {
    rx_CCR &= ~DMA_IT_TC;
 800713a:	f02c 0c02 	bic.w	ip, ip, #2
    dma_rx_ptr->CCR = rx_CCR;
 800713e:	f8c2 c000 	str.w	ip, [r2]

    // start DMA transfer
    dma_tx_ptr->CCR = tx_CCR | CCR_ENABLE;
 8007142:	6008      	str	r0, [r1, #0]

    // if no callback: wait until all bytes have been transmitted/received
    while( dma_rx_ptr->CNDTR );
 8007144:	6850      	ldr	r0, [r2, #4]
 8007146:	2800      	cmp	r0, #0
 8007148:	d1fc      	bne.n	8007144 <MIOS32_SPI_TransferBlock+0xf4>
 800714a:	e001      	b.n	8007150 <MIOS32_SPI_TransferBlock+0x100>
      return -2; // unsupported SPI port
  }

  // exit if ongoing transfer
  if( dma_rx_ptr->CNDTR )
    return -3;
 800714c:	f06f 0002 	mvn.w	r0, #2
    // if no callback: wait until all bytes have been transmitted/received
    while( dma_rx_ptr->CNDTR );
  }

  return 0; // no error;
}
 8007150:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007152:	bf00      	nop
 8007154:	200001bc 	.word	0x200001bc
 8007158:	4002001c 	.word	0x4002001c
 800715c:	40020030 	.word	0x40020030
 8007160:	40020044 	.word	0x40020044
 8007164:	40020058 	.word	0x40020058
 8007168:	200001ca 	.word	0x200001ca
 800716c:	200001c8 	.word	0x200001c8

08007170 <DMA1_Channel2_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Called when callback function has been defined and SPI transfer has finished
/////////////////////////////////////////////////////////////////////////////
MIOS32_SPI0_DMA_IRQHANDLER_FUNC
{
 8007170:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI0_DMA_RX_IRQ_FLAGS);
 8007172:	20f0      	movs	r0, #240	; 0xf0
 8007174:	f001 fc3a 	bl	80089ec <DMA_ClearFlag>

  if( spi_callback[0] != NULL )
 8007178:	4b02      	ldr	r3, [pc, #8]	; (8007184 <DMA1_Channel2_IRQHandler+0x14>)
 800717a:	681b      	ldr	r3, [r3, #0]
 800717c:	b103      	cbz	r3, 8007180 <DMA1_Channel2_IRQHandler+0x10>
    spi_callback[0]();
 800717e:	4798      	blx	r3
}
 8007180:	bd08      	pop	{r3, pc}
 8007182:	bf00      	nop
 8007184:	200001bc 	.word	0x200001bc

08007188 <DMA1_Channel4_IRQHandler>:

MIOS32_SPI1_DMA_IRQHANDLER_FUNC
{
 8007188:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI1_DMA_RX_IRQ_FLAGS);
 800718a:	f44f 4070 	mov.w	r0, #61440	; 0xf000
 800718e:	f001 fc2d 	bl	80089ec <DMA_ClearFlag>

  if( spi_callback[1] != NULL )
 8007192:	4b02      	ldr	r3, [pc, #8]	; (800719c <DMA1_Channel4_IRQHandler+0x14>)
 8007194:	685b      	ldr	r3, [r3, #4]
 8007196:	b103      	cbz	r3, 800719a <DMA1_Channel4_IRQHandler+0x12>
    spi_callback[1]();
 8007198:	4798      	blx	r3
}
 800719a:	bd08      	pop	{r3, pc}
 800719c:	200001bc 	.word	0x200001bc

080071a0 <MIOS32_BOARD_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 80071a0:	b910      	cbnz	r0, 80071a8 <MIOS32_BOARD_Init+0x8>
    return -1; // unsupported mode

  j5_enable_mask = 0;
 80071a2:	4b03      	ldr	r3, [pc, #12]	; (80071b0 <MIOS32_BOARD_Init+0x10>)
 80071a4:	8018      	strh	r0, [r3, #0]

  return 0; // no error
 80071a6:	e001      	b.n	80071ac <MIOS32_BOARD_Init+0xc>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80071a8:	f04f 30ff 	mov.w	r0, #4294967295

  j5_enable_mask = 0;

  return 0; // no error
}
 80071ac:	4770      	bx	lr
 80071ae:	bf00      	nop
 80071b0:	200001cc 	.word	0x200001cc

080071b4 <MIOS32_BOARD_LED_Init>:
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 80071b4:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80071b6:	ad01      	add	r5, sp, #4
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 80071b8:	4604      	mov	r4, r0
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80071ba:	4628      	mov	r0, r5
 80071bc:	f001 fa66 	bl	800868c <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80071c0:	2310      	movs	r3, #16
 80071c2:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80071c6:	2303      	movs	r3, #3

  // only one LED, connected to PD2
  if( leds & 1 ) {
 80071c8:	f014 0f01 	tst.w	r4, #1
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80071cc:	f88d 3006 	strb.w	r3, [sp, #6]

  // only one LED, connected to PD2
  if( leds & 1 ) {
 80071d0:	d006      	beq.n	80071e0 <MIOS32_BOARD_LED_Init+0x2c>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 80071d2:	2304      	movs	r3, #4
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 80071d4:	4806      	ldr	r0, [pc, #24]	; (80071f0 <MIOS32_BOARD_LED_Init+0x3c>)
 80071d6:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  // only one LED, connected to PD2
  if( leds & 1 ) {
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 80071d8:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 80071dc:	f001 f9fd 	bl	80085da <GPIO_Init>
  }

  if( leds & 0xfffffffe)
 80071e0:	f034 0401 	bics.w	r4, r4, #1
    return -2; // LED doesn't exist
 80071e4:	bf0c      	ite	eq
 80071e6:	4620      	moveq	r0, r4
 80071e8:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 80071ec:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 80071ee:	bf00      	nop
 80071f0:	40011400 	.word	0x40011400

080071f4 <MIOS32_BOARD_LED_Set>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Set(u32 leds, u32 value)
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( leds & 1 ) {
 80071f4:	f010 0f01 	tst.w	r0, #1
 80071f8:	d007      	beq.n	800720a <MIOS32_BOARD_LED_Set+0x16>
    GPIOD->BSRR = (value&1) ? GPIO_Pin_2 : (GPIO_Pin_2 << 16);
 80071fa:	f011 0f01 	tst.w	r1, #1
 80071fe:	4b06      	ldr	r3, [pc, #24]	; (8007218 <MIOS32_BOARD_LED_Set+0x24>)
 8007200:	bf0c      	ite	eq
 8007202:	f44f 2280 	moveq.w	r2, #262144	; 0x40000
 8007206:	2204      	movne	r2, #4
 8007208:	611a      	str	r2, [r3, #16]
  }

  if( leds & 0xfffffffe)
 800720a:	f030 0001 	bics.w	r0, r0, #1
    return -2; // LED doesn't exist
 800720e:	bf18      	it	ne
 8007210:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 8007214:	4770      	bx	lr
 8007216:	bf00      	nop
 8007218:	40011400 	.word	0x40011400

0800721c <MIOS32_BOARD_LED_Get>:
{
  u32 values = 0;

#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( GPIOD->ODR & GPIO_Pin_2 )
 800721c:	4b02      	ldr	r3, [pc, #8]	; (8007228 <MIOS32_BOARD_LED_Get+0xc>)
 800721e:	68d8      	ldr	r0, [r3, #12]
//! Returns the status of all LEDs
//! \return status of all LEDs
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_BOARD_LED_Get(void)
{
  u32 values = 0;
 8007220:	f3c0 0080 	ubfx	r0, r0, #2, #1
  if( GPIOB->ODR & GPIO_Pin_9 )
    values |= (1 << 1);
#endif

  return values;
}
 8007224:	4770      	bx	lr
 8007226:	bf00      	nop
 8007228:	40011400 	.word	0x40011400

0800722c <MIOS32_BOARD_J15_PortInit>:
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 800722c:	2801      	cmp	r0, #1
//!   <LI>1: J15 pins are configured in Open Drain mode (perfect for 3.3V->5V levelshifting)
//! </UL>
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PortInit(u32 mode)
{
 800722e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007230:	4606      	mov	r6, r0
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
    return -1; // unsupported mode
 8007232:	bf88      	it	hi
 8007234:	f04f 30ff 	movhi.w	r0, #4294967295
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 8007238:	d854      	bhi.n	80072e4 <MIOS32_BOARD_J15_PortInit+0xb8>
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800723a:	ad01      	add	r5, sp, #4
 800723c:	4628      	mov	r0, r5
 800723e:	f001 fa25 	bl	800868c <GPIO_StructInit>

  J15_PIN_SCLK_0;
  J15_PIN_RCLK_0;
 8007242:	4c29      	ldr	r4, [pc, #164]	; (80072e8 <MIOS32_BOARD_J15_PortInit+0xbc>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 8007244:	4829      	ldr	r0, [pc, #164]	; (80072ec <MIOS32_BOARD_J15_PortInit+0xc0>)
  J15_PIN_RCLK_0;
  J15_PIN_RW(0);
 8007246:	4a2a      	ldr	r2, [pc, #168]	; (80072f0 <MIOS32_BOARD_J15_PortInit+0xc4>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 8007248:	f44f 7380 	mov.w	r3, #256	; 0x100
  J15_PIN_RCLK_0;
 800724c:	f44f 7700 	mov.w	r7, #512	; 0x200
  J15_PIN_RW(0);
 8007250:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 8007254:	6143      	str	r3, [r0, #20]
  J15_PIN_RCLK_0;
 8007256:	6167      	str	r7, [r4, #20]
  J15_PIN_RW(0);
 8007258:	6111      	str	r1, [r2, #16]
  J15_PIN_E1(0);
 800725a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 800725e:	6122      	str	r2, [r4, #16]
  J15_PIN_E2(0);
 8007260:	f5a2 0280 	sub.w	r2, r2, #4194304	; 0x400000
 8007264:	6122      	str	r2, [r4, #16]
#ifdef MIOS32_BOARD_LCD_E4_PORT
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007266:	2210      	movs	r2, #16
 8007268:	f88d 2007 	strb.w	r2, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 800726c:	4629      	mov	r1, r5
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients
 800726e:	2202      	movs	r2, #2
 8007270:	f88d 2006 	strb.w	r2, [sp, #6]

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
 8007274:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 8007278:	f001 f9af 	bl	80085da <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 800727c:	4620      	mov	r0, r4
 800727e:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
 8007280:	f8ad 7004 	strh.w	r7, [sp, #4]
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 8007284:	f001 f9a9 	bl	80085da <GPIO_Init>

  // configure open-drain pins (if OD option enabled)
  if( mode )
 8007288:	b116      	cbz	r6, 8007290 <MIOS32_BOARD_J15_PortInit+0x64>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 800728a:	2314      	movs	r3, #20
 800728c:	f88d 3007 	strb.w	r3, [sp, #7]

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
 8007290:	ac02      	add	r4, sp, #8
 8007292:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007296:	f824 3d04 	strh.w	r3, [r4, #-4]!
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);
 800729a:	4813      	ldr	r0, [pc, #76]	; (80072e8 <MIOS32_BOARD_J15_PortInit+0xbc>)
 800729c:	4621      	mov	r1, r4
 800729e:	f001 f99c 	bl	80085da <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 80072a2:	2380      	movs	r3, #128	; 0x80
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 80072a4:	4810      	ldr	r0, [pc, #64]	; (80072e8 <MIOS32_BOARD_J15_PortInit+0xbc>)
 80072a6:	4621      	mov	r1, r4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 80072a8:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 80072ac:	f001 f995 	bl	80085da <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 80072b0:	2340      	movs	r3, #64	; 0x40
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 80072b2:	480d      	ldr	r0, [pc, #52]	; (80072e8 <MIOS32_BOARD_J15_PortInit+0xbc>)
 80072b4:	4621      	mov	r1, r4
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 80072b6:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 80072ba:	f001 f98e 	bl	80085da <GPIO_Init>
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 80072be:	2304      	movs	r3, #4
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 80072c0:	480b      	ldr	r0, [pc, #44]	; (80072f0 <MIOS32_BOARD_J15_PortInit+0xc4>)
 80072c2:	4621      	mov	r1, r4
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 80072c4:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 80072c8:	f001 f987 	bl	80085da <GPIO_Init>

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80072cc:	2348      	movs	r3, #72	; 0x48
 80072ce:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 80072d2:	4805      	ldr	r0, [pc, #20]	; (80072e8 <MIOS32_BOARD_J15_PortInit+0xbc>)
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 80072d4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 80072d8:	4621      	mov	r1, r4
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 80072da:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 80072de:	f001 f97c 	bl	80085da <GPIO_Init>

  return 0; // no error
 80072e2:	2000      	movs	r0, #0
#endif
}
 80072e4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80072e6:	bf00      	nop
 80072e8:	40011000 	.word	0x40011000
 80072ec:	40010800 	.word	0x40010800
 80072f0:	40010c00 	.word	0x40010c00

080072f4 <MIOS32_BOARD_J15_DataSet>:
#else
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
 80072f4:	492d      	ldr	r1, [pc, #180]	; (80073ac <MIOS32_BOARD_J15_DataSet+0xb8>)
 80072f6:	f010 0f80 	tst.w	r0, #128	; 0x80
 80072fa:	bf0c      	ite	eq
 80072fc:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 8007300:	f44f 7380 	movne.w	r3, #256	; 0x100
 8007304:	610b      	str	r3, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 8007306:	f44f 7280 	mov.w	r2, #256	; 0x100
 800730a:	4b29      	ldr	r3, [pc, #164]	; (80073b0 <MIOS32_BOARD_J15_DataSet+0xbc>)
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
 800730c:	f010 0f40 	tst.w	r0, #64	; 0x40
 8007310:	bf0c      	ite	eq
 8007312:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007316:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 8007318:	f010 0f20 	tst.w	r0, #32
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
 800731c:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800731e:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x40); // D6
 8007320:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 8007324:	bf0c      	ite	eq
 8007326:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 800732a:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 800732c:	f010 0f10 	tst.w	r0, #16

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
 8007330:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007332:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x20); // D5
 8007334:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 8007338:	bf0c      	ite	eq
 800733a:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 800733e:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 8007340:	f010 0f08 	tst.w	r0, #8
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
 8007344:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007346:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x10); // D4
 8007348:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 800734c:	bf0c      	ite	eq
 800734e:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007352:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 8007354:	f010 0f04 	tst.w	r0, #4
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
 8007358:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800735a:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x08); // D3
 800735c:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 8007360:	bf0c      	ite	eq
 8007362:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007366:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 8007368:	f010 0f02 	tst.w	r0, #2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
 800736c:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800736e:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x04); // D2
 8007370:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 8007374:	bf0c      	ite	eq
 8007376:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 800737a:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x01); // D0
 800737c:	f010 0f01 	tst.w	r0, #1
 8007380:	bf0c      	ite	eq
 8007382:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 8007386:	4610      	movne	r0, r2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
  J15_PIN_SCLK_0; // setup delay
 8007388:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800738a:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x02); // D1
 800738c:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 8007390:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007392:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x01); // D0
 8007394:	6108      	str	r0, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 8007396:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007398:	611a      	str	r2, [r3, #16]

  // transfer to output register
  J15_PIN_RCLK_1;
 800739a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800739e:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_0;

  return 0; // no error
#endif
}
 80073a0:	2000      	movs	r0, #0
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;

  // transfer to output register
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_1;
 80073a2:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
 80073a4:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_0;
 80073a6:	614b      	str	r3, [r1, #20]

  return 0; // no error
#endif
}
 80073a8:	4770      	bx	lr
 80073aa:	bf00      	nop
 80073ac:	40011000 	.word	0x40011000
 80073b0:	40010800 	.word	0x40010800

080073b4 <MIOS32_BOARD_J15_RS_Set>:
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 80073b4:	4b04      	ldr	r3, [pc, #16]	; (80073c8 <MIOS32_BOARD_J15_RS_Set+0x14>)
 80073b6:	2800      	cmp	r0, #0
 80073b8:	bf0c      	ite	eq
 80073ba:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 80073be:	f44f 7080 	movne.w	r0, #256	; 0x100
 80073c2:	6118      	str	r0, [r3, #16]
  J15_PIN_SCLK_0;
#endif

  return 0; // no error
#endif
}
 80073c4:	2000      	movs	r0, #0
 80073c6:	4770      	bx	lr
 80073c8:	40011000 	.word	0x40011000

080073cc <MIOS32_BOARD_J15_RW_Set>:
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80073cc:	4b04      	ldr	r3, [pc, #16]	; (80073e0 <MIOS32_BOARD_J15_RW_Set+0x14>)
 80073ce:	2800      	cmp	r0, #0
 80073d0:	bf0c      	ite	eq
 80073d2:	f44f 2080 	moveq.w	r0, #262144	; 0x40000
 80073d6:	2004      	movne	r0, #4
 80073d8:	6118      	str	r0, [r3, #16]

  return 0; // no error
#endif
}
 80073da:	2000      	movs	r0, #0
 80073dc:	4770      	bx	lr
 80073de:	bf00      	nop
 80073e0:	40010c00 	.word	0x40010c00

080073e4 <MIOS32_BOARD_J15_E_Set>:
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 80073e4:	b128      	cbz	r0, 80073f2 <MIOS32_BOARD_J15_E_Set+0xe>
 80073e6:	2801      	cmp	r0, #1
      return 0; // no error
#endif

  }

  return -1; // pin not available
 80073e8:	bf18      	it	ne
 80073ea:	f04f 30ff 	movne.w	r0, #4294967295
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 80073ee:	d110      	bne.n	8007412 <MIOS32_BOARD_J15_E_Set+0x2e>
 80073f0:	e007      	b.n	8007402 <MIOS32_BOARD_J15_E_Set+0x1e>
    case 0: 
      J15_PIN_E1(e);
 80073f2:	4b08      	ldr	r3, [pc, #32]	; (8007414 <MIOS32_BOARD_J15_E_Set+0x30>)
 80073f4:	2900      	cmp	r1, #0
 80073f6:	bf0c      	ite	eq
 80073f8:	f44f 0100 	moveq.w	r1, #8388608	; 0x800000
 80073fc:	2180      	movne	r1, #128	; 0x80
 80073fe:	6119      	str	r1, [r3, #16]
      return 0; // no error
 8007400:	e007      	b.n	8007412 <MIOS32_BOARD_J15_E_Set+0x2e>

    case 1: 
      J15_PIN_E2(e);
 8007402:	4b04      	ldr	r3, [pc, #16]	; (8007414 <MIOS32_BOARD_J15_E_Set+0x30>)
 8007404:	2900      	cmp	r1, #0
 8007406:	bf0c      	ite	eq
 8007408:	f44f 0180 	moveq.w	r1, #4194304	; 0x400000
 800740c:	2140      	movne	r1, #64	; 0x40
 800740e:	6119      	str	r1, [r3, #16]
      return 0; // no error
 8007410:	2000      	movs	r0, #0

  }

  return -1; // pin not available
#endif
}
 8007412:	4770      	bx	lr
 8007414:	40011000 	.word	0x40011000

08007418 <MIOS32_BOARD_J15_PollUnbusy>:
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 8007418:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 800741a:	4b1a      	ldr	r3, [pc, #104]	; (8007484 <MIOS32_BOARD_J15_PollUnbusy+0x6c>)
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 800741c:	4f1a      	ldr	r7, [pc, #104]	; (8007488 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 800741e:	2604      	movs	r6, #4
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 8007420:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8007424:	611a      	str	r2, [r3, #16]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 8007426:	460c      	mov	r4, r1
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007428:	613e      	str	r6, [r7, #16]

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 800742a:	2101      	movs	r1, #1
 800742c:	9301      	str	r3, [sp, #4]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 800742e:	4605      	mov	r5, r0

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 8007430:	f7ff ffd8 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
 8007434:	9b01      	ldr	r3, [sp, #4]
 8007436:	2800      	cmp	r0, #0

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 8007438:	bfa8      	it	ge
 800743a:	461e      	movge	r6, r3

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 800743c:	db1f      	blt.n	800747e <MIOS32_BOARD_J15_PollUnbusy+0x66>
 800743e:	e012      	b.n	8007466 <MIOS32_BOARD_J15_PollUnbusy+0x4e>
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);
 8007440:	2101      	movs	r1, #1
 8007442:	4628      	mov	r0, r5
 8007444:	f7ff ffce 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
 8007448:	210a      	movs	r1, #10
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 800744a:	4a0f      	ldr	r2, [pc, #60]	; (8007488 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 800744c:	2304      	movs	r3, #4
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 800744e:	f111 31ff 	adds.w	r1, r1, #4294967295
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007452:	6113      	str	r3, [r2, #16]
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 8007454:	d1f9      	bne.n	800744a <MIOS32_BOARD_J15_PollUnbusy+0x32>
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 8007456:	68b7      	ldr	r7, [r6, #8]
    MIOS32_BOARD_J15_E_Set(lcd, 0);
 8007458:	4628      	mov	r0, r5
 800745a:	f7ff ffc3 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
    if( !busy )
 800745e:	f417 5f80 	tst.w	r7, #4096	; 0x1000
 8007462:	d002      	beq.n	800746a <MIOS32_BOARD_J15_PollUnbusy+0x52>
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
 8007464:	3c01      	subs	r4, #1
 8007466:	2c00      	cmp	r4, #0
 8007468:	d1ea      	bne.n	8007440 <MIOS32_BOARD_J15_PollUnbusy+0x28>
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 800746a:	4b07      	ldr	r3, [pc, #28]	; (8007488 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 800746c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 8007470:	2c00      	cmp	r4, #0
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007472:	611a      	str	r2, [r3, #16]
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 8007474:	bf14      	ite	ne
 8007476:	2000      	movne	r0, #0
 8007478:	f06f 0001 	mvneq.w	r0, #1
 800747c:	e001      	b.n	8007482 <MIOS32_BOARD_J15_PollUnbusy+0x6a>
  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available
 800747e:	f04f 30ff 	mov.w	r0, #4294967295
  if( poll_ctr == 0 )
    return -2; // timeout error

  return 0; // no error
#endif
}
 8007482:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007484:	40011000 	.word	0x40011000
 8007488:	40010c00 	.word	0x40010c00

0800748c <TIM2_IRQHandler>:
//! Interrupt handlers
//! \note don't call them directly from application
/////////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_ALLOCATE_TIM2_IRQn
TIMER0_IRQ_HANDLER
{
 800748c:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER0_BASE, TIM_IT_Update) != RESET ) {
 800748e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8007492:	2101      	movs	r1, #1
 8007494:	f001 fb33 	bl	8008afe <TIM_GetITStatus>
 8007498:	b138      	cbz	r0, 80074aa <TIM2_IRQHandler+0x1e>
    TIM_ClearITPendingBit(TIMER0_BASE, TIM_IT_Update);
 800749a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800749e:	2101      	movs	r1, #1
 80074a0:	f001 fb39 	bl	8008b16 <TIM_ClearITPendingBit>
    timer_callback[0]();
 80074a4:	4b01      	ldr	r3, [pc, #4]	; (80074ac <TIM2_IRQHandler+0x20>)
 80074a6:	681b      	ldr	r3, [r3, #0]
 80074a8:	4798      	blx	r3
  }
}
 80074aa:	bd08      	pop	{r3, pc}
 80074ac:	200001d0 	.word	0x200001d0

080074b0 <TIM3_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM3_IRQn
TIMER1_IRQ_HANDLER
{
 80074b0:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER1_BASE, TIM_IT_Update) != RESET ) {
 80074b2:	4806      	ldr	r0, [pc, #24]	; (80074cc <TIM3_IRQHandler+0x1c>)
 80074b4:	2101      	movs	r1, #1
 80074b6:	f001 fb22 	bl	8008afe <TIM_GetITStatus>
 80074ba:	b130      	cbz	r0, 80074ca <TIM3_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER1_BASE, TIM_IT_Update);
 80074bc:	4803      	ldr	r0, [pc, #12]	; (80074cc <TIM3_IRQHandler+0x1c>)
 80074be:	2101      	movs	r1, #1
 80074c0:	f001 fb29 	bl	8008b16 <TIM_ClearITPendingBit>
    timer_callback[1]();
 80074c4:	4b02      	ldr	r3, [pc, #8]	; (80074d0 <TIM3_IRQHandler+0x20>)
 80074c6:	685b      	ldr	r3, [r3, #4]
 80074c8:	4798      	blx	r3
  }
}
 80074ca:	bd08      	pop	{r3, pc}
 80074cc:	40000400 	.word	0x40000400
 80074d0:	200001d0 	.word	0x200001d0

080074d4 <TIM5_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM5_IRQn
TIMER2_IRQ_HANDLER
{
 80074d4:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER2_BASE, TIM_IT_Update) != RESET ) {
 80074d6:	4806      	ldr	r0, [pc, #24]	; (80074f0 <TIM5_IRQHandler+0x1c>)
 80074d8:	2101      	movs	r1, #1
 80074da:	f001 fb10 	bl	8008afe <TIM_GetITStatus>
 80074de:	b130      	cbz	r0, 80074ee <TIM5_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER2_BASE, TIM_IT_Update);
 80074e0:	4803      	ldr	r0, [pc, #12]	; (80074f0 <TIM5_IRQHandler+0x1c>)
 80074e2:	2101      	movs	r1, #1
 80074e4:	f001 fb17 	bl	8008b16 <TIM_ClearITPendingBit>
    timer_callback[2]();
 80074e8:	4b02      	ldr	r3, [pc, #8]	; (80074f4 <TIM5_IRQHandler+0x20>)
 80074ea:	689b      	ldr	r3, [r3, #8]
 80074ec:	4798      	blx	r3
  }
}
 80074ee:	bd08      	pop	{r3, pc}
 80074f0:	40000c00 	.word	0x40000c00
 80074f4:	200001d0 	.word	0x200001d0

080074f8 <MIOS32_DELAY_Init>:
//!
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
 80074f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80074fa:	4604      	mov	r4, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80074fc:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8007500:	b9c4      	cbnz	r4, 8007534 <MIOS32_DELAY_Init+0x3c>
    return -1; // unsupported mode

  // enable timer clock
  if( MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM1 || MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM8 )
    RCC_APB2PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);
 8007502:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8007506:	2101      	movs	r1, #1
 8007508:	f001 fc06 	bl	8008d18 <RCC_APB2PeriphClockCmd>
  else
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
 800750c:	f04f 33ff 	mov.w	r3, #4294967295
 8007510:	f8ad 3008 	strh.w	r3, [sp, #8]
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007514:	4808      	ldr	r0, [pc, #32]	; (8007538 <MIOS32_DELAY_Init+0x40>)
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 8007516:	2347      	movs	r3, #71	; 0x47
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007518:	a901      	add	r1, sp, #4
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 800751a:	f8ad 3004 	strh.w	r3, [sp, #4]
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800751e:	f8ad 400a 	strh.w	r4, [sp, #10]
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8007522:	f8ad 4006 	strh.w	r4, [sp, #6]
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007526:	f001 fa6d 	bl	8008a04 <TIM_TimeBaseInit>

  // enable counter
  TIM_Cmd(MIOS32_DELAY_TIMER, ENABLE);
 800752a:	4803      	ldr	r0, [pc, #12]	; (8007538 <MIOS32_DELAY_Init+0x40>)
 800752c:	2101      	movs	r1, #1
 800752e:	f001 fad9 	bl	8008ae4 <TIM_Cmd>

  return 0; // no error
 8007532:	4620      	mov	r0, r4
}
 8007534:	b004      	add	sp, #16
 8007536:	bd10      	pop	{r4, pc}
 8007538:	40012c00 	.word	0x40012c00

0800753c <MIOS32_DELAY_Wait_uS>:
//! \param[in] uS delay (1..65535 microseconds)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Wait_uS(u16 uS)
{
  u16 start = MIOS32_DELAY_TIMER->CNT;
 800753c:	4b04      	ldr	r3, [pc, #16]	; (8007550 <MIOS32_DELAY_Wait_uS+0x14>)
 800753e:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 8007540:	b292      	uxth	r2, r2

  // note that this even works on 16bit counter wrap-arounds
  while( (u16)(MIOS32_DELAY_TIMER->CNT - start) <= uS );
 8007542:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 8007544:	1a89      	subs	r1, r1, r2
 8007546:	b289      	uxth	r1, r1
 8007548:	4281      	cmp	r1, r0
 800754a:	d9fa      	bls.n	8007542 <MIOS32_DELAY_Wait_uS+0x6>

  return 0; // no error
}
 800754c:	2000      	movs	r0, #0
 800754e:	4770      	bx	lr
 8007550:	40012c00 	.word	0x40012c00

08007554 <MIOS32_AIN_Init>:
  // finally start initial conversion
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0;
#endif
}
 8007554:	f04f 30ff 	mov.w	r0, #4294967295
 8007558:	4770      	bx	lr

0800755a <MIOS32_AIN_Handler>:
  // start next scan
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0; // no error
#endif
}
 800755a:	f04f 30ff 	mov.w	r0, #4294967295
 800755e:	4770      	bx	lr

08007560 <MIOS32_USB_CB_SetDeviceAddress>:
}

// update the device state to addressed
static void MIOS32_USB_CB_SetDeviceAddress (void)
{
  bDeviceState = ADDRESSED;
 8007560:	4b01      	ldr	r3, [pc, #4]	; (8007568 <MIOS32_USB_CB_SetDeviceAddress+0x8>)
 8007562:	2204      	movs	r2, #4
 8007564:	601a      	str	r2, [r3, #0]
}
 8007566:	4770      	bx	lr
 8007568:	200001dc 	.word	0x200001dc

0800756c <MIOS32_USB_CB_Status_In>:
static void MIOS32_USB_CB_Status_In(void)
{
#ifdef MIOS32_USE_USB_COM
  MIOS32_USB_COM_CB_StatusIn();
#endif
}
 800756c:	4770      	bx	lr

0800756e <MIOS32_USB_CB_Status_Out>:

// status OUT routine
static void MIOS32_USB_CB_Status_Out(void)
{
}
 800756e:	4770      	bx	lr

08007570 <MIOS32_USB_CB_Data_Setup>:
  RESULT res;
  if( (res=MIOS32_USB_COM_CB_Data_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif
  return USB_UNSUPPORT;
}
 8007570:	2002      	movs	r0, #2
 8007572:	4770      	bx	lr

08007574 <MIOS32_USB_CB_NoData_Setup>:
  if( (res=MIOS32_USB_COM_CB_NoData_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif

  return USB_UNSUPPORT;
}
 8007574:	2002      	movs	r0, #2
 8007576:	4770      	bx	lr

08007578 <MIOS32_USB_CB_Get_Interface_Setting>:
}

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
 8007578:	b921      	cbnz	r1, 8007584 <MIOS32_USB_CB_Get_Interface_Setting+0xc>
    return USB_UNSUPPORT;
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
 800757a:	2801      	cmp	r0, #1
 800757c:	bf8c      	ite	hi
 800757e:	2002      	movhi	r0, #2
 8007580:	2000      	movls	r0, #0
 8007582:	e000      	b.n	8007586 <MIOS32_USB_CB_Get_Interface_Setting+0xe>

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
    return USB_UNSUPPORT;
 8007584:	2002      	movs	r0, #2
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
  }

  return USB_SUCCESS;
}
 8007586:	4770      	bx	lr

08007588 <MIOS32_USB_CB_SetConfiguration>:
  bDeviceState = ATTACHED;
}

// update the device state to configured.
static void MIOS32_USB_CB_SetConfiguration(void)
{
 8007588:	b508      	push	{r3, lr}
  if (pInformation->Current_Configuration != 0) {
 800758a:	4b05      	ldr	r3, [pc, #20]	; (80075a0 <MIOS32_USB_CB_SetConfiguration+0x18>)
 800758c:	681b      	ldr	r3, [r3, #0]
 800758e:	7a9b      	ldrb	r3, [r3, #10]
 8007590:	b12b      	cbz	r3, 800759e <MIOS32_USB_CB_SetConfiguration+0x16>
#ifndef MIOS32_DONT_USE_USB_MIDI
    // propagate connection state to USB MIDI driver
    MIOS32_USB_MIDI_ChangeConnectionState(1); // connected
 8007592:	2001      	movs	r0, #1
 8007594:	f000 fa92 	bl	8007abc <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
    // propagate connection state to USB COM driver
    MIOS32_USB_COM_ChangeConnectionState(1); // connected
#endif

    bDeviceState = CONFIGURED;
 8007598:	4b02      	ldr	r3, [pc, #8]	; (80075a4 <MIOS32_USB_CB_SetConfiguration+0x1c>)
 800759a:	2205      	movs	r2, #5
 800759c:	601a      	str	r2, [r3, #0]
  }
}
 800759e:	bd08      	pop	{r3, pc}
 80075a0:	200030cc 	.word	0x200030cc
 80075a4:	200001dc 	.word	0x200001dc

080075a8 <MIOS32_USB_CB_GetStringDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 80075a8:	b570      	push	{r4, r5, r6, lr}
 80075aa:	b0c4      	sub	sp, #272	; 0x110
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 80075ac:	493f      	ldr	r1, [pc, #252]	; (80076ac <MIOS32_USB_CB_GetStringDescriptor+0x104>)
 80075ae:	220c      	movs	r2, #12
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 80075b0:	4604      	mov	r4, r0
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 80075b2:	a83d      	add	r0, sp, #244	; 0xf4
 80075b4:	f002 fc56 	bl	8009e64 <memcpy>
  const u8 product_str[] = MIOS32_USB_PRODUCT_STR;
 80075b8:	a842      	add	r0, sp, #264	; 0x108
 80075ba:	493d      	ldr	r1, [pc, #244]	; (80076b0 <MIOS32_USB_CB_GetStringDescriptor+0x108>)
 80075bc:	2207      	movs	r2, #7
 80075be:	f002 fc51 	bl	8009e64 <memcpy>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 80075c2:	4b3c      	ldr	r3, [pc, #240]	; (80076b4 <MIOS32_USB_CB_GetStringDescriptor+0x10c>)
 80075c4:	681b      	ldr	r3, [r3, #0]
 80075c6:	78db      	ldrb	r3, [r3, #3]
 80075c8:	2b03      	cmp	r3, #3
 80075ca:	d86c      	bhi.n	80076a6 <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 80075cc:	e8df f003 	tbb	[pc, r3]
 80075d0:	40020a12 	.word	0x40020a12
 80075d4:	a941      	add	r1, sp, #260	; 0x104
 80075d6:	3103      	adds	r1, #3
 80075d8:	f10d 0206 	add.w	r2, sp, #6
 80075dc:	2302      	movs	r3, #2

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 80075de:	f04f 0c00 	mov.w	ip, #0
 80075e2:	e027      	b.n	8007634 <MIOS32_USB_CB_GetStringDescriptor+0x8c>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 80075e4:	f10d 01f3 	add.w	r1, sp, #243	; 0xf3
 80075e8:	f10d 0206 	add.w	r2, sp, #6
 80075ec:	2302      	movs	r3, #2

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 80075ee:	f04f 0c00 	mov.w	ip, #0
 80075f2:	e00b      	b.n	800760c <MIOS32_USB_CB_GetStringDescriptor+0x64>
  int i;

  switch( pInformation->USBwValue0 ) {
    case 0: // Language
      // buffer[0] and [1] initialized below
      buffer[2] = 0x09;        // CharSet
 80075f4:	aa01      	add	r2, sp, #4
 80075f6:	2309      	movs	r3, #9
 80075f8:	7093      	strb	r3, [r2, #2]
      buffer[3] = 0x04;        // U.S.
 80075fa:	2304      	movs	r3, #4
 80075fc:	70d3      	strb	r3, [r2, #3]
      len = 4;
      break;
 80075fe:	e046      	b.n	800768e <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 8007600:	3302      	adds	r3, #2
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
 8007602:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 8007606:	f802 cc01 	strb.w	ip, [r2, #-1]
 800760a:	b29b      	uxth	r3, r3
      len = 4;
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
 800760c:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007610:	3202      	adds	r2, #2
 8007612:	1e05      	subs	r5, r0, #0
 8007614:	bf18      	it	ne
 8007616:	2501      	movne	r5, #1
 8007618:	2bc7      	cmp	r3, #199	; 0xc7
 800761a:	bf8c      	ite	hi
 800761c:	2500      	movhi	r5, #0
 800761e:	f005 0501 	andls.w	r5, r5, #1
 8007622:	2d00      	cmp	r5, #0
 8007624:	d1ec      	bne.n	8007600 <MIOS32_USB_CB_GetStringDescriptor+0x58>
 8007626:	e032      	b.n	800768e <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 8007628:	3302      	adds	r3, #2
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
 800762a:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 800762e:	f802 cc01 	strb.w	ip, [r2, #-1]
 8007632:	b29b      	uxth	r3, r3
      }
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
 8007634:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007638:	3202      	adds	r2, #2
 800763a:	1e05      	subs	r5, r0, #0
 800763c:	bf18      	it	ne
 800763e:	2501      	movne	r5, #1
 8007640:	2bc7      	cmp	r3, #199	; 0xc7
 8007642:	bf8c      	ite	hi
 8007644:	2500      	movhi	r5, #0
 8007646:	f005 0501 	andls.w	r5, r5, #1
 800764a:	2d00      	cmp	r5, #0
 800764c:	d1ec      	bne.n	8007628 <MIOS32_USB_CB_GetStringDescriptor+0x80>
 800764e:	e01e      	b.n	800768e <MIOS32_USB_CB_GetStringDescriptor+0xe6>
      }
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
 8007650:	ad33      	add	r5, sp, #204	; 0xcc
 8007652:	4628      	mov	r0, r5
 8007654:	f7fe ff2e 	bl	80064b4 <MIOS32_SYS_SerialNumberGet>
 8007658:	2800      	cmp	r0, #0
 800765a:	db24      	blt.n	80076a6 <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 800765c:	3d01      	subs	r5, #1
 800765e:	f10d 0206 	add.w	r2, sp, #6
 8007662:	2302      	movs	r3, #2
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
 8007664:	2000      	movs	r0, #0
 8007666:	e005      	b.n	8007674 <MIOS32_USB_CB_GetStringDescriptor+0xcc>
 8007668:	3302      	adds	r3, #2

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
 800766a:	f802 1c02 	strb.w	r1, [r2, #-2]
	    buffer[len++] = 0;
 800766e:	f802 0c01 	strb.w	r0, [r2, #-1]
 8007672:	b29b      	uxth	r3, r3
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
 8007674:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007678:	3202      	adds	r2, #2
 800767a:	1e0e      	subs	r6, r1, #0
 800767c:	bf18      	it	ne
 800767e:	2601      	movne	r6, #1
 8007680:	2bc7      	cmp	r3, #199	; 0xc7
 8007682:	bf8c      	ite	hi
 8007684:	2600      	movhi	r6, #0
 8007686:	f006 0601 	andls.w	r6, r6, #1
 800768a:	2e00      	cmp	r6, #0
 800768c:	d1ec      	bne.n	8007668 <MIOS32_USB_CB_GetStringDescriptor+0xc0>
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 800768e:	aa01      	add	r2, sp, #4
  buffer[1] = DSCR_STRING; // Descriptor Type
 8007690:	2103      	movs	r1, #3
 8007692:	7051      	strb	r1, [r2, #1]
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 8007694:	7013      	strb	r3, [r2, #0]
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
 8007696:	4620      	mov	r0, r4
 8007698:	a940      	add	r1, sp, #256	; 0x100
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
 800769a:	9240      	str	r2, [sp, #256]	; 0x100
 800769c:	f8ad 3104 	strh.w	r3, [sp, #260]	; 0x104
  return Standard_GetDescriptorData(Length, &desc);
 80076a0:	f001 fe3e 	bl	8009320 <Standard_GetDescriptorData>
 80076a4:	e000      	b.n	80076a8 <MIOS32_USB_CB_GetStringDescriptor+0x100>
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
	  }
	} else
	  return NULL;
 80076a6:	2000      	movs	r0, #0

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
}
 80076a8:	b044      	add	sp, #272	; 0x110
 80076aa:	bd70      	pop	{r4, r5, r6, pc}
 80076ac:	0800a31c 	.word	0x0800a31c
 80076b0:	0800a1c3 	.word	0x0800a1c3
 80076b4:	200030cc 	.word	0x200030cc

080076b8 <MIOS32_USB_CB_GetConfigDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 80076b8:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 80076ba:	4905      	ldr	r1, [pc, #20]	; (80076d0 <MIOS32_USB_CB_GetConfigDescriptor+0x18>)
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 80076bc:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 80076be:	466b      	mov	r3, sp
 80076c0:	c903      	ldmia	r1!, {r0, r1}
 80076c2:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 80076c6:	4610      	mov	r0, r2
 80076c8:	4669      	mov	r1, sp
 80076ca:	f001 fe29 	bl	8009320 <Standard_GetDescriptorData>
}
 80076ce:	bd0e      	pop	{r1, r2, r3, pc}
 80076d0:	0800a330 	.word	0x0800a330

080076d4 <MIOS32_USB_CB_GetDeviceDescriptor>:
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 80076d4:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 80076d6:	4905      	ldr	r1, [pc, #20]	; (80076ec <MIOS32_USB_CB_GetDeviceDescriptor+0x18>)
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 80076d8:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 80076da:	466b      	mov	r3, sp
 80076dc:	c903      	ldmia	r1!, {r0, r1}
 80076de:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 80076e2:	4610      	mov	r0, r2
 80076e4:	4669      	mov	r1, sp
 80076e6:	f001 fe1b 	bl	8009320 <Standard_GetDescriptorData>
}
 80076ea:	bd0e      	pop	{r1, r2, r3, pc}
 80076ec:	0800a328 	.word	0x0800a328

080076f0 <MIOS32_USB_CB_Reset>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
 80076f0:	b538      	push	{r3, r4, r5, lr}
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 80076f2:	4b27      	ldr	r3, [pc, #156]	; (8007790 <MIOS32_USB_CB_Reset+0xa0>)
 80076f4:	2400      	movs	r4, #0
 80076f6:	681b      	ldr	r3, [r3, #0]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 80076f8:	2580      	movs	r5, #128	; 0x80

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 80076fa:	729c      	strb	r4, [r3, #10]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 80076fc:	725d      	strb	r5, [r3, #9]

  // Set MIOS32 Device with the default Interface
  pInformation->Current_Interface = 0;
 80076fe:	72dc      	strb	r4, [r3, #11]

#ifdef STM32F10X_CL   
  // EP0 is already configured in DFU_Init() by USB_SIL_Init() function
#else 
  SetBTABLE(MIOS32_USB_BTABLE_ADDRESS);
 8007700:	4620      	mov	r0, r4
 8007702:	f002 f97b 	bl	80099fc <SetBTABLE>

  // Initialize Endpoint 0
  SetEPType(ENDP0, EP_CONTROL);
 8007706:	4620      	mov	r0, r4
 8007708:	f44f 7100 	mov.w	r1, #512	; 0x200
 800770c:	f002 f980 	bl	8009a10 <SetEPType>
  SetEPTxStatus(ENDP0, EP_TX_STALL);
 8007710:	4620      	mov	r0, r4
 8007712:	2110      	movs	r1, #16
 8007714:	f002 f994 	bl	8009a40 <SetEPTxStatus>
  SetEPRxAddr(ENDP0, MIOS32_USB_ENDP0_RXADDR);
 8007718:	4620      	mov	r0, r4
 800771a:	2140      	movs	r1, #64	; 0x40
 800771c:	f002 fa18 	bl	8009b50 <SetEPRxAddr>
  SetEPTxAddr(ENDP0, MIOS32_USB_ENDP0_TXADDR);
 8007720:	4629      	mov	r1, r5
 8007722:	4620      	mov	r0, r4
 8007724:	f002 fa04 	bl	8009b30 <SetEPTxAddr>
  Clear_Status_Out(ENDP0);
 8007728:	4620      	mov	r0, r4
 800772a:	f002 f9c9 	bl	8009ac0 <Clear_Status_Out>
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 800772e:	4b19      	ldr	r3, [pc, #100]	; (8007794 <MIOS32_USB_CB_Reset+0xa4>)
 8007730:	4620      	mov	r0, r4
 8007732:	681b      	ldr	r3, [r3, #0]
 8007734:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8007738:	f002 fa44 	bl	8009bc4 <SetEPRxCount>
  SetEPRxValid(ENDP0);
 800773c:	4620      	mov	r0, r4
 800773e:	f002 f9ad 	bl	8009a9c <SetEPRxValid>
  
  // Init EP1 OUT
  OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
# else
  // Initialize Endpoint 1
  SetEPType(ENDP1, EP_BULK);
 8007742:	2001      	movs	r0, #1
 8007744:	4621      	mov	r1, r4
 8007746:	f002 f963 	bl	8009a10 <SetEPType>

  SetEPTxAddr(ENDP1, MIOS32_USB_ENDP1_TXADDR);
 800774a:	2001      	movs	r0, #1
 800774c:	21c0      	movs	r1, #192	; 0xc0
 800774e:	f002 f9ef 	bl	8009b30 <SetEPTxAddr>
  SetEPTxCount(ENDP1, MIOS32_USB_MIDI_DATA_OUT_SIZE);
 8007752:	2001      	movs	r0, #1
 8007754:	2140      	movs	r1, #64	; 0x40
 8007756:	f002 fa27 	bl	8009ba8 <SetEPTxCount>
  SetEPTxStatus(ENDP1, EP_TX_NAK);
 800775a:	2001      	movs	r0, #1
 800775c:	2120      	movs	r1, #32
 800775e:	f002 f96f 	bl	8009a40 <SetEPTxStatus>

  SetEPRxAddr(ENDP1, MIOS32_USB_ENDP1_RXADDR);
 8007762:	2001      	movs	r0, #1
 8007764:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007768:	f002 f9f2 	bl	8009b50 <SetEPRxAddr>
  SetEPRxCount(ENDP1, MIOS32_USB_MIDI_DATA_IN_SIZE);
 800776c:	2140      	movs	r1, #64	; 0x40
 800776e:	2001      	movs	r0, #1
 8007770:	f002 fa28 	bl	8009bc4 <SetEPRxCount>
  SetEPRxValid(ENDP1);
 8007774:	2001      	movs	r0, #1
 8007776:	f002 f991 	bl	8009a9c <SetEPRxValid>
# endif
#endif

  // Set this device to response on default address
#ifndef STM32F10X_CL   
  SetDeviceAddress(0);
 800777a:	4620      	mov	r0, r4
 800777c:	f002 f802 	bl	8009784 <SetDeviceAddress>
#endif

#ifndef MIOS32_DONT_USE_USB_MIDI
  // propagate connection state to USB MIDI driver
  MIOS32_USB_MIDI_ChangeConnectionState(0); // not connected
 8007780:	4620      	mov	r0, r4
 8007782:	f000 f99b 	bl	8007abc <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
  // propagate connection state to USB COM driver
  MIOS32_USB_COM_ChangeConnectionState(0); // not connected
#endif

  bDeviceState = ATTACHED;
 8007786:	4b04      	ldr	r3, [pc, #16]	; (8007798 <MIOS32_USB_CB_Reset+0xa8>)
 8007788:	2201      	movs	r2, #1
 800778a:	601a      	str	r2, [r3, #0]
}
 800778c:	bd38      	pop	{r3, r4, r5, pc}
 800778e:	bf00      	nop
 8007790:	200030cc 	.word	0x200030cc
 8007794:	200030c4 	.word	0x200030c4
 8007798:	200001dc 	.word	0x200001dc

0800779c <USB_LP_CAN1_RX0_IRQHandler>:
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  u16 wIstr = _GetISTR();
 800779c:	4b0d      	ldr	r3, [pc, #52]	; (80077d4 <USB_LP_CAN1_RX0_IRQHandler+0x38>)
  }
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
 800779e:	b510      	push	{r4, lr}
  u16 wIstr = _GetISTR();
 80077a0:	681c      	ldr	r4, [r3, #0]
 80077a2:	b2a4      	uxth	r4, r4

  if( wIstr & ISTR_RESET ) {
 80077a4:	f414 6f80 	tst.w	r4, #1024	; 0x400
 80077a8:	d006      	beq.n	80077b8 <USB_LP_CAN1_RX0_IRQHandler+0x1c>
    _SetISTR((u16)CLR_RESET);
 80077aa:	f64f 32ff 	movw	r2, #64511	; 0xfbff
 80077ae:	601a      	str	r2, [r3, #0]
    pProperty->Reset();
 80077b0:	4b09      	ldr	r3, [pc, #36]	; (80077d8 <USB_LP_CAN1_RX0_IRQHandler+0x3c>)
 80077b2:	681b      	ldr	r3, [r3, #0]
 80077b4:	685b      	ldr	r3, [r3, #4]
 80077b6:	4798      	blx	r3
  }

  if( wIstr & ISTR_SOF ) {
 80077b8:	f414 7f00 	tst.w	r4, #512	; 0x200
    _SetISTR((u16)CLR_SOF);
 80077bc:	bf1e      	ittt	ne
 80077be:	4b05      	ldrne	r3, [pc, #20]	; (80077d4 <USB_LP_CAN1_RX0_IRQHandler+0x38>)
 80077c0:	f64f 52ff 	movwne	r2, #65023	; 0xfdff
 80077c4:	601a      	strne	r2, [r3, #0]
  }

  if( wIstr & ISTR_CTR ) {
 80077c6:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 80077ca:	d001      	beq.n	80077d0 <USB_LP_CAN1_RX0_IRQHandler+0x34>
    // servicing of the endpoint correct transfer interrupt
    // clear of the CTR flag into the sub
    CTR_LP();
 80077cc:	f002 f834 	bl	8009838 <CTR_LP>
  }
}
 80077d0:	bd10      	pop	{r4, pc}
 80077d2:	bf00      	nop
 80077d4:	40005c44 	.word	0x40005c44
 80077d8:	200030c4 	.word	0x200030c4

080077dc <MIOS32_USB_IsInitialized>:
//! This function is used by the bootloader to avoid a reconnection, it isn't
//! relevant for typical applications!
//! \return 1 if USB already initialized, 0 if not initialized
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_IsInitialized(void)
{
 80077dc:	b508      	push	{r3, lr}
  // we assume that initialisation has been done when B-Session valid flag is set
  __IO USB_OTG_GREGS *GREGS = (USB_OTG_GREGS *)(USB_OTG_FS_BASE_ADDR + USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  return (GREGS->GOTGCTL & (1 << 19));
#else
  // we assume that initialisation has been done when endpoint 0 contains a value
  return GetEPType(ENDP0) ? 1 : 0;
 80077de:	2000      	movs	r0, #0
 80077e0:	f002 f925 	bl	8009a2e <GetEPType>
 80077e4:	3800      	subs	r0, #0
 80077e6:	bf18      	it	ne
 80077e8:	2001      	movne	r0, #1
#endif
}
 80077ea:	bd08      	pop	{r3, pc}

080077ec <MIOS32_USB_Init>:
//!   </UL>
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_Init(u32 mode)
{
 80077ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80077ee:	4604      	mov	r4, r0
  u32 delay;

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80077f0:	a801      	add	r0, sp, #4
 80077f2:	f000 ff4b 	bl	800868c <GPIO_StructInit>

  // currently only mode 0..2 supported
  if( mode >= 3 )
 80077f6:	2c02      	cmp	r4, #2
    return -1; // unsupported mode
 80077f8:	bf88      	it	hi
 80077fa:	f04f 30ff 	movhi.w	r0, #4294967295

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  // currently only mode 0..2 supported
  if( mode >= 3 )
 80077fe:	d877      	bhi.n	80078f0 <MIOS32_USB_Init+0x104>
    return -1; // unsupported mode

  // clear all USB interrupt requests
#ifdef STM32F10X_CL
#else
  MIOS32_IRQ_Disable();
 8007800:	f7fe ff30 	bl	8006664 <MIOS32_IRQ_Disable>
  _SetCNTR(0); // Interrupt Mask
 8007804:	4b3b      	ldr	r3, [pc, #236]	; (80078f4 <MIOS32_USB_Init+0x108>)
 8007806:	2200      	movs	r2, #0
 8007808:	601a      	str	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 800780a:	f7fe ff41 	bl	8006690 <MIOS32_IRQ_Enable>
#endif

  // if mode != 2: install MIOS32 hooks
  // a local driver can install it's own hooks and call MIOS32_USB_Init(2) to force re-enumeration
  if( mode != 2 ) {
 800780e:	2c02      	cmp	r4, #2
 8007810:	d013      	beq.n	800783a <MIOS32_USB_Init+0x4e>
    pInformation = &My_Device_Info; // Note: usually no need to duplicate this for external drivers
 8007812:	4a39      	ldr	r2, [pc, #228]	; (80078f8 <MIOS32_USB_Init+0x10c>)
 8007814:	4b39      	ldr	r3, [pc, #228]	; (80078fc <MIOS32_USB_Init+0x110>)
 8007816:	601a      	str	r2, [r3, #0]

    // following hooks/pointers should be replaced by external drivers
    memcpy(&Device_Table, (DEVICE *)&My_Device_Table, sizeof(Device_Table));
 8007818:	4b39      	ldr	r3, [pc, #228]	; (8007900 <MIOS32_USB_Init+0x114>)
 800781a:	2205      	movs	r2, #5
 800781c:	701a      	strb	r2, [r3, #0]
 800781e:	2201      	movs	r2, #1
 8007820:	705a      	strb	r2, [r3, #1]
    pProperty = (DEVICE_PROP *)&My_Device_Property;
 8007822:	4a38      	ldr	r2, [pc, #224]	; (8007904 <MIOS32_USB_Init+0x118>)
 8007824:	4b38      	ldr	r3, [pc, #224]	; (8007908 <MIOS32_USB_Init+0x11c>)
 8007826:	601a      	str	r2, [r3, #0]
    pUser_Standard_Requests = (USER_STANDARD_REQUESTS *)&My_User_Standard_Requests;
 8007828:	4a38      	ldr	r2, [pc, #224]	; (800790c <MIOS32_USB_Init+0x120>)
 800782a:	4b39      	ldr	r3, [pc, #228]	; (8007910 <MIOS32_USB_Init+0x124>)
 800782c:	601a      	str	r2, [r3, #0]

#ifndef MIOS32_DONT_USE_USB_MIDI
    pEpInt_IN[0]  = MIOS32_USB_MIDI_EP1_IN_Callback;  // IN  EP1
 800782e:	4a39      	ldr	r2, [pc, #228]	; (8007914 <MIOS32_USB_Init+0x128>)
 8007830:	4b39      	ldr	r3, [pc, #228]	; (8007918 <MIOS32_USB_Init+0x12c>)
 8007832:	601a      	str	r2, [r3, #0]
    pEpInt_OUT[0] = MIOS32_USB_MIDI_EP1_OUT_Callback; // OUT EP1
 8007834:	4a39      	ldr	r2, [pc, #228]	; (800791c <MIOS32_USB_Init+0x130>)
 8007836:	4b3a      	ldr	r3, [pc, #232]	; (8007920 <MIOS32_USB_Init+0x134>)
 8007838:	601a      	str	r2, [r3, #0]
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 800783a:	4d30      	ldr	r5, [pc, #192]	; (80078fc <MIOS32_USB_Init+0x110>)
#endif
  }

  // change connection state to disconnected
#ifndef MIOS32_DONT_USE_USB_MIDI
  MIOS32_USB_MIDI_ChangeConnectionState(0);
 800783c:	2000      	movs	r0, #0
 800783e:	f000 f93d 	bl	8007abc <MIOS32_USB_MIDI_ChangeConnectionState>
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 8007842:	682b      	ldr	r3, [r5, #0]
 8007844:	2202      	movs	r2, #2
 8007846:	721a      	strb	r2, [r3, #8]
  pInformation->Current_Configuration = 0;
 8007848:	2200      	movs	r2, #0
 800784a:	729a      	strb	r2, [r3, #10]

  // if mode == 0: don't initialize USB if not required (important for BSL)
  if( mode == 0 && MIOS32_USB_IsInitialized() ) {
 800784c:	b99c      	cbnz	r4, 8007876 <MIOS32_USB_Init+0x8a>
 800784e:	f7ff ffc5 	bl	80077dc <MIOS32_USB_IsInitialized>
 8007852:	b180      	cbz	r0, 8007876 <MIOS32_USB_Init+0x8a>
    // Init EP1 OUT again
    OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
#else
#ifndef MIOS32_DONT_USE_USB_MIDI
    // release ENDP1 Rx/Tx
    SetEPTxStatus(ENDP1, EP_TX_NAK);
 8007854:	2001      	movs	r0, #1
 8007856:	2120      	movs	r1, #32
 8007858:	f002 f8f2 	bl	8009a40 <SetEPTxStatus>
    SetEPRxValid(ENDP1);
 800785c:	2001      	movs	r0, #1
 800785e:	f002 f91d 	bl	8009a9c <SetEPRxValid>
#endif
#endif

    pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007862:	682b      	ldr	r3, [r5, #0]
 8007864:	2280      	movs	r2, #128	; 0x80
 8007866:	725a      	strb	r2, [r3, #9]
    pInformation->Current_Configuration = 1;
 8007868:	2201      	movs	r2, #1
 800786a:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 800786c:	4b28      	ldr	r3, [pc, #160]	; (8007910 <MIOS32_USB_Init+0x124>)
 800786e:	681b      	ldr	r3, [r3, #0]
 8007870:	685b      	ldr	r3, [r3, #4]
 8007872:	4798      	blx	r3
 8007874:	e02d      	b.n	80078d2 <MIOS32_USB_Init+0xe6>
    
    // connect device
    USB_DevConnect();
#else
    // force USB reset and power-down (this will also release the USB pins for direct GPIO control)
    _SetCNTR(CNTR_FRES | CNTR_PDWN);
 8007876:	4a1f      	ldr	r2, [pc, #124]	; (80078f4 <MIOS32_USB_Init+0x108>)
 8007878:	2303      	movs	r3, #3
 800787a:	6013      	str	r3, [r2, #0]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 800787c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8007880:	f8ad 2004 	strh.w	r2, [sp, #4]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007884:	a901      	add	r1, sp, #4
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007886:	2210      	movs	r2, #16
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007888:	4826      	ldr	r0, [pc, #152]	; (8007924 <MIOS32_USB_Init+0x138>)
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 800788a:	f88d 2007 	strb.w	r2, [sp, #7]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800788e:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007892:	f000 fea2 	bl	80085da <GPIO_Init>
 8007896:	4b24      	ldr	r3, [pc, #144]	; (8007928 <MIOS32_USB_Init+0x13c>)

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 8007898:	4922      	ldr	r1, [pc, #136]	; (8007924 <MIOS32_USB_Init+0x138>)
 800789a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 800789e:	f113 33ff 	adds.w	r3, r3, #4294967295
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 80078a2:	614a      	str	r2, [r1, #20]
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 80078a4:	d1fb      	bne.n	800789e <MIOS32_USB_Init+0xb2>
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 80078a6:	4a13      	ldr	r2, [pc, #76]	; (80078f4 <MIOS32_USB_Init+0x108>)
 80078a8:	2102      	movs	r1, #2
 80078aa:	6011      	str	r1, [r2, #0]

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 80078ac:	4a1d      	ldr	r2, [pc, #116]	; (8007924 <MIOS32_USB_Init+0x138>)
    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 80078ae:	200a      	movs	r0, #10

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 80078b0:	f110 30ff 	adds.w	r0, r0, #4294967295
 80078b4:	6153      	str	r3, [r2, #20]
 80078b6:	d1fb      	bne.n	80078b0 <MIOS32_USB_Init+0xc4>

    // CNTR_FRES = 0
    _SetCNTR(0);
 80078b8:	4b0e      	ldr	r3, [pc, #56]	; (80078f4 <MIOS32_USB_Init+0x108>)
 80078ba:	6018      	str	r0, [r3, #0]

    // Clear pending interrupts
    _SetISTR(0);
 80078bc:	3304      	adds	r3, #4
 80078be:	6018      	str	r0, [r3, #0]

    // Configure USB clock
    // USBCLK = PLLCLK / 1.5
    RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
 80078c0:	f001 f9aa 	bl	8008c18 <RCC_USBCLKConfig>
    // Enable USB clock
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
 80078c4:	2101      	movs	r1, #1
 80078c6:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80078ca:	f001 fa33 	bl	8008d34 <RCC_APB1PeriphClockCmd>
#endif /* STM32F10X_CL */

  }

  // don't set interrupt mask on custom driver installation
  if( mode != 2 ) {
 80078ce:	2c02      	cmp	r4, #2
 80078d0:	d006      	beq.n	80078e0 <MIOS32_USB_Init+0xf4>
#ifdef STM32F10X_CL
    OTGD_FS_EnableGlobalInt();
#else
    // clear pending interrupts (again)
    _SetISTR(0);
 80078d2:	4b16      	ldr	r3, [pc, #88]	; (800792c <MIOS32_USB_Init+0x140>)
 80078d4:	2200      	movs	r2, #0
 80078d6:	601a      	str	r2, [r3, #0]

    // set interrupts mask
    _SetCNTR(IMR_MSK); // Interrupt mask
 80078d8:	f502 4204 	add.w	r2, r2, #33792	; 0x8400
 80078dc:	3b04      	subs	r3, #4
 80078de:	601a      	str	r2, [r3, #0]
#endif
  }

  bDeviceState = UNCONNECTED;
 80078e0:	4b13      	ldr	r3, [pc, #76]	; (8007930 <MIOS32_USB_Init+0x144>)
 80078e2:	2400      	movs	r4, #0
 80078e4:	601c      	str	r4, [r3, #0]
#ifdef STM32F10X_CL
  // Enable the USB interrupts
  MIOS32_IRQ_Install(OTG_FS_IRQn, MIOS32_IRQ_USB_PRIORITY);
#else
  // enable USB interrupts (unfortunately shared with CAN Rx0, as either CAN or USB can be used, but not at the same time)
  MIOS32_IRQ_Install(USB_LP_CAN1_RX0_IRQn, MIOS32_IRQ_USB_PRIORITY);
 80078e6:	2014      	movs	r0, #20
 80078e8:	2108      	movs	r1, #8
 80078ea:	f7fe fee3 	bl	80066b4 <MIOS32_IRQ_Install>
#endif

  return 0; // no error
 80078ee:	4620      	mov	r0, r4
}
 80078f0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 80078f2:	bf00      	nop
 80078f4:	40005c40 	.word	0x40005c40
 80078f8:	200001e0 	.word	0x200001e0
 80078fc:	200030cc 	.word	0x200030cc
 8007900:	200030d0 	.word	0x200030d0
 8007904:	0800a2ec 	.word	0x0800a2ec
 8007908:	200030c4 	.word	0x200030c4
 800790c:	0800a2b4 	.word	0x0800a2b4
 8007910:	200030c8 	.word	0x200030c8
 8007914:	08007c31 	.word	0x08007c31
 8007918:	2000000c 	.word	0x2000000c
 800791c:	08007c45 	.word	0x08007c45
 8007920:	20000028 	.word	0x20000028
 8007924:	40010800 	.word	0x40010800
 8007928:	00030d40 	.word	0x00030d40
 800792c:	40005c44 	.word	0x40005c44
 8007930:	200001dc 	.word	0x200001dc

08007934 <MIOS32_USB_MIDI_RxBufferHandler>:

/////////////////////////////////////////////////////////////////////////////
// This handler receives new packages if the Tx buffer is not full
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_RxBufferHandler(void)
{
 8007934:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  s16 count;

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 8007936:	f7fe fe95 	bl	8006664 <MIOS32_IRQ_Disable>

      OTGD_FS_EPStartXfer(ep);
    }
  }
#else
  if( rx_buffer_new_data && (count=GetEPRxCount(ENDP1)>>2) ) {
 800793a:	4b23      	ldr	r3, [pc, #140]	; (80079c8 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 800793c:	781b      	ldrb	r3, [r3, #0]
 800793e:	2b00      	cmp	r3, #0
 8007940:	d03f      	beq.n	80079c2 <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007942:	2001      	movs	r0, #1
 8007944:	f002 f95e 	bl	8009c04 <GetEPRxCount>
 8007948:	f3c0 058f 	ubfx	r5, r0, #2, #16
 800794c:	2d00      	cmp	r5, #0
 800794e:	d038      	beq.n	80079c2 <MIOS32_USB_MIDI_RxBufferHandler+0x8e>

    // check if buffer is free
    if( count < (MIOS32_USB_MIDI_RX_BUFFER_SIZE-rx_buffer_size) ) {
 8007950:	4b1e      	ldr	r3, [pc, #120]	; (80079cc <MIOS32_USB_MIDI_RxBufferHandler+0x98>)
 8007952:	b229      	sxth	r1, r5
 8007954:	881a      	ldrh	r2, [r3, #0]
 8007956:	b292      	uxth	r2, r2
 8007958:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
 800795c:	4291      	cmp	r1, r2
 800795e:	da30      	bge.n	80079c2 <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007960:	4e1b      	ldr	r6, [pc, #108]	; (80079d0 <MIOS32_USB_MIDI_RxBufferHandler+0x9c>)
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007962:	4c1c      	ldr	r4, [pc, #112]	; (80079d4 <MIOS32_USB_MIDI_RxBufferHandler+0xa0>)
 8007964:	4a1c      	ldr	r2, [pc, #112]	; (80079d8 <MIOS32_USB_MIDI_RxBufferHandler+0xa4>)
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007966:	f836 1c08 	ldrh.w	r1, [r6, #-8]
 800796a:	f836 7c04 	ldrh.w	r7, [r6, #-4]

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 800796e:	9201      	str	r2, [sp, #4]
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007970:	ea41 4707 	orr.w	r7, r1, r7, lsl #16

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8007974:	f3c7 1003 	ubfx	r0, r7, #4, #4
 8007978:	3010      	adds	r0, #16
 800797a:	4639      	mov	r1, r7
 800797c:	9300      	str	r3, [sp, #0]
 800797e:	f7fe fb11 	bl	8005fa4 <MIOS32_MIDI_SendPackageToRxCallback>
 8007982:	9a01      	ldr	r2, [sp, #4]
 8007984:	9b00      	ldr	r3, [sp, #0]
 8007986:	b980      	cbnz	r0, 80079aa <MIOS32_USB_MIDI_RxBufferHandler+0x76>
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007988:	8821      	ldrh	r1, [r4, #0]
 800798a:	b289      	uxth	r1, r1
 800798c:	f842 7021 	str.w	r7, [r2, r1, lsl #2]

	  if( ++rx_buffer_head >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8007990:	8821      	ldrh	r1, [r4, #0]
 8007992:	3101      	adds	r1, #1
 8007994:	b289      	uxth	r1, r1
 8007996:	8021      	strh	r1, [r4, #0]
 8007998:	8821      	ldrh	r1, [r4, #0]
 800799a:	b289      	uxth	r1, r1
 800799c:	293f      	cmp	r1, #63	; 0x3f
	    rx_buffer_head = 0;
 800799e:	bf88      	it	hi
 80079a0:	8020      	strhhi	r0, [r4, #0]
	  ++rx_buffer_size;
 80079a2:	8819      	ldrh	r1, [r3, #0]
 80079a4:	3101      	adds	r1, #1
 80079a6:	b289      	uxth	r1, r1
 80079a8:	8019      	strh	r1, [r3, #0]
	}
      } while( --count > 0 );
 80079aa:	3d01      	subs	r5, #1
 80079ac:	b2ad      	uxth	r5, r5
 80079ae:	b229      	sxth	r1, r5
 80079b0:	3608      	adds	r6, #8
 80079b2:	2900      	cmp	r1, #0
 80079b4:	dcd7      	bgt.n	8007966 <MIOS32_USB_MIDI_RxBufferHandler+0x32>

      // notify, that data has been put into buffer
      rx_buffer_new_data = 0;
 80079b6:	4b04      	ldr	r3, [pc, #16]	; (80079c8 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 80079b8:	2200      	movs	r2, #0
 80079ba:	701a      	strb	r2, [r3, #0]

      // release OUT pipe
      SetEPRxValid(ENDP1);
 80079bc:	2001      	movs	r0, #1
 80079be:	f002 f86d 	bl	8009a9c <SetEPRxValid>
    }
  }
#endif
  MIOS32_IRQ_Enable();
 80079c2:	f7fe fe65 	bl	8006690 <MIOS32_IRQ_Enable>
}
 80079c6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80079c8:	20000404 	.word	0x20000404
 80079cc:	200001fc 	.word	0x200001fc
 80079d0:	40006208 	.word	0x40006208
 80079d4:	20000406 	.word	0x20000406
 80079d8:	20000304 	.word	0x20000304

080079dc <MIOS32_USB_MIDI_TxBufferHandler>:
/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
{
 80079dc:	b510      	push	{r4, lr}
  //   - last transfer finished
  //   - new packages are in the buffer
  //   - the device is configured

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 80079de:	f7fe fe41 	bl	8006664 <MIOS32_IRQ_Disable>
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
	tx_buffer_tail = 0;
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
 80079e2:	4b2c      	ldr	r3, [pc, #176]	; (8007a94 <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
 80079e4:	781b      	ldrb	r3, [r3, #0]
 80079e6:	2b00      	cmp	r3, #0
 80079e8:	d150      	bne.n	8007a8c <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 80079ea:	4b2b      	ldr	r3, [pc, #172]	; (8007a98 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)
 80079ec:	881a      	ldrh	r2, [r3, #0]
 80079ee:	b292      	uxth	r2, r2
 80079f0:	2a00      	cmp	r2, #0
 80079f2:	d04b      	beq.n	8007a8c <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 80079f4:	4a29      	ldr	r2, [pc, #164]	; (8007a9c <MIOS32_USB_MIDI_TxBufferHandler+0xc0>)
 80079f6:	7812      	ldrb	r2, [r2, #0]
 80079f8:	2a00      	cmp	r2, #0
 80079fa:	d047      	beq.n	8007a8c <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 80079fc:	881a      	ldrh	r2, [r3, #0]
 80079fe:	b292      	uxth	r2, r2
 8007a00:	2a10      	cmp	r2, #16
 8007a02:	bf98      	it	ls
 8007a04:	881c      	ldrhls	r4, [r3, #0]

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007a06:	4b23      	ldr	r3, [pc, #140]	; (8007a94 <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8007a08:	bf94      	ite	ls
 8007a0a:	b2a4      	uxthls	r4, r4
 8007a0c:	2410      	movhi	r4, #16

    // notify that new package is sent
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007a0e:	b2a4      	uxth	r4, r4
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007a10:	2001      	movs	r0, #1

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007a12:	00a1      	lsls	r1, r4, #2
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007a14:	7018      	strb	r0, [r3, #0]

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007a16:	b289      	uxth	r1, r1
 8007a18:	f002 f8c6 	bl	8009ba8 <SetEPTxCount>

    tx_buffer_size -= count;
 8007a1c:	4b1e      	ldr	r3, [pc, #120]	; (8007a98 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007a1e:	4920      	ldr	r1, [pc, #128]	; (8007aa0 <MIOS32_USB_MIDI_TxBufferHandler+0xc4>)
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);

    tx_buffer_size -= count;
 8007a20:	881a      	ldrh	r2, [r3, #0]
 8007a22:	1b12      	subs	r2, r2, r4
 8007a24:	b292      	uxth	r2, r2
 8007a26:	801a      	strh	r2, [r3, #0]

/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
 8007a28:	3c01      	subs	r4, #1
 8007a2a:	4b1e      	ldr	r3, [pc, #120]	; (8007aa4 <MIOS32_USB_MIDI_TxBufferHandler+0xc8>)
 8007a2c:	b2a4      	uxth	r4, r4
 8007a2e:	18e3      	adds	r3, r4, r3
 8007a30:	00d8      	lsls	r0, r3, #3
 8007a32:	4a1d      	ldr	r2, [pc, #116]	; (8007aa8 <MIOS32_USB_MIDI_TxBufferHandler+0xcc>)

    tx_buffer_size -= count;

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007a34:	4b1d      	ldr	r3, [pc, #116]	; (8007aac <MIOS32_USB_MIDI_TxBufferHandler+0xd0>)
 8007a36:	f8b3 c000 	ldrh.w	ip, [r3]
 8007a3a:	fa1f fc8c 	uxth.w	ip, ip
 8007a3e:	f831 c02c 	ldrh.w	ip, [r1, ip, lsl #2]
 8007a42:	f842 cc08 	str.w	ip, [r2, #-8]
      *pma_addr++ = (tx_buffer[tx_buffer_tail]>>16) & 0xffff;
 8007a46:	f8b3 c000 	ldrh.w	ip, [r3]
 8007a4a:	fa1f fc8c 	uxth.w	ip, ip
 8007a4e:	f851 c02c 	ldr.w	ip, [r1, ip, lsl #2]
 8007a52:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8007a56:	f842 cc04 	str.w	ip, [r2, #-4]
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007a5a:	f8b3 c000 	ldrh.w	ip, [r3]
 8007a5e:	f10c 0c01 	add.w	ip, ip, #1
 8007a62:	fa1f fc8c 	uxth.w	ip, ip
 8007a66:	f8a3 c000 	strh.w	ip, [r3]
 8007a6a:	f8b3 c000 	ldrh.w	ip, [r3]
 8007a6e:	fa1f fc8c 	uxth.w	ip, ip
 8007a72:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
	tx_buffer_tail = 0;
 8007a76:	bf84      	itt	hi
 8007a78:	f04f 0c00 	movhi.w	ip, #0
 8007a7c:	f8a3 c000 	strhhi.w	ip, [r3]
 8007a80:	3208      	adds	r2, #8
    } while( --count );
 8007a82:	4282      	cmp	r2, r0
 8007a84:	d1d7      	bne.n	8007a36 <MIOS32_USB_MIDI_TxBufferHandler+0x5a>

    // send buffer
    SetEPTxValid(ENDP1);
 8007a86:	2001      	movs	r0, #1
 8007a88:	f001 fff6 	bl	8009a78 <SetEPTxValid>
  }
#endif
  MIOS32_IRQ_Enable();
 8007a8c:	f7fe fe00 	bl	8006690 <MIOS32_IRQ_Enable>
}
 8007a90:	bd10      	pop	{r4, pc}
 8007a92:	bf00      	nop
 8007a94:	20000300 	.word	0x20000300
 8007a98:	20000408 	.word	0x20000408
 8007a9c:	2000040e 	.word	0x2000040e
 8007aa0:	20000200 	.word	0x20000200
 8007aa4:	08000c32 	.word	0x08000c32
 8007aa8:	40006188 	.word	0x40006188
 8007aac:	2000040a 	.word	0x2000040a

08007ab0 <MIOS32_USB_MIDI_Init>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007ab0:	2800      	cmp	r0, #0
 8007ab2:	bf14      	ite	ne
 8007ab4:	f04f 30ff 	movne.w	r0, #4294967295
 8007ab8:	2000      	moveq	r0, #0

  return 0; // no error
}
 8007aba:	4770      	bx	lr

08007abc <MIOS32_USB_MIDI_ChangeConnectionState>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_ChangeConnectionState(u8 connected)
{
  // in all cases: re-initialize USB MIDI driver
  // clear buffer counters and busy/wait signals again (e.g., so that no invalid data will be sent out)
  rx_buffer_tail = rx_buffer_head = rx_buffer_size = 0;
 8007abc:	4a10      	ldr	r2, [pc, #64]	; (8007b00 <MIOS32_USB_MIDI_ChangeConnectionState+0x44>)
 8007abe:	2300      	movs	r3, #0
 8007ac0:	8013      	strh	r3, [r2, #0]
 8007ac2:	8811      	ldrh	r1, [r2, #0]
 8007ac4:	4a0f      	ldr	r2, [pc, #60]	; (8007b04 <MIOS32_USB_MIDI_ChangeConnectionState+0x48>)
 8007ac6:	b289      	uxth	r1, r1
 8007ac8:	8011      	strh	r1, [r2, #0]
 8007aca:	8811      	ldrh	r1, [r2, #0]
 8007acc:	4a0e      	ldr	r2, [pc, #56]	; (8007b08 <MIOS32_USB_MIDI_ChangeConnectionState+0x4c>)
 8007ace:	b289      	uxth	r1, r1
 8007ad0:	8011      	strh	r1, [r2, #0]
  rx_buffer_new_data = 0; // no data received yet
 8007ad2:	4a0e      	ldr	r2, [pc, #56]	; (8007b0c <MIOS32_USB_MIDI_ChangeConnectionState+0x50>)
 8007ad4:	7013      	strb	r3, [r2, #0]
  tx_buffer_tail = tx_buffer_head = tx_buffer_size = 0;
 8007ad6:	4a0e      	ldr	r2, [pc, #56]	; (8007b10 <MIOS32_USB_MIDI_ChangeConnectionState+0x54>)
 8007ad8:	8013      	strh	r3, [r2, #0]
 8007ada:	8811      	ldrh	r1, [r2, #0]
 8007adc:	4a0d      	ldr	r2, [pc, #52]	; (8007b14 <MIOS32_USB_MIDI_ChangeConnectionState+0x58>)
 8007ade:	b289      	uxth	r1, r1
 8007ae0:	8011      	strh	r1, [r2, #0]
 8007ae2:	8811      	ldrh	r1, [r2, #0]
 8007ae4:	4a0c      	ldr	r2, [pc, #48]	; (8007b18 <MIOS32_USB_MIDI_ChangeConnectionState+0x5c>)
 8007ae6:	b289      	uxth	r1, r1
 8007ae8:	8011      	strh	r1, [r2, #0]
 8007aea:	490c      	ldr	r1, [pc, #48]	; (8007b1c <MIOS32_USB_MIDI_ChangeConnectionState+0x60>)
 8007aec:	4a0c      	ldr	r2, [pc, #48]	; (8007b20 <MIOS32_USB_MIDI_ChangeConnectionState+0x64>)

  if( connected ) {
 8007aee:	b110      	cbz	r0, 8007af6 <MIOS32_USB_MIDI_ChangeConnectionState+0x3a>
    transfer_possible = 1;
 8007af0:	2001      	movs	r0, #1
 8007af2:	7008      	strb	r0, [r1, #0]
 8007af4:	e001      	b.n	8007afa <MIOS32_USB_MIDI_ChangeConnectionState+0x3e>
    tx_buffer_busy = 0; // buffer not busy anymore
  } else {
    // cable disconnected: disable transfers
    transfer_possible = 0;
 8007af6:	700b      	strb	r3, [r1, #0]
    tx_buffer_busy = 1; // buffer busy
 8007af8:	2301      	movs	r3, #1
 8007afa:	7013      	strb	r3, [r2, #0]
  }

  return 0; // no error
}
 8007afc:	2000      	movs	r0, #0
 8007afe:	4770      	bx	lr
 8007b00:	200001fc 	.word	0x200001fc
 8007b04:	20000406 	.word	0x20000406
 8007b08:	200001fe 	.word	0x200001fe
 8007b0c:	20000404 	.word	0x20000404
 8007b10:	20000408 	.word	0x20000408
 8007b14:	20000410 	.word	0x20000410
 8007b18:	2000040a 	.word	0x2000040a
 8007b1c:	2000040e 	.word	0x2000040e
 8007b20:	20000300 	.word	0x20000300

08007b24 <MIOS32_USB_MIDI_PackageSend_NonBlocking>:
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007b24:	b538      	push	{r3, r4, r5, lr}
  // device available?
  if( !transfer_possible )
 8007b26:	4d17      	ldr	r5, [pc, #92]	; (8007b84 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x60>)
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007b28:	4604      	mov	r4, r0
  // device available?
  if( !transfer_possible )
 8007b2a:	782b      	ldrb	r3, [r5, #0]
    return -1;
 8007b2c:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
  // device available?
  if( !transfer_possible )
 8007b30:	b33b      	cbz	r3, 8007b82 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    return -1;

  // buffer full?
  if( tx_buffer_size >= (MIOS32_USB_MIDI_TX_BUFFER_SIZE-1) ) {
 8007b32:	4b15      	ldr	r3, [pc, #84]	; (8007b88 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007b34:	881b      	ldrh	r3, [r3, #0]
 8007b36:	b29b      	uxth	r3, r3
 8007b38:	2b3e      	cmp	r3, #62	; 0x3e
 8007b3a:	d909      	bls.n	8007b50 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x2c>
    // call USB handler, so that we are able to get the buffer free again on next execution
    // (this call simplifies polling loops!)
    MIOS32_USB_MIDI_TxBufferHandler();
 8007b3c:	f7ff ff4e 	bl	80079dc <MIOS32_USB_MIDI_TxBufferHandler>

    // device still available?
    // (ensures that polling loop terminates if cable has been disconnected)
    if( !transfer_possible )
 8007b40:	782b      	ldrb	r3, [r5, #0]
 8007b42:	2b00      	cmp	r3, #0
      return -1;
 8007b44:	bf14      	ite	ne
 8007b46:	f06f 0001 	mvnne.w	r0, #1
 8007b4a:	f04f 30ff 	moveq.w	r0, #4294967295
 8007b4e:	e018      	b.n	8007b82 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    // notify that buffer was full (request retry)
    return -2;
  }

  // put package into buffer - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007b50:	f7fe fd88 	bl	8006664 <MIOS32_IRQ_Disable>
  tx_buffer[tx_buffer_head++] = package.ALL;
 8007b54:	4b0d      	ldr	r3, [pc, #52]	; (8007b8c <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x68>)
 8007b56:	490e      	ldr	r1, [pc, #56]	; (8007b90 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x6c>)
 8007b58:	881a      	ldrh	r2, [r3, #0]
 8007b5a:	b292      	uxth	r2, r2
 8007b5c:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
 8007b60:	3201      	adds	r2, #1
 8007b62:	b292      	uxth	r2, r2
 8007b64:	801a      	strh	r2, [r3, #0]
  if( tx_buffer_head >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007b66:	881a      	ldrh	r2, [r3, #0]
 8007b68:	b292      	uxth	r2, r2
 8007b6a:	2a3f      	cmp	r2, #63	; 0x3f
 8007b6c:	d901      	bls.n	8007b72 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x4e>
    tx_buffer_head = 0;
 8007b6e:	2200      	movs	r2, #0
 8007b70:	801a      	strh	r2, [r3, #0]
  ++tx_buffer_size;
 8007b72:	4b05      	ldr	r3, [pc, #20]	; (8007b88 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007b74:	881a      	ldrh	r2, [r3, #0]
 8007b76:	3201      	adds	r2, #1
 8007b78:	b292      	uxth	r2, r2
 8007b7a:	801a      	strh	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 8007b7c:	f7fe fd88 	bl	8006690 <MIOS32_IRQ_Enable>

  return 0;
 8007b80:	2000      	movs	r0, #0
}
 8007b82:	bd38      	pop	{r3, r4, r5, pc}
 8007b84:	2000040e 	.word	0x2000040e
 8007b88:	20000408 	.word	0x20000408
 8007b8c:	20000410 	.word	0x20000410
 8007b90:	20000200 	.word	0x20000200

08007b94 <MIOS32_USB_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: USB not connected
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend(mios32_midi_package_t package)
{
 8007b94:	b570      	push	{r4, r5, r6, lr}
 8007b96:	4606      	mov	r6, r0
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
    if( timeout_ctr >= 10000 )
 8007b98:	4c0a      	ldr	r4, [pc, #40]	; (8007bc4 <MIOS32_USB_MIDI_PackageSend+0x30>)
 8007b9a:	f242 750f 	movw	r5, #9999	; 0x270f
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8007b9e:	e004      	b.n	8007baa <MIOS32_USB_MIDI_PackageSend+0x16>
    if( timeout_ctr >= 10000 )
 8007ba0:	8823      	ldrh	r3, [r4, #0]
 8007ba2:	42ab      	cmp	r3, r5
 8007ba4:	d80c      	bhi.n	8007bc0 <MIOS32_USB_MIDI_PackageSend+0x2c>
      break;
    ++timeout_ctr;
 8007ba6:	3301      	adds	r3, #1
 8007ba8:	8023      	strh	r3, [r4, #0]
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8007baa:	4630      	mov	r0, r6
 8007bac:	f7ff ffba 	bl	8007b24 <MIOS32_USB_MIDI_PackageSend_NonBlocking>
 8007bb0:	f110 0f02 	cmn.w	r0, #2
 8007bb4:	d0f4      	beq.n	8007ba0 <MIOS32_USB_MIDI_PackageSend+0xc>
    if( timeout_ctr >= 10000 )
      break;
    ++timeout_ctr;
  }

  if( error >= 0 ) // no error: reset timeout counter
 8007bb6:	2800      	cmp	r0, #0
 8007bb8:	db02      	blt.n	8007bc0 <MIOS32_USB_MIDI_PackageSend+0x2c>
    timeout_ctr = 0;
 8007bba:	4b02      	ldr	r3, [pc, #8]	; (8007bc4 <MIOS32_USB_MIDI_PackageSend+0x30>)
 8007bbc:	2200      	movs	r2, #0
 8007bbe:	801a      	strh	r2, [r3, #0]

  return error;
}
 8007bc0:	bd70      	pop	{r4, r5, r6, pc}
 8007bc2:	bf00      	nop
 8007bc4:	2000040c 	.word	0x2000040c

08007bc8 <MIOS32_USB_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8007bc8:	4b12      	ldr	r3, [pc, #72]	; (8007c14 <MIOS32_USB_MIDI_PackageReceive+0x4c>)
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 8007bca:	b510      	push	{r4, lr}
  // package received?
  if( !rx_buffer_size )
 8007bcc:	881b      	ldrh	r3, [r3, #0]
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 8007bce:	4604      	mov	r4, r0
  // package received?
  if( !rx_buffer_size )
 8007bd0:	b29b      	uxth	r3, r3
    return -1;
 8007bd2:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8007bd6:	b1db      	cbz	r3, 8007c10 <MIOS32_USB_MIDI_PackageReceive+0x48>
    return -1;

  // get package - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007bd8:	f7fe fd44 	bl	8006664 <MIOS32_IRQ_Disable>
  package->ALL = rx_buffer[rx_buffer_tail];
 8007bdc:	4b0e      	ldr	r3, [pc, #56]	; (8007c18 <MIOS32_USB_MIDI_PackageReceive+0x50>)
 8007bde:	4a0f      	ldr	r2, [pc, #60]	; (8007c1c <MIOS32_USB_MIDI_PackageReceive+0x54>)
 8007be0:	8819      	ldrh	r1, [r3, #0]
 8007be2:	b289      	uxth	r1, r1
 8007be4:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8007be8:	6022      	str	r2, [r4, #0]
  if( ++rx_buffer_tail >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8007bea:	881a      	ldrh	r2, [r3, #0]
 8007bec:	3201      	adds	r2, #1
 8007bee:	b292      	uxth	r2, r2
 8007bf0:	801a      	strh	r2, [r3, #0]
 8007bf2:	881a      	ldrh	r2, [r3, #0]
 8007bf4:	b292      	uxth	r2, r2
 8007bf6:	2a3f      	cmp	r2, #63	; 0x3f
 8007bf8:	d901      	bls.n	8007bfe <MIOS32_USB_MIDI_PackageReceive+0x36>
    rx_buffer_tail = 0;
 8007bfa:	2200      	movs	r2, #0
 8007bfc:	801a      	strh	r2, [r3, #0]
  --rx_buffer_size;
 8007bfe:	4c05      	ldr	r4, [pc, #20]	; (8007c14 <MIOS32_USB_MIDI_PackageReceive+0x4c>)
 8007c00:	8823      	ldrh	r3, [r4, #0]
 8007c02:	3b01      	subs	r3, #1
 8007c04:	b29b      	uxth	r3, r3
 8007c06:	8023      	strh	r3, [r4, #0]
  MIOS32_IRQ_Enable();
 8007c08:	f7fe fd42 	bl	8006690 <MIOS32_IRQ_Enable>

  return rx_buffer_size;
 8007c0c:	8820      	ldrh	r0, [r4, #0]
 8007c0e:	b280      	uxth	r0, r0
}
 8007c10:	bd10      	pop	{r4, pc}
 8007c12:	bf00      	nop
 8007c14:	200001fc 	.word	0x200001fc
 8007c18:	200001fe 	.word	0x200001fe
 8007c1c:	20000304 	.word	0x20000304

08007c20 <MIOS32_USB_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Periodic_mS(void)
{
 8007c20:	b508      	push	{r3, lr}
  // check for received packages
  MIOS32_USB_MIDI_RxBufferHandler();
 8007c22:	f7ff fe87 	bl	8007934 <MIOS32_USB_MIDI_RxBufferHandler>

  // check for packages which should be transmitted
  MIOS32_USB_MIDI_TxBufferHandler();
 8007c26:	f7ff fed9 	bl	80079dc <MIOS32_USB_MIDI_TxBufferHandler>

  return 0;
}
 8007c2a:	2000      	movs	r0, #0
 8007c2c:	bd08      	pop	{r3, pc}
	...

08007c30 <MIOS32_USB_MIDI_EP1_IN_Callback>:
//! Called by STM32 USB driver to check for IN streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_IN_Callback(u8 bEP, u8 bEPStatus)
{
 8007c30:	b508      	push	{r3, lr}
  // package has been sent
  tx_buffer_busy = 0;
 8007c32:	4b03      	ldr	r3, [pc, #12]	; (8007c40 <MIOS32_USB_MIDI_EP1_IN_Callback+0x10>)
 8007c34:	2200      	movs	r2, #0
 8007c36:	701a      	strb	r2, [r3, #0]
  
  // check for next package
  MIOS32_USB_MIDI_TxBufferHandler();
 8007c38:	f7ff fed0 	bl	80079dc <MIOS32_USB_MIDI_TxBufferHandler>
}
 8007c3c:	bd08      	pop	{r3, pc}
 8007c3e:	bf00      	nop
 8007c40:	20000300 	.word	0x20000300

08007c44 <MIOS32_USB_MIDI_EP1_OUT_Callback>:
//! Called by STM32 USB driver to check for OUT streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_OUT_Callback(u8 bEP, u8 bEPStatus)
{
 8007c44:	b508      	push	{r3, lr}
  // put package into buffer
  rx_buffer_new_data = 1;
 8007c46:	4b03      	ldr	r3, [pc, #12]	; (8007c54 <MIOS32_USB_MIDI_EP1_OUT_Callback+0x10>)
 8007c48:	2201      	movs	r2, #1
 8007c4a:	701a      	strb	r2, [r3, #0]
  MIOS32_USB_MIDI_RxBufferHandler();
 8007c4c:	f7ff fe72 	bl	8007934 <MIOS32_USB_MIDI_RxBufferHandler>
}
 8007c50:	bd08      	pop	{r3, pc}
 8007c52:	bf00      	nop
 8007c54:	20000404 	.word	0x20000404

08007c58 <MIOS32_UART_BaudrateSet>:
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 8007c58:	b530      	push	{r4, r5, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007c5a:	2801      	cmp	r0, #1
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 8007c5c:	4604      	mov	r4, r0
 8007c5e:	b085      	sub	sp, #20
 8007c60:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1;
 8007c62:	bf88      	it	hi
 8007c64:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007c68:	d81a      	bhi.n	8007ca0 <MIOS32_UART_BaudrateSet+0x48>
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8007c6a:	f04f 0300 	mov.w	r3, #0
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 8007c6e:	a904      	add	r1, sp, #16
  if( uart >= MIOS32_UART_NUM )
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8007c70:	f8ad 3004 	strh.w	r3, [sp, #4]
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8007c74:	f8ad 3006 	strh.w	r3, [sp, #6]
  USART_InitStructure.USART_Parity = USART_Parity_No;
 8007c78:	f8ad 3008 	strh.w	r3, [sp, #8]
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8007c7c:	f8ad 300c 	strh.w	r3, [sp, #12]
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 8007c80:	f841 5d10 	str.w	r5, [r1, #-16]!
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8007c84:	f04f 030c 	mov.w	r3, #12

  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
 8007c88:	bf14      	ite	ne
 8007c8a:	4806      	ldrne	r0, [pc, #24]	; (8007ca4 <MIOS32_UART_BaudrateSet+0x4c>)
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 8007c8c:	4806      	ldreq	r0, [pc, #24]	; (8007ca8 <MIOS32_UART_BaudrateSet+0x50>)
 8007c8e:	4669      	mov	r1, sp
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8007c90:	f8ad 300a 	strh.w	r3, [sp, #10]
  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 8007c94:	f000 fd98 	bl	80087c8 <USART_Init>
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 8007c98:	4b04      	ldr	r3, [pc, #16]	; (8007cac <MIOS32_UART_BaudrateSet+0x54>)

  return 0;
 8007c9a:	2000      	movs	r0, #0
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 8007c9c:	f843 5024 	str.w	r5, [r3, r4, lsl #2]

  return 0;
#endif
}
 8007ca0:	b005      	add	sp, #20
 8007ca2:	bd30      	pop	{r4, r5, pc}
 8007ca4:	40013800 	.word	0x40013800
 8007ca8:	40004800 	.word	0x40004800
 8007cac:	20000528 	.word	0x20000528

08007cb0 <MIOS32_UART_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_Init(u32 mode)
{
 8007cb0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007cb2:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007cb4:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_UART_Init(u32 mode)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
 8007cb8:	2c00      	cmp	r4, #0
 8007cba:	f040 8086 	bne.w	8007dca <MIOS32_UART_Init+0x11a>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 8007cbe:	ad01      	add	r5, sp, #4
#else

  // map UART pins
  MIOS32_UART0_REMAP_FUNC;
#if MIOS32_UART_NUM >= 2
  MIOS32_UART1_REMAP_FUNC;
 8007cc0:	2101      	movs	r1, #1
 8007cc2:	4842      	ldr	r0, [pc, #264]	; (8007dcc <MIOS32_UART_Init+0x11c>)
 8007cc4:	f000 fcea 	bl	800869c <GPIO_PinRemapConfig>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 8007cc8:	4628      	mov	r0, r5
 8007cca:	f000 fcdf 	bl	800868c <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8007cce:	2302      	movs	r3, #2
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8007cd0:	4629      	mov	r1, r5
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8007cd2:	f88d 3006 	strb.w	r3, [sp, #6]

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8007cd6:	261c      	movs	r6, #28
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 8007cd8:	f44f 7300 	mov.w	r3, #512	; 0x200
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8007cdc:	483c      	ldr	r0, [pc, #240]	; (8007dd0 <MIOS32_UART_Init+0x120>)
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 8007cde:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8007ce2:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8007ce6:	f000 fc78 	bl	80085da <GPIO_Init>

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 8007cea:	f44f 6380 	mov.w	r3, #1024	; 0x400
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 8007cee:	4629      	mov	r1, r5
 8007cf0:	4838      	ldr	r0, [pc, #224]	; (8007dd4 <MIOS32_UART_Init+0x124>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 8007cf2:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8007cf6:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 8007cfa:	f000 fc6e 	bl	80085da <GPIO_Init>
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8007cfe:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8007d00:	4629      	mov	r1, r5
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8007d02:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8007d06:	4832      	ldr	r0, [pc, #200]	; (8007dd0 <MIOS32_UART_Init+0x120>)
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
 8007d08:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007d0c:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8007d10:	f000 fc63 	bl	80085da <GPIO_Init>
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 8007d14:	f44f 6300 	mov.w	r3, #2048	; 0x800
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 8007d18:	4629      	mov	r1, r5
 8007d1a:	482e      	ldr	r0, [pc, #184]	; (8007dd4 <MIOS32_UART_Init+0x124>)
  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 8007d1c:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 8007d20:	f000 fc5b 	bl	80085da <GPIO_Init>
  GPIO_Init(MIOS32_UART2_RX_PORT, &GPIO_InitStructure);
#endif

  // enable all USART clocks
  // TODO: more generic approach for different UART selections
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 8007d24:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8007d28:	2101      	movs	r1, #1
 8007d2a:	f000 fff5 	bl	8008d18 <RCC_APB2PeriphClockCmd>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 | RCC_APB1Periph_USART3, ENABLE);
 8007d2e:	f44f 20c0 	mov.w	r0, #393216	; 0x60000
 8007d32:	2101      	movs	r1, #1
 8007d34:	f000 fffe 	bl	8008d34 <RCC_APB1PeriphClockCmd>

  // USART configuration
  MIOS32_UART_BaudrateSet(0, MIOS32_UART0_BAUDRATE);
 8007d38:	f647 2112 	movw	r1, #31250	; 0x7a12
 8007d3c:	4620      	mov	r0, r4
 8007d3e:	f7ff ff8b 	bl	8007c58 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=2
  MIOS32_UART_BaudrateSet(1, MIOS32_UART1_BAUDRATE);
 8007d42:	f647 2112 	movw	r1, #31250	; 0x7a12
 8007d46:	2001      	movs	r0, #1
 8007d48:	f7ff ff86 	bl	8007c58 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=3
  MIOS32_UART_BaudrateSet(2, MIOS32_UART2_BAUDRATE);
#endif

  // configure and enable UART interrupts
  MIOS32_IRQ_Install(MIOS32_UART0_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 8007d4c:	2104      	movs	r1, #4
 8007d4e:	2025      	movs	r0, #37	; 0x25
 8007d50:	f7fe fcb0 	bl	80066b4 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART0, USART_IT_RXNE, ENABLE);
 8007d54:	2201      	movs	r2, #1
 8007d56:	4820      	ldr	r0, [pc, #128]	; (8007dd8 <MIOS32_UART_Init+0x128>)
 8007d58:	f240 5125 	movw	r1, #1317	; 0x525
 8007d5c:	f000 fd9d 	bl	800889a <USART_ITConfig>

#if MIOS32_UART_NUM >= 2
  MIOS32_IRQ_Install(MIOS32_UART1_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 8007d60:	2104      	movs	r1, #4
 8007d62:	2027      	movs	r0, #39	; 0x27
 8007d64:	f7fe fca6 	bl	80066b4 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART1, USART_IT_RXNE, ENABLE);
 8007d68:	481c      	ldr	r0, [pc, #112]	; (8007ddc <MIOS32_UART_Init+0x12c>)
 8007d6a:	f240 5125 	movw	r1, #1317	; 0x525
 8007d6e:	2201      	movs	r2, #1
 8007d70:	f000 fd93 	bl	800889a <USART_ITConfig>
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 8007d74:	481a      	ldr	r0, [pc, #104]	; (8007de0 <MIOS32_UART_Init+0x130>)
 8007d76:	491b      	ldr	r1, [pc, #108]	; (8007de4 <MIOS32_UART_Init+0x134>)
 8007d78:	7004      	strb	r4, [r0, #0]
 8007d7a:	7803      	ldrb	r3, [r0, #0]
 8007d7c:	f8df e068 	ldr.w	lr, [pc, #104]	; 8007de8 <MIOS32_UART_Init+0x138>
 8007d80:	700b      	strb	r3, [r1, #0]
 8007d82:	780b      	ldrb	r3, [r1, #0]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 8007d84:	4a19      	ldr	r2, [pc, #100]	; (8007dec <MIOS32_UART_Init+0x13c>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 8007d86:	f88e 3000 	strb.w	r3, [lr]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 8007d8a:	7014      	strb	r4, [r2, #0]
 8007d8c:	f892 c000 	ldrb.w	ip, [r2]
 8007d90:	4b17      	ldr	r3, [pc, #92]	; (8007df0 <MIOS32_UART_Init+0x140>)
 8007d92:	f883 c000 	strb.w	ip, [r3]
 8007d96:	781d      	ldrb	r5, [r3, #0]
 8007d98:	f8df c058 	ldr.w	ip, [pc, #88]	; 8007df4 <MIOS32_UART_Init+0x144>
 8007d9c:	f88c 5000 	strb.w	r5, [ip]
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 8007da0:	7044      	strb	r4, [r0, #1]
 8007da2:	7840      	ldrb	r0, [r0, #1]
 8007da4:	7048      	strb	r0, [r1, #1]
 8007da6:	7849      	ldrb	r1, [r1, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 8007da8:	480b      	ldr	r0, [pc, #44]	; (8007dd8 <MIOS32_UART_Init+0x128>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 8007daa:	f88e 1001 	strb.w	r1, [lr, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 8007dae:	7054      	strb	r4, [r2, #1]
 8007db0:	7852      	ldrb	r2, [r2, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 8007db2:	2101      	movs	r1, #1

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 8007db4:	705a      	strb	r2, [r3, #1]
 8007db6:	785b      	ldrb	r3, [r3, #1]
 8007db8:	f88c 3001 	strb.w	r3, [ip, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 8007dbc:	f000 fd60 	bl	8008880 <USART_Cmd>
#if MIOS32_UART_NUM >= 2
  USART_Cmd(MIOS32_UART1, ENABLE);
 8007dc0:	4806      	ldr	r0, [pc, #24]	; (8007ddc <MIOS32_UART_Init+0x12c>)
 8007dc2:	2101      	movs	r1, #1
 8007dc4:	f000 fd5c 	bl	8008880 <USART_Cmd>
#endif
#if MIOS32_UART_NUM >= 3
  USART_Cmd(MIOS32_UART2, ENABLE);
#endif

  return 0; // no error
 8007dc8:	4620      	mov	r0, r4
#endif
}
 8007dca:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 8007dcc:	00140010 	.word	0x00140010
 8007dd0:	40010800 	.word	0x40010800
 8007dd4:	40011000 	.word	0x40011000
 8007dd8:	40013800 	.word	0x40013800
 8007ddc:	40004800 	.word	0x40004800
 8007de0:	20000418 	.word	0x20000418
 8007de4:	20000520 	.word	0x20000520
 8007de8:	2000041c 	.word	0x2000041c
 8007dec:	20000524 	.word	0x20000524
 8007df0:	20000530 	.word	0x20000530
 8007df4:	20000414 	.word	0x20000414

08007df8 <MIOS32_UART_RxBufferGet>:
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007df8:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: number of received bytes
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
 8007dfa:	b538      	push	{r3, r4, r5, lr}
 8007dfc:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8007dfe:	bf88      	it	hi
 8007e00:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007e04:	d81d      	bhi.n	8007e42 <MIOS32_UART_RxBufferGet+0x4a>
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 8007e06:	4b0f      	ldr	r3, [pc, #60]	; (8007e44 <MIOS32_UART_RxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 8007e08:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 8007e0c:	5d1b      	ldrb	r3, [r3, r4]
 8007e0e:	b1c3      	cbz	r3, 8007e42 <MIOS32_UART_RxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007e10:	f7fe fc28 	bl	8006664 <MIOS32_IRQ_Disable>
  u8 b = rx_buffer[uart][rx_buffer_tail[uart]];
 8007e14:	4b0c      	ldr	r3, [pc, #48]	; (8007e48 <MIOS32_UART_RxBufferGet+0x50>)
 8007e16:	490d      	ldr	r1, [pc, #52]	; (8007e4c <MIOS32_UART_RxBufferGet+0x54>)
 8007e18:	5d1a      	ldrb	r2, [r3, r4]
 8007e1a:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 8007e1e:	5c8d      	ldrb	r5, [r1, r2]
  if( ++rx_buffer_tail[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8007e20:	5d1a      	ldrb	r2, [r3, r4]
 8007e22:	3201      	adds	r2, #1
 8007e24:	b2d2      	uxtb	r2, r2
 8007e26:	551a      	strb	r2, [r3, r4]
 8007e28:	5d1a      	ldrb	r2, [r3, r4]
 8007e2a:	2a3f      	cmp	r2, #63	; 0x3f
 8007e2c:	d901      	bls.n	8007e32 <MIOS32_UART_RxBufferGet+0x3a>
    rx_buffer_tail[uart] = 0;
 8007e2e:	2200      	movs	r2, #0
 8007e30:	551a      	strb	r2, [r3, r4]
  --rx_buffer_size[uart];
 8007e32:	4b04      	ldr	r3, [pc, #16]	; (8007e44 <MIOS32_UART_RxBufferGet+0x4c>)
 8007e34:	5d1a      	ldrb	r2, [r3, r4]
 8007e36:	3a01      	subs	r2, #1
 8007e38:	b2d2      	uxtb	r2, r2
 8007e3a:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 8007e3c:	f7fe fc28 	bl	8006690 <MIOS32_IRQ_Enable>

  return b; // return received byte
 8007e40:	4628      	mov	r0, r5
#endif
}
 8007e42:	bd38      	pop	{r3, r4, r5, pc}
 8007e44:	20000418 	.word	0x20000418
 8007e48:	2000041c 	.word	0x2000041c
 8007e4c:	200004a0 	.word	0x200004a0

08007e50 <MIOS32_UART_RxBufferPut>:
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007e50:	2801      	cmp	r0, #1
//! \return -1 if UART not available
//! \return -2 if buffer full (retry)
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
 8007e52:	b538      	push	{r3, r4, r5, lr}
 8007e54:	4604      	mov	r4, r0
 8007e56:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8007e58:	bf88      	it	hi
 8007e5a:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007e5e:	d81f      	bhi.n	8007ea0 <MIOS32_UART_RxBufferPut+0x50>
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8007e60:	4b10      	ldr	r3, [pc, #64]	; (8007ea4 <MIOS32_UART_RxBufferPut+0x54>)
 8007e62:	5d1b      	ldrb	r3, [r3, r4]
 8007e64:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full (retry)
 8007e66:	bf88      	it	hi
 8007e68:	f06f 0001 	mvnhi.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8007e6c:	d818      	bhi.n	8007ea0 <MIOS32_UART_RxBufferPut+0x50>
    return -2; // buffer full (retry)

  // copy received byte into receive buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007e6e:	f7fe fbf9 	bl	8006664 <MIOS32_IRQ_Disable>
  rx_buffer[uart][rx_buffer_head[uart]] = b;
 8007e72:	4b0d      	ldr	r3, [pc, #52]	; (8007ea8 <MIOS32_UART_RxBufferPut+0x58>)
 8007e74:	490d      	ldr	r1, [pc, #52]	; (8007eac <MIOS32_UART_RxBufferPut+0x5c>)
 8007e76:	5d1a      	ldrb	r2, [r3, r4]
 8007e78:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 8007e7c:	548d      	strb	r5, [r1, r2]
  if( ++rx_buffer_head[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8007e7e:	5d1a      	ldrb	r2, [r3, r4]
 8007e80:	3201      	adds	r2, #1
 8007e82:	b2d2      	uxtb	r2, r2
 8007e84:	551a      	strb	r2, [r3, r4]
 8007e86:	5d1a      	ldrb	r2, [r3, r4]
 8007e88:	2a3f      	cmp	r2, #63	; 0x3f
 8007e8a:	d901      	bls.n	8007e90 <MIOS32_UART_RxBufferPut+0x40>
    rx_buffer_head[uart] = 0;
 8007e8c:	2200      	movs	r2, #0
 8007e8e:	551a      	strb	r2, [r3, r4]
  ++rx_buffer_size[uart];
 8007e90:	4b04      	ldr	r3, [pc, #16]	; (8007ea4 <MIOS32_UART_RxBufferPut+0x54>)
 8007e92:	5d1a      	ldrb	r2, [r3, r4]
 8007e94:	3201      	adds	r2, #1
 8007e96:	b2d2      	uxtb	r2, r2
 8007e98:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 8007e9a:	f7fe fbf9 	bl	8006690 <MIOS32_IRQ_Enable>

  return 0; // no error
 8007e9e:	2000      	movs	r0, #0
#endif
}
 8007ea0:	bd38      	pop	{r3, r4, r5, pc}
 8007ea2:	bf00      	nop
 8007ea4:	20000418 	.word	0x20000418
 8007ea8:	20000520 	.word	0x20000520
 8007eac:	200004a0 	.word	0x200004a0

08007eb0 <MIOS32_UART_TxBufferGet>:
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007eb0:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: transmitted byte
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
 8007eb2:	b538      	push	{r3, r4, r5, lr}
 8007eb4:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8007eb6:	bf88      	it	hi
 8007eb8:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007ebc:	d81d      	bhi.n	8007efa <MIOS32_UART_TxBufferGet+0x4a>
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 8007ebe:	4b0f      	ldr	r3, [pc, #60]	; (8007efc <MIOS32_UART_TxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 8007ec0:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 8007ec4:	5d1b      	ldrb	r3, [r3, r4]
 8007ec6:	b1c3      	cbz	r3, 8007efa <MIOS32_UART_TxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007ec8:	f7fe fbcc 	bl	8006664 <MIOS32_IRQ_Disable>
  u8 b = tx_buffer[uart][tx_buffer_tail[uart]];
 8007ecc:	4b0c      	ldr	r3, [pc, #48]	; (8007f00 <MIOS32_UART_TxBufferGet+0x50>)
 8007ece:	490d      	ldr	r1, [pc, #52]	; (8007f04 <MIOS32_UART_TxBufferGet+0x54>)
 8007ed0:	5d1a      	ldrb	r2, [r3, r4]
 8007ed2:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 8007ed6:	5c8d      	ldrb	r5, [r1, r2]
  if( ++tx_buffer_tail[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 8007ed8:	5d1a      	ldrb	r2, [r3, r4]
 8007eda:	3201      	adds	r2, #1
 8007edc:	b2d2      	uxtb	r2, r2
 8007ede:	551a      	strb	r2, [r3, r4]
 8007ee0:	5d1a      	ldrb	r2, [r3, r4]
 8007ee2:	2a3f      	cmp	r2, #63	; 0x3f
 8007ee4:	d901      	bls.n	8007eea <MIOS32_UART_TxBufferGet+0x3a>
    tx_buffer_tail[uart] = 0;
 8007ee6:	2200      	movs	r2, #0
 8007ee8:	551a      	strb	r2, [r3, r4]
  --tx_buffer_size[uart];
 8007eea:	4b04      	ldr	r3, [pc, #16]	; (8007efc <MIOS32_UART_TxBufferGet+0x4c>)
 8007eec:	5d1a      	ldrb	r2, [r3, r4]
 8007eee:	3a01      	subs	r2, #1
 8007ef0:	b2d2      	uxtb	r2, r2
 8007ef2:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 8007ef4:	f7fe fbcc 	bl	8006690 <MIOS32_IRQ_Enable>

  return b; // return transmitted byte
 8007ef8:	4628      	mov	r0, r5
#endif
}
 8007efa:	bd38      	pop	{r3, r4, r5, pc}
 8007efc:	20000524 	.word	0x20000524
 8007f00:	20000414 	.word	0x20000414
 8007f04:	20000420 	.word	0x20000420

08007f08 <MIOS32_UART_TxBufferPutMore_NonBlocking>:
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 8007f08:	b5f0      	push	{r4, r5, r6, r7, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007f0a:	2801      	cmp	r0, #1
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 8007f0c:	4604      	mov	r4, r0
 8007f0e:	b087      	sub	sp, #28
 8007f10:	460d      	mov	r5, r1
 8007f12:	4617      	mov	r7, r2
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8007f14:	bf88      	it	hi
 8007f16:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007f1a:	d852      	bhi.n	8007fc2 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 8007f1c:	4e2a      	ldr	r6, [pc, #168]	; (8007fc8 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc0>)
 8007f1e:	5d33      	ldrb	r3, [r6, r4]
 8007f20:	18d3      	adds	r3, r2, r3
 8007f22:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full or cannot get all requested bytes (retry)
 8007f24:	bfc8      	it	gt
 8007f26:	f06f 0001 	mvngt.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 8007f2a:	dc4a      	bgt.n	8007fc2 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -2; // buffer full or cannot get all requested bytes (retry)

  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007f2c:	f7fe fb9a 	bl	8006664 <MIOS32_IRQ_Disable>

  u16 i;
  for(i=0; i<len; ++i) {
 8007f30:	2200      	movs	r2, #0
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 8007f32:	4b26      	ldr	r3, [pc, #152]	; (8007fcc <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc4>)

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007f34:	4826      	ldr	r0, [pc, #152]	; (8007fd0 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc8>)
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007f36:	4927      	ldr	r1, [pc, #156]	; (8007fd4 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xcc>)
 8007f38:	9701      	str	r7, [sp, #4]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 8007f3a:	e03c      	b.n	8007fb6 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xae>
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 8007f3c:	f813 c004 	ldrb.w	ip, [r3, r4]
 8007f40:	f815 7b01 	ldrb.w	r7, [r5], #1
 8007f44:	f8df e090 	ldr.w	lr, [pc, #144]	; 8007fd8 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xd0>
 8007f48:	eb0c 1c84 	add.w	ip, ip, r4, lsl #6
 8007f4c:	f80e 700c 	strb.w	r7, [lr, ip]

    if( ++tx_buffer_head[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 8007f50:	f813 c004 	ldrb.w	ip, [r3, r4]
 8007f54:	f10c 0c01 	add.w	ip, ip, #1
 8007f58:	fa5f fc8c 	uxtb.w	ip, ip
 8007f5c:	f803 c004 	strb.w	ip, [r3, r4]
 8007f60:	f813 c004 	ldrb.w	ip, [r3, r4]
 8007f64:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
      tx_buffer_head[uart] = 0;
 8007f68:	bf84      	itt	hi
 8007f6a:	f04f 0c00 	movhi.w	ip, #0
 8007f6e:	f803 c004 	strbhi.w	ip, [r3, r4]

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
 8007f72:	f816 c004 	ldrb.w	ip, [r6, r4]
 8007f76:	f10c 0c01 	add.w	ip, ip, #1
 8007f7a:	fa5f fc8c 	uxtb.w	ip, ip
 8007f7e:	f806 c004 	strb.w	ip, [r6, r4]
 8007f82:	f816 c004 	ldrb.w	ip, [r6, r4]
 8007f86:	f1bc 0f01 	cmp.w	ip, #1
 8007f8a:	d112      	bne.n	8007fb2 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xaa>
      switch( uart ) {
 8007f8c:	2c01      	cmp	r4, #1
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007f8e:	bf15      	itete	ne
 8007f90:	f8b1 c00c 	ldrhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007f94:	f8b0 c00c 	ldrheq.w	ip, [r0, #12]
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007f98:	fa1f fc8c 	uxthne.w	ip, ip
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007f9c:	fa1f fc8c 	uxtheq.w	ip, ip
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007fa0:	bf15      	itete	ne
 8007fa2:	f04c 0c80 	orrne.w	ip, ip, #128	; 0x80
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007fa6:	f04c 0c80 	orreq.w	ip, ip, #128	; 0x80
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007faa:	f8a1 c00c 	strhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8007fae:	f8a0 c00c 	strheq.w	ip, [r0, #12]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 8007fb2:	3201      	adds	r2, #1
 8007fb4:	b292      	uxth	r2, r2
 8007fb6:	9f01      	ldr	r7, [sp, #4]
 8007fb8:	42ba      	cmp	r2, r7
 8007fba:	d3bf      	bcc.n	8007f3c <MIOS32_UART_TxBufferPutMore_NonBlocking+0x34>
        default: MIOS32_IRQ_Enable(); return -3; // uart not supported by routine (yet)
      }
    }
  }

  MIOS32_IRQ_Enable();
 8007fbc:	f7fe fb68 	bl	8006690 <MIOS32_IRQ_Enable>

  return 0; // no error
 8007fc0:	2000      	movs	r0, #0
#endif
}
 8007fc2:	b007      	add	sp, #28
 8007fc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007fc6:	bf00      	nop
 8007fc8:	20000524 	.word	0x20000524
 8007fcc:	20000530 	.word	0x20000530
 8007fd0:	40004800 	.word	0x40004800
 8007fd4:	40013800 	.word	0x40013800
 8007fd8:	20000420 	.word	0x20000420

08007fdc <MIOS32_UART_TxBufferPutMore>:
//! \return -1 if UART not available
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore(u8 uart, u8 *buffer, u16 len)
{
 8007fdc:	b570      	push	{r4, r5, r6, lr}
 8007fde:	4605      	mov	r5, r0
 8007fe0:	460c      	mov	r4, r1
 8007fe2:	4616      	mov	r6, r2
  s32 error;

  while( (error=MIOS32_UART_TxBufferPutMore_NonBlocking(uart, buffer, len)) == -2 );
 8007fe4:	4628      	mov	r0, r5
 8007fe6:	4621      	mov	r1, r4
 8007fe8:	4632      	mov	r2, r6
 8007fea:	f7ff ff8d 	bl	8007f08 <MIOS32_UART_TxBufferPutMore_NonBlocking>
 8007fee:	f110 0f02 	cmn.w	r0, #2
 8007ff2:	d0f7      	beq.n	8007fe4 <MIOS32_UART_TxBufferPutMore+0x8>

  return error;
}
 8007ff4:	bd70      	pop	{r4, r5, r6, pc}
	...

08007ff8 <USART1_IRQHandler>:
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8007ff8:	4b14      	ldr	r3, [pc, #80]	; (800804c <USART1_IRQHandler+0x54>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
 8007ffa:	b510      	push	{r4, lr}
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8007ffc:	881a      	ldrh	r2, [r3, #0]
 8007ffe:	f012 0f20 	tst.w	r2, #32
 8008002:	d009      	beq.n	8008018 <USART1_IRQHandler+0x20>
    u8 b = MIOS32_UART0->DR;
 8008004:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 8008006:	2020      	movs	r0, #32
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART0->DR;
 8008008:	b2e4      	uxtb	r4, r4

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 800800a:	4621      	mov	r1, r4
 800800c:	f7fd ffc0 	bl	8005f90 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(0, b) < 0 ) {
 8008010:	b910      	cbnz	r0, 8008018 <USART1_IRQHandler+0x20>
 8008012:	4621      	mov	r1, r4
 8008014:	f7ff ff1c 	bl	8007e50 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
 8008018:	4c0c      	ldr	r4, [pc, #48]	; (800804c <USART1_IRQHandler+0x54>)
 800801a:	8823      	ldrh	r3, [r4, #0]
 800801c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008020:	d013      	beq.n	800804a <USART1_IRQHandler+0x52>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 8008022:	4b0b      	ldr	r3, [pc, #44]	; (8008050 <USART1_IRQHandler+0x58>)
 8008024:	781b      	ldrb	r3, [r3, #0]
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
 8008026:	b153      	cbz	r3, 800803e <USART1_IRQHandler+0x46>
      s32 b = MIOS32_UART_TxBufferGet(0);
 8008028:	2000      	movs	r0, #0
 800802a:	f7ff ff41 	bl	8007eb0 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 800802e:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
      } else {
	MIOS32_UART0->DR = b;
 8008030:	bfa4      	itt	ge
 8008032:	b280      	uxthge	r0, r0
 8008034:	80a0      	strhge	r0, [r4, #4]
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(0);
      if( b < 0 ) {
 8008036:	da08      	bge.n	800804a <USART1_IRQHandler+0x52>
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
 8008038:	23ff      	movs	r3, #255	; 0xff
 800803a:	80a3      	strh	r3, [r4, #4]
 800803c:	e005      	b.n	800804a <USART1_IRQHandler+0x52>
      } else {
	MIOS32_UART0->DR = b;
      }
    } else {
      MIOS32_UART0->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 800803e:	89a3      	ldrh	r3, [r4, #12]
 8008040:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008044:	041b      	lsls	r3, r3, #16
 8008046:	0c1b      	lsrs	r3, r3, #16
 8008048:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 800804a:	bd10      	pop	{r4, pc}
 800804c:	40013800 	.word	0x40013800
 8008050:	20000524 	.word	0x20000524

08008054 <USART3_IRQHandler>:
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 8008054:	4b15      	ldr	r3, [pc, #84]	; (80080ac <USART3_IRQHandler+0x58>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
 8008056:	b510      	push	{r4, lr}
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 8008058:	881a      	ldrh	r2, [r3, #0]
 800805a:	f012 0f20 	tst.w	r2, #32
 800805e:	d00a      	beq.n	8008076 <USART3_IRQHandler+0x22>
    u8 b = MIOS32_UART1->DR;
 8008060:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 8008062:	2021      	movs	r0, #33	; 0x21
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART1->DR;
 8008064:	b2e4      	uxtb	r4, r4

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 8008066:	4621      	mov	r1, r4
 8008068:	f7fd ff92 	bl	8005f90 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(1, b) < 0 ) {
 800806c:	b918      	cbnz	r0, 8008076 <USART3_IRQHandler+0x22>
 800806e:	3001      	adds	r0, #1
 8008070:	4621      	mov	r1, r4
 8008072:	f7ff feed 	bl	8007e50 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
 8008076:	4c0d      	ldr	r4, [pc, #52]	; (80080ac <USART3_IRQHandler+0x58>)
 8008078:	8823      	ldrh	r3, [r4, #0]
 800807a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800807e:	d013      	beq.n	80080a8 <USART3_IRQHandler+0x54>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 8008080:	4b0b      	ldr	r3, [pc, #44]	; (80080b0 <USART3_IRQHandler+0x5c>)
 8008082:	785b      	ldrb	r3, [r3, #1]
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
 8008084:	b153      	cbz	r3, 800809c <USART3_IRQHandler+0x48>
      s32 b = MIOS32_UART_TxBufferGet(1);
 8008086:	2001      	movs	r0, #1
 8008088:	f7ff ff12 	bl	8007eb0 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 800808c:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
      } else {
	MIOS32_UART1->DR = b;
 800808e:	bfa4      	itt	ge
 8008090:	b280      	uxthge	r0, r0
 8008092:	80a0      	strhge	r0, [r4, #4]
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(1);
      if( b < 0 ) {
 8008094:	da08      	bge.n	80080a8 <USART3_IRQHandler+0x54>
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
 8008096:	23ff      	movs	r3, #255	; 0xff
 8008098:	80a3      	strh	r3, [r4, #4]
 800809a:	e005      	b.n	80080a8 <USART3_IRQHandler+0x54>
      } else {
	MIOS32_UART1->DR = b;
      }
    } else {
      MIOS32_UART1->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 800809c:	89a3      	ldrh	r3, [r4, #12]
 800809e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80080a2:	041b      	lsls	r3, r3, #16
 80080a4:	0c1b      	lsrs	r3, r3, #16
 80080a6:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 80080a8:	bd10      	pop	{r4, pc}
 80080aa:	bf00      	nop
 80080ac:	40004800 	.word	0x40004800
 80080b0:	20000524 	.word	0x20000524

080080b4 <USART2_IRQHandler>:
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 80080b4:	4b0e      	ldr	r3, [pc, #56]	; (80080f0 <USART2_IRQHandler+0x3c>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
 80080b6:	b510      	push	{r4, lr}
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 80080b8:	881a      	ldrh	r2, [r3, #0]
 80080ba:	f012 0f20 	tst.w	r2, #32
 80080be:	d00a      	beq.n	80080d6 <USART2_IRQHandler+0x22>
    u8 b = MIOS32_UART2->DR;
 80080c0:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 80080c2:	2022      	movs	r0, #34	; 0x22
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART2->DR;
 80080c4:	b2e4      	uxtb	r4, r4

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 80080c6:	4621      	mov	r1, r4
 80080c8:	f7fd ff62 	bl	8005f90 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(2, b) < 0 ) {
 80080cc:	b918      	cbnz	r0, 80080d6 <USART2_IRQHandler+0x22>
 80080ce:	3002      	adds	r0, #2
 80080d0:	4621      	mov	r1, r4
 80080d2:	f7ff febd 	bl	8007e50 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART2->SR & (1 << 7) ) { // check if TXE flag is set
 80080d6:	4a06      	ldr	r2, [pc, #24]	; (80080f0 <USART2_IRQHandler+0x3c>)
 80080d8:	8813      	ldrh	r3, [r2, #0]
 80080da:	f013 0f80 	tst.w	r3, #128	; 0x80
 80080de:	d005      	beq.n	80080ec <USART2_IRQHandler+0x38>
	MIOS32_UART2->DR = 0xff;
      } else {
	MIOS32_UART2->DR = b;
      }
    } else {
      MIOS32_UART2->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 80080e0:	8993      	ldrh	r3, [r2, #12]
 80080e2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80080e6:	041b      	lsls	r3, r3, #16
 80080e8:	0c1b      	lsrs	r3, r3, #16
 80080ea:	8193      	strh	r3, [r2, #12]
    }
  }
}
 80080ec:	bd10      	pop	{r4, pc}
 80080ee:	bf00      	nop
 80080f0:	40004400 	.word	0x40004400

080080f4 <I2C2_EV_IRQHandler>:
/////////////////////////////////////////////////////////////////////////////
// interrupt vectors
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
 80080f4:	b570      	push	{r4, r5, r6, lr}
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 80080f6:	4c68      	ldr	r4, [pc, #416]	; (8008298 <I2C2_EV_IRQHandler+0x1a4>)
 80080f8:	6820      	ldr	r0, [r4, #0]
 80080fa:	f000 fc28 	bl	800894e <I2C_GetLastEvent>
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 80080fe:	4b67      	ldr	r3, [pc, #412]	; (800829c <I2C2_EV_IRQHandler+0x1a8>)
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8008100:	4605      	mov	r5, r0
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 8008102:	ea00 0303 	and.w	r3, r0, r3
 8008106:	2b00      	cmp	r3, #0
 8008108:	d033      	beq.n	8008172 <I2C2_EV_IRQHandler+0x7e>
 800810a:	68e3      	ldr	r3, [r4, #12]
 800810c:	2b00      	cmp	r3, #0
 800810e:	d030      	beq.n	8008172 <I2C2_EV_IRQHandler+0x7e>
    // get received data
    b = I2C_ReceiveData(iicx->base);
 8008110:	6820      	ldr	r0, [r4, #0]
 8008112:	f000 fc11 	bl	8008938 <I2C_ReceiveData>

    // failsave: still place in buffer?
    if( iicx->buffer_ix < iicx->buffer_len )
 8008116:	8a62      	ldrh	r2, [r4, #18]
 8008118:	8a23      	ldrh	r3, [r4, #16]
 800811a:	b292      	uxth	r2, r2
 800811c:	b29b      	uxth	r3, r3
 800811e:	429a      	cmp	r2, r3
 8008120:	d206      	bcs.n	8008130 <I2C2_EV_IRQHandler+0x3c>
      iicx->rx_buffer_ptr[iicx->buffer_ix++] = b;
 8008122:	8a63      	ldrh	r3, [r4, #18]
 8008124:	68e2      	ldr	r2, [r4, #12]
 8008126:	b29b      	uxth	r3, r3
 8008128:	54d0      	strb	r0, [r2, r3]
 800812a:	3301      	adds	r3, #1
 800812c:	b29b      	uxth	r3, r3
 800812e:	8263      	strh	r3, [r4, #18]

    // last byte received, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8008130:	4b59      	ldr	r3, [pc, #356]	; (8008298 <I2C2_EV_IRQHandler+0x1a4>)
 8008132:	695a      	ldr	r2, [r3, #20]
 8008134:	f012 0f02 	tst.w	r2, #2
 8008138:	d13e      	bne.n	80081b8 <I2C2_EV_IRQHandler+0xc4>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    }
 
    // request NAK and stop condition before receiving last data
    if( (iicx->buffer_ix >= iicx->buffer_len-1) || (iicx->transfer_state.ABORT_IF_FIRST_BYTE_0 && iicx->buffer_ix == 1 && b == 0x00) ) {
 800813a:	8a59      	ldrh	r1, [r3, #18]
 800813c:	8a1a      	ldrh	r2, [r3, #16]
 800813e:	b289      	uxth	r1, r1
 8008140:	b292      	uxth	r2, r2
 8008142:	3a01      	subs	r2, #1
 8008144:	4291      	cmp	r1, r2
 8008146:	da0c      	bge.n	8008162 <I2C2_EV_IRQHandler+0x6e>
 8008148:	695a      	ldr	r2, [r3, #20]
 800814a:	f012 0f04 	tst.w	r2, #4
 800814e:	f000 80a1 	beq.w	8008294 <I2C2_EV_IRQHandler+0x1a0>
 8008152:	8a5b      	ldrh	r3, [r3, #18]
 8008154:	b29b      	uxth	r3, r3
 8008156:	2b01      	cmp	r3, #1
 8008158:	f040 809c 	bne.w	8008294 <I2C2_EV_IRQHandler+0x1a0>
 800815c:	2800      	cmp	r0, #0
 800815e:	f040 8099 	bne.w	8008294 <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 8008162:	4c4d      	ldr	r4, [pc, #308]	; (8008298 <I2C2_EV_IRQHandler+0x1a4>)
 8008164:	2100      	movs	r1, #0
 8008166:	6820      	ldr	r0, [r4, #0]
 8008168:	f000 fbcc 	bl	8008904 <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 800816c:	6820      	ldr	r0, [r4, #0]
 800816e:	2101      	movs	r1, #1
 8008170:	e011      	b.n	8008196 <I2C2_EV_IRQHandler+0xa2>
  }

  // ADDR set, TRA flag not set (indicates transmitter/receiver mode).
  // ADDR will be cleared by a read of SR1 followed by a read of SR2 (done by I2C_GetLastEvent)
  // If transmitter mode is selected (TRA set), we go on, TXE will be catched to send the first byte
  if( (event & I2C_FLAG_ADDR) && !(event & I2C_FLAG_TRA) ){
 8008172:	4b4b      	ldr	r3, [pc, #300]	; (80082a0 <I2C2_EV_IRQHandler+0x1ac>)
 8008174:	ea05 0303 	and.w	r3, r5, r3
 8008178:	b1a3      	cbz	r3, 80081a4 <I2C2_EV_IRQHandler+0xb0>
 800817a:	f415 2180 	ands.w	r1, r5, #262144	; 0x40000
 800817e:	d111      	bne.n	80081a4 <I2C2_EV_IRQHandler+0xb0>
    // address sent (receiver mode), receiving first byte - check if we already have to request NAK/Stop
    if( iicx->buffer_len == 1 ) {
 8008180:	4c45      	ldr	r4, [pc, #276]	; (8008298 <I2C2_EV_IRQHandler+0x1a4>)
 8008182:	8a25      	ldrh	r5, [r4, #16]
 8008184:	b2ad      	uxth	r5, r5
 8008186:	2d01      	cmp	r5, #1
 8008188:	f040 8084 	bne.w	8008294 <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 800818c:	6820      	ldr	r0, [r4, #0]
 800818e:	f000 fbb9 	bl	8008904 <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 8008192:	6820      	ldr	r0, [r4, #0]
 8008194:	4629      	mov	r1, r5
 8008196:	f000 fba8 	bl	80088ea <I2C_GenerateSTOP>
      iicx->transfer_state.STOP_REQUESTED = 1;
 800819a:	6963      	ldr	r3, [r4, #20]
 800819c:	f043 0302 	orr.w	r3, r3, #2
 80081a0:	6163      	str	r3, [r4, #20]
 80081a2:	e077      	b.n	8008294 <I2C2_EV_IRQHandler+0x1a0>

  // TxE set, will be cleared by writing DR, or after START or STOP was generated
  // This handling also applies for BTF, as TXE will alway be set if BTF is.
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  if( event & I2C_FLAG_TXE ){
 80081a4:	4a3f      	ldr	r2, [pc, #252]	; (80082a4 <I2C2_EV_IRQHandler+0x1b0>)
 80081a6:	ea05 0202 	and.w	r2, r5, r2
 80081aa:	2a00      	cmp	r2, #0
 80081ac:	d03e      	beq.n	800822c <I2C2_EV_IRQHandler+0x138>

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 80081ae:	4b3a      	ldr	r3, [pc, #232]	; (8008298 <I2C2_EV_IRQHandler+0x1a4>)
 80081b0:	695a      	ldr	r2, [r3, #20]
 80081b2:	f012 0f02 	tst.w	r2, #2
 80081b6:	d007      	beq.n	80081c8 <I2C2_EV_IRQHandler+0xd4>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 80081b8:	695a      	ldr	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80081ba:	6818      	ldr	r0, [r3, #0]
  if( event & I2C_FLAG_TXE ){

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 80081bc:	f36f 0200 	bfc	r2, #0, #1
 80081c0:	615a      	str	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80081c2:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 80081c6:	e02f      	b.n	8008228 <I2C2_EV_IRQHandler+0x134>
      return;
    }

    if( iicx->buffer_ix < iicx->buffer_len ) {
 80081c8:	8a59      	ldrh	r1, [r3, #18]
 80081ca:	8a1a      	ldrh	r2, [r3, #16]
 80081cc:	b289      	uxth	r1, r1
 80081ce:	b292      	uxth	r2, r2
 80081d0:	4291      	cmp	r1, r2
 80081d2:	d20b      	bcs.n	80081ec <I2C2_EV_IRQHandler+0xf8>
      // checking tx_buffer_ptr for NULL is a failsafe measure.
      I2C_SendData(iicx->base, (iicx->tx_buffer_ptr == NULL) ? 0 : iicx->tx_buffer_ptr[iicx->buffer_ix++]);
 80081d4:	6899      	ldr	r1, [r3, #8]
 80081d6:	6818      	ldr	r0, [r3, #0]
 80081d8:	b129      	cbz	r1, 80081e6 <I2C2_EV_IRQHandler+0xf2>
 80081da:	8a5a      	ldrh	r2, [r3, #18]
 80081dc:	b292      	uxth	r2, r2
 80081de:	5c89      	ldrb	r1, [r1, r2]
 80081e0:	3201      	adds	r2, #1
 80081e2:	b292      	uxth	r2, r2
 80081e4:	825a      	strh	r2, [r3, #18]
 80081e6:	f000 fba5 	bl	8008934 <I2C_SendData>
 80081ea:	e053      	b.n	8008294 <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 

    // peripheral is transfering last byte, request stop condition /
    // on write-without-stop transfer-type, request start condition instead
    if( !iicx->transfer_state.WRITE_WITHOUT_STOP )
 80081ec:	695a      	ldr	r2, [r3, #20]
 80081ee:	f012 0f08 	tst.w	r2, #8
 80081f2:	d104      	bne.n	80081fe <I2C2_EV_IRQHandler+0x10a>
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80081f4:	6818      	ldr	r0, [r3, #0]
 80081f6:	2101      	movs	r1, #1
 80081f8:	f000 fb77 	bl	80088ea <I2C_GenerateSTOP>
 80081fc:	e003      	b.n	8008206 <I2C2_EV_IRQHandler+0x112>
    else
      I2C_GenerateSTART(iicx->base, ENABLE);
 80081fe:	6818      	ldr	r0, [r3, #0]
 8008200:	2101      	movs	r1, #1
 8008202:	f000 fb65 	bl	80088d0 <I2C_GenerateSTART>
    iicx->transfer_state.STOP_REQUESTED = 1;
 8008206:	4b24      	ldr	r3, [pc, #144]	; (8008298 <I2C2_EV_IRQHandler+0x1a4>)
 8008208:	695a      	ldr	r2, [r3, #20]
 800820a:	f042 0202 	orr.w	r2, r2, #2
 800820e:	615a      	str	r2, [r3, #20]

    if( iicx->buffer_len == 0 ) {
 8008210:	8a1a      	ldrh	r2, [r3, #16]
 8008212:	b292      	uxth	r2, r2
 8008214:	b92a      	cbnz	r2, 8008222 <I2C2_EV_IRQHandler+0x12e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008216:	6959      	ldr	r1, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008218:	6818      	ldr	r0, [r3, #0]
      I2C_GenerateSTART(iicx->base, ENABLE);
    iicx->transfer_state.STOP_REQUESTED = 1;

    if( iicx->buffer_len == 0 ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800821a:	f362 0100 	bfi	r1, r2, #0, #1
 800821e:	6159      	str	r1, [r3, #20]
 8008220:	e012      	b.n	8008248 <I2C2_EV_IRQHandler+0x154>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
    } else {
      // Disable the I2C_IT_BUF interrupt after sending the last buffer data 
      // (last EV8) to not allow a new interrupt just with TxE - only BTF will generate it
      // if this is not done, BUSY will be cleared before the transfer is finished
      I2C_ITConfig(iicx->base, I2C_IT_BUF, DISABLE);
 8008222:	6818      	ldr	r0, [r3, #0]
 8008224:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008228:	2200      	movs	r2, #0
 800822a:	e00f      	b.n	800824c <I2C2_EV_IRQHandler+0x158>
    }
  return;
  }

  // SB set, cleared by reading SR1 (done by I2C_GetLastEvent) followed by writing DR register
  if( event & I2C_FLAG_SB ){
 800822c:	4e1e      	ldr	r6, [pc, #120]	; (80082a8 <I2C2_EV_IRQHandler+0x1b4>)
 800822e:	4c1a      	ldr	r4, [pc, #104]	; (8008298 <I2C2_EV_IRQHandler+0x1a4>)
 8008230:	ea05 0606 	and.w	r6, r5, r6
 8008234:	b1a6      	cbz	r6, 8008260 <I2C2_EV_IRQHandler+0x16c>
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8008236:	6963      	ldr	r3, [r4, #20]
 8008238:	f013 0f02 	tst.w	r3, #2
 800823c:	d009      	beq.n	8008252 <I2C2_EV_IRQHandler+0x15e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800823e:	6963      	ldr	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008240:	6820      	ldr	r0, [r4, #0]
  if( event & I2C_FLAG_SB ){
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008242:	f362 0300 	bfi	r3, r2, #0, #1
 8008246:	6163      	str	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008248:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 800824c:	f000 fb67 	bl	800891e <I2C_ITConfig>
 8008250:	e020      	b.n	8008294 <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
      (iicx->iic_address & 1)
 8008252:	7921      	ldrb	r1, [r4, #4]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
 8008254:	6820      	ldr	r0, [r4, #0]
 8008256:	f001 0201 	and.w	r2, r1, #1
 800825a:	f000 fb70 	bl	800893e <I2C_Send7bitAddress>
 800825e:	e019      	b.n	8008294 <I2C2_EV_IRQHandler+0x1a0>
  }

  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008260:	4632      	mov	r2, r6
 8008262:	6820      	ldr	r0, [r4, #0]
 8008264:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8008268:	f000 fb59 	bl	800891e <I2C_ITConfig>
  // notify error
  MIOS32_IIC_unexpected_event = event;
 800826c:	4b0f      	ldr	r3, [pc, #60]	; (80082ac <I2C2_EV_IRQHandler+0x1b8>)
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 800826e:	4631      	mov	r1, r6
  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
 8008270:	601d      	str	r5, [r3, #0]
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
 8008272:	f06f 0307 	mvn.w	r3, #7
 8008276:	61a3      	str	r3, [r4, #24]
  iicx->transfer_state.BUSY = 0;
 8008278:	6963      	ldr	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 800827a:	6820      	ldr	r0, [r4, #0]
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
 800827c:	f366 0300 	bfi	r3, r6, #0, #1
 8008280:	6163      	str	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 8008282:	f000 fb3f 	bl	8008904 <I2C_AcknowledgeConfig>
  b = I2C_ReceiveData(iicx->base);
 8008286:	6820      	ldr	r0, [r4, #0]
 8008288:	f000 fb56 	bl	8008938 <I2C_ReceiveData>
  I2C_GenerateSTOP(iicx->base, ENABLE);
 800828c:	6820      	ldr	r0, [r4, #0]
 800828e:	2101      	movs	r1, #1
 8008290:	f000 fb2b 	bl	80088ea <I2C_GenerateSTOP>
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
  EV_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 8008294:	bd70      	pop	{r4, r5, r6, pc}
 8008296:	bf00      	nop
 8008298:	20000534 	.word	0x20000534
 800829c:	10000040 	.word	0x10000040
 80082a0:	10000002 	.word	0x10000002
 80082a4:	10000080 	.word	0x10000080
 80082a8:	10000001 	.word	0x10000001
 80082ac:	200030d4 	.word	0x200030d4

080082b0 <I2C2_ER_IRQHandler>:

void I2C2_ER_IRQHandler(void)
{
 80082b0:	b538      	push	{r3, r4, r5, lr}
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 80082b2:	4d1c      	ldr	r5, [pc, #112]	; (8008324 <I2C2_ER_IRQHandler+0x74>)
 80082b4:	6828      	ldr	r0, [r5, #0]
 80082b6:	f000 fb4a 	bl	800894e <I2C_GetLastEvent>
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 80082ba:	4b1b      	ldr	r3, [pc, #108]	; (8008328 <I2C2_ER_IRQHandler+0x78>)
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 80082bc:	4604      	mov	r4, r0
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 80082be:	ea00 0303 	and.w	r3, r0, r3
 80082c2:	b133      	cbz	r3, 80082d2 <I2C2_ER_IRQHandler+0x22>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_BERR);
 80082c4:	6828      	ldr	r0, [r5, #0]
 80082c6:	4919      	ldr	r1, [pc, #100]	; (800832c <I2C2_ER_IRQHandler+0x7c>)
 80082c8:	f000 fb49 	bl	800895e <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_BUS;
 80082cc:	f06f 0305 	mvn.w	r3, #5
 80082d0:	61ab      	str	r3, [r5, #24]
  }

  // arbitration lost
  if( event & I2C_FLAG_ARLO ) {
 80082d2:	4b17      	ldr	r3, [pc, #92]	; (8008330 <I2C2_ER_IRQHandler+0x80>)
 80082d4:	ea04 0303 	and.w	r3, r4, r3
 80082d8:	b13b      	cbz	r3, 80082ea <I2C2_ER_IRQHandler+0x3a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_ARLO);
 80082da:	4d12      	ldr	r5, [pc, #72]	; (8008324 <I2C2_ER_IRQHandler+0x74>)
 80082dc:	4915      	ldr	r1, [pc, #84]	; (8008334 <I2C2_ER_IRQHandler+0x84>)
 80082de:	6828      	ldr	r0, [r5, #0]
 80082e0:	f000 fb3d 	bl	800895e <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_ARBITRATION_LOST;
 80082e4:	f06f 0304 	mvn.w	r3, #4
 80082e8:	61ab      	str	r3, [r5, #24]
  }

  // no acknowledge received from slave (e.g. slave not connected)
  if( event & I2C_FLAG_AF ) {
 80082ea:	4b13      	ldr	r3, [pc, #76]	; (8008338 <I2C2_ER_IRQHandler+0x88>)
 80082ec:	ea04 0303 	and.w	r3, r4, r3
 80082f0:	b15b      	cbz	r3, 800830a <I2C2_ER_IRQHandler+0x5a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_AF);
 80082f2:	4c0c      	ldr	r4, [pc, #48]	; (8008324 <I2C2_ER_IRQHandler+0x74>)
 80082f4:	4911      	ldr	r1, [pc, #68]	; (800833c <I2C2_ER_IRQHandler+0x8c>)
 80082f6:	6820      	ldr	r0, [r4, #0]
 80082f8:	f000 fb31 	bl	800895e <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_SLAVE_NOT_CONNECTED;
 80082fc:	f06f 0306 	mvn.w	r3, #6
 8008300:	61a3      	str	r3, [r4, #24]
    // send stop condition to release bus
    I2C_GenerateSTOP(iicx->base, ENABLE);
 8008302:	6820      	ldr	r0, [r4, #0]
 8008304:	2101      	movs	r1, #1
 8008306:	f000 faf0 	bl	80088ea <I2C_GenerateSTOP>
  }

  // disable interrupts
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 800830a:	4c06      	ldr	r4, [pc, #24]	; (8008324 <I2C2_ER_IRQHandler+0x74>)
 800830c:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8008310:	6820      	ldr	r0, [r4, #0]
 8008312:	2200      	movs	r2, #0
 8008314:	f000 fb03 	bl	800891e <I2C_ITConfig>

  // notify that transfer has finished (due to the error)
  iicx->transfer_state.BUSY = 0;
 8008318:	6963      	ldr	r3, [r4, #20]
 800831a:	f36f 0300 	bfc	r3, #0, #1
 800831e:	6163      	str	r3, [r4, #20]
}

void I2C2_ER_IRQHandler(void)
{
  ER_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 8008320:	bd38      	pop	{r3, r4, r5, pc}
 8008322:	bf00      	nop
 8008324:	20000534 	.word	0x20000534
 8008328:	10000100 	.word	0x10000100
 800832c:	01000100 	.word	0x01000100
 8008330:	10000200 	.word	0x10000200
 8008334:	01000200 	.word	0x01000200
 8008338:	10000400 	.word	0x10000400
 800833c:	01000400 	.word	0x01000400

08008340 <printchar>:

#include <stdarg.h>
#include <mios32.h>

static void printchar(char **str, int c)
{
 8008340:	b508      	push	{r3, lr}
  //	extern int putchar(int c);
	
	if (str) {
 8008342:	b128      	cbz	r0, 8008350 <printchar+0x10>
		**str = c;
 8008344:	6803      	ldr	r3, [r0, #0]
 8008346:	7019      	strb	r1, [r3, #0]
		++(*str);
 8008348:	6803      	ldr	r3, [r0, #0]
 800834a:	3301      	adds	r3, #1
 800834c:	6003      	str	r3, [r0, #0]
 800834e:	e003      	b.n	8008358 <printchar+0x18>
	}
#ifndef MIOS32_DONT_USE_COM
	else MIOS32_COM_SendChar(1, c); // (void)putchar(c);
 8008350:	b2c9      	uxtb	r1, r1
 8008352:	2001      	movs	r0, #1
 8008354:	f7fd fe82 	bl	800605c <MIOS32_COM_SendChar>
#endif
}
 8008358:	bd08      	pop	{r3, pc}

0800835a <prints>:

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 800835a:	2a00      	cmp	r2, #0

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 800835c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800835e:	468c      	mov	ip, r1
 8008360:	4604      	mov	r4, r0
 8008362:	4615      	mov	r5, r2
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 8008364:	dd10      	ble.n	8008388 <prints+0x2e>
 8008366:	2200      	movs	r2, #0
 8008368:	e000      	b.n	800836c <prints+0x12>
		register int len = 0;
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
 800836a:	3201      	adds	r2, #1
 800836c:	f81c 1002 	ldrb.w	r1, [ip, r2]
 8008370:	2900      	cmp	r1, #0
 8008372:	d1fa      	bne.n	800836a <prints+0x10>
		if (len >= width) width = 0;
 8008374:	42aa      	cmp	r2, r5
 8008376:	bfac      	ite	ge
 8008378:	460d      	movge	r5, r1
		else width -= len;
 800837a:	1aad      	sublt	r5, r5, r2
		if (pad & PAD_ZERO) padchar = '0';
 800837c:	f013 0f02 	tst.w	r3, #2
 8008380:	bf0c      	ite	eq
 8008382:	2720      	moveq	r7, #32
 8008384:	2730      	movne	r7, #48	; 0x30
 8008386:	e000      	b.n	800838a <prints+0x30>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 8008388:	2720      	movs	r7, #32
		for (ptr = string; *ptr; ++ptr) ++len;
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
 800838a:	f013 0601 	ands.w	r6, r3, #1
 800838e:	d10d      	bne.n	80083ac <prints+0x52>
 8008390:	e009      	b.n	80083a6 <prints+0x4c>
		for ( ; width > 0; --width) {
			printchar (out, padchar);
 8008392:	4620      	mov	r0, r4
 8008394:	4639      	mov	r1, r7
 8008396:	f8cd c004 	str.w	ip, [sp, #4]
 800839a:	f7ff ffd1 	bl	8008340 <printchar>
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 800839e:	f8dd c004 	ldr.w	ip, [sp, #4]
			printchar (out, padchar);
			++pc;
 80083a2:	3601      	adds	r6, #1
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80083a4:	3d01      	subs	r5, #1
 80083a6:	2d00      	cmp	r5, #0
 80083a8:	dcf3      	bgt.n	8008392 <prints+0x38>
 80083aa:	e000      	b.n	80083ae <prints+0x54>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 80083ac:	2600      	movs	r6, #0
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80083ae:	4663      	mov	r3, ip
 80083b0:	e005      	b.n	80083be <prints+0x64>
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
 80083b2:	4620      	mov	r0, r4
 80083b4:	9301      	str	r3, [sp, #4]
 80083b6:	f7ff ffc3 	bl	8008340 <printchar>
		++pc;
 80083ba:	9b01      	ldr	r3, [sp, #4]
 80083bc:	3601      	adds	r6, #1
		for ( ; width > 0; --width) {
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
 80083be:	f813 1b01 	ldrb.w	r1, [r3], #1
 80083c2:	2900      	cmp	r1, #0
 80083c4:	d1f5      	bne.n	80083b2 <prints+0x58>
 80083c6:	e005      	b.n	80083d4 <prints+0x7a>
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
		printchar (out, padchar);
 80083c8:	4620      	mov	r0, r4
 80083ca:	4639      	mov	r1, r7
 80083cc:	f7ff ffb8 	bl	8008340 <printchar>
		++pc;
 80083d0:	3601      	adds	r6, #1
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
 80083d2:	3d01      	subs	r5, #1
 80083d4:	2d00      	cmp	r5, #0
 80083d6:	dcf7      	bgt.n	80083c8 <prints+0x6e>
		printchar (out, padchar);
		++pc;
	}

	return pc;
}
 80083d8:	4630      	mov	r0, r6
 80083da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080083dc <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 80083dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80083de:	b087      	sub	sp, #28
 80083e0:	4604      	mov	r4, r0
 80083e2:	461d      	mov	r5, r3
 80083e4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80083e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
	register unsigned int u = i;
 80083e8:	4608      	mov	r0, r1

	if (i == 0) {
 80083ea:	b951      	cbnz	r1, 8008402 <printi+0x26>
		print_buf[0] = '0';
 80083ec:	2230      	movs	r2, #48	; 0x30
 80083ee:	f88d 200c 	strb.w	r2, [sp, #12]
		print_buf[1] = '\0';
 80083f2:	f88d 100d 	strb.w	r1, [sp, #13]
		return prints (out, print_buf, width, pad);
 80083f6:	4620      	mov	r0, r4
 80083f8:	a903      	add	r1, sp, #12
 80083fa:	4632      	mov	r2, r6
 80083fc:	f7ff ffad 	bl	800835a <prints>
 8008400:	e043      	b.n	800848a <printi+0xae>
	}

	if (sg && b == 10 && i < 0) {
 8008402:	2a0a      	cmp	r2, #10
 8008404:	bf14      	ite	ne
 8008406:	2100      	movne	r1, #0
 8008408:	2101      	moveq	r1, #1
 800840a:	2d00      	cmp	r5, #0
 800840c:	bf0c      	ite	eq
 800840e:	2500      	moveq	r5, #0
 8008410:	f001 0501 	andne.w	r5, r1, #1
 8008414:	b12d      	cbz	r5, 8008422 <printi+0x46>
 8008416:	2800      	cmp	r0, #0
 8008418:	da02      	bge.n	8008420 <printi+0x44>
		neg = 1;
		u = -i;
 800841a:	4240      	negs	r0, r0
		print_buf[1] = '\0';
		return prints (out, print_buf, width, pad);
	}

	if (sg && b == 10 && i < 0) {
		neg = 1;
 800841c:	2501      	movs	r5, #1
 800841e:	e000      	b.n	8008422 <printi+0x46>

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 8008420:	2500      	movs	r5, #0
	*s = '\0';

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 8008422:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
		neg = 1;
		u = -i;
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';
 8008426:	a906      	add	r1, sp, #24
 8008428:	f04f 0c00 	mov.w	ip, #0
 800842c:	f801 cd01 	strb.w	ip, [r1, #-1]!

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 8008430:	f1ae 0e3a 	sub.w	lr, lr, #58	; 0x3a
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 8008434:	e00d      	b.n	8008452 <printi+0x76>
		t = u % b;
 8008436:	fbb0 fcf2 	udiv	ip, r0, r2
 800843a:	fb02 0c1c 	mls	ip, r2, ip, r0
		if( t >= 10 )
 800843e:	f1bc 0f09 	cmp.w	ip, #9
			t += letbase - '0' - 10;
 8008442:	bfc8      	it	gt
 8008444:	44f4      	addgt	ip, lr
		*--s = t + '0';
 8008446:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800844a:	f801 cd01 	strb.w	ip, [r1, #-1]!
		u /= b;
 800844e:	fbb0 f0f2 	udiv	r0, r0, r2
 8008452:	460f      	mov	r7, r1
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 8008454:	2800      	cmp	r0, #0
 8008456:	d1ee      	bne.n	8008436 <printi+0x5a>
			t += letbase - '0' - 10;
		*--s = t + '0';
		u /= b;
	}

	if (neg) {
 8008458:	b18d      	cbz	r5, 800847e <printi+0xa2>
		if( width && (pad & PAD_ZERO) ) {
 800845a:	b15e      	cbz	r6, 8008474 <printi+0x98>
 800845c:	f013 0f02 	tst.w	r3, #2
 8008460:	d008      	beq.n	8008474 <printi+0x98>
			printchar (out, '-');
 8008462:	4620      	mov	r0, r4
 8008464:	212d      	movs	r1, #45	; 0x2d
 8008466:	9301      	str	r3, [sp, #4]
			++pc;
			--width;
 8008468:	3e01      	subs	r6, #1
		u /= b;
	}

	if (neg) {
		if( width && (pad & PAD_ZERO) ) {
			printchar (out, '-');
 800846a:	f7ff ff69 	bl	8008340 <printchar>
			++pc;
 800846e:	2501      	movs	r5, #1
			--width;
 8008470:	9b01      	ldr	r3, [sp, #4]
 8008472:	e004      	b.n	800847e <printi+0xa2>
		}
		else {
			*--s = '-';
 8008474:	222d      	movs	r2, #45	; 0x2d
 8008476:	1e4f      	subs	r7, r1, #1
 8008478:	f801 2c01 	strb.w	r2, [r1, #-1]

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 800847c:	2500      	movs	r5, #0
		else {
			*--s = '-';
		}
	}

	return pc + prints (out, s, width, pad);
 800847e:	4620      	mov	r0, r4
 8008480:	4639      	mov	r1, r7
 8008482:	4632      	mov	r2, r6
 8008484:	f7ff ff69 	bl	800835a <prints>
 8008488:	1940      	adds	r0, r0, r5
}
 800848a:	b007      	add	sp, #28
 800848c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08008490 <print>:

static int print( char **out, const char *format, va_list args )
{
 8008490:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008492:	b089      	sub	sp, #36	; 0x24
 8008494:	4606      	mov	r6, r0
 8008496:	460d      	mov	r5, r1
 8008498:	9205      	str	r2, [sp, #20]
	register int width, pad;
	register int pc = 0;
 800849a:	2400      	movs	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
 800849c:	e07a      	b.n	8008594 <print+0x104>
		if (*format == '%') {
 800849e:	2b25      	cmp	r3, #37	; 0x25
 80084a0:	d172      	bne.n	8008588 <print+0xf8>
			++format;
			width = pad = 0;
			if (*format == '\0') break;
 80084a2:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80084a6:	2b00      	cmp	r3, #0
 80084a8:	d077      	beq.n	800859a <print+0x10a>
			if (*format == '%') goto out;
 80084aa:	2b25      	cmp	r3, #37	; 0x25
 80084ac:	d06c      	beq.n	8008588 <print+0xf8>
			if (*format == '-') {
 80084ae:	2b2d      	cmp	r3, #45	; 0x2d
 80084b0:	d102      	bne.n	80084b8 <print+0x28>
				++format;
 80084b2:	3501      	adds	r5, #1
				pad = PAD_RIGHT;
 80084b4:	2301      	movs	r3, #1
 80084b6:	e003      	b.n	80084c0 <print+0x30>
	char scr[2];

	for (; *format != 0; ++format) {
		if (*format == '%') {
			++format;
			width = pad = 0;
 80084b8:	2300      	movs	r3, #0
 80084ba:	e001      	b.n	80084c0 <print+0x30>
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
 80084bc:	f043 0302 	orr.w	r3, r3, #2
 80084c0:	462f      	mov	r7, r5
			if (*format == '%') goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
 80084c2:	f815 2b01 	ldrb.w	r2, [r5], #1
 80084c6:	2a30      	cmp	r2, #48	; 0x30
 80084c8:	d0f8      	beq.n	80084bc <print+0x2c>
 80084ca:	2200      	movs	r2, #0
 80084cc:	e002      	b.n	80084d4 <print+0x44>
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
				width *= 10;
				width += *format - '0';
 80084ce:	200a      	movs	r0, #10
 80084d0:	fb00 c202 	mla	r2, r0, r2, ip
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 80084d4:	7839      	ldrb	r1, [r7, #0]
				width *= 10;
				width += *format - '0';
 80084d6:	463d      	mov	r5, r7
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 80084d8:	f1a1 0c30 	sub.w	ip, r1, #48	; 0x30
 80084dc:	fa5f f08c 	uxtb.w	r0, ip
 80084e0:	3701      	adds	r7, #1
 80084e2:	2809      	cmp	r0, #9
 80084e4:	d9f3      	bls.n	80084ce <print+0x3e>
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
 80084e6:	2973      	cmp	r1, #115	; 0x73
 80084e8:	d109      	bne.n	80084fe <print+0x6e>
				register char *s = (char *)va_arg( args, int );
 80084ea:	9905      	ldr	r1, [sp, #20]
 80084ec:	1d08      	adds	r0, r1, #4
 80084ee:	9005      	str	r0, [sp, #20]
 80084f0:	6809      	ldr	r1, [r1, #0]
				pc += prints (out, s?s:"(null)", width, pad);
 80084f2:	482d      	ldr	r0, [pc, #180]	; (80085a8 <print+0x118>)
 80084f4:	2900      	cmp	r1, #0
 80084f6:	bf08      	it	eq
 80084f8:	4601      	moveq	r1, r0
 80084fa:	4630      	mov	r0, r6
 80084fc:	e041      	b.n	8008582 <print+0xf2>
				continue;
			}
			if( *format == 'd' ) {
 80084fe:	2964      	cmp	r1, #100	; 0x64
 8008500:	d10e      	bne.n	8008520 <print+0x90>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 8008502:	9905      	ldr	r1, [sp, #20]
 8008504:	9301      	str	r3, [sp, #4]
 8008506:	2361      	movs	r3, #97	; 0x61
 8008508:	9200      	str	r2, [sp, #0]
 800850a:	9302      	str	r3, [sp, #8]
 800850c:	1d08      	adds	r0, r1, #4
 800850e:	6809      	ldr	r1, [r1, #0]
 8008510:	9005      	str	r0, [sp, #20]
 8008512:	220a      	movs	r2, #10
 8008514:	4630      	mov	r0, r6
 8008516:	2301      	movs	r3, #1
 8008518:	f7ff ff60 	bl	80083dc <printi>
 800851c:	1824      	adds	r4, r4, r0
				continue;
 800851e:	e038      	b.n	8008592 <print+0x102>
			}
			if( *format == 'x' ) {
 8008520:	2978      	cmp	r1, #120	; 0x78
 8008522:	d106      	bne.n	8008532 <print+0xa2>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 8008524:	9905      	ldr	r1, [sp, #20]
 8008526:	9301      	str	r3, [sp, #4]
 8008528:	1d08      	adds	r0, r1, #4
 800852a:	9005      	str	r0, [sp, #20]
 800852c:	9200      	str	r2, [sp, #0]
 800852e:	2361      	movs	r3, #97	; 0x61
 8008530:	e007      	b.n	8008542 <print+0xb2>
				continue;
			}
			if( *format == 'X' ) {
 8008532:	2958      	cmp	r1, #88	; 0x58
 8008534:	d10a      	bne.n	800854c <print+0xbc>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 8008536:	9905      	ldr	r1, [sp, #20]
 8008538:	9301      	str	r3, [sp, #4]
 800853a:	1d08      	adds	r0, r1, #4
 800853c:	9005      	str	r0, [sp, #20]
 800853e:	9200      	str	r2, [sp, #0]
 8008540:	2341      	movs	r3, #65	; 0x41
 8008542:	9302      	str	r3, [sp, #8]
 8008544:	4630      	mov	r0, r6
 8008546:	6809      	ldr	r1, [r1, #0]
 8008548:	2210      	movs	r2, #16
 800854a:	e00b      	b.n	8008564 <print+0xd4>
				continue;
			}
			if( *format == 'u' ) {
 800854c:	2975      	cmp	r1, #117	; 0x75
 800854e:	d10b      	bne.n	8008568 <print+0xd8>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 8008550:	9905      	ldr	r1, [sp, #20]
 8008552:	9301      	str	r3, [sp, #4]
 8008554:	2361      	movs	r3, #97	; 0x61
 8008556:	9200      	str	r2, [sp, #0]
 8008558:	9302      	str	r3, [sp, #8]
 800855a:	1d08      	adds	r0, r1, #4
 800855c:	6809      	ldr	r1, [r1, #0]
 800855e:	9005      	str	r0, [sp, #20]
 8008560:	220a      	movs	r2, #10
 8008562:	4630      	mov	r0, r6
 8008564:	2300      	movs	r3, #0
 8008566:	e7d7      	b.n	8008518 <print+0x88>
				continue;
			}
			if( *format == 'c' ) {
 8008568:	2963      	cmp	r1, #99	; 0x63
 800856a:	d112      	bne.n	8008592 <print+0x102>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
 800856c:	9905      	ldr	r1, [sp, #20]
 800856e:	1d08      	adds	r0, r1, #4
 8008570:	6809      	ldr	r1, [r1, #0]
 8008572:	9005      	str	r0, [sp, #20]
 8008574:	f88d 101c 	strb.w	r1, [sp, #28]
				scr[1] = '\0';
 8008578:	2100      	movs	r1, #0
 800857a:	f88d 101d 	strb.w	r1, [sp, #29]
				pc += prints (out, scr, width, pad);
 800857e:	4630      	mov	r0, r6
 8008580:	a907      	add	r1, sp, #28
 8008582:	f7ff feea 	bl	800835a <prints>
 8008586:	e7c9      	b.n	800851c <print+0x8c>
				continue;
			}
		}
		else {
		out:
			printchar (out, *format);
 8008588:	7829      	ldrb	r1, [r5, #0]
 800858a:	4630      	mov	r0, r6
 800858c:	f7ff fed8 	bl	8008340 <printchar>
			++pc;
 8008590:	3401      	adds	r4, #1
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
 8008592:	3501      	adds	r5, #1
 8008594:	782b      	ldrb	r3, [r5, #0]
 8008596:	2b00      	cmp	r3, #0
 8008598:	d181      	bne.n	800849e <print+0xe>
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
 800859a:	b116      	cbz	r6, 80085a2 <print+0x112>
 800859c:	6833      	ldr	r3, [r6, #0]
 800859e:	2200      	movs	r2, #0
 80085a0:	701a      	strb	r2, [r3, #0]
	va_end( args );
	return pc;
}
 80085a2:	4620      	mov	r0, r4
 80085a4:	b009      	add	sp, #36	; 0x24
 80085a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80085a8:	0800a3a0 	.word	0x0800a3a0

080085ac <sprintf>:
{
  return print( 0, format, args );
}

int sprintf(char *out, const char *format, ...)
{
 80085ac:	b40e      	push	{r1, r2, r3}
 80085ae:	b50f      	push	{r0, r1, r2, r3, lr}
 80085b0:	aa05      	add	r2, sp, #20
 80085b2:	f852 1b04 	ldr.w	r1, [r2], #4
 80085b6:	9001      	str	r0, [sp, #4]
        va_list args;
        
        va_start( args, format );
        return print( &out, format, args );
 80085b8:	a801      	add	r0, sp, #4

int sprintf(char *out, const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
 80085ba:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 80085bc:	f7ff ff68 	bl	8008490 <print>
}
 80085c0:	b004      	add	sp, #16
 80085c2:	f85d eb04 	ldr.w	lr, [sp], #4
 80085c6:	b003      	add	sp, #12
 80085c8:	4770      	bx	lr

080085ca <vsprintf>:

// TK: added for alternative parameter passing
int vsprintf(char *out, const char *format, va_list args)
{
 80085ca:	b507      	push	{r0, r1, r2, lr}
 80085cc:	4603      	mov	r3, r0
  char *_out;
  _out = out;
 80085ce:	a802      	add	r0, sp, #8
 80085d0:	f840 3d04 	str.w	r3, [r0, #-4]!
  return print( &_out, format, args );
 80085d4:	f7ff ff5c 	bl	8008490 <print>
}
 80085d8:	bd0e      	pop	{r1, r2, r3, pc}

080085da <GPIO_Init>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 80085da:	78cb      	ldrb	r3, [r1, #3]
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80085dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 80085de:	f013 0f10 	tst.w	r3, #16
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 80085e2:	f003 020f 	and.w	r2, r3, #15
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 80085e6:	880f      	ldrh	r7, [r1, #0]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 80085e8:	bf1c      	itt	ne
 80085ea:	788b      	ldrbne	r3, [r1, #2]
 80085ec:	431a      	orrne	r2, r3
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 80085ee:	f017 0fff 	tst.w	r7, #255	; 0xff
 80085f2:	d022      	beq.n	800863a <GPIO_Init+0x60>
  {
    tmpreg = GPIOx->CRL;
 80085f4:	f8d0 c000 	ldr.w	ip, [r0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80085f8:	2300      	movs	r3, #0
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 80085fa:	9701      	str	r7, [sp, #4]
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
 80085fc:	2401      	movs	r4, #1
 80085fe:	fa14 f503 	lsls.w	r5, r4, r3
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8008602:	9e01      	ldr	r6, [sp, #4]
 8008604:	ea05 0406 	and.w	r4, r5, r6
      if (currentpin == pos)
 8008608:	42ac      	cmp	r4, r5
 800860a:	d111      	bne.n	8008630 <GPIO_Init+0x56>
      {
        pos = pinpos << 2;
 800860c:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 800860e:	270f      	movs	r7, #15
 8008610:	fa17 f506 	lsls.w	r5, r7, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008614:	fa12 f606 	lsls.w	r6, r2, r6
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8008618:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800861c:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800861e:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008622:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8008624:	bf08      	it	eq
 8008626:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008628:	d002      	beq.n	8008630 <GPIO_Init+0x56>
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 800862a:	2d48      	cmp	r5, #72	; 0x48
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 800862c:	bf08      	it	eq
 800862e:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008630:	3301      	adds	r3, #1
 8008632:	2b08      	cmp	r3, #8
 8008634:	d1e2      	bne.n	80085fc <GPIO_Init+0x22>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8008636:	f8c0 c000 	str.w	ip, [r0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 800863a:	880f      	ldrh	r7, [r1, #0]
 800863c:	2fff      	cmp	r7, #255	; 0xff
 800863e:	d924      	bls.n	800868a <GPIO_Init+0xb0>
  {
    tmpreg = GPIOx->CRH;
 8008640:	f8d0 c004 	ldr.w	ip, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008644:	2300      	movs	r3, #0
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008646:	9201      	str	r2, [sp, #4]
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8008648:	2201      	movs	r2, #1
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
 800864a:	f103 0508 	add.w	r5, r3, #8
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 800864e:	fa12 f505 	lsls.w	r5, r2, r5
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8008652:	ea05 0407 	and.w	r4, r5, r7
      if (currentpin == pos)
 8008656:	42ac      	cmp	r4, r5
 8008658:	d112      	bne.n	8008680 <GPIO_Init+0xa6>
      {
        pos = pinpos << 2;
 800865a:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 800865c:	320e      	adds	r2, #14
 800865e:	fa12 f506 	lsls.w	r5, r2, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008662:	9a01      	ldr	r2, [sp, #4]
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8008664:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008668:	fa12 f606 	lsls.w	r6, r2, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800866c:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800866e:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008672:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8008674:	bf08      	it	eq
 8008676:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008678:	d002      	beq.n	8008680 <GPIO_Init+0xa6>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 800867a:	2d48      	cmp	r5, #72	; 0x48
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800867c:	bf08      	it	eq
 800867e:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008680:	3301      	adds	r3, #1
 8008682:	2b08      	cmp	r3, #8
 8008684:	d1e0      	bne.n	8008648 <GPIO_Init+0x6e>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8008686:	f8c0 c004 	str.w	ip, [r0, #4]
  }
}
 800868a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800868c <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800868c:	f04f 33ff 	mov.w	r3, #4294967295
 8008690:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8008692:	2302      	movs	r3, #2
 8008694:	7083      	strb	r3, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8008696:	18db      	adds	r3, r3, r3
 8008698:	70c3      	strb	r3, [r0, #3]
}
 800869a:	4770      	bx	lr

0800869c <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 800869c:	2800      	cmp	r0, #0
  {
    tmpreg = AFIO->MAPR2;
 800869e:	bfb4      	ite	lt
 80086a0:	4b1a      	ldrlt	r3, [pc, #104]	; (800870c <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    tmpreg = AFIO->MAPR;
 80086a2:	4b1a      	ldrge	r3, [pc, #104]	; (800870c <GPIO_PinRemapConfig+0x70>)
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80086a4:	f400 1c40 	and.w	ip, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 80086a8:	bfb4      	ite	lt
 80086aa:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 80086ac:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80086ae:	f5bc 1f40 	cmp.w	ip, #3145728	; 0x300000
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 80086b2:	b510      	push	{r4, lr}
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 80086b4:	b282      	uxth	r2, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80086b6:	d10a      	bne.n	80086ce <GPIO_PinRemapConfig+0x32>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 80086b8:	f8df c050 	ldr.w	ip, [pc, #80]	; 800870c <GPIO_PinRemapConfig+0x70>
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 80086bc:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 80086c0:	f8dc 4004 	ldr.w	r4, [ip, #4]
 80086c4:	f024 6470 	bic.w	r4, r4, #251658240	; 0xf000000
 80086c8:	f8cc 4004 	str.w	r4, [ip, #4]
 80086cc:	e012      	b.n	80086f4 <GPIO_PinRemapConfig+0x58>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 80086ce:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 80086d2:	bf02      	ittt	eq
 80086d4:	ea4f 5c50 	moveq.w	ip, r0, lsr #21
 80086d8:	ea4f 1c0c 	moveq.w	ip, ip, lsl #4
 80086dc:	fa02 fc0c 	lsleq.w	ip, r2, ip
  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 80086e0:	d004      	beq.n	80086ec <GPIO_PinRemapConfig+0x50>
  else
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 80086e2:	f3c0 4c03 	ubfx	ip, r0, #16, #4
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 80086e6:	2403      	movs	r4, #3
 80086e8:	fa04 fc0c 	lsl.w	ip, r4, ip
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 80086ec:	ea23 030c 	bic.w	r3, r3, ip
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 80086f0:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  }

  if (NewState != DISABLE)
 80086f4:	b119      	cbz	r1, 80086fe <GPIO_PinRemapConfig+0x62>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 80086f6:	0d41      	lsrs	r1, r0, #21
 80086f8:	0109      	lsls	r1, r1, #4
 80086fa:	408a      	lsls	r2, r1
 80086fc:	4313      	orrs	r3, r2
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 80086fe:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 8008700:	bfb5      	itete	lt
 8008702:	4a02      	ldrlt	r2, [pc, #8]	; (800870c <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008704:	4a01      	ldrge	r2, [pc, #4]	; (800870c <GPIO_PinRemapConfig+0x70>)
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    AFIO->MAPR2 = tmpreg;
 8008706:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008708:	6053      	strge	r3, [r2, #4]
  }  
}
 800870a:	bd10      	pop	{r4, pc}
 800870c:	40010000 	.word	0x40010000

08008710 <FLASH_SetLatency>:
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 8008710:	4b03      	ldr	r3, [pc, #12]	; (8008720 <FLASH_SetLatency+0x10>)
 8008712:	681a      	ldr	r2, [r3, #0]
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8008714:	f002 0238 	and.w	r2, r2, #56	; 0x38
  tmpreg |= FLASH_Latency;
 8008718:	4310      	orrs	r0, r2
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 800871a:	6018      	str	r0, [r3, #0]
}
 800871c:	4770      	bx	lr
 800871e:	bf00      	nop
 8008720:	40022000 	.word	0x40022000

08008724 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 8008724:	4b04      	ldr	r3, [pc, #16]	; (8008738 <FLASH_PrefetchBufferCmd+0x14>)
 8008726:	681a      	ldr	r2, [r3, #0]
 8008728:	f022 0210 	bic.w	r2, r2, #16
 800872c:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 800872e:	681a      	ldr	r2, [r3, #0]
 8008730:	4310      	orrs	r0, r2
 8008732:	6018      	str	r0, [r3, #0]
}
 8008734:	4770      	bx	lr
 8008736:	bf00      	nop
 8008738:	40022000 	.word	0x40022000

0800873c <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800873c:	f8b1 c002 	ldrh.w	ip, [r1, #2]
 8008740:	880b      	ldrh	r3, [r1, #0]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8008742:	8802      	ldrh	r2, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008744:	ea4c 0303 	orr.w	r3, ip, r3
 8008748:	f8b1 c004 	ldrh.w	ip, [r1, #4]

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_Mask;
 800874c:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008750:	ea43 030c 	orr.w	r3, r3, ip
 8008754:	f8b1 c006 	ldrh.w	ip, [r1, #6]
 8008758:	ea43 030c 	orr.w	r3, r3, ip
 800875c:	f8b1 c008 	ldrh.w	ip, [r1, #8]
 8008760:	ea43 030c 	orr.w	r3, r3, ip
 8008764:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 8008768:	ea43 030c 	orr.w	r3, r3, ip
 800876c:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
 8008770:	ea43 030c 	orr.w	r3, r3, ip
 8008774:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
 8008778:	ea43 030c 	orr.w	r3, r3, ip
 800877c:	ea42 0303 	orr.w	r3, r2, r3
 8008780:	b29b      	uxth	r3, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8008782:	8003      	strh	r3, [r0, #0]
  
  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= SPI_Mode_Select;		
 8008784:	8b83      	ldrh	r3, [r0, #28]
 8008786:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800878a:	041b      	lsls	r3, r3, #16
 800878c:	0c1b      	lsrs	r3, r3, #16
 800878e:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8008790:	8a0b      	ldrh	r3, [r1, #16]
 8008792:	8203      	strh	r3, [r0, #16]
}
 8008794:	4770      	bx	lr

08008796 <SPI_Cmd>:
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008796:	b121      	cbz	r1, 80087a2 <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 8008798:	8803      	ldrh	r3, [r0, #0]
 800879a:	b29b      	uxth	r3, r3
 800879c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80087a0:	e004      	b.n	80087ac <SPI_Cmd+0x16>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= CR1_SPE_Reset;
 80087a2:	8803      	ldrh	r3, [r0, #0]
 80087a4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80087a8:	041b      	lsls	r3, r3, #16
 80087aa:	0c1b      	lsrs	r3, r3, #16
 80087ac:	8003      	strh	r3, [r0, #0]
  }
}
 80087ae:	4770      	bx	lr

080087b0 <SPI_I2S_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
 80087b0:	b11a      	cbz	r2, 80087ba <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80087b2:	8883      	ldrh	r3, [r0, #4]
 80087b4:	b29b      	uxth	r3, r3
 80087b6:	4319      	orrs	r1, r3
 80087b8:	e003      	b.n	80087c2 <SPI_I2S_DMACmd+0x12>
  }
  else
  {
    /* Disable the selected SPI/I2S DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 80087ba:	8883      	ldrh	r3, [r0, #4]
 80087bc:	b29b      	uxth	r3, r3
 80087be:	ea23 0101 	bic.w	r1, r3, r1
 80087c2:	8081      	strh	r1, [r0, #4]
  }
}
 80087c4:	4770      	bx	lr
	...

080087c8 <USART_Init>:
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80087c8:	8a03      	ldrh	r3, [r0, #16]
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 80087ca:	88ca      	ldrh	r2, [r1, #6]
  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 80087cc:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80087d0:	041b      	lsls	r3, r3, #16
 80087d2:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80087d4:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80087d6:	b530      	push	{r4, r5, lr}
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80087d8:	8203      	strh	r3, [r0, #16]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80087da:	460d      	mov	r5, r1
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 80087dc:	8983      	ldrh	r3, [r0, #12]
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80087de:	8909      	ldrh	r1, [r1, #8]
 80087e0:	88aa      	ldrh	r2, [r5, #4]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80087e2:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80087e6:	ea41 0202 	orr.w	r2, r1, r2
 80087ea:	8969      	ldrh	r1, [r5, #10]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80087ec:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80087f0:	430a      	orrs	r2, r1
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80087f2:	041b      	lsls	r3, r3, #16
 80087f4:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80087f6:	b292      	uxth	r2, r2
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 80087f8:	ea42 0303 	orr.w	r3, r2, r3
 80087fc:	8183      	strh	r3, [r0, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80087fe:	8a83      	ldrh	r3, [r0, #20]
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8008800:	89aa      	ldrh	r2, [r5, #12]
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8008802:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008806:	041b      	lsls	r3, r3, #16
 8008808:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 800880a:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800880c:	b087      	sub	sp, #28
 800880e:	4604      	mov	r4, r0
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8008810:	8283      	strh	r3, [r0, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8008812:	a801      	add	r0, sp, #4
 8008814:	f000 fa1e 	bl	8008c54 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 8008818:	4b18      	ldr	r3, [pc, #96]	; (800887c <USART_Init+0xb4>)
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 800881a:	89a2      	ldrh	r2, [r4, #12]
  USARTx->CR3 = (uint16_t)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
 800881c:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 800881e:	b212      	sxth	r2, r2
/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8008820:	bf0c      	ite	eq
 8008822:	9b04      	ldreq	r3, [sp, #16]
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8008824:	9b03      	ldrne	r3, [sp, #12]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008826:	2a00      	cmp	r2, #0
 8008828:	682a      	ldr	r2, [r5, #0]
 800882a:	da03      	bge.n	8008834 <USART_Init+0x6c>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 800882c:	2119      	movs	r1, #25
 800882e:	4359      	muls	r1, r3
 8008830:	0052      	lsls	r2, r2, #1
 8008832:	e002      	b.n	800883a <USART_Init+0x72>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8008834:	2119      	movs	r1, #25
 8008836:	4359      	muls	r1, r3
 8008838:	0092      	lsls	r2, r2, #2
  }
  tmpreg = (integerdivider / 100) << 4;
 800883a:	2364      	movs	r3, #100	; 0x64
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 800883c:	fbb1 f1f2 	udiv	r1, r1, r2
  }
  tmpreg = (integerdivider / 100) << 4;
 8008840:	fbb1 f2f3 	udiv	r2, r1, r3
 8008844:	0112      	lsls	r2, r2, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8008846:	0910      	lsrs	r0, r2, #4
 8008848:	fb03 1110 	mls	r1, r3, r0, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 800884c:	89a0      	ldrh	r0, [r4, #12]
 800884e:	b200      	sxth	r0, r0
 8008850:	2800      	cmp	r0, #0
 8008852:	da06      	bge.n	8008862 <USART_Init+0x9a>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8008854:	00c9      	lsls	r1, r1, #3
 8008856:	3132      	adds	r1, #50	; 0x32
 8008858:	fbb1 f3f3 	udiv	r3, r1, r3
 800885c:	f003 0307 	and.w	r3, r3, #7
 8008860:	e005      	b.n	800886e <USART_Init+0xa6>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8008862:	0109      	lsls	r1, r1, #4
 8008864:	3132      	adds	r1, #50	; 0x32
 8008866:	fbb1 f3f3 	udiv	r3, r1, r3
 800886a:	f003 030f 	and.w	r3, r3, #15
 800886e:	ea43 0202 	orr.w	r2, r3, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 8008872:	b292      	uxth	r2, r2
 8008874:	8122      	strh	r2, [r4, #8]
}
 8008876:	b007      	add	sp, #28
 8008878:	bd30      	pop	{r4, r5, pc}
 800887a:	bf00      	nop
 800887c:	40013800 	.word	0x40013800

08008880 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008880:	b121      	cbz	r1, 800888c <USART_Cmd+0xc>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8008882:	8983      	ldrh	r3, [r0, #12]
 8008884:	b29b      	uxth	r3, r3
 8008886:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800888a:	e004      	b.n	8008896 <USART_Cmd+0x16>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 800888c:	8983      	ldrh	r3, [r0, #12]
 800888e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008892:	041b      	lsls	r3, r3, #16
 8008894:	0c1b      	lsrs	r3, r3, #16
 8008896:	8183      	strh	r3, [r0, #12]
  }
}
 8008898:	4770      	bx	lr

0800889a <USART_ITConfig>:
  }   
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 800889a:	f3c1 1342 	ubfx	r3, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 800889e:	f04f 0c01 	mov.w	ip, #1

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
 80088a2:	f001 011f 	and.w	r1, r1, #31
  itmask = (((uint32_t)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80088a6:	4563      	cmp	r3, ip
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 80088a8:	fa0c f101 	lsl.w	r1, ip, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80088ac:	d101      	bne.n	80088b2 <USART_ITConfig+0x18>
  {
    usartxbase += 0x0C;
 80088ae:	300c      	adds	r0, #12
 80088b0:	e004      	b.n	80088bc <USART_ITConfig+0x22>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 80088b2:	2b02      	cmp	r3, #2
 80088b4:	d101      	bne.n	80088ba <USART_ITConfig+0x20>
  {
    usartxbase += 0x10;
 80088b6:	3010      	adds	r0, #16
 80088b8:	e000      	b.n	80088bc <USART_ITConfig+0x22>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 80088ba:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
 80088bc:	b11a      	cbz	r2, 80088c6 <USART_ITConfig+0x2c>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80088be:	6803      	ldr	r3, [r0, #0]
 80088c0:	ea43 0101 	orr.w	r1, r3, r1
 80088c4:	e002      	b.n	80088cc <USART_ITConfig+0x32>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80088c6:	6803      	ldr	r3, [r0, #0]
 80088c8:	ea23 0101 	bic.w	r1, r3, r1
 80088cc:	6001      	str	r1, [r0, #0]
  }
}
 80088ce:	4770      	bx	lr

080088d0 <I2C_GenerateSTART>:
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80088d0:	b121      	cbz	r1, 80088dc <I2C_GenerateSTART+0xc>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 80088d2:	8803      	ldrh	r3, [r0, #0]
 80088d4:	b29b      	uxth	r3, r3
 80088d6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80088da:	e004      	b.n	80088e6 <I2C_GenerateSTART+0x16>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
 80088dc:	8803      	ldrh	r3, [r0, #0]
 80088de:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80088e2:	041b      	lsls	r3, r3, #16
 80088e4:	0c1b      	lsrs	r3, r3, #16
 80088e6:	8003      	strh	r3, [r0, #0]
  }
}
 80088e8:	4770      	bx	lr

080088ea <I2C_GenerateSTOP>:
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80088ea:	b121      	cbz	r1, 80088f6 <I2C_GenerateSTOP+0xc>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 80088ec:	8803      	ldrh	r3, [r0, #0]
 80088ee:	b29b      	uxth	r3, r3
 80088f0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80088f4:	e004      	b.n	8008900 <I2C_GenerateSTOP+0x16>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
 80088f6:	8803      	ldrh	r3, [r0, #0]
 80088f8:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80088fc:	041b      	lsls	r3, r3, #16
 80088fe:	0c1b      	lsrs	r3, r3, #16
 8008900:	8003      	strh	r3, [r0, #0]
  }
}
 8008902:	4770      	bx	lr

08008904 <I2C_AcknowledgeConfig>:
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008904:	b121      	cbz	r1, 8008910 <I2C_AcknowledgeConfig+0xc>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8008906:	8803      	ldrh	r3, [r0, #0]
 8008908:	b29b      	uxth	r3, r3
 800890a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800890e:	e004      	b.n	800891a <I2C_AcknowledgeConfig+0x16>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
 8008910:	8803      	ldrh	r3, [r0, #0]
 8008912:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008916:	041b      	lsls	r3, r3, #16
 8008918:	0c1b      	lsrs	r3, r3, #16
 800891a:	8003      	strh	r3, [r0, #0]
  }
}
 800891c:	4770      	bx	lr

0800891e <I2C_ITConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 800891e:	b11a      	cbz	r2, 8008928 <I2C_ITConfig+0xa>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8008920:	8883      	ldrh	r3, [r0, #4]
 8008922:	b29b      	uxth	r3, r3
 8008924:	4319      	orrs	r1, r3
 8008926:	e003      	b.n	8008930 <I2C_ITConfig+0x12>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8008928:	8883      	ldrh	r3, [r0, #4]
 800892a:	b29b      	uxth	r3, r3
 800892c:	ea23 0101 	bic.w	r1, r3, r1
 8008930:	8081      	strh	r1, [r0, #4]
  }
}
 8008932:	4770      	bx	lr

08008934 <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8008934:	8201      	strh	r1, [r0, #16]
}
 8008936:	4770      	bx	lr

08008938 <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8008938:	8a00      	ldrh	r0, [r0, #16]
 800893a:	b2c0      	uxtb	r0, r0
}
 800893c:	4770      	bx	lr

0800893e <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 800893e:	b112      	cbz	r2, 8008946 <I2C_Send7bitAddress+0x8>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 8008940:	f041 0101 	orr.w	r1, r1, #1
 8008944:	e001      	b.n	800894a <I2C_Send7bitAddress+0xc>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 8008946:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 800894a:	8201      	strh	r1, [r0, #16]
}
 800894c:	4770      	bx	lr

0800894e <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 800894e:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 8008950:	8b00      	ldrh	r0, [r0, #24]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8008952:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 8008954:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8008958:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

  /* Return status */
  return lastevent;
}
 800895c:	4770      	bx	lr

0800895e <I2C_ClearITPendingBit>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_Mask;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 800895e:	43c9      	mvns	r1, r1
 8008960:	b289      	uxth	r1, r1
 8008962:	8281      	strh	r1, [r0, #20]
}
 8008964:	4770      	bx	lr

08008966 <DMA_Init>:
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008966:	f8d1 c020 	ldr.w	ip, [r1, #32]
 800896a:	688b      	ldr	r3, [r1, #8]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 800896c:	6802      	ldr	r2, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800896e:	ea4c 0303 	orr.w	r3, ip, r3
 8008972:	f8d1 c010 	ldr.w	ip, [r1, #16]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8008976:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800897a:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800897e:	f8d1 c014 	ldr.w	ip, [r1, #20]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8008982:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8008986:	ea43 030c 	orr.w	r3, r3, ip
 800898a:	f8d1 c018 	ldr.w	ip, [r1, #24]
 800898e:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8008992:	f8d1 c01c 	ldr.w	ip, [r1, #28]
 8008996:	ea43 030c 	orr.w	r3, r3, ip
 800899a:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
 800899e:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 80089a2:	f8d1 c028 	ldr.w	ip, [r1, #40]	; 0x28
 80089a6:	ea43 030c 	orr.w	r3, r3, ip
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80089aa:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 80089ac:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 80089ae:	68cb      	ldr	r3, [r1, #12]
 80089b0:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 80089b2:	680b      	ldr	r3, [r1, #0]
 80089b4:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 80089b6:	684b      	ldr	r3, [r1, #4]
 80089b8:	60c3      	str	r3, [r0, #12]
}
 80089ba:	4770      	bx	lr

080089bc <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 80089bc:	2300      	movs	r3, #0
 80089be:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 80089c0:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 80089c2:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 80089c4:	60c3      	str	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 80089c6:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 80089c8:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 80089ca:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 80089cc:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 80089ce:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 80089d0:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 80089d2:	6283      	str	r3, [r0, #40]	; 0x28
}
 80089d4:	4770      	bx	lr

080089d6 <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80089d6:	b119      	cbz	r1, 80089e0 <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= CCR_ENABLE_Set;
 80089d8:	6803      	ldr	r3, [r0, #0]
 80089da:	f043 0301 	orr.w	r3, r3, #1
 80089de:	e002      	b.n	80089e6 <DMA_Cmd+0x10>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 80089e0:	6803      	ldr	r3, [r0, #0]
 80089e2:	f023 0301 	bic.w	r3, r3, #1
 80089e6:	6003      	str	r3, [r0, #0]
  }
}
 80089e8:	4770      	bx	lr
	...

080089ec <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
  /* Calculate the used DMA */

  if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
 80089ec:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
  {
    /* Clear the selected DMA flags */
    DMA2->IFCR = DMA_FLAG;
 80089f0:	bf14      	ite	ne
 80089f2:	4b02      	ldrne	r3, [pc, #8]	; (80089fc <DMA_ClearFlag+0x10>)
  }
  else
  {
    /* Clear the selected DMA flags */
    DMA1->IFCR = DMA_FLAG;
 80089f4:	4b02      	ldreq	r3, [pc, #8]	; (8008a00 <DMA_ClearFlag+0x14>)
 80089f6:	6058      	str	r0, [r3, #4]
  }
}
 80089f8:	4770      	bx	lr
 80089fa:	bf00      	nop
 80089fc:	40020400 	.word	0x40020400
 8008a00:	40020000 	.word	0x40020000

08008a04 <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8008a04:	4a2d      	ldr	r2, [pc, #180]	; (8008abc <TIM_TimeBaseInit+0xb8>)
 8008a06:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 8008ac0 <TIM_TimeBaseInit+0xbc>
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8008a0a:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8008a0c:	4290      	cmp	r0, r2
 8008a0e:	bf14      	ite	ne
 8008a10:	2200      	movne	r2, #0
 8008a12:	2201      	moveq	r2, #1
 8008a14:	4560      	cmp	r0, ip
 8008a16:	bf08      	it	eq
 8008a18:	f042 0201 	orreq.w	r2, r2, #1
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
  *   structure that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8008a1c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8008a1e:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8008a20:	b9ca      	cbnz	r2, 8008a56 <TIM_TimeBaseInit+0x52>
 8008a22:	4c28      	ldr	r4, [pc, #160]	; (8008ac4 <TIM_TimeBaseInit+0xc0>)
 8008a24:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8008a28:	bf14      	ite	ne
 8008a2a:	f04f 0c00 	movne.w	ip, #0
 8008a2e:	f04f 0c01 	moveq.w	ip, #1
 8008a32:	42a0      	cmp	r0, r4
 8008a34:	bf14      	ite	ne
 8008a36:	4664      	movne	r4, ip
 8008a38:	f04c 0401 	orreq.w	r4, ip, #1
 8008a3c:	b95c      	cbnz	r4, 8008a56 <TIM_TimeBaseInit+0x52>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8008a3e:	4c22      	ldr	r4, [pc, #136]	; (8008ac8 <TIM_TimeBaseInit+0xc4>)
 8008a40:	f8df c088 	ldr.w	ip, [pc, #136]	; 8008acc <TIM_TimeBaseInit+0xc8>
 8008a44:	42a0      	cmp	r0, r4
 8008a46:	bf14      	ite	ne
 8008a48:	2400      	movne	r4, #0
 8008a4a:	2401      	moveq	r4, #1
 8008a4c:	4560      	cmp	r0, ip
 8008a4e:	bf08      	it	eq
 8008a50:	f044 0401 	orreq.w	r4, r4, #1
 8008a54:	b12c      	cbz	r4, 8008a62 <TIM_TimeBaseInit+0x5e>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8008a56:	f8b1 c002 	ldrh.w	ip, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 8008a5a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8008a5e:	ea43 030c 	orr.w	r3, r3, ip
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8008a62:	4c1b      	ldr	r4, [pc, #108]	; (8008ad0 <TIM_TimeBaseInit+0xcc>)
 8008a64:	f8df c06c 	ldr.w	ip, [pc, #108]	; 8008ad4 <TIM_TimeBaseInit+0xd0>
 8008a68:	1b04      	subs	r4, r0, r4
 8008a6a:	bf18      	it	ne
 8008a6c:	2401      	movne	r4, #1
 8008a6e:	4560      	cmp	r0, ip
 8008a70:	bf0c      	ite	eq
 8008a72:	2400      	moveq	r4, #0
 8008a74:	f004 0401 	andne.w	r4, r4, #1
 8008a78:	b134      	cbz	r4, 8008a88 <TIM_TimeBaseInit+0x84>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 8008a7a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8008a7e:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 8008a82:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8008a84:	ea43 030c 	orr.w	r3, r3, ip
  }

  TIMx->CR1 = tmpcr1;
 8008a88:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8008a8a:	888b      	ldrh	r3, [r1, #4]
 8008a8c:	8583      	strh	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8008a8e:	880b      	ldrh	r3, [r1, #0]
 8008a90:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8008a92:	b96a      	cbnz	r2, 8008ab0 <TIM_TimeBaseInit+0xac>
 8008a94:	4b10      	ldr	r3, [pc, #64]	; (8008ad8 <TIM_TimeBaseInit+0xd4>)
 8008a96:	4a11      	ldr	r2, [pc, #68]	; (8008adc <TIM_TimeBaseInit+0xd8>)
 8008a98:	4298      	cmp	r0, r3
 8008a9a:	bf14      	ite	ne
 8008a9c:	2300      	movne	r3, #0
 8008a9e:	2301      	moveq	r3, #1
 8008aa0:	4290      	cmp	r0, r2
 8008aa2:	bf08      	it	eq
 8008aa4:	f043 0301 	orreq.w	r3, r3, #1
 8008aa8:	b913      	cbnz	r3, 8008ab0 <TIM_TimeBaseInit+0xac>
 8008aaa:	4b0d      	ldr	r3, [pc, #52]	; (8008ae0 <TIM_TimeBaseInit+0xdc>)
 8008aac:	4298      	cmp	r0, r3
 8008aae:	d101      	bne.n	8008ab4 <TIM_TimeBaseInit+0xb0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8008ab0:	7a0b      	ldrb	r3, [r1, #8]
 8008ab2:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 8008ab4:	2301      	movs	r3, #1
 8008ab6:	8283      	strh	r3, [r0, #20]
}
 8008ab8:	bd10      	pop	{r4, pc}
 8008aba:	bf00      	nop
 8008abc:	40012c00 	.word	0x40012c00
 8008ac0:	40013400 	.word	0x40013400
 8008ac4:	40000400 	.word	0x40000400
 8008ac8:	40000800 	.word	0x40000800
 8008acc:	40000c00 	.word	0x40000c00
 8008ad0:	40001000 	.word	0x40001000
 8008ad4:	40001400 	.word	0x40001400
 8008ad8:	40014000 	.word	0x40014000
 8008adc:	40014400 	.word	0x40014400
 8008ae0:	40014800 	.word	0x40014800

08008ae4 <TIM_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008ae4:	b121      	cbz	r1, 8008af0 <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8008ae6:	8803      	ldrh	r3, [r0, #0]
 8008ae8:	b29b      	uxth	r3, r3
 8008aea:	f043 0301 	orr.w	r3, r3, #1
 8008aee:	e004      	b.n	8008afa <TIM_Cmd+0x16>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 8008af0:	8803      	ldrh	r3, [r0, #0]
 8008af2:	f023 0301 	bic.w	r3, r3, #1
 8008af6:	041b      	lsls	r3, r3, #16
 8008af8:	0c1b      	lsrs	r3, r3, #16
 8008afa:	8003      	strh	r3, [r0, #0]
  }
}
 8008afc:	4770      	bx	lr

08008afe <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8008afe:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 8008b00:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8008b02:	4211      	tst	r1, r2
 8008b04:	bf0c      	ite	eq
 8008b06:	2000      	moveq	r0, #0
 8008b08:	2001      	movne	r0, #1
 8008b0a:	4219      	tst	r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 8008b0c:	bf0c      	ite	eq
 8008b0e:	2000      	moveq	r0, #0
 8008b10:	f000 0001 	andne.w	r0, r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8008b14:	4770      	bx	lr

08008b16 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8008b16:	43c9      	mvns	r1, r1
 8008b18:	b289      	uxth	r1, r1
 8008b1a:	8201      	strh	r1, [r0, #16]
}
 8008b1c:	4770      	bx	lr
	...

08008b20 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8008b20:	4b0d      	ldr	r3, [pc, #52]	; (8008b58 <RCC_DeInit+0x38>)
 8008b22:	681a      	ldr	r2, [r3, #0]
 8008b24:	f042 0201 	orr.w	r2, r2, #1
 8008b28:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8008b2a:	6859      	ldr	r1, [r3, #4]
 8008b2c:	4a0b      	ldr	r2, [pc, #44]	; (8008b5c <RCC_DeInit+0x3c>)
 8008b2e:	ea01 0202 	and.w	r2, r1, r2
 8008b32:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8008b34:	681a      	ldr	r2, [r3, #0]
 8008b36:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8008b3a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008b3e:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8008b40:	681a      	ldr	r2, [r3, #0]
 8008b42:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008b46:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8008b48:	685a      	ldr	r2, [r3, #4]
 8008b4a:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8008b4e:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8008b50:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8008b54:	609a      	str	r2, [r3, #8]
#endif /* STM32F10X_CL */

}
 8008b56:	4770      	bx	lr
 8008b58:	40021000 	.word	0x40021000
 8008b5c:	f8ff0000 	.word	0xf8ff0000

08008b60 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8008b60:	4b0c      	ldr	r3, [pc, #48]	; (8008b94 <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8008b62:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8008b66:	681a      	ldr	r2, [r3, #0]
 8008b68:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008b6c:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 8008b6e:	681a      	ldr	r2, [r3, #0]
 8008b70:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008b74:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8008b76:	d003      	beq.n	8008b80 <RCC_HSEConfig+0x20>
 8008b78:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8008b7c:	d108      	bne.n	8008b90 <RCC_HSEConfig+0x30>
 8008b7e:	e003      	b.n	8008b88 <RCC_HSEConfig+0x28>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 8008b80:	681a      	ldr	r2, [r3, #0]
 8008b82:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8008b86:	e002      	b.n	8008b8e <RCC_HSEConfig+0x2e>
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 8008b88:	681a      	ldr	r2, [r3, #0]
 8008b8a:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8008b8e:	601a      	str	r2, [r3, #0]
      break;
      
    default:
      break;
  }
}
 8008b90:	4770      	bx	lr
 8008b92:	bf00      	nop
 8008b94:	40021000 	.word	0x40021000

08008b98 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8008b98:	4b03      	ldr	r3, [pc, #12]	; (8008ba8 <RCC_PLLConfig+0x10>)
 8008b9a:	685a      	ldr	r2, [r3, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 8008b9c:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8008ba0:	4310      	orrs	r0, r2
 8008ba2:	4308      	orrs	r0, r1
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008ba4:	6058      	str	r0, [r3, #4]
}
 8008ba6:	4770      	bx	lr
 8008ba8:	40021000 	.word	0x40021000

08008bac <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8008bac:	4b01      	ldr	r3, [pc, #4]	; (8008bb4 <RCC_PLLCmd+0x8>)
 8008bae:	6018      	str	r0, [r3, #0]
}
 8008bb0:	4770      	bx	lr
 8008bb2:	bf00      	nop
 8008bb4:	42420060 	.word	0x42420060

08008bb8 <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8008bb8:	4b03      	ldr	r3, [pc, #12]	; (8008bc8 <RCC_SYSCLKConfig+0x10>)
 8008bba:	685a      	ldr	r2, [r3, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 8008bbc:	f022 0203 	bic.w	r2, r2, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8008bc0:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008bc2:	6058      	str	r0, [r3, #4]
}
 8008bc4:	4770      	bx	lr
 8008bc6:	bf00      	nop
 8008bc8:	40021000 	.word	0x40021000

08008bcc <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8008bcc:	4b02      	ldr	r3, [pc, #8]	; (8008bd8 <RCC_GetSYSCLKSource+0xc>)
 8008bce:	6858      	ldr	r0, [r3, #4]
 8008bd0:	f000 000c 	and.w	r0, r0, #12
}
 8008bd4:	4770      	bx	lr
 8008bd6:	bf00      	nop
 8008bd8:	40021000 	.word	0x40021000

08008bdc <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8008bdc:	4b03      	ldr	r3, [pc, #12]	; (8008bec <RCC_HCLKConfig+0x10>)
 8008bde:	685a      	ldr	r2, [r3, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8008be0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8008be4:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008be6:	6058      	str	r0, [r3, #4]
}
 8008be8:	4770      	bx	lr
 8008bea:	bf00      	nop
 8008bec:	40021000 	.word	0x40021000

08008bf0 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8008bf0:	4b03      	ldr	r3, [pc, #12]	; (8008c00 <RCC_PCLK1Config+0x10>)
 8008bf2:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 8008bf4:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8008bf8:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008bfa:	6058      	str	r0, [r3, #4]
}
 8008bfc:	4770      	bx	lr
 8008bfe:	bf00      	nop
 8008c00:	40021000 	.word	0x40021000

08008c04 <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8008c04:	4b03      	ldr	r3, [pc, #12]	; (8008c14 <RCC_PCLK2Config+0x10>)
 8008c06:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 8008c08:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8008c0c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008c10:	6058      	str	r0, [r3, #4]
}
 8008c12:	4770      	bx	lr
 8008c14:	40021000 	.word	0x40021000

08008c18 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 8008c18:	4b01      	ldr	r3, [pc, #4]	; (8008c20 <RCC_USBCLKConfig+0x8>)
 8008c1a:	6018      	str	r0, [r3, #0]
}
 8008c1c:	4770      	bx	lr
 8008c1e:	bf00      	nop
 8008c20:	424200d8 	.word	0x424200d8

08008c24 <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 8008c24:	4b03      	ldr	r3, [pc, #12]	; (8008c34 <RCC_ADCCLKConfig+0x10>)
 8008c26:	685a      	ldr	r2, [r3, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 8008c28:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 8008c2c:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008c2e:	6058      	str	r0, [r3, #4]
}
 8008c30:	4770      	bx	lr
 8008c32:	bf00      	nop
 8008c34:	40021000 	.word	0x40021000

08008c38 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8008c38:	4b02      	ldr	r3, [pc, #8]	; (8008c44 <RCC_RTCCLKConfig+0xc>)
 8008c3a:	6a1a      	ldr	r2, [r3, #32]
 8008c3c:	4310      	orrs	r0, r2
 8008c3e:	6218      	str	r0, [r3, #32]
}
 8008c40:	4770      	bx	lr
 8008c42:	bf00      	nop
 8008c44:	40021000 	.word	0x40021000

08008c48 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8008c48:	4b01      	ldr	r3, [pc, #4]	; (8008c50 <RCC_RTCCLKCmd+0x8>)
 8008c4a:	6018      	str	r0, [r3, #0]
}
 8008c4c:	4770      	bx	lr
 8008c4e:	bf00      	nop
 8008c50:	4242043c 	.word	0x4242043c

08008c54 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8008c54:	4b22      	ldr	r3, [pc, #136]	; (8008ce0 <RCC_GetClocksFreq+0x8c>)
 8008c56:	685a      	ldr	r2, [r3, #4]
 8008c58:	f002 020c 	and.w	r2, r2, #12
  
  switch (tmp)
 8008c5c:	2a04      	cmp	r2, #4
 8008c5e:	d002      	beq.n	8008c66 <RCC_GetClocksFreq+0x12>
 8008c60:	2a08      	cmp	r2, #8
 8008c62:	d115      	bne.n	8008c90 <RCC_GetClocksFreq+0x3c>
 8008c64:	e001      	b.n	8008c6a <RCC_GetClocksFreq+0x16>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
 8008c66:	4b1f      	ldr	r3, [pc, #124]	; (8008ce4 <RCC_GetClocksFreq+0x90>)
 8008c68:	e013      	b.n	8008c92 <RCC_GetClocksFreq+0x3e>
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8008c6a:	685a      	ldr	r2, [r3, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8008c6c:	6859      	ldr	r1, [r3, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8008c6e:	f3c2 4283 	ubfx	r2, r2, #18, #4
 8008c72:	3202      	adds	r2, #2
      
      if (pllsource == 0x00)
 8008c74:	f411 3f80 	tst.w	r1, #65536	; 0x10000
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
 8008c78:	bf08      	it	eq
 8008c7a:	4b1b      	ldreq	r3, [pc, #108]	; (8008ce8 <RCC_GetClocksFreq+0x94>)
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
      
      if (pllsource == 0x00)
 8008c7c:	d005      	beq.n	8008c8a <RCC_GetClocksFreq+0x36>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8008c7e:	685b      	ldr	r3, [r3, #4]
 8008c80:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 8008c84:	bf14      	ite	ne
 8008c86:	4b19      	ldrne	r3, [pc, #100]	; (8008cec <RCC_GetClocksFreq+0x98>)
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 8008c88:	4b16      	ldreq	r3, [pc, #88]	; (8008ce4 <RCC_GetClocksFreq+0x90>)
 8008c8a:	435a      	muls	r2, r3
 8008c8c:	6002      	str	r2, [r0, #0]
 8008c8e:	e001      	b.n	8008c94 <RCC_GetClocksFreq+0x40>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 8008c90:	4b17      	ldr	r3, [pc, #92]	; (8008cf0 <RCC_GetClocksFreq+0x9c>)
 8008c92:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8008c94:	4b12      	ldr	r3, [pc, #72]	; (8008ce0 <RCC_GetClocksFreq+0x8c>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8008c96:	4917      	ldr	r1, [pc, #92]	; (8008cf4 <RCC_GetClocksFreq+0xa0>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8008c98:	685a      	ldr	r2, [r3, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8008c9a:	f8d0 c000 	ldr.w	ip, [r0]
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
  tmp = tmp >> 4;
 8008c9e:	f3c2 1203 	ubfx	r2, r2, #4, #4
  presc = APBAHBPrescTable[tmp];
 8008ca2:	5c8a      	ldrb	r2, [r1, r2]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8008ca4:	fa2c f202 	lsr.w	r2, ip, r2
 8008ca8:	6042      	str	r2, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8008caa:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 8;
 8008cae:	f3cc 2c02 	ubfx	ip, ip, #8, #3
  presc = APBAHBPrescTable[tmp];
 8008cb2:	f811 c00c 	ldrb.w	ip, [r1, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8008cb6:	fa22 fc0c 	lsr.w	ip, r2, ip
 8008cba:	f8c0 c008 	str.w	ip, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8008cbe:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 11;
 8008cc2:	f3cc 2cc2 	ubfx	ip, ip, #11, #3
  presc = APBAHBPrescTable[tmp];
 8008cc6:	f811 100c 	ldrb.w	r1, [r1, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8008cca:	40ca      	lsrs	r2, r1
 8008ccc:	60c2      	str	r2, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8008cce:	685b      	ldr	r3, [r3, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
 8008cd0:	4909      	ldr	r1, [pc, #36]	; (8008cf8 <RCC_GetClocksFreq+0xa4>)
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
 8008cd2:	f3c3 3381 	ubfx	r3, r3, #14, #2
  presc = ADCPrescTable[tmp];
 8008cd6:	5ccb      	ldrb	r3, [r1, r3]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8008cd8:	fbb2 f2f3 	udiv	r2, r2, r3
 8008cdc:	6102      	str	r2, [r0, #16]
}
 8008cde:	4770      	bx	lr
 8008ce0:	40021000 	.word	0x40021000
 8008ce4:	00b71b00 	.word	0x00b71b00
 8008ce8:	003d0900 	.word	0x003d0900
 8008cec:	005b8d80 	.word	0x005b8d80
 8008cf0:	007a1200 	.word	0x007a1200
 8008cf4:	20000048 	.word	0x20000048
 8008cf8:	20000044 	.word	0x20000044

08008cfc <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008cfc:	b119      	cbz	r1, 8008d06 <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8008cfe:	4b05      	ldr	r3, [pc, #20]	; (8008d14 <RCC_AHBPeriphClockCmd+0x18>)
 8008d00:	695a      	ldr	r2, [r3, #20]
 8008d02:	4310      	orrs	r0, r2
 8008d04:	e003      	b.n	8008d0e <RCC_AHBPeriphClockCmd+0x12>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8008d06:	4b03      	ldr	r3, [pc, #12]	; (8008d14 <RCC_AHBPeriphClockCmd+0x18>)
 8008d08:	695a      	ldr	r2, [r3, #20]
 8008d0a:	ea22 0000 	bic.w	r0, r2, r0
 8008d0e:	6158      	str	r0, [r3, #20]
  }
}
 8008d10:	4770      	bx	lr
 8008d12:	bf00      	nop
 8008d14:	40021000 	.word	0x40021000

08008d18 <RCC_APB2PeriphClockCmd>:
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008d18:	b119      	cbz	r1, 8008d22 <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8008d1a:	4b05      	ldr	r3, [pc, #20]	; (8008d30 <RCC_APB2PeriphClockCmd+0x18>)
 8008d1c:	699a      	ldr	r2, [r3, #24]
 8008d1e:	4310      	orrs	r0, r2
 8008d20:	e003      	b.n	8008d2a <RCC_APB2PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8008d22:	4b03      	ldr	r3, [pc, #12]	; (8008d30 <RCC_APB2PeriphClockCmd+0x18>)
 8008d24:	699a      	ldr	r2, [r3, #24]
 8008d26:	ea22 0000 	bic.w	r0, r2, r0
 8008d2a:	6198      	str	r0, [r3, #24]
  }
}
 8008d2c:	4770      	bx	lr
 8008d2e:	bf00      	nop
 8008d30:	40021000 	.word	0x40021000

08008d34 <RCC_APB1PeriphClockCmd>:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008d34:	b119      	cbz	r1, 8008d3e <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8008d36:	4b05      	ldr	r3, [pc, #20]	; (8008d4c <RCC_APB1PeriphClockCmd+0x18>)
 8008d38:	69da      	ldr	r2, [r3, #28]
 8008d3a:	4310      	orrs	r0, r2
 8008d3c:	e003      	b.n	8008d46 <RCC_APB1PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8008d3e:	4b03      	ldr	r3, [pc, #12]	; (8008d4c <RCC_APB1PeriphClockCmd+0x18>)
 8008d40:	69da      	ldr	r2, [r3, #28]
 8008d42:	ea22 0000 	bic.w	r0, r2, r0
 8008d46:	61d8      	str	r0, [r3, #28]
  }
}
 8008d48:	4770      	bx	lr
 8008d4a:	bf00      	nop
 8008d4c:	40021000 	.word	0x40021000

08008d50 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008d50:	b119      	cbz	r1, 8008d5a <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8008d52:	4b05      	ldr	r3, [pc, #20]	; (8008d68 <RCC_APB2PeriphResetCmd+0x18>)
 8008d54:	68da      	ldr	r2, [r3, #12]
 8008d56:	4310      	orrs	r0, r2
 8008d58:	e003      	b.n	8008d62 <RCC_APB2PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8008d5a:	4b03      	ldr	r3, [pc, #12]	; (8008d68 <RCC_APB2PeriphResetCmd+0x18>)
 8008d5c:	68da      	ldr	r2, [r3, #12]
 8008d5e:	ea22 0000 	bic.w	r0, r2, r0
 8008d62:	60d8      	str	r0, [r3, #12]
  }
}
 8008d64:	4770      	bx	lr
 8008d66:	bf00      	nop
 8008d68:	40021000 	.word	0x40021000

08008d6c <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008d6c:	b119      	cbz	r1, 8008d76 <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8008d6e:	4b05      	ldr	r3, [pc, #20]	; (8008d84 <RCC_APB1PeriphResetCmd+0x18>)
 8008d70:	691a      	ldr	r2, [r3, #16]
 8008d72:	4310      	orrs	r0, r2
 8008d74:	e003      	b.n	8008d7e <RCC_APB1PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8008d76:	4b03      	ldr	r3, [pc, #12]	; (8008d84 <RCC_APB1PeriphResetCmd+0x18>)
 8008d78:	691a      	ldr	r2, [r3, #16]
 8008d7a:	ea22 0000 	bic.w	r0, r2, r0
 8008d7e:	6118      	str	r0, [r3, #16]
  }
}
 8008d80:	4770      	bx	lr
 8008d82:	bf00      	nop
 8008d84:	40021000 	.word	0x40021000

08008d88 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8008d88:	4b01      	ldr	r3, [pc, #4]	; (8008d90 <RCC_BackupResetCmd+0x8>)
 8008d8a:	6018      	str	r0, [r3, #0]
}
 8008d8c:	4770      	bx	lr
 8008d8e:	bf00      	nop
 8008d90:	42420440 	.word	0x42420440

08008d94 <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8008d94:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8008d96:	2b01      	cmp	r3, #1
  {
    statusreg = RCC->CR;
 8008d98:	bf04      	itt	eq
 8008d9a:	4b08      	ldreq	r3, [pc, #32]	; (8008dbc <RCC_GetFlagStatus+0x28>)
 8008d9c:	681b      	ldreq	r3, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
 8008d9e:	d005      	beq.n	8008dac <RCC_GetFlagStatus+0x18>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8008da0:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8008da2:	bf0b      	itete	eq
 8008da4:	4b05      	ldreq	r3, [pc, #20]	; (8008dbc <RCC_GetFlagStatus+0x28>)
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8008da6:	4b05      	ldrne	r3, [pc, #20]	; (8008dbc <RCC_GetFlagStatus+0x28>)
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 8008da8:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8008daa:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 8008dac:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8008db0:	fa33 f000 	lsrs.w	r0, r3, r0
  {
    statusreg = RCC->BDCR;
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8008db4:	f000 0001 	and.w	r0, r0, #1
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8008db8:	4770      	bx	lr
 8008dba:	bf00      	nop
 8008dbc:	40021000 	.word	0x40021000

08008dc0 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8008dc0:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 8008dc2:	2300      	movs	r3, #0
 8008dc4:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8008dc6:	2031      	movs	r0, #49	; 0x31
 8008dc8:	f7ff ffe4 	bl	8008d94 <RCC_GetFlagStatus>
    StartUpCounter++;  
 8008dcc:	9b01      	ldr	r3, [sp, #4]
 8008dce:	3301      	adds	r3, #1
 8008dd0:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
 8008dd2:	9b01      	ldr	r3, [sp, #4]
 8008dd4:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8008dd8:	d001      	beq.n	8008dde <RCC_WaitForHSEStartUp+0x1e>
 8008dda:	2800      	cmp	r0, #0
 8008ddc:	d0f3      	beq.n	8008dc6 <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8008dde:	2031      	movs	r0, #49	; 0x31
 8008de0:	f7ff ffd8 	bl	8008d94 <RCC_GetFlagStatus>
 8008de4:	3800      	subs	r0, #0
 8008de6:	bf18      	it	ne
 8008de8:	2001      	movne	r0, #1
  else
  {
    status = ERROR;
  }  
  return (status);
}
 8008dea:	bd0e      	pop	{r1, r2, r3, pc}

08008dec <RTC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008dec:	b121      	cbz	r1, 8008df8 <RTC_ITConfig+0xc>
  {
    RTC->CRH |= RTC_IT;
 8008dee:	4b06      	ldr	r3, [pc, #24]	; (8008e08 <RTC_ITConfig+0x1c>)
 8008df0:	881a      	ldrh	r2, [r3, #0]
 8008df2:	b292      	uxth	r2, r2
 8008df4:	4310      	orrs	r0, r2
 8008df6:	e004      	b.n	8008e02 <RTC_ITConfig+0x16>
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
 8008df8:	4b03      	ldr	r3, [pc, #12]	; (8008e08 <RTC_ITConfig+0x1c>)
 8008dfa:	881a      	ldrh	r2, [r3, #0]
 8008dfc:	b292      	uxth	r2, r2
 8008dfe:	ea22 0000 	bic.w	r0, r2, r0
 8008e02:	8018      	strh	r0, [r3, #0]
  }
}
 8008e04:	4770      	bx	lr
 8008e06:	bf00      	nop
 8008e08:	40002800 	.word	0x40002800

08008e0c <RTC_EnterConfigMode>:
  * @retval None
  */
void RTC_EnterConfigMode(void)
{
  /* Set the CNF flag to enter in the Configuration Mode */
  RTC->CRL |= CRL_CNF_Set;
 8008e0c:	4b03      	ldr	r3, [pc, #12]	; (8008e1c <RTC_EnterConfigMode+0x10>)
 8008e0e:	889a      	ldrh	r2, [r3, #4]
 8008e10:	b292      	uxth	r2, r2
 8008e12:	f042 0210 	orr.w	r2, r2, #16
 8008e16:	809a      	strh	r2, [r3, #4]
}
 8008e18:	4770      	bx	lr
 8008e1a:	bf00      	nop
 8008e1c:	40002800 	.word	0x40002800

08008e20 <RTC_ExitConfigMode>:
  * @retval None
  */
void RTC_ExitConfigMode(void)
{
  /* Reset the CNF flag to exit from the Configuration Mode */
  RTC->CRL &= CRL_CNF_Reset;
 8008e20:	4a03      	ldr	r2, [pc, #12]	; (8008e30 <RTC_ExitConfigMode+0x10>)
 8008e22:	8893      	ldrh	r3, [r2, #4]
 8008e24:	f023 0310 	bic.w	r3, r3, #16
 8008e28:	041b      	lsls	r3, r3, #16
 8008e2a:	0c1b      	lsrs	r3, r3, #16
 8008e2c:	8093      	strh	r3, [r2, #4]
}
 8008e2e:	4770      	bx	lr
 8008e30:	40002800 	.word	0x40002800

08008e34 <RTC_SetCounter>:
  * @brief  Sets the RTC counter value.
  * @param  CounterValue: RTC counter new value.
  * @retval None
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
 8008e34:	b510      	push	{r4, lr}
 8008e36:	4604      	mov	r4, r0
  RTC_EnterConfigMode();
 8008e38:	f7ff ffe8 	bl	8008e0c <RTC_EnterConfigMode>
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 8008e3c:	4b03      	ldr	r3, [pc, #12]	; (8008e4c <RTC_SetCounter+0x18>)
 8008e3e:	0c22      	lsrs	r2, r4, #16
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 8008e40:	b2a4      	uxth	r4, r4
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
  RTC_EnterConfigMode();
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 8008e42:	831a      	strh	r2, [r3, #24]
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 8008e44:	839c      	strh	r4, [r3, #28]
  RTC_ExitConfigMode();
 8008e46:	f7ff ffeb 	bl	8008e20 <RTC_ExitConfigMode>
}
 8008e4a:	bd10      	pop	{r4, pc}
 8008e4c:	40002800 	.word	0x40002800

08008e50 <RTC_SetPrescaler>:
  * @brief  Sets the RTC prescaler value.
  * @param  PrescalerValue: RTC prescaler new value.
  * @retval None
  */
void RTC_SetPrescaler(uint32_t PrescalerValue)
{
 8008e50:	b510      	push	{r4, lr}
 8008e52:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
 8008e54:	f7ff ffda 	bl	8008e0c <RTC_EnterConfigMode>
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 8008e58:	4b04      	ldr	r3, [pc, #16]	; (8008e6c <RTC_SetPrescaler+0x1c>)
 8008e5a:	f3c4 4203 	ubfx	r2, r4, #16, #4
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 8008e5e:	b2a4      	uxth	r4, r4
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 8008e60:	811a      	strh	r2, [r3, #8]
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 8008e62:	819c      	strh	r4, [r3, #12]
  RTC_ExitConfigMode();
 8008e64:	f7ff ffdc 	bl	8008e20 <RTC_ExitConfigMode>
}
 8008e68:	bd10      	pop	{r4, pc}
 8008e6a:	bf00      	nop
 8008e6c:	40002800 	.word	0x40002800

08008e70 <RTC_WaitForLastTask>:
  * @retval None
  */
void RTC_WaitForLastTask(void)
{
  /* Loop until RTOFF flag is set */
  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
 8008e70:	4b02      	ldr	r3, [pc, #8]	; (8008e7c <RTC_WaitForLastTask+0xc>)
 8008e72:	889a      	ldrh	r2, [r3, #4]
 8008e74:	f012 0f20 	tst.w	r2, #32
 8008e78:	d0fb      	beq.n	8008e72 <RTC_WaitForLastTask+0x2>
  {
  }
}
 8008e7a:	4770      	bx	lr
 8008e7c:	40002800 	.word	0x40002800

08008e80 <RTC_WaitForSynchro>:
  * @retval None
  */
void RTC_WaitForSynchro(void)
{
  /* Clear RSF flag */
  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
 8008e80:	4a05      	ldr	r2, [pc, #20]	; (8008e98 <RTC_WaitForSynchro+0x18>)
 8008e82:	8893      	ldrh	r3, [r2, #4]
 8008e84:	f023 0308 	bic.w	r3, r3, #8
 8008e88:	041b      	lsls	r3, r3, #16
 8008e8a:	0c1b      	lsrs	r3, r3, #16
 8008e8c:	8093      	strh	r3, [r2, #4]
  /* Loop until RSF flag is set */
  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
 8008e8e:	8893      	ldrh	r3, [r2, #4]
 8008e90:	f013 0f08 	tst.w	r3, #8
 8008e94:	d0fb      	beq.n	8008e8e <RTC_WaitForSynchro+0xe>
  {
  }
}
 8008e96:	4770      	bx	lr
 8008e98:	40002800 	.word	0x40002800

08008e9c <BKP_DeInit>:
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
  RCC_BackupResetCmd(ENABLE);
 8008e9c:	2001      	movs	r0, #1
  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
 8008e9e:	b508      	push	{r3, lr}
  RCC_BackupResetCmd(ENABLE);
 8008ea0:	f7ff ff72 	bl	8008d88 <RCC_BackupResetCmd>
  RCC_BackupResetCmd(DISABLE);
 8008ea4:	2000      	movs	r0, #0
 8008ea6:	f7ff ff6f 	bl	8008d88 <RCC_BackupResetCmd>
}
 8008eaa:	bd08      	pop	{r3, pc}

08008eac <PWR_BackupAccessCmd>:
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 8008eac:	4b01      	ldr	r3, [pc, #4]	; (8008eb4 <PWR_BackupAccessCmd+0x8>)
 8008eae:	6018      	str	r0, [r3, #0]
}
 8008eb0:	4770      	bx	lr
 8008eb2:	bf00      	nop
 8008eb4:	420e0020 	.word	0x420e0020

08008eb8 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8008eb8:	f040 60be 	orr.w	r0, r0, #99614720	; 0x5f00000
 8008ebc:	4b02      	ldr	r3, [pc, #8]	; (8008ec8 <NVIC_PriorityGroupConfig+0x10>)
 8008ebe:	f440 2020 	orr.w	r0, r0, #655360	; 0xa0000
 8008ec2:	60d8      	str	r0, [r3, #12]
}
 8008ec4:	4770      	bx	lr
 8008ec6:	bf00      	nop
 8008ec8:	e000ed00 	.word	0xe000ed00

08008ecc <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8008ecc:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8008ed0:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8008ed4:	4b02      	ldr	r3, [pc, #8]	; (8008ee0 <NVIC_SetVectorTable+0x14>)
 8008ed6:	ea41 0000 	orr.w	r0, r1, r0
 8008eda:	6098      	str	r0, [r3, #8]
}
 8008edc:	4770      	bx	lr
 8008ede:	bf00      	nop
 8008ee0:	e000ed00 	.word	0xe000ed00

08008ee4 <SysTick_CLKSourceConfig>:
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8008ee4:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8008ee6:	bf0b      	itete	eq
 8008ee8:	4b05      	ldreq	r3, [pc, #20]	; (8008f00 <SysTick_CLKSourceConfig+0x1c>)
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8008eea:	4b05      	ldrne	r3, [pc, #20]	; (8008f00 <SysTick_CLKSourceConfig+0x1c>)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8008eec:	681a      	ldreq	r2, [r3, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8008eee:	681a      	ldrne	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8008ef0:	bf0c      	ite	eq
 8008ef2:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8008ef6:	f022 0204 	bicne.w	r2, r2, #4
 8008efa:	601a      	str	r2, [r3, #0]
  }
}
 8008efc:	4770      	bx	lr
 8008efe:	bf00      	nop
 8008f00:	e000e010 	.word	0xe000e010

08008f04 <Standard_GetConfiguration>:
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetConfiguration(uint16_t Length)
{
 8008f04:	b510      	push	{r4, lr}
 8008f06:	4c06      	ldr	r4, [pc, #24]	; (8008f20 <Standard_GetConfiguration+0x1c>)
  if (Length == 0)
 8008f08:	b918      	cbnz	r0, 8008f12 <Standard_GetConfiguration+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 8008f0a:	6823      	ldr	r3, [r4, #0]
 8008f0c:	2201      	movs	r2, #1
 8008f0e:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_Configuration);
    return 0;
 8008f10:	e005      	b.n	8008f1e <Standard_GetConfiguration+0x1a>
  }
  pUser_Standard_Requests->User_GetConfiguration();
 8008f12:	4b04      	ldr	r3, [pc, #16]	; (8008f24 <Standard_GetConfiguration+0x20>)
 8008f14:	681b      	ldr	r3, [r3, #0]
 8008f16:	681b      	ldr	r3, [r3, #0]
 8008f18:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_Configuration;
 8008f1a:	6820      	ldr	r0, [r4, #0]
 8008f1c:	300a      	adds	r0, #10
}
 8008f1e:	bd10      	pop	{r4, pc}
 8008f20:	200030cc 	.word	0x200030cc
 8008f24:	200030c8 	.word	0x200030c8

08008f28 <Standard_GetInterface>:
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetInterface(uint16_t Length)
{
 8008f28:	b510      	push	{r4, lr}
 8008f2a:	4c06      	ldr	r4, [pc, #24]	; (8008f44 <Standard_GetInterface+0x1c>)
  if (Length == 0)
 8008f2c:	b918      	cbnz	r0, 8008f36 <Standard_GetInterface+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 8008f2e:	6823      	ldr	r3, [r4, #0]
 8008f30:	2201      	movs	r2, #1
 8008f32:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
 8008f34:	e005      	b.n	8008f42 <Standard_GetInterface+0x1a>
  }
  pUser_Standard_Requests->User_GetInterface();
 8008f36:	4b04      	ldr	r3, [pc, #16]	; (8008f48 <Standard_GetInterface+0x20>)
 8008f38:	681b      	ldr	r3, [r3, #0]
 8008f3a:	689b      	ldr	r3, [r3, #8]
 8008f3c:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_AlternateSetting;
 8008f3e:	6820      	ldr	r0, [r4, #0]
 8008f40:	300c      	adds	r0, #12
}
 8008f42:	bd10      	pop	{r4, pc}
 8008f44:	200030cc 	.word	0x200030cc
 8008f48:	200030c8 	.word	0x200030c8

08008f4c <Standard_GetStatus>:
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
uint8_t *Standard_GetStatus(uint16_t Length)
{
 8008f4c:	b508      	push	{r3, lr}
 8008f4e:	4b27      	ldr	r3, [pc, #156]	; (8008fec <Standard_GetStatus+0xa0>)
  if (Length == 0)
 8008f50:	b918      	cbnz	r0, 8008f5a <Standard_GetStatus+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
 8008f52:	681b      	ldr	r3, [r3, #0]
 8008f54:	2202      	movs	r2, #2
 8008f56:	821a      	strh	r2, [r3, #16]
    return 0;
 8008f58:	e047      	b.n	8008fea <Standard_GetStatus+0x9e>
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 8008f5a:	4825      	ldr	r0, [pc, #148]	; (8008ff0 <Standard_GetStatus+0xa4>)
 8008f5c:	2200      	movs	r2, #0

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8008f5e:	681b      	ldr	r3, [r3, #0]
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 8008f60:	8002      	strh	r2, [r0, #0]

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8008f62:	781a      	ldrb	r2, [r3, #0]
 8008f64:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8008f68:	d115      	bne.n	8008f96 <Standard_GetStatus+0x4a>
  {
    /*Get Device Status */
    uint8_t Feature = pInformation->Current_Feature;

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
 8008f6a:	7a5b      	ldrb	r3, [r3, #9]
 8008f6c:	7802      	ldrb	r2, [r0, #0]
 8008f6e:	f013 0f20 	tst.w	r3, #32
    {
      SetBit(StatusInfo0, 1);
 8008f72:	bf14      	ite	ne
 8008f74:	f042 0202 	orrne.w	r2, r2, #2
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 8008f78:	f022 0202 	biceq.w	r2, r2, #2
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
 8008f7c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8008f80:	4b1b      	ldr	r3, [pc, #108]	; (8008ff0 <Standard_GetStatus+0xa4>)
    {
      SetBit(StatusInfo0, 1);
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 8008f82:	7002      	strb	r2, [r0, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 8008f84:	bf15      	itete	ne
 8008f86:	781a      	ldrbne	r2, [r3, #0]
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 8008f88:	781a      	ldrbeq	r2, [r3, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 8008f8a:	f042 0201 	orrne.w	r2, r2, #1
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 8008f8e:	f022 0201 	biceq.w	r2, r2, #1
 8008f92:	701a      	strb	r2, [r3, #0]
 8008f94:	e022      	b.n	8008fdc <Standard_GetStatus+0x90>
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8008f96:	2a01      	cmp	r2, #1
 8008f98:	d027      	beq.n	8008fea <Standard_GetStatus+0x9e>
  {
    return (uint8_t *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8008f9a:	2a02      	cmp	r2, #2
 8008f9c:	d124      	bne.n	8008fe8 <Standard_GetStatus+0x9c>
  {
    uint8_t Related_Endpoint;
    uint8_t wIndex0 = pInformation->USBwIndex0;
 8008f9e:	795a      	ldrb	r2, [r3, #5]

    Related_Endpoint = (wIndex0 & 0x0f);
 8008fa0:	f002 030f 	and.w	r3, r2, #15
    if (ValBit(wIndex0, 7))
 8008fa4:	f012 0f80 	tst.w	r2, #128	; 0x80
 8008fa8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8008fac:	d008      	beq.n	8008fc0 <Standard_GetStatus+0x74>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
 8008fae:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8008fb2:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8008fb6:	681b      	ldr	r3, [r3, #0]
 8008fb8:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8008fbc:	2b10      	cmp	r3, #16
 8008fbe:	e008      	b.n	8008fd2 <Standard_GetStatus+0x86>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 8008fc0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8008fc4:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8008fc8:	681b      	ldr	r3, [r3, #0]
 8008fca:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8008fce:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
      {
        SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
 8008fd2:	bf02      	ittt	eq
 8008fd4:	7803      	ldrbeq	r3, [r0, #0]
 8008fd6:	f043 0301 	orreq.w	r3, r3, #1
 8008fda:	7003      	strbeq	r3, [r0, #0]
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
 8008fdc:	4b05      	ldr	r3, [pc, #20]	; (8008ff4 <Standard_GetStatus+0xa8>)
 8008fde:	681b      	ldr	r3, [r3, #0]
 8008fe0:	691b      	ldr	r3, [r3, #16]
 8008fe2:	4798      	blx	r3
  return (uint8_t *)&StatusInfo;
 8008fe4:	4802      	ldr	r0, [pc, #8]	; (8008ff0 <Standard_GetStatus+0xa4>)
 8008fe6:	e000      	b.n	8008fea <Standard_GetStatus+0x9e>
    }

  }
  else
  {
    return NULL;
 8008fe8:	2000      	movs	r0, #0
  }
  pUser_Standard_Requests->User_GetStatus();
  return (uint8_t *)&StatusInfo;
}
 8008fea:	bd08      	pop	{r3, pc}
 8008fec:	200030cc 	.word	0x200030cc
 8008ff0:	200030d8 	.word	0x200030d8
 8008ff4:	200030c8 	.word	0x200030c8

08008ff8 <DataStageIn>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
 8008ff8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 8008ffa:	4b27      	ldr	r3, [pc, #156]	; (8009098 <DataStageIn+0xa0>)
 8008ffc:	681c      	ldr	r4, [r3, #0]
  uint32_t save_wLength = pEPinfo->Usb_wLength;
 8008ffe:	8a23      	ldrh	r3, [r4, #16]
  uint32_t ControlState = pInformation->ControlState;
 8009000:	7a26      	ldrb	r6, [r4, #8]

  uint8_t *DataBuffer;
  uint32_t Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
 8009002:	f1d3 0201 	rsbs	r2, r3, #1
 8009006:	bf38      	it	cc
 8009008:	2200      	movcc	r2, #0
 800900a:	2e04      	cmp	r6, #4
 800900c:	bf14      	ite	ne
 800900e:	2600      	movne	r6, #0
 8009010:	f002 0601 	andeq.w	r6, r2, #1
 8009014:	b1ae      	cbz	r6, 8009042 <DataStageIn+0x4a>
  {
    if(Data_Mul_MaxPacketSize == TRUE)
 8009016:	4921      	ldr	r1, [pc, #132]	; (800909c <DataStageIn+0xa4>)
 8009018:	4a21      	ldr	r2, [pc, #132]	; (80090a0 <DataStageIn+0xa8>)
 800901a:	780b      	ldrb	r3, [r1, #0]
 800901c:	2b01      	cmp	r3, #1
 800901e:	d10c      	bne.n	800903a <DataStageIn+0x42>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 8009020:	4b20      	ldr	r3, [pc, #128]	; (80090a4 <DataStageIn+0xac>)
      ControlState = LAST_IN_DATA;
 8009022:	2704      	movs	r7, #4
  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 8009024:	6818      	ldr	r0, [r3, #0]
 8009026:	4b20      	ldr	r3, [pc, #128]	; (80090a8 <DataStageIn+0xb0>)
 8009028:	b280      	uxth	r0, r0
 800902a:	18c3      	adds	r3, r0, r3
 800902c:	005b      	lsls	r3, r3, #1
 800902e:	2000      	movs	r0, #0
 8009030:	6018      	str	r0, [r3, #0]
 8009032:	2330      	movs	r3, #48	; 0x30
 8009034:	8013      	strh	r3, [r2, #0]
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
 8009036:	7008      	strb	r0, [r1, #0]
 8009038:	e02a      	b.n	8009090 <DataStageIn+0x98>
    #ifdef STM32F10X_CL      
      PCD_EP_Read (ENDP0, 0, 0);
    #endif  /* STM32F10X_CL */ 
    
    #ifndef STM32F10X_CL 
      vSetEPTxStatus(EP_TX_STALL);
 800903a:	2310      	movs	r3, #16
 800903c:	8013      	strh	r3, [r2, #0]
      Data_Mul_MaxPacketSize = FALSE;
    }
    else 
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
 800903e:	2707      	movs	r7, #7
 8009040:	e026      	b.n	8009090 <DataStageIn+0x98>
    }
    
    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
 8009042:	8aa5      	ldrh	r5, [r4, #20]
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
 8009044:	42ab      	cmp	r3, r5
 8009046:	bf8c      	ite	hi
 8009048:	2702      	movhi	r7, #2
 800904a:	2704      	movls	r7, #4
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
 800904c:	429d      	cmp	r5, r3
 800904e:	bf28      	it	cs
 8009050:	461d      	movcs	r5, r3
 8009052:	4628      	mov	r0, r5
 8009054:	69a3      	ldr	r3, [r4, #24]
 8009056:	4798      	blx	r3
 8009058:	4603      	mov	r3, r0

#ifdef STM32F10X_CL
  PCD_EP_Write (ENDP0, DataBuffer, Length);
#else   
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
 800905a:	4630      	mov	r0, r6
 800905c:	9301      	str	r3, [sp, #4]
 800905e:	f000 fd87 	bl	8009b70 <GetEPTxAddr>
 8009062:	9b01      	ldr	r3, [sp, #4]
 8009064:	462a      	mov	r2, r5
 8009066:	4601      	mov	r1, r0
 8009068:	4618      	mov	r0, r3
 800906a:	f000 fca1 	bl	80099b0 <UserToPMABufferCopy>
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);
 800906e:	4629      	mov	r1, r5
 8009070:	4630      	mov	r0, r6
 8009072:	f000 fd99 	bl	8009ba8 <SetEPTxCount>

  pEPinfo->Usb_wLength -= Length;
 8009076:	8a23      	ldrh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);
 8009078:	2230      	movs	r2, #48	; 0x30
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
 800907a:	1b5b      	subs	r3, r3, r5
 800907c:	8223      	strh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
 800907e:	8a63      	ldrh	r3, [r4, #18]
 8009080:	18ed      	adds	r5, r5, r3
  vSetEPTxStatus(EP_TX_VALID);
 8009082:	4b07      	ldr	r3, [pc, #28]	; (80090a0 <DataStageIn+0xa8>)
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
 8009084:	8265      	strh	r5, [r4, #18]
  vSetEPTxStatus(EP_TX_VALID);
 8009086:	801a      	strh	r2, [r3, #0]

  USB_StatusOut();/* Expect the host to abort the data IN stage */
 8009088:	4b08      	ldr	r3, [pc, #32]	; (80090ac <DataStageIn+0xb4>)
 800908a:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 800908e:	801a      	strh	r2, [r3, #0]

Expect_Status_Out:
  pInformation->ControlState = ControlState;
 8009090:	4b01      	ldr	r3, [pc, #4]	; (8009098 <DataStageIn+0xa0>)
 8009092:	681b      	ldr	r3, [r3, #0]
 8009094:	721f      	strb	r7, [r3, #8]
}
 8009096:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009098:	200030cc 	.word	0x200030cc
 800909c:	20000558 	.word	0x20000558
 80090a0:	200030dc 	.word	0x200030dc
 80090a4:	40005c50 	.word	0x40005c50
 80090a8:	20003002 	.word	0x20003002
 80090ac:	200030da 	.word	0x200030da

080090b0 <Standard_SetConfiguration>:
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
 80090b0:	b510      	push	{r4, lr}

  if ((pInformation->USBwValue0 <=
 80090b2:	4b0a      	ldr	r3, [pc, #40]	; (80090dc <Standard_SetConfiguration+0x2c>)
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 80090b4:	490a      	ldr	r1, [pc, #40]	; (80090e0 <Standard_SetConfiguration+0x30>)
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
 80090b6:	681b      	ldr	r3, [r3, #0]
 80090b8:	7849      	ldrb	r1, [r1, #1]
 80090ba:	78da      	ldrb	r2, [r3, #3]
 80090bc:	4291      	cmp	r1, r2
 80090be:	d30a      	bcc.n	80090d6 <Standard_SetConfiguration+0x26>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 80090c0:	7899      	ldrb	r1, [r3, #2]
 80090c2:	b941      	cbnz	r1, 80090d6 <Standard_SetConfiguration+0x26>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
 80090c4:	889c      	ldrh	r4, [r3, #4]
 80090c6:	b934      	cbnz	r4, 80090d6 <Standard_SetConfiguration+0x26>
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
 80090c8:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 80090ca:	4b06      	ldr	r3, [pc, #24]	; (80090e4 <Standard_SetConfiguration+0x34>)
 80090cc:	681b      	ldr	r3, [r3, #0]
 80090ce:	685b      	ldr	r3, [r3, #4]
 80090d0:	4798      	blx	r3
    return USB_SUCCESS;
 80090d2:	4620      	mov	r0, r4
 80090d4:	e000      	b.n	80090d8 <Standard_SetConfiguration+0x28>
  }
  else
  {
    return USB_UNSUPPORT;
 80090d6:	2002      	movs	r0, #2
  }
}
 80090d8:	bd10      	pop	{r4, pc}
 80090da:	bf00      	nop
 80090dc:	200030cc 	.word	0x200030cc
 80090e0:	200030d0 	.word	0x200030d0
 80090e4:	200030c8 	.word	0x200030c8

080090e8 <Standard_SetInterface>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
 80090e8:	b538      	push	{r3, r4, r5, lr}
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
 80090ea:	4a0e      	ldr	r2, [pc, #56]	; (8009124 <Standard_SetInterface+0x3c>)
 80090ec:	4c0e      	ldr	r4, [pc, #56]	; (8009128 <Standard_SetInterface+0x40>)
 80090ee:	6812      	ldr	r2, [r2, #0]
 80090f0:	6823      	ldr	r3, [r4, #0]
 80090f2:	7958      	ldrb	r0, [r3, #5]
 80090f4:	78d9      	ldrb	r1, [r3, #3]
 80090f6:	6993      	ldr	r3, [r2, #24]
 80090f8:	4798      	blx	r3

  if (pInformation->Current_Configuration != 0)
 80090fa:	6823      	ldr	r3, [r4, #0]
 80090fc:	7a9a      	ldrb	r2, [r3, #10]
 80090fe:	b17a      	cbz	r2, 8009120 <Standard_SetInterface+0x38>
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
 8009100:	b970      	cbnz	r0, 8009120 <Standard_SetInterface+0x38>
 8009102:	791a      	ldrb	r2, [r3, #4]
 8009104:	b962      	cbnz	r2, 8009120 <Standard_SetInterface+0x38>
        || (pInformation->USBwValue1 != 0))
 8009106:	789d      	ldrb	r5, [r3, #2]
 8009108:	b955      	cbnz	r5, 8009120 <Standard_SetInterface+0x38>
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
 800910a:	4b08      	ldr	r3, [pc, #32]	; (800912c <Standard_SetInterface+0x44>)
 800910c:	681b      	ldr	r3, [r3, #0]
 800910e:	68db      	ldr	r3, [r3, #12]
 8009110:	4798      	blx	r3
      pInformation->Current_Interface = pInformation->USBwIndex0;
 8009112:	6823      	ldr	r3, [r4, #0]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
 8009114:	4628      	mov	r0, r5
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
 8009116:	795a      	ldrb	r2, [r3, #5]
 8009118:	72da      	strb	r2, [r3, #11]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
 800911a:	78da      	ldrb	r2, [r3, #3]
 800911c:	731a      	strb	r2, [r3, #12]
      return USB_SUCCESS;
 800911e:	e000      	b.n	8009122 <Standard_SetInterface+0x3a>
  if (pInformation->Current_Configuration != 0)
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
        || (pInformation->USBwValue1 != 0))
    {
      return  USB_UNSUPPORT;
 8009120:	2002      	movs	r0, #2
    }

  }

  return USB_UNSUPPORT;
}
 8009122:	bd38      	pop	{r3, r4, r5, pc}
 8009124:	200030c4 	.word	0x200030c4
 8009128:	200030cc 	.word	0x200030cc
 800912c:	200030c8 	.word	0x200030c8

08009130 <Standard_ClearFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
 8009130:	b510      	push	{r4, lr}
  uint32_t     Type_Rec = Type_Recipient;
 8009132:	4b3f      	ldr	r3, [pc, #252]	; (8009230 <Standard_ClearFeature+0x100>)
 8009134:	681b      	ldr	r3, [r3, #0]
 8009136:	7818      	ldrb	r0, [r3, #0]
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009138:	f010 007f 	ands.w	r0, r0, #127	; 0x7f
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
 800913c:	bf02      	ittt	eq
 800913e:	7a5a      	ldrbeq	r2, [r3, #9]
 8009140:	f022 0220 	biceq.w	r2, r2, #32
 8009144:	725a      	strbeq	r2, [r3, #9]
{
  uint32_t     Type_Rec = Type_Recipient;
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009146:	d072      	beq.n	800922e <Standard_ClearFeature+0xfe>
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009148:	2802      	cmp	r0, #2
 800914a:	d16f      	bne.n	800922c <Standard_ClearFeature+0xfc>
    DEVICE* pDev;
    uint32_t Related_Endpoint;
    uint32_t wIndex0;
    uint32_t rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
 800914c:	885a      	ldrh	r2, [r3, #2]
 800914e:	2a00      	cmp	r2, #0
 8009150:	d16d      	bne.n	800922e <Standard_ClearFeature+0xfe>
        || (pInformation->USBwIndex1 != 0))
 8009152:	791a      	ldrb	r2, [r3, #4]
 8009154:	2a00      	cmp	r2, #0
 8009156:	d16a      	bne.n	800922e <Standard_ClearFeature+0xfe>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
 8009158:	795a      	ldrb	r2, [r3, #5]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 800915a:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 8009234 <Standard_ClearFeature+0x104>
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
 800915e:	f022 0080 	bic.w	r0, r2, #128	; 0x80
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
 8009162:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009166:	ea4f 0480 	mov.w	r4, r0, lsl #2
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 800916a:	bf15      	itete	ne
 800916c:	f104 4480 	addne.w	r4, r4, #1073741824	; 0x40000000
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009170:	f104 4480 	addeq.w	r4, r4, #1073741824	; 0x40000000

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8009174:	f504 44b8 	addne.w	r4, r4, #23552	; 0x5c00
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009178:	f504 44b8 	addeq.w	r4, r4, #23552	; 0x5c00

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 800917c:	bf14      	ite	ne
 800917e:	6821      	ldrne	r1, [r4, #0]
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009180:	6821      	ldreq	r1, [r4, #0]
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 8009182:	f89c c000 	ldrb.w	ip, [ip]

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8009186:	bf14      	ite	ne
 8009188:	f001 0130 	andne.w	r1, r1, #48	; 0x30
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 800918c:	f401 5140 	andeq.w	r1, r1, #12288	; 0x3000
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 8009190:	4560      	cmp	r0, ip
 8009192:	bf34      	ite	cc
 8009194:	f04f 0c00 	movcc.w	ip, #0
 8009198:	f04f 0c01 	movcs.w	ip, #1
 800919c:	2900      	cmp	r1, #0
 800919e:	bf14      	ite	ne
 80091a0:	4661      	movne	r1, ip
 80091a2:	f04c 0101 	orreq.w	r1, ip, #1
 80091a6:	2900      	cmp	r1, #0
 80091a8:	d140      	bne.n	800922c <Standard_ClearFeature+0xfc>
        || (pInformation->Current_Configuration == 0))
 80091aa:	7a9b      	ldrb	r3, [r3, #10]
 80091ac:	2b00      	cmp	r3, #0
 80091ae:	d03d      	beq.n	800922c <Standard_ClearFeature+0xfc>
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
 80091b0:	f012 0f80 	tst.w	r2, #128	; 0x80
 80091b4:	ea4f 0480 	mov.w	r4, r0, lsl #2
 80091b8:	d011      	beq.n	80091de <Standard_ClearFeature+0xae>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
 80091ba:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80091be:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 80091c2:	6823      	ldr	r3, [r4, #0]
 80091c4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80091c8:	2b10      	cmp	r3, #16
 80091ca:	d129      	bne.n	8009220 <Standard_ClearFeature+0xf0>
      {
      #ifndef STM32F10X_CL
        ClearDTOG_TX(Related_Endpoint);
 80091cc:	b2c4      	uxtb	r4, r0
 80091ce:	4620      	mov	r0, r4
 80091d0:	f000 fc9a 	bl	8009b08 <ClearDTOG_TX>
      #endif /* STM32F10X_CL */
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
 80091d4:	4620      	mov	r0, r4
 80091d6:	2130      	movs	r1, #48	; 0x30
 80091d8:	f000 fc32 	bl	8009a40 <SetEPTxStatus>
 80091dc:	e020      	b.n	8009220 <Standard_ClearFeature+0xf0>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 80091de:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80091e2:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 80091e6:	6823      	ldr	r3, [r4, #0]
 80091e8:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80091ec:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80091f0:	d116      	bne.n	8009220 <Standard_ClearFeature+0xf0>
      {
        if (Related_Endpoint == ENDP0)
 80091f2:	b930      	cbnz	r0, 8009202 <Standard_ClearFeature+0xd2>
        {
          /* After clear the STALL, enable the default endpoint receiver */
//          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
          SetEPRxCount(Related_Endpoint, pProperty->MaxPacketSize);
 80091f4:	4b10      	ldr	r3, [pc, #64]	; (8009238 <Standard_ClearFeature+0x108>)
 80091f6:	681b      	ldr	r3, [r3, #0]
 80091f8:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 80091fc:	f000 fce2 	bl	8009bc4 <SetEPRxCount>
 8009200:	e002      	b.n	8009208 <Standard_ClearFeature+0xd8>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
        #ifndef STM32F10X_CL
          ClearDTOG_RX(Related_Endpoint);
 8009202:	b2c0      	uxtb	r0, r0
 8009204:	f000 fc6c 	bl	8009ae0 <ClearDTOG_RX>
        #endif /* STM32F10X_CL */
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 8009208:	6822      	ldr	r2, [r4, #0]
 800920a:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 800920e:	ea02 0303 	and.w	r3, r2, r3
 8009212:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8009216:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800921a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800921e:	6023      	str	r3, [r4, #0]
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
 8009220:	4b06      	ldr	r3, [pc, #24]	; (800923c <Standard_ClearFeature+0x10c>)
 8009222:	681b      	ldr	r3, [r3, #0]
 8009224:	695b      	ldr	r3, [r3, #20]
 8009226:	4798      	blx	r3
    return USB_SUCCESS;
 8009228:	2000      	movs	r0, #0
 800922a:	e000      	b.n	800922e <Standard_ClearFeature+0xfe>
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
        || (pInformation->Current_Configuration == 0))
    {
      return USB_UNSUPPORT;
 800922c:	2002      	movs	r0, #2
    pUser_Standard_Requests->User_ClearFeature();
    return USB_SUCCESS;
  }

  return USB_UNSUPPORT;
}
 800922e:	bd10      	pop	{r4, pc}
 8009230:	200030cc 	.word	0x200030cc
 8009234:	200030d0 	.word	0x200030d0
 8009238:	200030c4 	.word	0x200030c4
 800923c:	200030c8 	.word	0x200030c8

08009240 <Standard_SetEndPointFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
 8009240:	b508      	push	{r3, lr}
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 8009242:	4b2b      	ldr	r3, [pc, #172]	; (80092f0 <Standard_SetEndPointFeature+0xb0>)
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 8009244:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 80092f4 <Standard_SetEndPointFeature+0xb4>
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 8009248:	6818      	ldr	r0, [r3, #0]
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 800924a:	f89c c000 	ldrb.w	ip, [ip]
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 800924e:	7941      	ldrb	r1, [r0, #5]
  rEP = wIndex0 & ~0x80;
 8009250:	f021 0280 	bic.w	r2, r1, #128	; 0x80
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
 8009254:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009258:	ea4f 0382 	mov.w	r3, r2, lsl #2
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 800925c:	bf15      	itete	ne
 800925e:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009262:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 8009266:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 800926a:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 800926e:	bf15      	itete	ne
 8009270:	681b      	ldrne	r3, [r3, #0]
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009272:	681b      	ldreq	r3, [r3, #0]

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 8009274:	f003 0330 	andne.w	r3, r3, #48	; 0x30
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009278:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 800927c:	4562      	cmp	r2, ip
 800927e:	d235      	bcs.n	80092ec <Standard_SetEndPointFeature+0xac>
      || pInformation->USBwValue != 0 || Status == 0
 8009280:	f8b0 c002 	ldrh.w	ip, [r0, #2]
 8009284:	f1bc 0c00 	subs.w	ip, ip, #0
 8009288:	bf18      	it	ne
 800928a:	f04f 0c01 	movne.w	ip, #1
 800928e:	2b00      	cmp	r3, #0
 8009290:	bf14      	ite	ne
 8009292:	4663      	movne	r3, ip
 8009294:	f04c 0301 	orreq.w	r3, ip, #1
 8009298:	bb43      	cbnz	r3, 80092ec <Standard_SetEndPointFeature+0xac>
      || pInformation->Current_Configuration == 0)
 800929a:	7a83      	ldrb	r3, [r0, #10]
 800929c:	b333      	cbz	r3, 80092ec <Standard_SetEndPointFeature+0xac>
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
 800929e:	f011 0f80 	tst.w	r1, #128	; 0x80
 80092a2:	ea4f 0382 	mov.w	r3, r2, lsl #2
 80092a6:	d00b      	beq.n	80092c0 <Standard_SetEndPointFeature+0x80>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
 80092a8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80092ac:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80092b0:	6819      	ldr	r1, [r3, #0]
 80092b2:	f648 72bf 	movw	r2, #36799	; 0x8fbf
 80092b6:	ea01 0202 	and.w	r2, r1, r2
 80092ba:	f082 0210 	eor.w	r2, r2, #16
 80092be:	e00a      	b.n	80092d6 <Standard_SetEndPointFeature+0x96>
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
 80092c0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80092c4:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80092c8:	6819      	ldr	r1, [r3, #0]
 80092ca:	f64b 728f 	movw	r2, #49039	; 0xbf8f
 80092ce:	ea01 0202 	and.w	r2, r1, r2
 80092d2:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 80092d6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80092da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80092de:	601a      	str	r2, [r3, #0]
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
 80092e0:	4b05      	ldr	r3, [pc, #20]	; (80092f8 <Standard_SetEndPointFeature+0xb8>)
 80092e2:	681b      	ldr	r3, [r3, #0]
 80092e4:	699b      	ldr	r3, [r3, #24]
 80092e6:	4798      	blx	r3
  return USB_SUCCESS;
 80092e8:	2000      	movs	r0, #0
 80092ea:	e000      	b.n	80092ee <Standard_SetEndPointFeature+0xae>

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
 80092ec:	2002      	movs	r0, #2
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
 80092ee:	bd08      	pop	{r3, pc}
 80092f0:	200030cc 	.word	0x200030cc
 80092f4:	200030d0 	.word	0x200030d0
 80092f8:	200030c8 	.word	0x200030c8

080092fc <Standard_SetDeviceFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
 80092fc:	b508      	push	{r3, lr}
  SetBit(pInformation->Current_Feature, 5);
 80092fe:	4b06      	ldr	r3, [pc, #24]	; (8009318 <Standard_SetDeviceFeature+0x1c>)
 8009300:	681b      	ldr	r3, [r3, #0]
 8009302:	7a5a      	ldrb	r2, [r3, #9]
 8009304:	f042 0220 	orr.w	r2, r2, #32
 8009308:	725a      	strb	r2, [r3, #9]
  pUser_Standard_Requests->User_SetDeviceFeature();
 800930a:	4b04      	ldr	r3, [pc, #16]	; (800931c <Standard_SetDeviceFeature+0x20>)
 800930c:	681b      	ldr	r3, [r3, #0]
 800930e:	69db      	ldr	r3, [r3, #28]
 8009310:	4798      	blx	r3
  return USB_SUCCESS;
}
 8009312:	2000      	movs	r0, #0
 8009314:	bd08      	pop	{r3, pc}
 8009316:	bf00      	nop
 8009318:	200030cc 	.word	0x200030cc
 800931c:	200030c8 	.word	0x200030c8

08009320 <Standard_GetDescriptorData>:
*******************************************************************************/
uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
{
  uint32_t  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
 8009320:	4b05      	ldr	r3, [pc, #20]	; (8009338 <Standard_GetDescriptorData+0x18>)
 8009322:	681a      	ldr	r2, [r3, #0]
 8009324:	8a53      	ldrh	r3, [r2, #18]
  if (Length == 0)
 8009326:	b918      	cbnz	r0, 8009330 <Standard_GetDescriptorData+0x10>
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
 8009328:	8889      	ldrh	r1, [r1, #4]
 800932a:	1acb      	subs	r3, r1, r3
 800932c:	8213      	strh	r3, [r2, #16]
    return 0;
 800932e:	e001      	b.n	8009334 <Standard_GetDescriptorData+0x14>
  }

  return pDesc->Descriptor + wOffset;
 8009330:	6808      	ldr	r0, [r1, #0]
 8009332:	18c0      	adds	r0, r0, r3
}
 8009334:	4770      	bx	lr
 8009336:	bf00      	nop
 8009338:	200030cc 	.word	0x200030cc

0800933c <Post0_Process>:
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
uint8_t Post0_Process(void)
{
 800933c:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
#endif /* STM32F10X_CL */
      
//  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 800933e:	4b0c      	ldr	r3, [pc, #48]	; (8009370 <Post0_Process+0x34>)
 8009340:	2000      	movs	r0, #0
 8009342:	681b      	ldr	r3, [r3, #0]
 8009344:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8009348:	f000 fc3c 	bl	8009bc4 <SetEPRxCount>

  if (pInformation->ControlState == STALLED)
 800934c:	4b09      	ldr	r3, [pc, #36]	; (8009374 <Post0_Process+0x38>)
 800934e:	681b      	ldr	r3, [r3, #0]
 8009350:	7a18      	ldrb	r0, [r3, #8]
 8009352:	2808      	cmp	r0, #8
 8009354:	d106      	bne.n	8009364 <Post0_Process+0x28>
  {
    vSetEPRxStatus(EP_RX_STALL);
 8009356:	4b08      	ldr	r3, [pc, #32]	; (8009378 <Post0_Process+0x3c>)
 8009358:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800935c:	801a      	strh	r2, [r3, #0]
    vSetEPTxStatus(EP_TX_STALL);
 800935e:	4b07      	ldr	r3, [pc, #28]	; (800937c <Post0_Process+0x40>)
 8009360:	2210      	movs	r2, #16
 8009362:	801a      	strh	r2, [r3, #0]
 8009364:	2809      	cmp	r0, #9
 8009366:	bf14      	ite	ne
 8009368:	2000      	movne	r0, #0
 800936a:	2001      	moveq	r0, #1
    OTGD_FS_EP0StartXfer(ep);    
  }  
#endif /* STM32F10X_CL */

  return (pInformation->ControlState == PAUSE);
}
 800936c:	bd08      	pop	{r3, pc}
 800936e:	bf00      	nop
 8009370:	200030c4 	.word	0x200030c4
 8009374:	200030cc 	.word	0x200030cc
 8009378:	200030da 	.word	0x200030da
 800937c:	200030dc 	.word	0x200030dc

08009380 <Out0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Out0_Process(void)
{
 8009380:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t ControlState = pInformation->ControlState;
 8009382:	4b38      	ldr	r3, [pc, #224]	; (8009464 <Out0_Process+0xe4>)
 8009384:	681c      	ldr	r4, [r3, #0]
 8009386:	7a23      	ldrb	r3, [r4, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8009388:	2b02      	cmp	r3, #2
 800938a:	bf14      	ite	ne
 800938c:	2600      	movne	r6, #0
 800938e:	2601      	moveq	r6, #1
 8009390:	2b04      	cmp	r3, #4
 8009392:	bf08      	it	eq
 8009394:	f046 0601 	orreq.w	r6, r6, #1
 8009398:	2e00      	cmp	r6, #0
 800939a:	d15b      	bne.n	8009454 <Out0_Process+0xd4>
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
 800939c:	2b03      	cmp	r3, #3
 800939e:	bf14      	ite	ne
 80093a0:	2200      	movne	r2, #0
 80093a2:	2201      	moveq	r2, #1
 80093a4:	2b05      	cmp	r3, #5
 80093a6:	bf08      	it	eq
 80093a8:	f042 0201 	orreq.w	r2, r2, #1
 80093ac:	2a00      	cmp	r2, #0
 80093ae:	d04b      	beq.n	8009448 <Out0_Process+0xc8>
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
 80093b0:	69a3      	ldr	r3, [r4, #24]
void DataStageOut(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;
 80093b2:	8a22      	ldrh	r2, [r4, #16]

  if (pEPinfo->CopyData && save_rLength)
 80093b4:	1e19      	subs	r1, r3, #0
 80093b6:	bf18      	it	ne
 80093b8:	2101      	movne	r1, #1
 80093ba:	2a00      	cmp	r2, #0
 80093bc:	bf0c      	ite	eq
 80093be:	2100      	moveq	r1, #0
 80093c0:	f001 0101 	andne.w	r1, r1, #1
 80093c4:	b1a1      	cbz	r1, 80093f0 <Out0_Process+0x70>
  {
    uint8_t *Buffer;
    uint32_t Length;

    Length = pEPinfo->PacketSize;
 80093c6:	8aa5      	ldrh	r5, [r4, #20]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 80093c8:	4295      	cmp	r5, r2
 80093ca:	bf28      	it	cs
 80093cc:	4615      	movcs	r5, r2
 80093ce:	4628      	mov	r0, r5
 80093d0:	4798      	blx	r3
    pEPinfo->Usb_rLength -= Length;
 80093d2:	8a23      	ldrh	r3, [r4, #16]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 80093d4:	4607      	mov	r7, r0
    pEPinfo->Usb_rLength -= Length;
 80093d6:	1b5b      	subs	r3, r3, r5
 80093d8:	8223      	strh	r3, [r4, #16]
    pEPinfo->Usb_rOffset += Length;
 80093da:	8a63      	ldrh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 80093dc:	4630      	mov	r0, r6
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    pEPinfo->Usb_rLength -= Length;
    pEPinfo->Usb_rOffset += Length;
 80093de:	18eb      	adds	r3, r5, r3
 80093e0:	8263      	strh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 80093e2:	f000 fbd3 	bl	8009b8c <GetEPRxAddr>
 80093e6:	462a      	mov	r2, r5
 80093e8:	4601      	mov	r1, r0
 80093ea:	4638      	mov	r0, r7
 80093ec:	f000 faf6 	bl	80099dc <PMAToUserBufferCopy>
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
 80093f0:	8a23      	ldrh	r3, [r4, #16]
 80093f2:	b153      	cbz	r3, 800940a <Out0_Process+0x8a>
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 80093f4:	4b1c      	ldr	r3, [pc, #112]	; (8009468 <Out0_Process+0xe8>)
 80093f6:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    SetEPTxCount(ENDP0, 0);
 80093fa:	2000      	movs	r0, #0
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 80093fc:	801a      	strh	r2, [r3, #0]
    SetEPTxCount(ENDP0, 0);
 80093fe:	4601      	mov	r1, r0
 8009400:	f000 fbd2 	bl	8009ba8 <SetEPTxCount>
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 8009404:	4b19      	ldr	r3, [pc, #100]	; (800946c <Out0_Process+0xec>)
 8009406:	2230      	movs	r2, #48	; 0x30
 8009408:	801a      	strh	r2, [r3, #0]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
 800940a:	8a23      	ldrh	r3, [r4, #16]
 800940c:	8aa2      	ldrh	r2, [r4, #20]
 800940e:	429a      	cmp	r2, r3
 8009410:	d803      	bhi.n	800941a <Out0_Process+0x9a>
  {
    pInformation->ControlState = OUT_DATA;
 8009412:	4b14      	ldr	r3, [pc, #80]	; (8009464 <Out0_Process+0xe4>)
 8009414:	2203      	movs	r2, #3
 8009416:	681b      	ldr	r3, [r3, #0]
 8009418:	e003      	b.n	8009422 <Out0_Process+0xa2>
 800941a:	4a12      	ldr	r2, [pc, #72]	; (8009464 <Out0_Process+0xe4>)
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
 800941c:	b11b      	cbz	r3, 8009426 <Out0_Process+0xa6>
    {
      pInformation->ControlState = LAST_OUT_DATA;
 800941e:	6813      	ldr	r3, [r2, #0]
 8009420:	2205      	movs	r2, #5
 8009422:	721a      	strb	r2, [r3, #8]
 8009424:	e00c      	b.n	8009440 <Out0_Process+0xc0>
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
 8009426:	6812      	ldr	r2, [r2, #0]
 8009428:	2106      	movs	r1, #6
 800942a:	7211      	strb	r1, [r2, #8]
      USB_StatusIn();
 800942c:	4a10      	ldr	r2, [pc, #64]	; (8009470 <Out0_Process+0xf0>)
 800942e:	6811      	ldr	r1, [r2, #0]
 8009430:	4a10      	ldr	r2, [pc, #64]	; (8009474 <Out0_Process+0xf4>)
 8009432:	b289      	uxth	r1, r1
 8009434:	188a      	adds	r2, r1, r2
 8009436:	0052      	lsls	r2, r2, #1
 8009438:	6013      	str	r3, [r2, #0]
 800943a:	4b0c      	ldr	r3, [pc, #48]	; (800946c <Out0_Process+0xec>)
 800943c:	2230      	movs	r2, #48	; 0x30
 800943e:	801a      	strh	r2, [r3, #0]
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
 8009440:	4b08      	ldr	r3, [pc, #32]	; (8009464 <Out0_Process+0xe4>)
 8009442:	681b      	ldr	r3, [r3, #0]
 8009444:	7a1b      	ldrb	r3, [r3, #8]
 8009446:	e006      	b.n	8009456 <Out0_Process+0xd6>
  }

  else if (ControlState == WAIT_STATUS_OUT)
 8009448:	2b07      	cmp	r3, #7
 800944a:	d103      	bne.n	8009454 <Out0_Process+0xd4>
  {
    (*pProperty->Process_Status_OUT)();
 800944c:	4b0a      	ldr	r3, [pc, #40]	; (8009478 <Out0_Process+0xf8>)
 800944e:	681b      	ldr	r3, [r3, #0]
 8009450:	68db      	ldr	r3, [r3, #12]
 8009452:	4798      	blx	r3


  /* Unexpect state, STALL the endpoint */
  else
  {
    ControlState = STALLED;
 8009454:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 8009456:	4a03      	ldr	r2, [pc, #12]	; (8009464 <Out0_Process+0xe4>)
 8009458:	6812      	ldr	r2, [r2, #0]
 800945a:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 800945c:	f7ff ff6e 	bl	800933c <Post0_Process>
}
 8009460:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009462:	bf00      	nop
 8009464:	200030cc 	.word	0x200030cc
 8009468:	200030da 	.word	0x200030da
 800946c:	200030dc 	.word	0x200030dc
 8009470:	40005c50 	.word	0x40005c50
 8009474:	20003002 	.word	0x20003002
 8009478:	200030c4 	.word	0x200030c4

0800947c <Setup0_Process>:
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 800947c:	4bb5      	ldr	r3, [pc, #724]	; (8009754 <Setup0_Process+0x2d8>)
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Setup0_Process(void)
{
 800947e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009480:	681a      	ldr	r2, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009482:	4eb5      	ldr	r6, [pc, #724]	; (8009758 <Setup0_Process+0x2dc>)
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009484:	4bb5      	ldr	r3, [pc, #724]	; (800975c <Setup0_Process+0x2e0>)
 8009486:	b292      	uxth	r2, r2
 8009488:	18d3      	adds	r3, r2, r3
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 800948a:	6835      	ldr	r5, [r6, #0]
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 800948c:	005b      	lsls	r3, r3, #1
 800948e:	681f      	ldr	r7, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009490:	7a2b      	ldrb	r3, [r5, #8]
 8009492:	2b09      	cmp	r3, #9
 8009494:	d01a      	beq.n	80094cc <Setup0_Process+0x50>
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009496:	b2bf      	uxth	r7, r7
 8009498:	f107 5700 	add.w	r7, r7, #536870912	; 0x20000000
 800949c:	f507 5740 	add.w	r7, r7, #12288	; 0x3000
 80094a0:	007f      	lsls	r7, r7, #1
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
 80094a2:	463c      	mov	r4, r7
 80094a4:	f814 3b01 	ldrb.w	r3, [r4], #1
 80094a8:	702b      	strb	r3, [r5, #0]
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 80094aa:	787b      	ldrb	r3, [r7, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 80094ac:	370a      	adds	r7, #10
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 80094ae:	706b      	strb	r3, [r5, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
 80094b0:	f8b4 0003 	ldrh.w	r0, [r4, #3]
 80094b4:	f000 fbb6 	bl	8009c24 <ByteSwap>
 80094b8:	8068      	strh	r0, [r5, #2]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 80094ba:	f8b4 0007 	ldrh.w	r0, [r4, #7]
 80094be:	6835      	ldr	r5, [r6, #0]
 80094c0:	f000 fbb0 	bl	8009c24 <ByteSwap>
 80094c4:	80a8      	strh	r0, [r5, #4]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength */
 80094c6:	6833      	ldr	r3, [r6, #0]
 80094c8:	887f      	ldrh	r7, [r7, #2]
 80094ca:	80df      	strh	r7, [r3, #6]
  }

  pInformation->ControlState = SETTING_UP;
 80094cc:	4ca2      	ldr	r4, [pc, #648]	; (8009758 <Setup0_Process+0x2dc>)
 80094ce:	2201      	movs	r2, #1
 80094d0:	6823      	ldr	r3, [r4, #0]
 80094d2:	721a      	strb	r2, [r3, #8]
  if (pInformation->USBwLength == 0)
 80094d4:	88da      	ldrh	r2, [r3, #6]
 80094d6:	785d      	ldrb	r5, [r3, #1]
 80094d8:	2a00      	cmp	r2, #0
 80094da:	d161      	bne.n	80095a0 <Setup0_Process+0x124>
{
  RESULT Result = USB_UNSUPPORT;
  uint32_t RequestNo = pInformation->USBbRequest;
  uint32_t ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80094dc:	781a      	ldrb	r2, [r3, #0]
 80094de:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 80094e2:	d12e      	bne.n	8009542 <Setup0_Process+0xc6>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
 80094e4:	2d09      	cmp	r5, #9
 80094e6:	d102      	bne.n	80094ee <Setup0_Process+0x72>
    {
      Result = Standard_SetConfiguration();
 80094e8:	f7ff fde2 	bl	80090b0 <Standard_SetConfiguration>
 80094ec:	e03b      	b.n	8009566 <Setup0_Process+0xea>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
 80094ee:	2d05      	cmp	r5, #5
 80094f0:	d10d      	bne.n	800950e <Setup0_Process+0x92>
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
 80094f2:	f993 2003 	ldrsb.w	r2, [r3, #3]
 80094f6:	2a00      	cmp	r2, #0
 80094f8:	db4d      	blt.n	8009596 <Setup0_Process+0x11a>
 80094fa:	789a      	ldrb	r2, [r3, #2]
 80094fc:	2a00      	cmp	r2, #0
 80094fe:	d14a      	bne.n	8009596 <Setup0_Process+0x11a>
          || (pInformation->USBwIndex != 0)
 8009500:	889a      	ldrh	r2, [r3, #4]
 8009502:	2a00      	cmp	r2, #0
 8009504:	d147      	bne.n	8009596 <Setup0_Process+0x11a>
          || (pInformation->Current_Configuration != 0))
 8009506:	7a9b      	ldrb	r3, [r3, #10]
 8009508:	2b00      	cmp	r3, #0
 800950a:	d035      	beq.n	8009578 <Setup0_Process+0xfc>
 800950c:	e043      	b.n	8009596 <Setup0_Process+0x11a>
         SetDeviceAddress(pInformation->USBwValue0);
      #endif  /* STM32F10X_CL */
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
 800950e:	2d03      	cmp	r5, #3
 8009510:	d10b      	bne.n	800952a <Setup0_Process+0xae>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
 8009512:	78da      	ldrb	r2, [r3, #3]
 8009514:	2a01      	cmp	r2, #1
 8009516:	d127      	bne.n	8009568 <Setup0_Process+0xec>
          && (pInformation->USBwIndex == 0)
 8009518:	889a      	ldrh	r2, [r3, #4]
 800951a:	bb2a      	cbnz	r2, 8009568 <Setup0_Process+0xec>
          && (ValBit(pInformation->Current_Feature, 5)))
 800951c:	7a5b      	ldrb	r3, [r3, #9]
 800951e:	f013 0f20 	tst.w	r3, #32
 8009522:	d021      	beq.n	8009568 <Setup0_Process+0xec>
      {
        Result = Standard_SetDeviceFeature();
 8009524:	f7ff feea 	bl	80092fc <Standard_SetDeviceFeature>
 8009528:	e01d      	b.n	8009566 <Setup0_Process+0xea>
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
 800952a:	2d01      	cmp	r5, #1
 800952c:	d11c      	bne.n	8009568 <Setup0_Process+0xec>
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
 800952e:	78da      	ldrb	r2, [r3, #3]
 8009530:	2a01      	cmp	r2, #1
 8009532:	d119      	bne.n	8009568 <Setup0_Process+0xec>
          && pInformation->USBwIndex == 0
 8009534:	889a      	ldrh	r2, [r3, #4]
 8009536:	b9ba      	cbnz	r2, 8009568 <Setup0_Process+0xec>
          && ValBit(pInformation->Current_Feature, 5))
 8009538:	7a5b      	ldrb	r3, [r3, #9]
 800953a:	f013 0f20 	tst.w	r3, #32
 800953e:	d013      	beq.n	8009568 <Setup0_Process+0xec>
 8009540:	e00a      	b.n	8009558 <Setup0_Process+0xdc>
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009542:	2a01      	cmp	r2, #1
 8009544:	d104      	bne.n	8009550 <Setup0_Process+0xd4>
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
 8009546:	2d0b      	cmp	r5, #11
 8009548:	d10e      	bne.n	8009568 <Setup0_Process+0xec>
    {
      Result = Standard_SetInterface();
 800954a:	f7ff fdcd 	bl	80090e8 <Standard_SetInterface>
 800954e:	e00a      	b.n	8009566 <Setup0_Process+0xea>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009550:	2a02      	cmp	r2, #2
 8009552:	d109      	bne.n	8009568 <Setup0_Process+0xec>
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
 8009554:	2d01      	cmp	r5, #1
 8009556:	d102      	bne.n	800955e <Setup0_Process+0xe2>
    {
      Result = Standard_ClearFeature();
 8009558:	f7ff fdea 	bl	8009130 <Standard_ClearFeature>
 800955c:	e003      	b.n	8009566 <Setup0_Process+0xea>
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
 800955e:	2d03      	cmp	r5, #3
 8009560:	d102      	bne.n	8009568 <Setup0_Process+0xec>
    {
      Result = Standard_SetEndPointFeature();
 8009562:	f7ff fe6d 	bl	8009240 <Standard_SetEndPointFeature>
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
 8009566:	b138      	cbz	r0, 8009578 <Setup0_Process+0xfc>
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
 8009568:	4b7d      	ldr	r3, [pc, #500]	; (8009760 <Setup0_Process+0x2e4>)
 800956a:	4628      	mov	r0, r5
 800956c:	681b      	ldr	r3, [r3, #0]
 800956e:	695b      	ldr	r3, [r3, #20]
 8009570:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 8009572:	2803      	cmp	r0, #3
 8009574:	d00d      	beq.n	8009592 <Setup0_Process+0x116>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
 8009576:	b970      	cbnz	r0, 8009596 <Setup0_Process+0x11a>
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
 8009578:	4b76      	ldr	r3, [pc, #472]	; (8009754 <Setup0_Process+0x2d8>)
 800957a:	2130      	movs	r1, #48	; 0x30
 800957c:	681a      	ldr	r2, [r3, #0]
 800957e:	4b79      	ldr	r3, [pc, #484]	; (8009764 <Setup0_Process+0x2e8>)
 8009580:	b292      	uxth	r2, r2
 8009582:	18d3      	adds	r3, r2, r3
 8009584:	005b      	lsls	r3, r3, #1
 8009586:	2200      	movs	r2, #0
 8009588:	601a      	str	r2, [r3, #0]
 800958a:	4b77      	ldr	r3, [pc, #476]	; (8009768 <Setup0_Process+0x2ec>)
 800958c:	8019      	strh	r1, [r3, #0]
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
 800958e:	2306      	movs	r3, #6
 8009590:	e002      	b.n	8009598 <Setup0_Process+0x11c>
  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    if (Result == USB_NOT_READY)
    {
      ControlState = PAUSE;
 8009592:	2309      	movs	r3, #9
 8009594:	e000      	b.n	8009598 <Setup0_Process+0x11c>
    }
  }

  if (Result != USB_SUCCESS)
  {
    ControlState = STALLED;
 8009596:	2308      	movs	r3, #8
  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
 8009598:	4a6f      	ldr	r2, [pc, #444]	; (8009758 <Setup0_Process+0x2dc>)
 800959a:	6812      	ldr	r2, [r2, #0]
 800959c:	7213      	strb	r3, [r2, #8]
 800959e:	e0d6      	b.n	800974e <Setup0_Process+0x2d2>

  CopyRoutine = NULL;
  wOffset = 0;

  /*GET DESCRIPTOR*/
  if (Request_No == GET_DESCRIPTOR)
 80095a0:	2d06      	cmp	r5, #6
 80095a2:	d117      	bne.n	80095d4 <Setup0_Process+0x158>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80095a4:	781a      	ldrb	r2, [r3, #0]
 80095a6:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 80095aa:	f040 808a 	bne.w	80096c2 <Setup0_Process+0x246>
    {
      uint8_t wValue1 = pInformation->USBwValue1;
 80095ae:	789b      	ldrb	r3, [r3, #2]
      if (wValue1 == DEVICE_DESCRIPTOR)
 80095b0:	2b01      	cmp	r3, #1
 80095b2:	d103      	bne.n	80095bc <Setup0_Process+0x140>
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
 80095b4:	4b6a      	ldr	r3, [pc, #424]	; (8009760 <Setup0_Process+0x2e4>)
 80095b6:	681b      	ldr	r3, [r3, #0]
 80095b8:	69db      	ldr	r3, [r3, #28]
 80095ba:	e079      	b.n	80096b0 <Setup0_Process+0x234>
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
 80095bc:	2b02      	cmp	r3, #2
 80095be:	d103      	bne.n	80095c8 <Setup0_Process+0x14c>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
 80095c0:	4b67      	ldr	r3, [pc, #412]	; (8009760 <Setup0_Process+0x2e4>)
 80095c2:	681b      	ldr	r3, [r3, #0]
 80095c4:	6a1b      	ldr	r3, [r3, #32]
 80095c6:	e073      	b.n	80096b0 <Setup0_Process+0x234>
      }
      else if (wValue1 == STRING_DESCRIPTOR)
 80095c8:	2b03      	cmp	r3, #3
 80095ca:	d17a      	bne.n	80096c2 <Setup0_Process+0x246>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
 80095cc:	4b64      	ldr	r3, [pc, #400]	; (8009760 <Setup0_Process+0x2e4>)
 80095ce:	681b      	ldr	r3, [r3, #0]
 80095d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80095d2:	e06d      	b.n	80096b0 <Setup0_Process+0x234>
      }  /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
 80095d4:	2d00      	cmp	r5, #0
 80095d6:	d147      	bne.n	8009668 <Setup0_Process+0x1ec>
 80095d8:	8859      	ldrh	r1, [r3, #2]
 80095da:	2900      	cmp	r1, #0
 80095dc:	d171      	bne.n	80096c2 <Setup0_Process+0x246>
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
 80095de:	685a      	ldr	r2, [r3, #4]
 80095e0:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80095e4:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 80095e8:	d16b      	bne.n	80096c2 <Setup0_Process+0x246>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80095ea:	781a      	ldrb	r2, [r3, #0]
 80095ec:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 80095f0:	d103      	bne.n	80095fa <Setup0_Process+0x17e>
        && (pInformation->USBwIndex == 0))
 80095f2:	889b      	ldrh	r3, [r3, #4]
 80095f4:	2b00      	cmp	r3, #0
 80095f6:	d059      	beq.n	80096ac <Setup0_Process+0x230>
 80095f8:	e063      	b.n	80096c2 <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 80095fa:	2a01      	cmp	r2, #1
 80095fc:	d109      	bne.n	8009612 <Setup0_Process+0x196>
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
 80095fe:	4a58      	ldr	r2, [pc, #352]	; (8009760 <Setup0_Process+0x2e4>)
 8009600:	7958      	ldrb	r0, [r3, #5]
 8009602:	6812      	ldr	r2, [r2, #0]
 8009604:	6993      	ldr	r3, [r2, #24]
 8009606:	4798      	blx	r3
 8009608:	2800      	cmp	r0, #0
 800960a:	d15a      	bne.n	80096c2 <Setup0_Process+0x246>
          && (pInformation->Current_Configuration != 0))
 800960c:	6823      	ldr	r3, [r4, #0]
 800960e:	7a9b      	ldrb	r3, [r3, #10]
 8009610:	e028      	b.n	8009664 <Setup0_Process+0x1e8>
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009612:	2a02      	cmp	r2, #2
 8009614:	d155      	bne.n	80096c2 <Setup0_Process+0x246>
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 8009616:	795b      	ldrb	r3, [r3, #5]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009618:	4854      	ldr	r0, [pc, #336]	; (800976c <Setup0_Process+0x2f0>)
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 800961a:	f003 020f 	and.w	r2, r3, #15
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
 800961e:	f013 0f80 	tst.w	r3, #128	; 0x80

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;
 8009622:	f003 0170 	and.w	r1, r3, #112	; 0x70
 8009626:	ea4f 0382 	mov.w	r3, r2, lsl #2

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 800962a:	bf15      	itete	ne
 800962c:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009630:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009634:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009638:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 800963c:	bf14      	ite	ne
 800963e:	681b      	ldrne	r3, [r3, #0]
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009640:	681b      	ldreq	r3, [r3, #0]
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009642:	7800      	ldrb	r0, [r0, #0]

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009644:	bf14      	ite	ne
 8009646:	f003 0330 	andne.w	r3, r3, #48	; 0x30
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 800964a:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 800964e:	4282      	cmp	r2, r0
 8009650:	bf2c      	ite	cs
 8009652:	2200      	movcs	r2, #0
 8009654:	2201      	movcc	r2, #1
 8009656:	2900      	cmp	r1, #0
 8009658:	bf14      	ite	ne
 800965a:	2200      	movne	r2, #0
 800965c:	f002 0201 	andeq.w	r2, r2, #1
 8009660:	2a00      	cmp	r2, #0
 8009662:	d02e      	beq.n	80096c2 <Setup0_Process+0x246>
          && (Status != 0))
 8009664:	bb13      	cbnz	r3, 80096ac <Setup0_Process+0x230>
 8009666:	e02c      	b.n	80096c2 <Setup0_Process+0x246>
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
 8009668:	2d08      	cmp	r5, #8
 800966a:	d106      	bne.n	800967a <Setup0_Process+0x1fe>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 800966c:	781b      	ldrb	r3, [r3, #0]
 800966e:	f013 0f7f 	tst.w	r3, #127	; 0x7f
    {
      CopyRoutine = Standard_GetConfiguration;
 8009672:	bf08      	it	eq
 8009674:	4b3e      	ldreq	r3, [pc, #248]	; (8009770 <Setup0_Process+0x2f4>)
  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009676:	d01c      	beq.n	80096b2 <Setup0_Process+0x236>
 8009678:	e023      	b.n	80096c2 <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
 800967a:	2d0a      	cmp	r5, #10
 800967c:	d121      	bne.n	80096c2 <Setup0_Process+0x246>
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 800967e:	781a      	ldrb	r2, [r3, #0]
 8009680:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8009684:	2a01      	cmp	r2, #1
 8009686:	d11c      	bne.n	80096c2 <Setup0_Process+0x246>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
 8009688:	7a9a      	ldrb	r2, [r3, #10]
 800968a:	b1d2      	cbz	r2, 80096c2 <Setup0_Process+0x246>
 800968c:	8859      	ldrh	r1, [r3, #2]
 800968e:	b9c1      	cbnz	r1, 80096c2 <Setup0_Process+0x246>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
 8009690:	685a      	ldr	r2, [r3, #4]
 8009692:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8009696:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800969a:	d112      	bne.n	80096c2 <Setup0_Process+0x246>
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 800969c:	4a30      	ldr	r2, [pc, #192]	; (8009760 <Setup0_Process+0x2e4>)
 800969e:	7958      	ldrb	r0, [r3, #5]
 80096a0:	6812      	ldr	r2, [r2, #0]
 80096a2:	6993      	ldr	r3, [r2, #24]
 80096a4:	4798      	blx	r3
    {
      CopyRoutine = Standard_GetInterface;
 80096a6:	4b33      	ldr	r3, [pc, #204]	; (8009774 <Setup0_Process+0x2f8>)
  else if (Request_No == GET_INTERFACE)
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 80096a8:	b118      	cbz	r0, 80096b2 <Setup0_Process+0x236>
 80096aa:	e00a      	b.n	80096c2 <Setup0_Process+0x246>
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
          && (Status != 0))
      {
        CopyRoutine = Standard_GetStatus;
 80096ac:	4b32      	ldr	r3, [pc, #200]	; (8009778 <Setup0_Process+0x2fc>)
 80096ae:	e000      	b.n	80096b2 <Setup0_Process+0x236>
      CopyRoutine = Standard_GetInterface;
    }

  }
  
  if (CopyRoutine)
 80096b0:	b13b      	cbz	r3, 80096c2 <Setup0_Process+0x246>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
 80096b2:	6822      	ldr	r2, [r4, #0]
 80096b4:	2100      	movs	r1, #0
 80096b6:	8251      	strh	r1, [r2, #18]
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
 80096b8:	6193      	str	r3, [r2, #24]
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
 80096ba:	2000      	movs	r0, #0
 80096bc:	4798      	blx	r3
    Result = USB_SUCCESS;
 80096be:	2000      	movs	r0, #0
 80096c0:	e00a      	b.n	80096d8 <Setup0_Process+0x25c>
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
 80096c2:	4b27      	ldr	r3, [pc, #156]	; (8009760 <Setup0_Process+0x2e4>)
 80096c4:	6822      	ldr	r2, [r4, #0]
 80096c6:	681b      	ldr	r3, [r3, #0]
 80096c8:	7850      	ldrb	r0, [r2, #1]
 80096ca:	691b      	ldr	r3, [r3, #16]
 80096cc:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 80096ce:	2803      	cmp	r0, #3
    {
      pInformation->ControlState = PAUSE;
 80096d0:	bf04      	itt	eq
 80096d2:	4b21      	ldreq	r3, [pc, #132]	; (8009758 <Setup0_Process+0x2dc>)
 80096d4:	681b      	ldreq	r3, [r3, #0]
    Result = USB_SUCCESS;
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    if (Result == USB_NOT_READY)
 80096d6:	d006      	beq.n	80096e6 <Setup0_Process+0x26a>
      pInformation->ControlState = PAUSE;
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
 80096d8:	4b1f      	ldr	r3, [pc, #124]	; (8009758 <Setup0_Process+0x2dc>)
 80096da:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80096de:	681b      	ldr	r3, [r3, #0]
 80096e0:	8a1a      	ldrh	r2, [r3, #16]
 80096e2:	428a      	cmp	r2, r1
 80096e4:	d101      	bne.n	80096ea <Setup0_Process+0x26e>
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
 80096e6:	2209      	movs	r2, #9
 80096e8:	e003      	b.n	80096f2 <Setup0_Process+0x276>
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
 80096ea:	2802      	cmp	r0, #2
 80096ec:	d000      	beq.n	80096f0 <Setup0_Process+0x274>
 80096ee:	b912      	cbnz	r2, 80096f6 <Setup0_Process+0x27a>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
 80096f0:	2208      	movs	r2, #8
 80096f2:	721a      	strb	r2, [r3, #8]
 80096f4:	e02b      	b.n	800974e <Setup0_Process+0x2d2>
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
 80096f6:	f993 1000 	ldrsb.w	r1, [r3]
 80096fa:	2900      	cmp	r1, #0
 80096fc:	da21      	bge.n	8009742 <Setup0_Process+0x2c6>
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
 80096fe:	88d9      	ldrh	r1, [r3, #6]
 8009700:	9101      	str	r1, [sp, #4]
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8009702:	9801      	ldr	r0, [sp, #4]
 8009704:	4282      	cmp	r2, r0
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
 8009706:	bf84      	itt	hi
 8009708:	9a01      	ldrhi	r2, [sp, #4]
 800970a:	821a      	strhhi	r2, [r3, #16]
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 800970c:	d811      	bhi.n	8009732 <Setup0_Process+0x2b6>
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    }
    
    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
 800970e:	428a      	cmp	r2, r1
 8009710:	d20f      	bcs.n	8009732 <Setup0_Process+0x2b6>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
 8009712:	4913      	ldr	r1, [pc, #76]	; (8009760 <Setup0_Process+0x2e4>)
 8009714:	6809      	ldr	r1, [r1, #0]
 8009716:	f891 102c 	ldrb.w	r1, [r1, #44]	; 0x2c
 800971a:	428a      	cmp	r2, r1
 800971c:	d201      	bcs.n	8009722 <Setup0_Process+0x2a6>
      {
        Data_Mul_MaxPacketSize = FALSE;
 800971e:	2100      	movs	r1, #0
 8009720:	e005      	b.n	800972e <Setup0_Process+0x2b2>
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
 8009722:	fb92 f0f1 	sdiv	r0, r2, r1
 8009726:	fb01 2210 	mls	r2, r1, r0, r2
 800972a:	b912      	cbnz	r2, 8009732 <Setup0_Process+0x2b6>
      {
        Data_Mul_MaxPacketSize = TRUE;
 800972c:	2101      	movs	r1, #1
 800972e:	4a13      	ldr	r2, [pc, #76]	; (800977c <Setup0_Process+0x300>)
 8009730:	7011      	strb	r1, [r2, #0]
      }
    }   

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
 8009732:	4a0b      	ldr	r2, [pc, #44]	; (8009760 <Setup0_Process+0x2e4>)
 8009734:	6812      	ldr	r2, [r2, #0]
 8009736:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 800973a:	829a      	strh	r2, [r3, #20]
    DataStageIn();
 800973c:	f7ff fc5c 	bl	8008ff8 <DataStageIn>
 8009740:	e005      	b.n	800974e <Setup0_Process+0x2d2>
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
 8009742:	2203      	movs	r2, #3
 8009744:	721a      	strb	r2, [r3, #8]
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
 8009746:	4b0e      	ldr	r3, [pc, #56]	; (8009780 <Setup0_Process+0x304>)
 8009748:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 800974c:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
 800974e:	f7ff fdf5 	bl	800933c <Post0_Process>
}
 8009752:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009754:	40005c50 	.word	0x40005c50
 8009758:	200030cc 	.word	0x200030cc
 800975c:	20003004 	.word	0x20003004
 8009760:	200030c4 	.word	0x200030c4
 8009764:	20003002 	.word	0x20003002
 8009768:	200030dc 	.word	0x200030dc
 800976c:	200030d0 	.word	0x200030d0
 8009770:	08008f05 	.word	0x08008f05
 8009774:	08008f29 	.word	0x08008f29
 8009778:	08008f4d 	.word	0x08008f4d
 800977c:	20000558 	.word	0x20000558
 8009780:	200030da 	.word	0x200030da

08009784 <SetDeviceAddress>:
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(uint8_t Val)
{
 8009784:	b530      	push	{r4, r5, lr}
#ifdef STM32F10X_CL 
  PCD_EP_SetAddress ((uint8_t)Val);
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;
 8009786:	4b0f      	ldr	r3, [pc, #60]	; (80097c4 <SetDeviceAddress+0x40>)
 8009788:	f893 c000 	ldrb.w	ip, [r3]

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 800978c:	2300      	movs	r3, #0
 800978e:	e012      	b.n	80097b6 <SetDeviceAddress+0x32>
 8009790:	b2da      	uxtb	r2, r3
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
 8009792:	0091      	lsls	r1, r2, #2
 8009794:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8009798:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 800979c:	680d      	ldr	r5, [r1, #0]
 800979e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80097a2:	f042 0480 	orr.w	r4, r2, #128	; 0x80
 80097a6:	f640 720f 	movw	r2, #3855	; 0xf0f
 80097aa:	ea05 0202 	and.w	r2, r5, r2
 80097ae:	ea44 0202 	orr.w	r2, r4, r2
 80097b2:	600a      	str	r2, [r1, #0]
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 80097b4:	3301      	adds	r3, #1
 80097b6:	4563      	cmp	r3, ip
 80097b8:	d3ea      	bcc.n	8009790 <SetDeviceAddress+0xc>
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
 80097ba:	4b03      	ldr	r3, [pc, #12]	; (80097c8 <SetDeviceAddress+0x44>)
 80097bc:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80097c0:	6018      	str	r0, [r3, #0]
#endif  /* STM32F10X_CL */  
}
 80097c2:	bd30      	pop	{r4, r5, pc}
 80097c4:	200030d0 	.word	0x200030d0
 80097c8:	40005c4c 	.word	0x40005c4c

080097cc <In0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t In0_Process(void)
{
 80097cc:	b510      	push	{r4, lr}
  uint32_t ControlState = pInformation->ControlState;
 80097ce:	4c16      	ldr	r4, [pc, #88]	; (8009828 <In0_Process+0x5c>)
 80097d0:	6823      	ldr	r3, [r4, #0]
 80097d2:	7a1a      	ldrb	r2, [r3, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 80097d4:	2a02      	cmp	r2, #2
 80097d6:	bf14      	ite	ne
 80097d8:	2100      	movne	r1, #0
 80097da:	2101      	moveq	r1, #1
 80097dc:	2a04      	cmp	r2, #4
 80097de:	bf08      	it	eq
 80097e0:	f041 0101 	orreq.w	r1, r1, #1
 80097e4:	b121      	cbz	r1, 80097f0 <In0_Process+0x24>
  {
    DataStageIn();
 80097e6:	f7ff fc07 	bl	8008ff8 <DataStageIn>
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
 80097ea:	6823      	ldr	r3, [r4, #0]
 80097ec:	7a1b      	ldrb	r3, [r3, #8]
 80097ee:	e014      	b.n	800981a <In0_Process+0x4e>
  }

  else if (ControlState == WAIT_STATUS_IN)
 80097f0:	2a06      	cmp	r2, #6
 80097f2:	d111      	bne.n	8009818 <In0_Process+0x4c>
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 80097f4:	785a      	ldrb	r2, [r3, #1]
 80097f6:	2a05      	cmp	r2, #5
 80097f8:	d10a      	bne.n	8009810 <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 80097fa:	781a      	ldrb	r2, [r3, #0]
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 80097fc:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 8009800:	d106      	bne.n	8009810 <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
 8009802:	78d8      	ldrb	r0, [r3, #3]
 8009804:	f7ff ffbe 	bl	8009784 <SetDeviceAddress>
      pUser_Standard_Requests->User_SetDeviceAddress();
 8009808:	4b08      	ldr	r3, [pc, #32]	; (800982c <In0_Process+0x60>)
 800980a:	681b      	ldr	r3, [r3, #0]
 800980c:	6a1b      	ldr	r3, [r3, #32]
 800980e:	4798      	blx	r3
    }
    (*pProperty->Process_Status_IN)();
 8009810:	4b07      	ldr	r3, [pc, #28]	; (8009830 <In0_Process+0x64>)
 8009812:	681b      	ldr	r3, [r3, #0]
 8009814:	689b      	ldr	r3, [r3, #8]
 8009816:	4798      	blx	r3
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
 8009818:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 800981a:	4a03      	ldr	r2, [pc, #12]	; (8009828 <In0_Process+0x5c>)
 800981c:	6812      	ldr	r2, [r2, #0]
 800981e:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 8009820:	f7ff fd8c 	bl	800933c <Post0_Process>
}
 8009824:	bd10      	pop	{r4, pc}
 8009826:	bf00      	nop
 8009828:	200030cc 	.word	0x200030cc
 800982c:	200030c8 	.word	0x200030c8
 8009830:	200030c4 	.word	0x200030c4

08009834 <NOP_Process>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
}
 8009834:	4770      	bx	lr
	...

08009838 <CTR_LP>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
 8009838:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint16_t wEPVal = 0;
 800983a:	2200      	movs	r2, #0
 800983c:	f8ad 2006 	strh.w	r2, [sp, #6]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009840:	4f54      	ldr	r7, [pc, #336]	; (8009994 <CTR_LP+0x15c>)
 8009842:	4e55      	ldr	r6, [pc, #340]	; (8009998 <CTR_LP+0x160>)
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8009844:	e09d      	b.n	8009982 <CTR_LP+0x14a>
  {
    /* extract highest priority endpoint number */
    EPindex = (uint8_t)(wIstr & ISTR_EP_ID);
    if (EPindex == 0)
 8009846:	f013 050f 	ands.w	r5, r3, #15
 800984a:	d171      	bne.n	8009930 <CTR_LP+0xf8>

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 800984c:	683a      	ldr	r2, [r7, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 800984e:	f013 0f10 	tst.w	r3, #16

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009852:	b292      	uxth	r2, r2
 8009854:	8032      	strh	r2, [r6, #0]
	    SaveTState = SaveRState & EPTX_STAT;
 8009856:	8831      	ldrh	r1, [r6, #0]
 8009858:	4a50      	ldr	r2, [pc, #320]	; (800999c <CTR_LP+0x164>)
 800985a:	f001 0130 	and.w	r1, r1, #48	; 0x30
 800985e:	8011      	strh	r1, [r2, #0]
	    SaveRState &=  EPRX_STAT;	
 8009860:	8832      	ldrh	r2, [r6, #0]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009862:	4c4c      	ldr	r4, [pc, #304]	; (8009994 <CTR_LP+0x15c>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	
 8009864:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8009868:	8032      	strh	r2, [r6, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 800986a:	6839      	ldr	r1, [r7, #0]
 800986c:	f64b 72bf 	movw	r2, #49087	; 0xbfbf
 8009870:	ea01 0202 	and.w	r2, r1, r2
 8009874:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8009878:	f082 0220 	eor.w	r2, r2, #32
 800987c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009880:	f042 0280 	orr.w	r2, r2, #128	; 0x80

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009884:	4d44      	ldr	r5, [pc, #272]	; (8009998 <CTR_LP+0x160>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8009886:	603a      	str	r2, [r7, #0]

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8009888:	d108      	bne.n	800989c <CTR_LP+0x64>

        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */


        _ClearEP_CTR_TX(ENDP0);
 800988a:	6822      	ldr	r2, [r4, #0]
 800988c:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8009890:	ea02 0303 	and.w	r3, r2, r3
 8009894:	6023      	str	r3, [r4, #0]
        In0_Process();
 8009896:	f7ff ff99 	bl	80097cc <In0_Process>
 800989a:	e01e      	b.n	80098da <CTR_LP+0xa2>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
 800989c:	683b      	ldr	r3, [r7, #0]
 800989e:	b29b      	uxth	r3, r3
 80098a0:	f8ad 3006 	strh.w	r3, [sp, #6]
        
        if ((wEPVal &EP_SETUP) != 0)
 80098a4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80098a8:	f413 6f00 	tst.w	r3, #2048	; 0x800
 80098ac:	d008      	beq.n	80098c0 <CTR_LP+0x88>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
 80098ae:	6822      	ldr	r2, [r4, #0]
 80098b0:	f640 738f 	movw	r3, #3983	; 0xf8f
 80098b4:	ea02 0303 	and.w	r3, r2, r3
 80098b8:	6023      	str	r3, [r4, #0]
          Setup0_Process();
 80098ba:	f7ff fddf 	bl	800947c <Setup0_Process>
 80098be:	e00c      	b.n	80098da <CTR_LP+0xa2>

		      _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
 80098c0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80098c4:	b21b      	sxth	r3, r3
 80098c6:	2b00      	cmp	r3, #0
 80098c8:	da5b      	bge.n	8009982 <CTR_LP+0x14a>
        {
          _ClearEP_CTR_RX(ENDP0);
 80098ca:	6822      	ldr	r2, [r4, #0]
 80098cc:	f640 738f 	movw	r3, #3983	; 0xf8f
 80098d0:	ea02 0303 	and.w	r3, r2, r3
 80098d4:	6023      	str	r3, [r4, #0]
          Out0_Process();
 80098d6:	f7ff fd53 	bl	8009380 <Out0_Process>
          /* before terminate set Tx & Rx status */
     
		     _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
 80098da:	6822      	ldr	r2, [r4, #0]
 80098dc:	f64b 73bf 	movw	r3, #49087	; 0xbfbf
 80098e0:	ea02 0303 	and.w	r3, r2, r3
 80098e4:	882a      	ldrh	r2, [r5, #0]
 80098e6:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 80098ea:	b292      	uxth	r2, r2
 80098ec:	b10a      	cbz	r2, 80098f2 <CTR_LP+0xba>
 80098ee:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80098f2:	4a29      	ldr	r2, [pc, #164]	; (8009998 <CTR_LP+0x160>)
 80098f4:	8812      	ldrh	r2, [r2, #0]
 80098f6:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 80098fa:	b292      	uxth	r2, r2
 80098fc:	b10a      	cbz	r2, 8009902 <CTR_LP+0xca>
 80098fe:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8009902:	4a26      	ldr	r2, [pc, #152]	; (800999c <CTR_LP+0x164>)
 8009904:	8812      	ldrh	r2, [r2, #0]
 8009906:	f002 0210 	and.w	r2, r2, #16
 800990a:	b292      	uxth	r2, r2
 800990c:	b10a      	cbz	r2, 8009912 <CTR_LP+0xda>
 800990e:	f083 0310 	eor.w	r3, r3, #16
 8009912:	4a22      	ldr	r2, [pc, #136]	; (800999c <CTR_LP+0x164>)
 8009914:	8812      	ldrh	r2, [r2, #0]
 8009916:	f002 0220 	and.w	r2, r2, #32
 800991a:	b292      	uxth	r2, r2
 800991c:	b10a      	cbz	r2, 8009922 <CTR_LP+0xea>
 800991e:	f083 0320 	eor.w	r3, r3, #32
 8009922:	4a1f      	ldr	r2, [pc, #124]	; (80099a0 <CTR_LP+0x168>)
 8009924:	ea43 0202 	orr.w	r2, r3, r2
 8009928:	4b1a      	ldr	r3, [pc, #104]	; (8009994 <CTR_LP+0x15c>)
 800992a:	b292      	uxth	r2, r2
 800992c:	601a      	str	r2, [r3, #0]
          return;
 800992e:	e02f      	b.n	8009990 <CTR_LP+0x158>
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
 8009930:	00ac      	lsls	r4, r5, #2
 8009932:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8009936:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 800993a:	6823      	ldr	r3, [r4, #0]
 800993c:	b29b      	uxth	r3, r3
 800993e:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & EP_CTR_RX) != 0)
 8009942:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009946:	b21b      	sxth	r3, r3
 8009948:	2b00      	cmp	r3, #0
 800994a:	da0a      	bge.n	8009962 <CTR_LP+0x12a>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 800994c:	6822      	ldr	r2, [r4, #0]
 800994e:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009952:	ea02 0303 	and.w	r3, r2, r3

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 8009956:	4a13      	ldr	r2, [pc, #76]	; (80099a4 <CTR_LP+0x16c>)
      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
      if ((wEPVal & EP_CTR_RX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 8009958:	6023      	str	r3, [r4, #0]

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 800995a:	1e6b      	subs	r3, r5, #1
 800995c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009960:	4798      	blx	r3

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
 8009962:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009966:	f013 0f80 	tst.w	r3, #128	; 0x80
 800996a:	d00a      	beq.n	8009982 <CTR_LP+0x14a>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 800996c:	6822      	ldr	r2, [r4, #0]
 800996e:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8009972:	ea02 0303 	and.w	r3, r2, r3

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 8009976:	4a0c      	ldr	r2, [pc, #48]	; (80099a8 <CTR_LP+0x170>)
 8009978:	3d01      	subs	r5, #1
      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 800997a:	6023      	str	r3, [r4, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 800997c:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
 8009980:	4798      	blx	r3
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8009982:	4a0a      	ldr	r2, [pc, #40]	; (80099ac <CTR_LP+0x174>)
 8009984:	6813      	ldr	r3, [r2, #0]
 8009986:	b29b      	uxth	r3, r3
 8009988:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800998c:	f47f af5b 	bne.w	8009846 <CTR_LP+0xe>
      } /* if((wEPVal & EP_CTR_TX) != 0) */

    }/* if(EPindex == 0) else */

  }/* while(...) */
}
 8009990:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009992:	bf00      	nop
 8009994:	40005c00 	.word	0x40005c00
 8009998:	200030da 	.word	0x200030da
 800999c:	200030dc 	.word	0x200030dc
 80099a0:	ffff8080 	.word	0xffff8080
 80099a4:	20000028 	.word	0x20000028
 80099a8:	2000000c 	.word	0x2000000c
 80099ac:	40005c44 	.word	0x40005c44

080099b0 <UserToPMABufferCopy>:
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 80099b0:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
 80099b4:	3201      	adds	r2, #1
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 80099b6:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 80099ba:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 80099bc:	0852      	lsrs	r2, r2, #1
 80099be:	e008      	b.n	80099d2 <UserToPMABufferCopy+0x22>
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 80099c0:	f810 cc01 	ldrb.w	ip, [r0, #-1]
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (uint16_t) * pbUsrBuf;
 80099c4:	f810 3c02 	ldrb.w	r3, [r0, #-2]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 80099c8:	3a01      	subs	r2, #1
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 80099ca:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
    *pdwVal++ = temp2;
 80099ce:	f821 3c04 	strh.w	r3, [r1, #-4]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 80099d2:	3002      	adds	r0, #2
 80099d4:	3104      	adds	r1, #4
 80099d6:	2a00      	cmp	r2, #0
 80099d8:	d1f2      	bne.n	80099c0 <UserToPMABufferCopy+0x10>
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
    pdwVal++;
    pbUsrBuf++;
  }
}
 80099da:	4770      	bx	lr

080099dc <PMAToUserBufferCopy>:
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 80099dc:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
 80099e0:	3201      	adds	r2, #1
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 80099e2:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 80099e6:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 80099e8:	0852      	lsrs	r2, r2, #1
 80099ea:	e004      	b.n	80099f6 <PMAToUserBufferCopy+0x1a>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 80099ec:	f851 3b04 	ldr.w	r3, [r1], #4
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 80099f0:	3a01      	subs	r2, #1
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 80099f2:	f820 3b02 	strh.w	r3, [r0], #2
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 80099f6:	2a00      	cmp	r2, #0
 80099f8:	d1f8      	bne.n	80099ec <PMAToUserBufferCopy+0x10>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
    pbUsrBuf++;
  }
}
 80099fa:	4770      	bx	lr

080099fc <SetBTABLE>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetBTABLE(uint16_t wRegValue)
{
  _SetBTABLE(wRegValue);
 80099fc:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 8009a00:	4a02      	ldr	r2, [pc, #8]	; (8009a0c <SetBTABLE+0x10>)
 8009a02:	ea00 0303 	and.w	r3, r0, r3
 8009a06:	6013      	str	r3, [r2, #0]
}
 8009a08:	4770      	bx	lr
 8009a0a:	bf00      	nop
 8009a0c:	40005c50 	.word	0x40005c50

08009a10 <SetEPType>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPType(uint8_t bEpNum, uint16_t wType)
{
  _SetEPType(bEpNum, wType);
 8009a10:	0080      	lsls	r0, r0, #2
 8009a12:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009a16:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009a1a:	6803      	ldr	r3, [r0, #0]
 8009a1c:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8009a20:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009a24:	ea43 0101 	orr.w	r1, r3, r1
 8009a28:	b289      	uxth	r1, r1
 8009a2a:	6001      	str	r1, [r0, #0]
}
 8009a2c:	4770      	bx	lr

08009a2e <GetEPType>:
* Output         : None.
* Return         : Endpoint Type
*******************************************************************************/
uint16_t GetEPType(uint8_t bEpNum)
{
  return(_GetEPType(bEpNum));
 8009a2e:	0080      	lsls	r0, r0, #2
 8009a30:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009a34:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009a38:	6800      	ldr	r0, [r0, #0]
 8009a3a:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
}
 8009a3e:	4770      	bx	lr

08009a40 <SetEPTxStatus>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(uint8_t bEpNum, uint16_t wState)
{
  _SetEPTxStatus(bEpNum, wState);
 8009a40:	0080      	lsls	r0, r0, #2
 8009a42:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009a46:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009a4a:	6802      	ldr	r2, [r0, #0]
 8009a4c:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 8009a50:	ea02 0303 	and.w	r3, r2, r3
 8009a54:	f001 0210 	and.w	r2, r1, #16
 8009a58:	b292      	uxth	r2, r2
 8009a5a:	b10a      	cbz	r2, 8009a60 <SetEPTxStatus+0x20>
 8009a5c:	f083 0310 	eor.w	r3, r3, #16
 8009a60:	f001 0120 	and.w	r1, r1, #32
 8009a64:	b289      	uxth	r1, r1
 8009a66:	b109      	cbz	r1, 8009a6c <SetEPTxStatus+0x2c>
 8009a68:	f083 0320 	eor.w	r3, r3, #32
 8009a6c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009a70:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009a74:	6003      	str	r3, [r0, #0]
}
 8009a76:	4770      	bx	lr

08009a78 <SetEPTxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxValid(uint8_t bEpNum)
{
  _SetEPTxStatus(bEpNum, EP_TX_VALID);
 8009a78:	0080      	lsls	r0, r0, #2
 8009a7a:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009a7e:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009a82:	6802      	ldr	r2, [r0, #0]
 8009a84:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 8009a88:	ea02 0303 	and.w	r3, r2, r3
 8009a8c:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8009a90:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009a94:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009a98:	6003      	str	r3, [r0, #0]
}
 8009a9a:	4770      	bx	lr

08009a9c <SetEPRxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(uint8_t bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
 8009a9c:	0080      	lsls	r0, r0, #2
 8009a9e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009aa2:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009aa6:	6802      	ldr	r2, [r0, #0]
 8009aa8:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 8009aac:	ea02 0303 	and.w	r3, r2, r3
 8009ab0:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8009ab4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009ab8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009abc:	6003      	str	r3, [r0, #0]
}
 8009abe:	4770      	bx	lr

08009ac0 <Clear_Status_Out>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(uint8_t bEpNum)
{
  _ClearEP_KIND(bEpNum);
 8009ac0:	0080      	lsls	r0, r0, #2
 8009ac2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009ac6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009aca:	6802      	ldr	r2, [r0, #0]
 8009acc:	f640 630f 	movw	r3, #3599	; 0xe0f
 8009ad0:	ea02 0303 	and.w	r3, r2, r3
 8009ad4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009ad8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009adc:	6003      	str	r3, [r0, #0]
}
 8009ade:	4770      	bx	lr

08009ae0 <ClearDTOG_RX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(uint8_t bEpNum)
{
  _ClearDTOG_RX(bEpNum);
 8009ae0:	0080      	lsls	r0, r0, #2
 8009ae2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009ae6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009aea:	6803      	ldr	r3, [r0, #0]
 8009aec:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8009af0:	d009      	beq.n	8009b06 <ClearDTOG_RX+0x26>
 8009af2:	6802      	ldr	r2, [r0, #0]
 8009af4:	f640 730f 	movw	r3, #3855	; 0xf0f
 8009af8:	ea02 0303 	and.w	r3, r2, r3
 8009afc:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8009b00:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009b04:	6003      	str	r3, [r0, #0]
}
 8009b06:	4770      	bx	lr

08009b08 <ClearDTOG_TX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(uint8_t bEpNum)
{
  _ClearDTOG_TX(bEpNum);
 8009b08:	0080      	lsls	r0, r0, #2
 8009b0a:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009b0e:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009b12:	6803      	ldr	r3, [r0, #0]
 8009b14:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009b18:	d009      	beq.n	8009b2e <ClearDTOG_TX+0x26>
 8009b1a:	6802      	ldr	r2, [r0, #0]
 8009b1c:	f640 730f 	movw	r3, #3855	; 0xf0f
 8009b20:	ea02 0303 	and.w	r3, r2, r3
 8009b24:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009b28:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8009b2c:	6003      	str	r3, [r0, #0]
}
 8009b2e:	4770      	bx	lr

08009b30 <SetEPTxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPTxAddr(bEpNum, wAddr);
 8009b30:	4b06      	ldr	r3, [pc, #24]	; (8009b4c <SetEPTxAddr+0x1c>)
 8009b32:	0849      	lsrs	r1, r1, #1
 8009b34:	681b      	ldr	r3, [r3, #0]
 8009b36:	0049      	lsls	r1, r1, #1
 8009b38:	b29b      	uxth	r3, r3
 8009b3a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8009b3e:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
 8009b42:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
 8009b46:	0040      	lsls	r0, r0, #1
 8009b48:	6001      	str	r1, [r0, #0]
}
 8009b4a:	4770      	bx	lr
 8009b4c:	40005c50 	.word	0x40005c50

08009b50 <SetEPRxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPRxAddr(bEpNum, wAddr);
 8009b50:	4b05      	ldr	r3, [pc, #20]	; (8009b68 <SetEPRxAddr+0x18>)
 8009b52:	0849      	lsrs	r1, r1, #1
 8009b54:	681b      	ldr	r3, [r3, #0]
 8009b56:	0049      	lsls	r1, r1, #1
 8009b58:	b29b      	uxth	r3, r3
 8009b5a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8009b5e:	4b03      	ldr	r3, [pc, #12]	; (8009b6c <SetEPRxAddr+0x1c>)
 8009b60:	18c3      	adds	r3, r0, r3
 8009b62:	005b      	lsls	r3, r3, #1
 8009b64:	6019      	str	r1, [r3, #0]
}
 8009b66:	4770      	bx	lr
 8009b68:	40005c50 	.word	0x40005c50
 8009b6c:	20003004 	.word	0x20003004

08009b70 <GetEPTxAddr>:
* Output         : None.
* Return         : Rx buffer address. 
*******************************************************************************/
uint16_t GetEPTxAddr(uint8_t bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
 8009b70:	4b05      	ldr	r3, [pc, #20]	; (8009b88 <GetEPTxAddr+0x18>)
 8009b72:	681b      	ldr	r3, [r3, #0]
 8009b74:	b29b      	uxth	r3, r3
 8009b76:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 8009b7a:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8009b7e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8009b82:	005b      	lsls	r3, r3, #1
 8009b84:	8818      	ldrh	r0, [r3, #0]
}
 8009b86:	4770      	bx	lr
 8009b88:	40005c50 	.word	0x40005c50

08009b8c <GetEPRxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
uint16_t GetEPRxAddr(uint8_t bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
 8009b8c:	4b04      	ldr	r3, [pc, #16]	; (8009ba0 <GetEPRxAddr+0x14>)
 8009b8e:	681b      	ldr	r3, [r3, #0]
 8009b90:	b29b      	uxth	r3, r3
 8009b92:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8009b96:	4b03      	ldr	r3, [pc, #12]	; (8009ba4 <GetEPRxAddr+0x18>)
 8009b98:	18c3      	adds	r3, r0, r3
 8009b9a:	005b      	lsls	r3, r3, #1
 8009b9c:	8818      	ldrh	r0, [r3, #0]
}
 8009b9e:	4770      	bx	lr
 8009ba0:	40005c50 	.word	0x40005c50
 8009ba4:	20003004 	.word	0x20003004

08009ba8 <SetEPTxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPTxCount(bEpNum, wCount);
 8009ba8:	4b04      	ldr	r3, [pc, #16]	; (8009bbc <SetEPTxCount+0x14>)
 8009baa:	681b      	ldr	r3, [r3, #0]
 8009bac:	b29b      	uxth	r3, r3
 8009bae:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8009bb2:	4b03      	ldr	r3, [pc, #12]	; (8009bc0 <SetEPTxCount+0x18>)
 8009bb4:	18c3      	adds	r3, r0, r3
 8009bb6:	005b      	lsls	r3, r3, #1
 8009bb8:	6019      	str	r1, [r3, #0]
}
 8009bba:	4770      	bx	lr
 8009bbc:	40005c50 	.word	0x40005c50
 8009bc0:	20003002 	.word	0x20003002

08009bc4 <SetEPRxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPRxCount(bEpNum, wCount);
 8009bc4:	4b0d      	ldr	r3, [pc, #52]	; (8009bfc <SetEPRxCount+0x38>)
 8009bc6:	681a      	ldr	r2, [r3, #0]
 8009bc8:	4b0d      	ldr	r3, [pc, #52]	; (8009c00 <SetEPRxCount+0x3c>)
 8009bca:	b292      	uxth	r2, r2
 8009bcc:	18d3      	adds	r3, r2, r3
 8009bce:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8009bd2:	0040      	lsls	r0, r0, #1
 8009bd4:	293e      	cmp	r1, #62	; 0x3e
 8009bd6:	d909      	bls.n	8009bec <SetEPRxCount+0x28>
 8009bd8:	094b      	lsrs	r3, r1, #5
 8009bda:	f011 0f1f 	tst.w	r1, #31
 8009bde:	d101      	bne.n	8009be4 <SetEPRxCount+0x20>
 8009be0:	3b01      	subs	r3, #1
 8009be2:	b29b      	uxth	r3, r3
 8009be4:	029b      	lsls	r3, r3, #10
 8009be6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009bea:	e005      	b.n	8009bf8 <SetEPRxCount+0x34>
 8009bec:	084b      	lsrs	r3, r1, #1
 8009bee:	f011 0f01 	tst.w	r1, #1
 8009bf2:	bf18      	it	ne
 8009bf4:	3301      	addne	r3, #1
 8009bf6:	029b      	lsls	r3, r3, #10
 8009bf8:	6003      	str	r3, [r0, #0]
}
 8009bfa:	4770      	bx	lr
 8009bfc:	40005c50 	.word	0x40005c50
 8009c00:	20003006 	.word	0x20003006

08009c04 <GetEPRxCount>:
* Output         : None.
* Return         : Rx count value.
*******************************************************************************/
uint16_t GetEPRxCount(uint8_t bEpNum)
{
  return(_GetEPRxCount(bEpNum));
 8009c04:	4b05      	ldr	r3, [pc, #20]	; (8009c1c <GetEPRxCount+0x18>)
 8009c06:	681b      	ldr	r3, [r3, #0]
 8009c08:	b29b      	uxth	r3, r3
 8009c0a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8009c0e:	4b04      	ldr	r3, [pc, #16]	; (8009c20 <GetEPRxCount+0x1c>)
 8009c10:	18c3      	adds	r3, r0, r3
 8009c12:	005b      	lsls	r3, r3, #1
 8009c14:	6818      	ldr	r0, [r3, #0]
 8009c16:	0580      	lsls	r0, r0, #22
 8009c18:	0d80      	lsrs	r0, r0, #22
}
 8009c1a:	4770      	bx	lr
 8009c1c:	40005c50 	.word	0x40005c50
 8009c20:	20003006 	.word	0x20003006

08009c24 <ByteSwap>:
uint16_t ByteSwap(uint16_t wSwW)
{
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
 8009c24:	b2c3      	uxtb	r3, r0
 8009c26:	0a00      	lsrs	r0, r0, #8
* Input          : wSwW: word to Swap.
* Output         : None.
* Return         : resulted word.
*******************************************************************************/
uint16_t ByteSwap(uint16_t wSwW)
{
 8009c28:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
  return(wRet);
}
 8009c2c:	4770      	bx	lr
	...

08009c30 <APP_LCD_Data>:
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 8009c30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 8009c32:	4c16      	ldr	r4, [pc, #88]	; (8009c8c <APP_LCD_Data+0x5c>)
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 8009c34:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 8009c36:	7820      	ldrb	r0, [r4, #0]
 8009c38:	2501      	movs	r5, #1
 8009c3a:	fa15 f200 	lsls.w	r2, r5, r0
 8009c3e:	4e14      	ldr	r6, [pc, #80]	; (8009c90 <APP_LCD_Data+0x60>)
 8009c40:	6833      	ldr	r3, [r6, #0]
 8009c42:	421a      	tst	r2, r3
    return -1;
 8009c44:	bf08      	it	eq
 8009c46:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 8009c4a:	d01d      	beq.n	8009c88 <APP_LCD_Data+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 8009c4c:	f640 11c4 	movw	r1, #2500	; 0x9c4
 8009c50:	f7fd fbe2 	bl	8007418 <MIOS32_BOARD_J15_PollUnbusy>
 8009c54:	2800      	cmp	r0, #0
 8009c56:	da08      	bge.n	8009c6a <APP_LCD_Data+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 8009c58:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 8009c5a:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 8009c5e:	409d      	lsls	r5, r3
 8009c60:	6833      	ldr	r3, [r6, #0]
 8009c62:	ea23 0505 	bic.w	r5, r3, r5
 8009c66:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 8009c68:	e00e      	b.n	8009c88 <APP_LCD_Data+0x58>
  }

  // write data
  MIOS32_BOARD_J15_DataSet(data);
 8009c6a:	4638      	mov	r0, r7
 8009c6c:	f7fd fb42 	bl	80072f4 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(1);
 8009c70:	4628      	mov	r0, r5
 8009c72:	f7fd fb9f 	bl	80073b4 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 8009c76:	4629      	mov	r1, r5
 8009c78:	7820      	ldrb	r0, [r4, #0]
 8009c7a:	f7fd fbb3 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 8009c7e:	7820      	ldrb	r0, [r4, #0]
 8009c80:	2100      	movs	r1, #0
 8009c82:	f7fd fbaf 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 8009c86:	2000      	movs	r0, #0
}
 8009c88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009c8a:	bf00      	nop
 8009c8c:	2000015f 	.word	0x2000015f
 8009c90:	2000055c 	.word	0x2000055c

08009c94 <APP_LCD_Cmd>:
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 8009c94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 8009c96:	4c16      	ldr	r4, [pc, #88]	; (8009cf0 <APP_LCD_Cmd+0x5c>)
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 8009c98:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 8009c9a:	7820      	ldrb	r0, [r4, #0]
 8009c9c:	2501      	movs	r5, #1
 8009c9e:	fa15 f200 	lsls.w	r2, r5, r0
 8009ca2:	4e14      	ldr	r6, [pc, #80]	; (8009cf4 <APP_LCD_Cmd+0x60>)
 8009ca4:	6833      	ldr	r3, [r6, #0]
 8009ca6:	421a      	tst	r2, r3
    return -1;
 8009ca8:	bf08      	it	eq
 8009caa:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 8009cae:	d01d      	beq.n	8009cec <APP_LCD_Cmd+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 8009cb0:	f640 11c4 	movw	r1, #2500	; 0x9c4
 8009cb4:	f7fd fbb0 	bl	8007418 <MIOS32_BOARD_J15_PollUnbusy>
 8009cb8:	2800      	cmp	r0, #0
 8009cba:	da08      	bge.n	8009cce <APP_LCD_Cmd+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 8009cbc:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 8009cbe:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 8009cc2:	409d      	lsls	r5, r3
 8009cc4:	6833      	ldr	r3, [r6, #0]
 8009cc6:	ea23 0505 	bic.w	r5, r3, r5
 8009cca:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 8009ccc:	e00e      	b.n	8009cec <APP_LCD_Cmd+0x58>
  }

  // write command
  MIOS32_BOARD_J15_DataSet(cmd);
 8009cce:	4638      	mov	r0, r7
 8009cd0:	f7fd fb10 	bl	80072f4 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 8009cd4:	2000      	movs	r0, #0
 8009cd6:	f7fd fb6d 	bl	80073b4 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 8009cda:	4629      	mov	r1, r5
 8009cdc:	7820      	ldrb	r0, [r4, #0]
 8009cde:	f7fd fb81 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 8009ce2:	7820      	ldrb	r0, [r4, #0]
 8009ce4:	2100      	movs	r1, #0
 8009ce6:	f7fd fb7d 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 8009cea:	2000      	movs	r0, #0
}
 8009cec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009cee:	bf00      	nop
 8009cf0:	2000015f 	.word	0x2000015f
 8009cf4:	2000055c 	.word	0x2000055c

08009cf8 <APP_LCD_Init>:
// Initializes application specific LCD driver
// IN: <mode>: optional configuration
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
 8009cf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009cfa:	4606      	mov	r6, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8009cfc:	f04f 30ff 	mov.w	r0, #4294967295
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8009d00:	2e00      	cmp	r6, #0
 8009d02:	d15b      	bne.n	8009dbc <APP_LCD_Init+0xc4>
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 8009d04:	2001      	movs	r0, #1
 8009d06:	f7fd fa91 	bl	800722c <MIOS32_BOARD_J15_PortInit>
 8009d0a:	2800      	cmp	r0, #0
    return -2; // failed to initialize J15
 8009d0c:	bfb8      	it	lt
 8009d0e:	f06f 0001 	mvnlt.w	r0, #1
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 8009d12:	db53      	blt.n	8009dbc <APP_LCD_Init+0xc4>
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 8009d14:	4c2a      	ldr	r4, [pc, #168]	; (8009dc0 <APP_LCD_Init+0xc8>)
 8009d16:	2501      	movs	r5, #1
 8009d18:	7823      	ldrb	r3, [r4, #0]
 8009d1a:	4f2a      	ldr	r7, [pc, #168]	; (8009dc4 <APP_LCD_Init+0xcc>)
 8009d1c:	fa15 f303 	lsls.w	r3, r5, r3
 8009d20:	683a      	ldr	r2, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 8009d22:	2038      	movs	r0, #56	; 0x38

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 8009d24:	4313      	orrs	r3, r2
 8009d26:	603b      	str	r3, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 8009d28:	f7fd fae4 	bl	80072f4 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 8009d2c:	4630      	mov	r0, r6
 8009d2e:	f7fd fb41 	bl	80073b4 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 8009d32:	4629      	mov	r1, r5
 8009d34:	7820      	ldrb	r0, [r4, #0]
 8009d36:	f7fd fb55 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 8009d3a:	4631      	mov	r1, r6
 8009d3c:	7820      	ldrb	r0, [r4, #0]
 8009d3e:	f7fd fb51 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_RW_Set(0);
 8009d42:	4630      	mov	r0, r6
 8009d44:	f7fd fb42 	bl	80073cc <MIOS32_BOARD_J15_RW_Set>
#ifdef MIOS32_DONT_USE_DELAY
  u32 delay;
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 8009d48:	f24c 3050 	movw	r0, #50000	; 0xc350
 8009d4c:	f7fd fbf6 	bl	800753c <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 8009d50:	4629      	mov	r1, r5
 8009d52:	7820      	ldrb	r0, [r4, #0]
 8009d54:	f7fd fb46 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 8009d58:	4631      	mov	r1, r6
 8009d5a:	7820      	ldrb	r0, [r4, #0]
 8009d5c:	f7fd fb42 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 8009d60:	f24c 3050 	movw	r0, #50000	; 0xc350
 8009d64:	f7fd fbea 	bl	800753c <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 8009d68:	4629      	mov	r1, r5
 8009d6a:	7820      	ldrb	r0, [r4, #0]
 8009d6c:	f7fd fb3a 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 8009d70:	4631      	mov	r1, r6
 8009d72:	7820      	ldrb	r0, [r4, #0]
 8009d74:	f7fd fb36 	bl	80073e4 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 8009d78:	f24c 3050 	movw	r0, #50000	; 0xc350
 8009d7c:	f7fd fbde 	bl	800753c <MIOS32_DELAY_Wait_uS>
#endif

  APP_LCD_Cmd(0x08); // Display Off
 8009d80:	2008      	movs	r0, #8
 8009d82:	f7ff ff87 	bl	8009c94 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // Display On
 8009d86:	200c      	movs	r0, #12
 8009d88:	f7ff ff84 	bl	8009c94 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x06); // Entry Mode
 8009d8c:	2006      	movs	r0, #6
 8009d8e:	f7ff ff81 	bl	8009c94 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x01); // Clear Display
 8009d92:	4628      	mov	r0, r5
 8009d94:	f7ff ff7e 	bl	8009c94 <APP_LCD_Cmd>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 8009d98:	f24c 3050 	movw	r0, #50000	; 0xc350
 8009d9c:	f7fd fbce 	bl	800753c <MIOS32_DELAY_Wait_uS>
  // modify cursor mapping, so that it complies with 3-line dog displays
  u8 cursor_map[] = {0x00, 0x10, 0x20, 0x30}; // offset line 0/1/2/3
  MIOS32_LCD_CursorMapSet(cursor_map);
#endif

  APP_LCD_Cmd(0x38); // experience from PIC based MIOS: without these lines
 8009da0:	2038      	movs	r0, #56	; 0x38
 8009da2:	f7ff ff77 	bl	8009c94 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // the LCD won't work correctly after a second APP_LCD_Init
 8009da6:	200c      	movs	r0, #12
 8009da8:	f7ff ff74 	bl	8009c94 <APP_LCD_Cmd>

  return (display_available & (1 << mios32_lcd_device)) ? 0 : -1; // return -1 if display not available
 8009dac:	7823      	ldrb	r3, [r4, #0]
 8009dae:	409d      	lsls	r5, r3
 8009db0:	683b      	ldr	r3, [r7, #0]
 8009db2:	421d      	tst	r5, r3
 8009db4:	bf0c      	ite	eq
 8009db6:	f04f 30ff 	moveq.w	r0, #4294967295
 8009dba:	2000      	movne	r0, #0
}
 8009dbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009dbe:	bf00      	nop
 8009dc0:	2000015f 	.word	0x2000015f
 8009dc4:	2000055c 	.word	0x2000055c

08009dc8 <APP_LCD_Clear>:
// Clear Screen
// IN: -
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Clear(void)
{
 8009dc8:	b508      	push	{r3, lr}
  // -> send clear command
  return APP_LCD_Cmd(0x01);
 8009dca:	2001      	movs	r0, #1
 8009dcc:	f7ff ff62 	bl	8009c94 <APP_LCD_Cmd>
}
 8009dd0:	bd08      	pop	{r3, pc}
	...

08009dd4 <APP_LCD_CursorSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 8009dd4:	2903      	cmp	r1, #3
// Sets cursor to given position
// IN: <column> and <line>
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
 8009dd6:	b508      	push	{r3, lr}
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
    return -1;
 8009dd8:	bf88      	it	hi
 8009dda:	f04f 30ff 	movhi.w	r0, #4294967295
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 8009dde:	d807      	bhi.n	8009df0 <APP_LCD_CursorSet+0x1c>
    return -1;

  // -> set cursor address
  return APP_LCD_Cmd(0x80 | (mios32_lcd_cursor_map[line] + column));
 8009de0:	4b04      	ldr	r3, [pc, #16]	; (8009df4 <APP_LCD_CursorSet+0x20>)
 8009de2:	5c5b      	ldrb	r3, [r3, r1]
 8009de4:	1818      	adds	r0, r3, r0
 8009de6:	f060 007f 	orn	r0, r0, #127	; 0x7f
 8009dea:	b2c0      	uxtb	r0, r0
 8009dec:	f7ff ff52 	bl	8009c94 <APP_LCD_Cmd>
}
 8009df0:	bd08      	pop	{r3, pc}
 8009df2:	bf00      	nop
 8009df4:	200030b8 	.word	0x200030b8

08009df8 <APP_LCD_GCursorSet>:
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_GCursorSet(u16 x, u16 y)
{
  // n.a.
  return -1;
}
 8009df8:	f04f 30ff 	mov.w	r0, #4294967295
 8009dfc:	4770      	bx	lr

08009dfe <APP_LCD_BColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BColourSet(u32 rgb)
{
  return -1; // n.a.
}
 8009dfe:	f04f 30ff 	mov.w	r0, #4294967295
 8009e02:	4770      	bx	lr

08009e04 <APP_LCD_FColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_FColourSet(u32 rgb)
{
  return -1; // n.a.
}
 8009e04:	f04f 30ff 	mov.w	r0, #4294967295
 8009e08:	4770      	bx	lr

08009e0a <APP_LCD_BitmapPrint>:
// Transfers a Bitmap within given boundaries to the LCD
// IN: bitmap
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BitmapPrint(mios32_lcd_bitmap_t bitmap)
{
 8009e0a:	b084      	sub	sp, #16
 8009e0c:	ab01      	add	r3, sp, #4
 8009e0e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  return -1; // n.a.
}
 8009e12:	f04f 30ff 	mov.w	r0, #4294967295
 8009e16:	b004      	add	sp, #16
 8009e18:	4770      	bx	lr
	...

08009e1c <__libc_init_array>:
 8009e1c:	b570      	push	{r4, r5, r6, lr}
 8009e1e:	4d0d      	ldr	r5, [pc, #52]	; (8009e54 <__libc_init_array+0x38>)
 8009e20:	4e0d      	ldr	r6, [pc, #52]	; (8009e58 <__libc_init_array+0x3c>)
 8009e22:	2400      	movs	r4, #0
 8009e24:	1b76      	subs	r6, r6, r5
 8009e26:	10b6      	asrs	r6, r6, #2
 8009e28:	e003      	b.n	8009e32 <__libc_init_array+0x16>
 8009e2a:	f855 3b04 	ldr.w	r3, [r5], #4
 8009e2e:	4798      	blx	r3
 8009e30:	3401      	adds	r4, #1
 8009e32:	42b4      	cmp	r4, r6
 8009e34:	d3f9      	bcc.n	8009e2a <__libc_init_array+0xe>
 8009e36:	4d09      	ldr	r5, [pc, #36]	; (8009e5c <__libc_init_array+0x40>)
 8009e38:	4e09      	ldr	r6, [pc, #36]	; (8009e60 <__libc_init_array+0x44>)
 8009e3a:	f7fb f825 	bl	8004e88 <_init>
 8009e3e:	1b76      	subs	r6, r6, r5
 8009e40:	10b6      	asrs	r6, r6, #2
 8009e42:	2400      	movs	r4, #0
 8009e44:	e003      	b.n	8009e4e <__libc_init_array+0x32>
 8009e46:	f855 3b04 	ldr.w	r3, [r5], #4
 8009e4a:	4798      	blx	r3
 8009e4c:	3401      	adds	r4, #1
 8009e4e:	42b4      	cmp	r4, r6
 8009e50:	d3f9      	bcc.n	8009e46 <__libc_init_array+0x2a>
 8009e52:	bd70      	pop	{r4, r5, r6, pc}
 8009e54:	0800a3a8 	.word	0x0800a3a8
 8009e58:	0800a3a8 	.word	0x0800a3a8
 8009e5c:	0800a3a8 	.word	0x0800a3a8
 8009e60:	0800a3a8 	.word	0x0800a3a8

08009e64 <memcpy>:
 8009e64:	2300      	movs	r3, #0
 8009e66:	e005      	b.n	8009e74 <memcpy+0x10>
 8009e68:	f811 c003 	ldrb.w	ip, [r1, r3]
 8009e6c:	3a01      	subs	r2, #1
 8009e6e:	f800 c003 	strb.w	ip, [r0, r3]
 8009e72:	3301      	adds	r3, #1
 8009e74:	2a00      	cmp	r2, #0
 8009e76:	d1f7      	bne.n	8009e68 <memcpy+0x4>
 8009e78:	4770      	bx	lr

08009e7a <memset>:
 8009e7a:	4603      	mov	r3, r0
 8009e7c:	e002      	b.n	8009e84 <memset+0xa>
 8009e7e:	f803 1b01 	strb.w	r1, [r3], #1
 8009e82:	3a01      	subs	r2, #1
 8009e84:	2a00      	cmp	r2, #0
 8009e86:	d1fa      	bne.n	8009e7e <memset+0x4>
 8009e88:	4770      	bx	lr

08009e8a <strcpy>:
 8009e8a:	2300      	movs	r3, #0
 8009e8c:	5cca      	ldrb	r2, [r1, r3]
 8009e8e:	54c2      	strb	r2, [r0, r3]
 8009e90:	3301      	adds	r3, #1
 8009e92:	2a00      	cmp	r2, #0
 8009e94:	d1fa      	bne.n	8009e8c <strcpy+0x2>
 8009e96:	4770      	bx	lr

08009e98 <strlen>:
 8009e98:	4603      	mov	r3, r0
 8009e9a:	461a      	mov	r2, r3
 8009e9c:	f813 1b01 	ldrb.w	r1, [r3], #1
 8009ea0:	2900      	cmp	r1, #0
 8009ea2:	d1fa      	bne.n	8009e9a <strlen+0x2>
 8009ea4:	1a10      	subs	r0, r2, r0
 8009ea6:	4770      	bx	lr

08009ea8 <strncpy>:
 8009ea8:	b510      	push	{r4, lr}
 8009eaa:	4684      	mov	ip, r0
 8009eac:	e007      	b.n	8009ebe <strncpy+0x16>
 8009eae:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009eb2:	4663      	mov	r3, ip
 8009eb4:	f803 4b01 	strb.w	r4, [r3], #1
 8009eb8:	3a01      	subs	r2, #1
 8009eba:	469c      	mov	ip, r3
 8009ebc:	b12c      	cbz	r4, 8009eca <strncpy+0x22>
 8009ebe:	2a00      	cmp	r2, #0
 8009ec0:	d1f5      	bne.n	8009eae <strncpy+0x6>
 8009ec2:	e004      	b.n	8009ece <strncpy+0x26>
 8009ec4:	f803 4b01 	strb.w	r4, [r3], #1
 8009ec8:	3a01      	subs	r2, #1
 8009eca:	2a00      	cmp	r2, #0
 8009ecc:	d1fa      	bne.n	8009ec4 <strncpy+0x1c>
 8009ece:	bd10      	pop	{r4, pc}
