
project_build/project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .mios32_bsl   00004000  08000000  08000000  00008000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .isr_vector   000001e4  08004000  08004000  0000c000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00006368  080041e4  080041e4  0000c1e4  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000c64  0800a54c  0800a54c  0001254c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00000058  20000000  0800b1b0  00018000  2**3  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00003758  20000058  0800b208  00018058  2**3  ALLOC
  6 ._usrstack    00000100  200037b0  200037b0  00018058  2**0  CONTENTS
  7 .ARM.attributes 00000031  00000000  00000000  00018158  2**0  CONTENTS, READONLY
  8 .comment      00000011  00000000  00000000  00018189  2**0  CONTENTS, READONLY
  9 .debug_aranges 000021c8  00000000  00000000  000181a0  2**3  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00005786  00000000  00000000  0001a368  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0001b8dd  00000000  00000000  0001faee  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00006515  00000000  00000000  0003b3cb  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000c94e  00000000  00000000  000418e0  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00004bac  00000000  00000000  0004e230  2**2  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00009e81  00000000  00000000  00052ddc  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000fadd  00000000  00000000  0005cc5d  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubtypes 0000245f  00000000  00000000  0006c73a  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00002308  00000000  00000000  0006eb99  2**0  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080041e4 <APP_Init>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
{
 80041e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  // initialize all LEDs
  MIOS32_BOARD_LED_Init(0xffffffff);
 80041e6:	f04f 30ff 	mov.w	r0, #4294967295
 80041ea:	f002 ff71 	bl	80070d0 <MIOS32_BOARD_LED_Init>
 80041ee:	4b29      	ldr	r3, [pc, #164]	; (8004294 <APP_Init+0xb0>)


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
    din_value[row] = 0xffffffff; // default state: buttons depressed
 80041f0:	f04f 32ff 	mov.w	r2, #4294967295
};

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
 80041f4:	f103 0144 	add.w	r1, r3, #68	; 0x44


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
    din_value[row] = 0xffffffff; // default state: buttons depressed
 80041f8:	f843 2f04 	str.w	r2, [r3, #4]!
  MIOS32_BOARD_LED_Init(0xffffffff);


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
 80041fc:	428b      	cmp	r3, r1
 80041fe:	d1fb      	bne.n	80041f8 <APP_Init+0x14>
 8004200:	4b25      	ldr	r3, [pc, #148]	; (8004298 <APP_Init+0xb4>)
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
    last_timestamp[i] = 0;
 8004202:	2400      	movs	r4, #0
};

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
 8004204:	f503 62c0 	add.w	r2, r3, #1536	; 0x600
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
    last_timestamp[i] = 0;
 8004208:	f843 4f04 	str.w	r4, [r3, #4]!
    din_value[row] = 0xffffffff; // default state: buttons depressed
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
 800420c:	4293      	cmp	r3, r2
 800420e:	d1fb      	bne.n	8004208 <APP_Init+0x24>
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
 8004210:	b2e0      	uxtb	r0, r4
 8004212:	2104      	movs	r1, #4
    last_timestamp[i] = 0;
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
 8004214:	3401      	adds	r4, #1
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
 8004216:	f002 ff97 	bl	8007148 <MIOS32_BOARD_J5_PinInit>
    last_timestamp[i] = 0;
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
 800421a:	2c0c      	cmp	r4, #12
 800421c:	d1f8      	bne.n	8004210 <APP_Init+0x2c>
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
	
  //Initialize pin 7 as an output to be row 17
  MIOS32_BOARD_J5_PinInit(7, MIOS32_BOARD_PIN_MODE_OUTPUT_PP);
 800421e:	2105      	movs	r1, #5
 8004220:	2007      	movs	r0, #7
 8004222:	f002 ff91 	bl	8007148 <MIOS32_BOARD_J5_PinInit>
	
  // initialize keyboard delay values
  keyboard_delay_fastest = INITIAL_KEYBOARD_DELAY_FASTEST;
 8004226:	4b1d      	ldr	r3, [pc, #116]	; (800429c <APP_Init+0xb8>)
 8004228:	2400      	movs	r4, #0
 800422a:	601c      	str	r4, [r3, #0]
  keyboard_delay_slowest = INITIAL_KEYBOARD_DELAY_SLOWEST;
 800422c:	4b1c      	ldr	r3, [pc, #112]	; (80042a0 <APP_Init+0xbc>)
 800422e:	227f      	movs	r2, #127	; 0x7f
 8004230:	601a      	str	r2, [r3, #0]
  
  no_velocity=MIOS32_BOARD_J5_PinGet(1);
 8004232:	2001      	movs	r0, #1
 8004234:	f002 fff4 	bl	8007220 <MIOS32_BOARD_J5_PinGet>
 8004238:	4b1a      	ldr	r3, [pc, #104]	; (80042a4 <APP_Init+0xc0>)
 800423a:	4601      	mov	r1, r0
 800423c:	6018      	str	r0, [r3, #0]
  MIOS32_MIDI_SendDebugMessage("no_velocity:%02x",no_velocity);
 800423e:	481a      	ldr	r0, [pc, #104]	; (80042a8 <APP_Init+0xc4>)
 8004240:	f001 fb22 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  
  if (MIOS32_BOARD_J5_PinGet(0)){
 8004244:	4620      	mov	r0, r4
 8004246:	f002 ffeb 	bl	8007220 <MIOS32_BOARD_J5_PinGet>
 800424a:	4b18      	ldr	r3, [pc, #96]	; (80042ac <APP_Init+0xc8>)
 800424c:	b150      	cbz	r0, 8004264 <APP_Init+0x80>
	selected_midi_port=0x20;
 800424e:	2220      	movs	r2, #32
 8004250:	601a      	str	r2, [r3, #0]
	MIOS32_LCD_CursorSet(0, 0); // X, Y
 8004252:	4621      	mov	r1, r4
 8004254:	4620      	mov	r0, r4
 8004256:	f001 f8ef 	bl	8005438 <MIOS32_LCD_CursorSet>
    MIOS32_LCD_PrintFormattedString("UART");
 800425a:	4815      	ldr	r0, [pc, #84]	; (80042b0 <APP_Init+0xcc>)
 800425c:	f001 f9ae 	bl	80055bc <MIOS32_LCD_PrintFormattedString>
	MIOS32_MIDI_SendDebugMessage("UART");
 8004260:	4813      	ldr	r0, [pc, #76]	; (80042b0 <APP_Init+0xcc>)
 8004262:	e008      	b.n	8004276 <APP_Init+0x92>
	}
  else {
	selected_midi_port=0x10;
 8004264:	2210      	movs	r2, #16
 8004266:	601a      	str	r2, [r3, #0]
	MIOS32_LCD_CursorSet(0, 0); // X, Y
 8004268:	4601      	mov	r1, r0
 800426a:	f001 f8e5 	bl	8005438 <MIOS32_LCD_CursorSet>
    MIOS32_LCD_PrintFormattedString("USB");
 800426e:	4811      	ldr	r0, [pc, #68]	; (80042b4 <APP_Init+0xd0>)
 8004270:	f001 f9a4 	bl	80055bc <MIOS32_LCD_PrintFormattedString>
	MIOS32_MIDI_SendDebugMessage("USB");
 8004274:	480f      	ldr	r0, [pc, #60]	; (80042b4 <APP_Init+0xd0>)
 8004276:	f001 fb07 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
	}

  // start matrix scan task
  xTaskCreate(TASK_MatrixScan, (signed portCHAR *)"MatrixScan", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_MATRIX_SCAN, NULL);
 800427a:	2302      	movs	r3, #2
 800427c:	9300      	str	r3, [sp, #0]
 800427e:	490e      	ldr	r1, [pc, #56]	; (80042b8 <APP_Init+0xd4>)
 8004280:	2300      	movs	r3, #0
 8004282:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004286:	480d      	ldr	r0, [pc, #52]	; (80042bc <APP_Init+0xd8>)
 8004288:	9301      	str	r3, [sp, #4]
 800428a:	9302      	str	r3, [sp, #8]
 800428c:	9303      	str	r3, [sp, #12]
 800428e:	f000 fb19 	bl	80048c4 <xTaskGenericCreate>
}
 8004292:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8004294:	20000058 	.word	0x20000058
 8004298:	200000a4 	.word	0x200000a4
 800429c:	20000058 	.word	0x20000058
 80042a0:	200000a4 	.word	0x200000a4
 80042a4:	20000c2c 	.word	0x20000c2c
 80042a8:	0800aa4c 	.word	0x0800aa4c
 80042ac:	20000c28 	.word	0x20000c28
 80042b0:	0800aa5d 	.word	0x0800aa5d
 80042b4:	0800aa62 	.word	0x0800aa62
 80042b8:	0800aa66 	.word	0x0800aa66
 80042bc:	08004485 	.word	0x08004485

080042c0 <APP_Background>:

/////////////////////////////////////////////////////////////////////////////
// This task is running endless in background
/////////////////////////////////////////////////////////////////////////////
void APP_Background(void)
{
 80042c0:	b510      	push	{r4, lr}
  // endless loop
  while( 1 ) {
    // toggle the state of all LEDs (allows to measure the execution speed with a scope)
    MIOS32_BOARD_LED_Set(0xffffffff, ~MIOS32_BOARD_LED_Get());
	
	no_velocity=MIOS32_BOARD_J5_PinGet(1);
 80042c2:	4c06      	ldr	r4, [pc, #24]	; (80042dc <APP_Background+0x1c>)
    old_state[pin] = 1;

  // endless loop
  while( 1 ) {
    // toggle the state of all LEDs (allows to measure the execution speed with a scope)
    MIOS32_BOARD_LED_Set(0xffffffff, ~MIOS32_BOARD_LED_Get());
 80042c4:	f002 ff38 	bl	8007138 <MIOS32_BOARD_LED_Get>
 80042c8:	43c1      	mvns	r1, r0
 80042ca:	f04f 30ff 	mov.w	r0, #4294967295
 80042ce:	f002 ff1f 	bl	8007110 <MIOS32_BOARD_LED_Set>
	
	no_velocity=MIOS32_BOARD_J5_PinGet(1);
 80042d2:	2001      	movs	r0, #1
 80042d4:	f002 ffa4 	bl	8007220 <MIOS32_BOARD_J5_PinGet>
 80042d8:	6020      	str	r0, [r4, #0]
 80042da:	e7f3      	b.n	80042c4 <APP_Background+0x4>
 80042dc:	20000c2c 	.word	0x20000c2c

080042e0 <APP_MIDI_NotifyPackage>:
                   midi_package.evnt0, midi_package.evnt1, midi_package.evnt2);
	break;
	
    case 0x20: MIOS32_MIDI_SendPackage(0x10,  midi_package); break;
  }*/
}
 80042e0:	4770      	bx	lr

080042e2 <APP_DIN_NotifyToggle>:
// This hook is called when a button has been toggled
// pin_value is 1 when button released, and 0 when button pressed
/////////////////////////////////////////////////////////////////////////////
void APP_DIN_NotifyToggle(u32 pin, u32 pin_value)
{
}
 80042e2:	4770      	bx	lr

080042e4 <APP_ENC_NotifyChange>:
// incrementer is positive when encoder has been turned clockwise, else
// it is negative
/////////////////////////////////////////////////////////////////////////////
void APP_ENC_NotifyChange(u32 encoder, s32 incrementer)
{
}
 80042e4:	4770      	bx	lr
	...

080042e8 <APP_AIN_NotifyChange>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a pot has been moved
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
 80042e8:	b508      	push	{r3, lr}
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 80042ea:	4b06      	ldr	r3, [pc, #24]	; (8004304 <APP_AIN_NotifyChange+0x1c>)

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a pot has been moved
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
 80042ec:	4602      	mov	r2, r0
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 80042ee:	7818      	ldrb	r0, [r3, #0]
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);
 80042f0:	094b      	lsrs	r3, r1, #5
 80042f2:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 80042f6:	b2d2      	uxtb	r2, r2
 80042f8:	b2db      	uxtb	r3, r3
 80042fa:	2100      	movs	r1, #0
 80042fc:	f001 fa19 	bl	8005732 <MIOS32_MIDI_SendCC>
  u16 value_14bit = pin_value << 2;

  // send Pitch Bender event
  MIOS32_MIDI_SendPitchBend(selected_midi_port, pin, value_14bit);
#endif
}
 8004300:	bd08      	pop	{r3, pc}
 8004302:	bf00      	nop
 8004304:	20000c28 	.word	0x20000c28

08004308 <BUTTON_NotifyToggle>:
// This task is called each mS to scan the button matrix
/////////////////////////////////////////////////////////////////////////////

// will be called on button pin changes (see TASK_BLM_Check)
void BUTTON_NotifyToggle(u8 row, u8 column, u8 pin_value, u32 timestamp)
{
 8004308:	b5f0      	push	{r4, r5, r6, r7, lr}
 800430a:	468c      	mov	ip, r1
 800430c:	b089      	sub	sp, #36	; 0x24
 800430e:	4606      	mov	r6, r0
 8004310:	4617      	mov	r7, r2
 8004312:	9305      	str	r3, [sp, #20]
  // determine pin number based on row/column
  // based on pin map for fadar keyboard provided by Robin (see doc/ directory)
  // tested with utils/test_pinmap.pl

#if DEBUG_VERBOSE_LEVEL >= 3
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d\n",
 8004314:	4662      	mov	r2, ip
 8004316:	484e      	ldr	r0, [pc, #312]	; (8004450 <BUTTON_NotifyToggle+0x148>)
 8004318:	4631      	mov	r1, r6
 800431a:	463b      	mov	r3, r7
 800431c:	f8cd c010 	str.w	ip, [sp, #16]
 8004320:	f001 fab2 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>

  // combine to pin value
//  if( column < 8 ) {
    // left half
//    if( row >= 0 && row <= 0x9 ) {
      pin = (column << 3) | bit3to1;
 8004324:	f8dd c010 	ldr.w	ip, [sp, #16]

  // pin number (counted from 0) consists of:
  //   bit #0 if row -> pin bit #0
  //int bit0 = row & 1;
  //   bit #2..0 of column -> pin bit #3..1
  int bit3to1 = row & 0x7;
 8004328:	f006 0407 	and.w	r4, r6, #7

  // combine to pin value
//  if( column < 8 ) {
    // left half
//    if( row >= 0 && row <= 0x9 ) {
      pin = (column << 3) | bit3to1;
 800432c:	ea44 04cc 	orr.w	r4, r4, ip, lsl #3
 // }

  // following check ensures that we never continue with an unexpected/invalid pin number.
  // e.g. this could address a memory location outside the last_timestamp[] array!
  // print a warning message in this case for analysis purposes
  if( pin < 0 || pin >= KEYBOARD_NUM_PINS ) {
 8004330:	f5b4 7fc0 	cmp.w	r4, #384	; 0x180
#if DEBUG_VERBOSE_LEVEL >= 1
    DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d NOT MAPPED!\n",
 8004334:	bf24      	itt	cs
 8004336:	9400      	strcs	r4, [sp, #0]
 8004338:	4846      	ldrcs	r0, [pc, #280]	; (8004454 <BUTTON_NotifyToggle+0x14c>)
 // }

  // following check ensures that we never continue with an unexpected/invalid pin number.
  // e.g. this could address a memory location outside the last_timestamp[] array!
  // print a warning message in this case for analysis purposes
  if( pin < 0 || pin >= KEYBOARD_NUM_PINS ) {
 800433a:	d246      	bcs.n	80043ca <BUTTON_NotifyToggle+0xc2>

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch

  // the note number lookup
  int note_number = note_table[pin];
 800433c:	4b46      	ldr	r3, [pc, #280]	; (8004458 <BUTTON_NotifyToggle+0x150>)
#endif
    return;
  }

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch
 800433e:	f3c6 05c0 	ubfx	r5, r6, #3, #1

  // the note number lookup
  int note_number = note_table[pin];
 8004342:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
  //    - send Note On event
  // c) first switch changes from 0->1 (pin_value == 1): 
  //    - send Note Off event (resp. Note On with velocity 0)
  //    - clear captured timestamp (allows to check for valid delay on next transition)

  unsigned key_ix = pin & 0xfffffffe;
 8004346:	f024 0301 	bic.w	r3, r4, #1

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch

  // the note number lookup
  int note_number = note_table[pin];
 800434a:	2a7f      	cmp	r2, #127	; 0x7f
 800434c:	bfa8      	it	ge
 800434e:	227f      	movge	r2, #127	; 0x7f
  unsigned key_ix = pin & 0xfffffffe;
  int delay = -1;
  u8 send_note_on = 0;
  u8 send_note_off = 0;

  if( pin_value == 0 ) {
 8004350:	b9bf      	cbnz	r7, 8004382 <BUTTON_NotifyToggle+0x7a>
 8004352:	4942      	ldr	r1, [pc, #264]	; (800445c <BUTTON_NotifyToggle+0x154>)
    if( second_switch == 0 ) { // first switch
 8004354:	b91d      	cbnz	r5, 800435e <BUTTON_NotifyToggle+0x56>
      last_timestamp[key_ix] = timestamp;
 8004356:	9a05      	ldr	r2, [sp, #20]
 8004358:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800435c:	e031      	b.n	80043c2 <BUTTON_NotifyToggle+0xba>
 //     if (no_velocity)
 //      send_note_on = 1;

    } else { // second switch
      if( last_timestamp[key_ix] ) {
 800435e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8004362:	2b00      	cmp	r3, #0
 8004364:	d02d      	beq.n	80043c2 <BUTTON_NotifyToggle+0xba>
	delay = timestamp - last_timestamp[key_ix];
 8004366:	f8dd e014 	ldr.w	lr, [sp, #20]
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
     if (no_velocity)
 800436a:	483d      	ldr	r0, [pc, #244]	; (8004460 <BUTTON_NotifyToggle+0x158>)
 //     if (no_velocity)
 //      send_note_on = 1;

    } else { // second switch
      if( last_timestamp[key_ix] ) {
	delay = timestamp - last_timestamp[key_ix];
 800436c:	ebc3 030e 	rsb	r3, r3, lr
 8004370:	9306      	str	r3, [sp, #24]
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 8004372:	493c      	ldr	r1, [pc, #240]	; (8004464 <BUTTON_NotifyToggle+0x15c>)
 8004374:	4b3c      	ldr	r3, [pc, #240]	; (8004468 <BUTTON_NotifyToggle+0x160>)
     if (no_velocity)
 8004376:	6800      	ldr	r0, [r0, #0]
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 8004378:	681b      	ldr	r3, [r3, #0]
 800437a:	6809      	ldr	r1, [r1, #0]
     if (no_velocity)
 800437c:	2800      	cmp	r0, #0
 800437e:	d13b      	bne.n	80043f8 <BUTTON_NotifyToggle+0xf0>
 8004380:	e029      	b.n	80043d6 <BUTTON_NotifyToggle+0xce>
	delay = timestamp - last_timestamp[key_ix];
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
 8004382:	b9f5      	cbnz	r5, 80043c2 <BUTTON_NotifyToggle+0xba>
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, 0x00);
 8004384:	b2d2      	uxtb	r2, r2
 8004386:	9206      	str	r2, [sp, #24]
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
      last_timestamp[key_ix] = 0;
 8004388:	4934      	ldr	r1, [pc, #208]	; (800445c <BUTTON_NotifyToggle+0x154>)
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, 0x00);
 800438a:	4a38      	ldr	r2, [pc, #224]	; (800446c <BUTTON_NotifyToggle+0x164>)
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
      last_timestamp[key_ix] = 0;
 800438c:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, 0x00);
 8004390:	2020      	movs	r0, #32
 8004392:	7811      	ldrb	r1, [r2, #0]
 8004394:	462b      	mov	r3, r5
 8004396:	9a06      	ldr	r2, [sp, #24]
 8004398:	f8cd c010 	str.w	ip, [sp, #16]
 800439c:	f001 f9c3 	bl	8005726 <MIOS32_MIDI_SendNoteOn>
	MIOS32_MIDI_SendNoteOn(0x10, channel, note_number, 0x00);
 80043a0:	4b32      	ldr	r3, [pc, #200]	; (800446c <BUTTON_NotifyToggle+0x164>)
 80043a2:	2010      	movs	r0, #16
 80043a4:	7819      	ldrb	r1, [r3, #0]
 80043a6:	9a06      	ldr	r2, [sp, #24]
 80043a8:	462b      	mov	r3, r5
 80043aa:	f001 f9bc 	bl	8005726 <MIOS32_MIDI_SendNoteOn>
	

#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE OFF\n",
 80043ae:	f8dd e014 	ldr.w	lr, [sp, #20]
 80043b2:	9400      	str	r4, [sp, #0]
 80043b4:	f8cd e004 	str.w	lr, [sp, #4]
 80043b8:	482d      	ldr	r0, [pc, #180]	; (8004470 <BUTTON_NotifyToggle+0x168>)
 80043ba:	4631      	mov	r1, r6
 80043bc:	f8dd c010 	ldr.w	ip, [sp, #16]
 80043c0:	e004      	b.n	80043cc <BUTTON_NotifyToggle+0xc4>
	      row, column, pin_value, pin, timestamp);
#endif
  } else {
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> IGNORE\n",
 80043c2:	9905      	ldr	r1, [sp, #20]
 80043c4:	482b      	ldr	r0, [pc, #172]	; (8004474 <BUTTON_NotifyToggle+0x16c>)
 80043c6:	9400      	str	r4, [sp, #0]
 80043c8:	9101      	str	r1, [sp, #4]
 80043ca:	4631      	mov	r1, r6
 80043cc:	4662      	mov	r2, ip
 80043ce:	463b      	mov	r3, r7
 80043d0:	f001 fa5a 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
 80043d4:	e039      	b.n	800444a <BUTTON_NotifyToggle+0x142>
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 80043d6:	f8dd e018 	ldr.w	lr, [sp, #24]
 80043da:	257f      	movs	r5, #127	; 0x7f
 80043dc:	ebc3 000e 	rsb	r0, r3, lr
 80043e0:	4345      	muls	r5, r0
 80043e2:	1acb      	subs	r3, r1, r3
 80043e4:	fbb5 f5f3 	udiv	r5, r5, r3
 80043e8:	f1c5 057f 	rsb	r5, r5, #127	; 0x7f
     if (no_velocity)
       velocity = 127;

    // saturate to ensure that range 1..127 won't be exceeded
    if( velocity < 1 )
 80043ec:	2d00      	cmp	r5, #0
 80043ee:	dd05      	ble.n	80043fc <BUTTON_NotifyToggle+0xf4>
      velocity = 1;
    if( velocity > 127 )
      velocity = 127;
 80043f0:	2d7f      	cmp	r5, #127	; 0x7f
 80043f2:	bfa8      	it	ge
 80043f4:	257f      	movge	r5, #127	; 0x7f
 80043f6:	e002      	b.n	80043fe <BUTTON_NotifyToggle+0xf6>

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
     if (no_velocity)
       velocity = 127;
 80043f8:	257f      	movs	r5, #127	; 0x7f
 80043fa:	e000      	b.n	80043fe <BUTTON_NotifyToggle+0xf6>

    // saturate to ensure that range 1..127 won't be exceeded
    if( velocity < 1 )
      velocity = 1;
 80043fc:	2501      	movs	r5, #1
    if( velocity > 127 )
      velocity = 127;

    last_velocity=velocity_table[velocity];
 80043fe:	4b1e      	ldr	r3, [pc, #120]	; (8004478 <BUTTON_NotifyToggle+0x170>)
 8004400:	491e      	ldr	r1, [pc, #120]	; (800447c <BUTTON_NotifyToggle+0x174>)
 8004402:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, last_velocity);
 8004406:	4f19      	ldr	r7, [pc, #100]	; (800446c <BUTTON_NotifyToggle+0x164>)
    if( velocity < 1 )
      velocity = 1;
    if( velocity > 127 )
      velocity = 127;

    last_velocity=velocity_table[velocity];
 8004408:	600b      	str	r3, [r1, #0]
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, last_velocity);
 800440a:	b2d2      	uxtb	r2, r2
 800440c:	7839      	ldrb	r1, [r7, #0]
 800440e:	b2db      	uxtb	r3, r3
 8004410:	2020      	movs	r0, #32
 8004412:	f8cd c010 	str.w	ip, [sp, #16]
 8004416:	9207      	str	r2, [sp, #28]
 8004418:	f001 f985 	bl	8005726 <MIOS32_MIDI_SendNoteOn>
	MIOS32_MIDI_SendNoteOn(0x10, channel, note_number, last_velocity);
 800441c:	4a17      	ldr	r2, [pc, #92]	; (800447c <BUTTON_NotifyToggle+0x174>)
 800441e:	7839      	ldrb	r1, [r7, #0]
 8004420:	7813      	ldrb	r3, [r2, #0]
 8004422:	2010      	movs	r0, #16
 8004424:	9a07      	ldr	r2, [sp, #28]
 8004426:	f001 f97e 	bl	8005726 <MIOS32_MIDI_SendNoteOn>
	
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
 800442a:	9b05      	ldr	r3, [sp, #20]
 800442c:	f8dd c010 	ldr.w	ip, [sp, #16]
 8004430:	f8dd e018 	ldr.w	lr, [sp, #24]
 8004434:	9301      	str	r3, [sp, #4]
 8004436:	4812      	ldr	r0, [pc, #72]	; (8004480 <BUTTON_NotifyToggle+0x178>)
 8004438:	4631      	mov	r1, r6
 800443a:	4662      	mov	r2, ip
 800443c:	2300      	movs	r3, #0
 800443e:	9400      	str	r4, [sp, #0]
 8004440:	f8cd e008 	str.w	lr, [sp, #8]
 8004444:	9503      	str	r5, [sp, #12]
 8004446:	f001 fa1f 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> IGNORE\n",
	      row, column, pin_value, pin, timestamp);
#endif
  }
}
 800444a:	b009      	add	sp, #36	; 0x24
 800444c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800444e:	bf00      	nop
 8004450:	0800aa71 	.word	0x0800aa71
 8004454:	0800aa9a 	.word	0x0800aa9a
 8004458:	0800a54c 	.word	0x0800a54c
 800445c:	200000a8 	.word	0x200000a8
 8004460:	20000c2c 	.word	0x20000c2c
 8004464:	200000a4 	.word	0x200000a4
 8004468:	20000058 	.word	0x20000058
 800446c:	200000a0 	.word	0x200000a0
 8004470:	0800aae2 	.word	0x0800aae2
 8004474:	0800ab2f 	.word	0x0800ab2f
 8004478:	0800a84c 	.word	0x0800a84c
 800447c:	20000c24 	.word	0x20000c24
 8004480:	0800ab7a 	.word	0x0800ab7a

08004484 <TASK_MatrixScan>:


static void TASK_MatrixScan(void *pvParameters)
{
 8004484:	b5f0      	push	{r4, r5, r6, r7, lr}
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
	    if( changed & mask ){
		  if (row == 16) {
			channel = channel_table[column - 8];
 8004486:	4f55      	ldr	r7, [pc, #340]	; (80045dc <TASK_MatrixScan+0x158>)
  }
}


static void TASK_MatrixScan(void *pvParameters)
{
 8004488:	b08d      	sub	sp, #52	; 0x34
  while( 1 ) {
    // wait for next timesplice (1 mS)
    vTaskDelay(1 / portTICK_RATE_MS);
 800448a:	2001      	movs	r0, #1
 800448c:	f000 fc16 	bl	8004cbc <vTaskDelay>

    // determine timestamp (we need it for delay measurements)
    mios32_sys_time_t t = MIOS32_SYS_TimeGet();
 8004490:	a80a      	add	r0, sp, #40	; 0x28
 8004492:	f002 f8d1 	bl	8006638 <MIOS32_SYS_TimeGet>
    u32 timestamp = 1000*t.seconds + t.fraction_ms;
 8004496:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004498:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800449a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800449e:	fb01 3302 	mla	r3, r1, r2, r3
 80044a2:	f04f 35ff 	mov.w	r5, #4294967295
 80044a6:	9308      	str	r3, [sp, #32]
 80044a8:	4e4d      	ldr	r6, [pc, #308]	; (80045e0 <TASK_MatrixScan+0x15c>)
    //   - shift selection pattern for *next* row to DOUT registers
    //   - read DIN values of previously selected row
    // since we need to select the first row before the first DIN values are latched, we loop from -1
    // to handle the initial state
    int row;
    for(row=-1; row<MATRIX_NUM_ROWS; ++row) {
 80044aa:	9505      	str	r5, [sp, #20]
 80044ac:	e00e      	b.n	80044cc <TASK_MatrixScan+0x48>
      if( row >= 0 ) { // not required for initial scan
	// latch DIN values
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 80044ae:	2100      	movs	r1, #0
 80044b0:	460a      	mov	r2, r1
 80044b2:	2001      	movs	r0, #1
 80044b4:	f002 f9f0 	bl	8006898 <MIOS32_SPI_RC_PinSet>
	MIOS32_DELAY_Wait_uS(1);
 80044b8:	2001      	movs	r0, #1
 80044ba:	f003 f857 	bl	800756c <MIOS32_DELAY_Wait_uS>
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 80044be:	2001      	movs	r0, #1
 80044c0:	2100      	movs	r1, #0
 80044c2:	4602      	mov	r2, r0
 80044c4:	f002 f9e8 	bl	8006898 <MIOS32_SPI_RC_PinSet>
 80044c8:	3501      	adds	r5, #1
 80044ca:	3604      	adds	r6, #4
      }

      // determine selection mask for next row (written into DOUT registers while reading DIN registers)
	  u16 select_row_pattern = ~(1 << (row+1));
 80044cc:	9905      	ldr	r1, [sp, #20]
 80044ce:	2401      	movs	r4, #1
 80044d0:	3101      	adds	r1, #1
 80044d2:	fa14 f301 	lsls.w	r3, r4, r1
 80044d6:	43db      	mvns	r3, r3
 80044d8:	b29b      	uxth	r3, r3
 80044da:	9105      	str	r1, [sp, #20]
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 80044dc:	4620      	mov	r0, r4
 80044de:	21ff      	movs	r1, #255	; 0xff
	MIOS32_DELAY_Wait_uS(1);
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
      }

      // determine selection mask for next row (written into DOUT registers while reading DIN registers)
	  u16 select_row_pattern = ~(1 << (row+1));
 80044e0:	9304      	str	r3, [sp, #16]
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 80044e2:	f002 fa21 	bl	8006928 <MIOS32_SPI_TransferByte>
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 80044e6:	9a04      	ldr	r2, [sp, #16]
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 80044e8:	9006      	str	r0, [sp, #24]
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 80044ea:	0a11      	lsrs	r1, r2, #8
 80044ec:	4620      	mov	r0, r4
 80044ee:	f002 fa1b 	bl	8006928 <MIOS32_SPI_TransferByte>
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 80044f2:	9b04      	ldr	r3, [sp, #16]
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 80044f4:	9007      	str	r0, [sp, #28]
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 80044f6:	b2d9      	uxtb	r1, r3
 80044f8:	4620      	mov	r0, r4
 80044fa:	f002 fa15 	bl	8006928 <MIOS32_SPI_TransferByte>

      // latch new DOUT value
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 80044fe:	2100      	movs	r1, #0
 8004500:	460a      	mov	r2, r1
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 8004502:	9004      	str	r0, [sp, #16]

      // latch new DOUT value
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004504:	4620      	mov	r0, r4
 8004506:	f002 f9c7 	bl	8006898 <MIOS32_SPI_RC_PinSet>
      MIOS32_DELAY_Wait_uS(1);
 800450a:	4620      	mov	r0, r4
 800450c:	f003 f82e 	bl	800756c <MIOS32_DELAY_Wait_uS>
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8004510:	2100      	movs	r1, #0
 8004512:	4620      	mov	r0, r4
 8004514:	4622      	mov	r2, r4
 8004516:	f002 f9bf 	bl	8006898 <MIOS32_SPI_RC_PinSet>
	  if ( row == 15 ) {MIOS32_BOARD_J5_PinSet(7, 0);}
 800451a:	2d0f      	cmp	r5, #15
 800451c:	d104      	bne.n	8004528 <TASK_MatrixScan+0xa4>
 800451e:	2007      	movs	r0, #7
 8004520:	2100      	movs	r1, #0
 8004522:	f002 fe59 	bl	80071d8 <MIOS32_BOARD_J5_PinSet>
 8004526:	e006      	b.n	8004536 <TASK_MatrixScan+0xb2>
	  else {MIOS32_BOARD_J5_PinSet(7, 1);}
 8004528:	2007      	movs	r0, #7
 800452a:	4621      	mov	r1, r4
 800452c:	f002 fe54 	bl	80071d8 <MIOS32_BOARD_J5_PinSet>

      if( row >= 0 ) {
 8004530:	f1b5 3fff 	cmp.w	r5, #4294967295
 8004534:	d04d      	beq.n	80045d2 <TASK_MatrixScan+0x14e>
	// combine read DIN bytes to 24bit value
	u32 din_pattern = 0xff000000 | (din2 << 16) | (din1 << 8) | din0;
 8004536:	9906      	ldr	r1, [sp, #24]
 8004538:	b2cb      	uxtb	r3, r1
 800453a:	9904      	ldr	r1, [sp, #16]
 800453c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8004540:	b2ca      	uxtb	r2, r1
 8004542:	9907      	ldr	r1, [sp, #28]
 8004544:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8004548:	b2ca      	uxtb	r2, r1
 800454a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

	// check if values have been changed via XOR combination with previously scanned value
	u32 changed = din_pattern ^ din_value[row];
 800454e:	f856 3c04 	ldr.w	r3, [r6, #-4]
	  if ( row == 15 ) {MIOS32_BOARD_J5_PinSet(7, 0);}
	  else {MIOS32_BOARD_J5_PinSet(7, 1);}

      if( row >= 0 ) {
	// combine read DIN bytes to 24bit value
	u32 din_pattern = 0xff000000 | (din2 << 16) | (din1 << 8) | din0;
 8004552:	9204      	str	r2, [sp, #16]

	// check if values have been changed via XOR combination with previously scanned value
	u32 changed = din_pattern ^ din_value[row];
	if( changed ) {
 8004554:	4053      	eors	r3, r2
 8004556:	9306      	str	r3, [sp, #24]
 8004558:	d03b      	beq.n	80045d2 <TASK_MatrixScan+0x14e>
	  // store changed value
	  din_value[row] = din_pattern;
 800455a:	f8df c088 	ldr.w	ip, [pc, #136]	; 80045e4 <TASK_MatrixScan+0x160>
 800455e:	f846 2c04 	str.w	r2, [r6, #-4]
			#if DEBUG_VERBOSE_LEVEL >= 1
			DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x,  pin_value=%d, channel=%02x /n",row, column, (din_pattern & mask) ? 1 : 0, channel);
			#endif
			}
		  else {
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);}
 8004562:	b2ea      	uxtb	r2, r5
 8004564:	9609      	str	r6, [sp, #36]	; 0x24
	  // store changed value
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
 8004566:	2400      	movs	r4, #0
			#if DEBUG_VERBOSE_LEVEL >= 1
			DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x,  pin_value=%d, channel=%02x /n",row, column, (din_pattern & mask) ? 1 : 0, channel);
			#endif
			}
		  else {
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);}
 8004568:	462e      	mov	r6, r5
 800456a:	9207      	str	r2, [sp, #28]
 800456c:	4665      	mov	r5, ip
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
 800456e:	2301      	movs	r3, #1
 8004570:	fa13 f204 	lsls.w	r2, r3, r4
	    if( changed & mask ){
 8004574:	9906      	ldr	r1, [sp, #24]
 8004576:	420a      	tst	r2, r1
 8004578:	d025      	beq.n	80045c6 <TASK_MatrixScan+0x142>
 800457a:	9b04      	ldr	r3, [sp, #16]
		  if (row == 16) {
 800457c:	2e10      	cmp	r6, #16
 800457e:	ea02 0203 	and.w	r2, r2, r3
 8004582:	d118      	bne.n	80045b6 <TASK_MatrixScan+0x132>
			channel = channel_table[column - 8];
 8004584:	f855 3c20 	ldr.w	r3, [r5, #-32]
			MIOS32_LCD_CursorSet (0,1);
 8004588:	2101      	movs	r1, #1
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
	    if( changed & mask ){
		  if (row == 16) {
			channel = channel_table[column - 8];
 800458a:	603b      	str	r3, [r7, #0]
			MIOS32_LCD_CursorSet (0,1);
 800458c:	2000      	movs	r0, #0
 800458e:	9203      	str	r2, [sp, #12]
 8004590:	f000 ff52 	bl	8005438 <MIOS32_LCD_CursorSet>
			MIOS32_LCD_PrintFormattedString("%02d", channel + 1);
 8004594:	6839      	ldr	r1, [r7, #0]
 8004596:	4814      	ldr	r0, [pc, #80]	; (80045e8 <TASK_MatrixScan+0x164>)
 8004598:	3101      	adds	r1, #1
 800459a:	f001 f80f 	bl	80055bc <MIOS32_LCD_PrintFormattedString>
			#if DEBUG_VERBOSE_LEVEL >= 1
			DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x,  pin_value=%d, channel=%02x /n",row, column, (din_pattern & mask) ? 1 : 0, channel);
 800459e:	9a03      	ldr	r2, [sp, #12]
 80045a0:	4631      	mov	r1, r6
 80045a2:	1e13      	subs	r3, r2, #0
 80045a4:	bf18      	it	ne
 80045a6:	2301      	movne	r3, #1
 80045a8:	683a      	ldr	r2, [r7, #0]
 80045aa:	4810      	ldr	r0, [pc, #64]	; (80045ec <TASK_MatrixScan+0x168>)
 80045ac:	9200      	str	r2, [sp, #0]
 80045ae:	4622      	mov	r2, r4
 80045b0:	f001 f96a 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
 80045b4:	e007      	b.n	80045c6 <TASK_MatrixScan+0x142>
			#endif
			}
		  else {
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);}
 80045b6:	b2e1      	uxtb	r1, r4
 80045b8:	3a00      	subs	r2, #0
 80045ba:	bf18      	it	ne
 80045bc:	2201      	movne	r2, #1
 80045be:	9807      	ldr	r0, [sp, #28]
 80045c0:	9b08      	ldr	r3, [sp, #32]
 80045c2:	f7ff fea1 	bl	8004308 <BUTTON_NotifyToggle>
	  // store changed value
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
 80045c6:	3401      	adds	r4, #1
 80045c8:	3504      	adds	r5, #4
 80045ca:	2c18      	cmp	r4, #24
 80045cc:	d1cf      	bne.n	800456e <TASK_MatrixScan+0xea>
 80045ce:	4635      	mov	r5, r6
 80045d0:	9e09      	ldr	r6, [sp, #36]	; 0x24
    //   - shift selection pattern for *next* row to DOUT registers
    //   - read DIN values of previously selected row
    // since we need to select the first row before the first DIN values are latched, we loop from -1
    // to handle the initial state
    int row;
    for(row=-1; row<MATRIX_NUM_ROWS; ++row) {
 80045d2:	9905      	ldr	r1, [sp, #20]
 80045d4:	2911      	cmp	r1, #17
 80045d6:	f47f af6a 	bne.w	80044ae <TASK_MatrixScan+0x2a>
 80045da:	e756      	b.n	800448a <TASK_MatrixScan+0x6>
 80045dc:	200000a0 	.word	0x200000a0
 80045e0:	2000005c 	.word	0x2000005c
 80045e4:	0800ac28 	.word	0x0800ac28
 80045e8:	0800abde 	.word	0x0800abde
 80045ec:	0800abe3 	.word	0x0800abe3

080045f0 <TASK_MIDI_Hooks>:
// MIDI task (separated from TASK_Hooks() to ensure parallel handling of
// MIDI events if a hook in TASK_Hooks() blocks)
/////////////////////////////////////////////////////////////////////////////
#if !defined(MIOS32_DONT_USE_MIDI)
static void TASK_MIDI_Hooks(void *pvParameters)
{
 80045f0:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 80045f2:	f000 fa61 	bl	8004ab8 <xTaskGetTickCount>
 80045f6:	ac02      	add	r4, sp, #8
 80045f8:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 80045fc:	2101      	movs	r1, #1
 80045fe:	4620      	mov	r0, r4
 8004600:	f000 fb84 	bl	8004d0c <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 8004604:	f000 fa58 	bl	8004ab8 <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 8004608:	9a01      	ldr	r2, [sp, #4]
 800460a:	1f43      	subs	r3, r0, #5
 800460c:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 800460e:	bf38      	it	cc
 8004610:	9001      	strcc	r0, [sp, #4]

    // handle timeout/expire counters and USB packages
    MIOS32_MIDI_Periodic_mS();
 8004612:	f001 fc8f 	bl	8005f34 <MIOS32_MIDI_Periodic_mS>

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 8004616:	4802      	ldr	r0, [pc, #8]	; (8004620 <TASK_MIDI_Hooks+0x30>)
 8004618:	f001 faf2 	bl	8005c00 <MIOS32_MIDI_Receive_Handler>
  }
 800461c:	e7ee      	b.n	80045fc <TASK_MIDI_Hooks+0xc>
 800461e:	bf00      	nop
 8004620:	080042e1 	.word	0x080042e1

08004624 <TASK_Hooks>:

/////////////////////////////////////////////////////////////////////////////
// Remaining application hooks
/////////////////////////////////////////////////////////////////////////////
static void TASK_Hooks(void *pvParameters)
{
 8004624:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 8004626:	f000 fa47 	bl	8004ab8 <xTaskGetTickCount>
 800462a:	ac02      	add	r4, sp, #8
 800462c:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8004630:	2101      	movs	r1, #1
 8004632:	4620      	mov	r0, r4
 8004634:	f000 fb6a 	bl	8004d0c <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 8004638:	f000 fa3e 	bl	8004ab8 <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 800463c:	9a01      	ldr	r2, [sp, #4]
 800463e:	1f43      	subs	r3, r0, #5
 8004640:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 8004642:	bf38      	it	cc
 8004644:	9001      	strcc	r0, [sp, #4]

#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
    // check for DIN pin changes, call APP_DIN_NotifyToggle on each toggled pin
    MIOS32_DIN_Handler(APP_DIN_NotifyToggle);
 8004646:	4806      	ldr	r0, [pc, #24]	; (8004660 <TASK_Hooks+0x3c>)
 8004648:	f000 fe6c 	bl	8005324 <MIOS32_DIN_Handler>

    // check for encoder changes, call APP_ENC_NotifyChanged on each change
# ifndef MIOS32_DONT_USE_ENC
    MIOS32_ENC_Handler(APP_ENC_NotifyChange);
 800464c:	4805      	ldr	r0, [pc, #20]	; (8004664 <TASK_Hooks+0x40>)
 800464e:	f000 fecd 	bl	80053ec <MIOS32_ENC_Handler>
# endif
#endif

#if !defined(MIOS32_DONT_USE_AIN)
    // check for AIN pin changes, call APP_AIN_NotifyChange on each pin change
    MIOS32_AIN_Handler(APP_AIN_NotifyChange);
 8004652:	4805      	ldr	r0, [pc, #20]	; (8004668 <TASK_Hooks+0x44>)
 8004654:	f003 f8c8 	bl	80077e8 <MIOS32_AIN_Handler>
#endif

#if !defined(MIOS32_DONT_USE_COM)
    // check for incoming COM messages
    MIOS32_COM_Receive_Handler();
 8004658:	f001 fcf3 	bl	8006042 <MIOS32_COM_Receive_Handler>
#endif
  }
 800465c:	e7e8      	b.n	8004630 <TASK_Hooks+0xc>
 800465e:	bf00      	nop
 8004660:	080042e3 	.word	0x080042e3
 8004664:	080042e5 	.word	0x080042e5
 8004668:	080042e9 	.word	0x080042e9

0800466c <main>:

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 800466c:	b530      	push	{r4, r5, lr}
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 800466e:	2000      	movs	r0, #0

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 8004670:	b085      	sub	sp, #20
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 8004672:	f001 ff51 	bl	8006518 <MIOS32_SYS_Init>
#endif
#ifndef MIOS32_DONT_USE_DELAY
  MIOS32_DELAY_Init(0);
 8004676:	2000      	movs	r0, #0
 8004678:	f002 ff56 	bl	8007528 <MIOS32_DELAY_Init>
#endif
#ifndef MIOS32_DONT_USE_BOARD
  MIOS32_BOARD_Init(0);
 800467c:	2000      	movs	r0, #0
 800467e:	f002 fd1d 	bl	80070bc <MIOS32_BOARD_Init>
#endif
#ifndef MIOS32_DONT_USE_SPI
  MIOS32_SPI_Init(0);
 8004682:	2000      	movs	r0, #0
 8004684:	f002 fc2a 	bl	8006edc <MIOS32_SPI_Init>
#endif
#ifndef MIOS32_DONT_USE_SRIO
  MIOS32_SRIO_Init(0);
 8004688:	2000      	movs	r0, #0
 800468a:	f000 fdd3 	bl	8005234 <MIOS32_SRIO_Init>
#endif
#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DIN_Init(0);
 800468e:	2000      	movs	r0, #0
 8004690:	f000 fe1a 	bl	80052c8 <MIOS32_DIN_Init>
#endif
#if !defined(MIOS32_DONT_USE_DOUT) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DOUT_Init(0);
 8004694:	2000      	movs	r0, #0
 8004696:	f000 fe6d 	bl	8005374 <MIOS32_DOUT_Init>
#endif
#if !defined(MIOS32_DONT_USE_ENC) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_ENC_Init(0);
 800469a:	2000      	movs	r0, #0
 800469c:	f000 fe78 	bl	8005390 <MIOS32_ENC_Init>
#endif
#if !defined(MIOS32_DONT_USE_MF)
  MIOS32_MF_Init(0);
 80046a0:	2000      	movs	r0, #0
 80046a2:	f001 fe9b 	bl	80063dc <MIOS32_MF_Init>
#endif
#if !defined(MIOS32_DONT_USE_AIN)
  MIOS32_AIN_Init(0);
 80046a6:	2000      	movs	r0, #0
 80046a8:	f002 ff6c 	bl	8007584 <MIOS32_AIN_Init>
#endif
#ifndef MIOS32_DONT_USE_IIC_BS
  MIOS32_IIC_BS_Init(0);
 80046ac:	2000      	movs	r0, #0
 80046ae:	f001 fe92 	bl	80063d6 <MIOS32_IIC_BS_Init>
#endif
#ifndef MIOS32_DONT_USE_USB
  MIOS32_USB_Init(0);
 80046b2:	2000      	movs	r0, #0
 80046b4:	f003 faa8 	bl	8007c08 <MIOS32_USB_Init>
#endif
#ifndef MIOS32_DONT_USE_MIDI
  MIOS32_MIDI_Init(0);
 80046b8:	2000      	movs	r0, #0
 80046ba:	f000 ff9b 	bl	80055f4 <MIOS32_MIDI_Init>
#endif
#ifndef MIOS32_DONT_USE_OSC
  MIOS32_OSC_Init(0);
 80046be:	2000      	movs	r0, #0
 80046c0:	f001 fc86 	bl	8005fd0 <MIOS32_OSC_Init>
#endif
#ifndef MIOS32_DONT_USE_COM
  MIOS32_COM_Init(0);
 80046c4:	2000      	movs	r0, #0
 80046c6:	f001 fc89 	bl	8005fdc <MIOS32_COM_Init>
#endif
#ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_Init(0);
 80046ca:	2000      	movs	r0, #0
 80046cc:	f000 feee 	bl	80054ac <MIOS32_LCD_Init>
#ifdef MIOS32_USE_I2S
  MIOS32_I2S_Init(0);
#endif

  // call C++ constructors
  __libc_init_array();
 80046d0:	f005 fee2 	bl	800a498 <__libc_init_array>

  // initialize application
  APP_Init();
 80046d4:	f7ff fd86 	bl	80041e4 <APP_Init>

#if MIOS32_LCD_BOOT_MSG_DELAY
  // print boot message
# ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_PrintBootMessage();
 80046d8:	f000 ff50 	bl	800557c <MIOS32_LCD_PrintBootMessage>
 80046dc:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
    MIOS32_DELAY_Wait_uS(1000);
 80046e0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80046e4:	f002 ff42 	bl	800756c <MIOS32_DELAY_Wait_uS>
# endif

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
 80046e8:	f114 34ff 	adds.w	r4, r4, #4294967295
 80046ec:	d1f8      	bne.n	80046e0 <main+0x74>
    MIOS32_DELAY_Wait_uS(1000);
# endif
#endif

  // start the task which calls the application hooks
  xTaskCreate(TASK_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 80046ee:	2503      	movs	r5, #3
 80046f0:	4623      	mov	r3, r4
 80046f2:	490d      	ldr	r1, [pc, #52]	; (8004728 <main+0xbc>)
 80046f4:	f44f 7280 	mov.w	r2, #256	; 0x100
 80046f8:	480c      	ldr	r0, [pc, #48]	; (800472c <main+0xc0>)
 80046fa:	9500      	str	r5, [sp, #0]
 80046fc:	9401      	str	r4, [sp, #4]
 80046fe:	9402      	str	r4, [sp, #8]
 8004700:	9403      	str	r4, [sp, #12]
 8004702:	f000 f8df 	bl	80048c4 <xTaskGenericCreate>
#if !defined(MIOS32_DONT_USE_MIDI)
  xTaskCreate(TASK_MIDI_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 8004706:	4908      	ldr	r1, [pc, #32]	; (8004728 <main+0xbc>)
 8004708:	f44f 7280 	mov.w	r2, #256	; 0x100
 800470c:	4623      	mov	r3, r4
 800470e:	4808      	ldr	r0, [pc, #32]	; (8004730 <main+0xc4>)
 8004710:	9500      	str	r5, [sp, #0]
 8004712:	9401      	str	r4, [sp, #4]
 8004714:	9402      	str	r4, [sp, #8]
 8004716:	9403      	str	r4, [sp, #12]
 8004718:	f000 f8d4 	bl	80048c4 <xTaskGenericCreate>
#endif

  // start the scheduler
  vTaskStartScheduler();
 800471c:	f000 f9a0 	bl	8004a60 <vTaskStartScheduler>

  // Will only get here if there was not enough heap space to create the idle task
  return 0;
}
 8004720:	4620      	mov	r0, r4
 8004722:	b005      	add	sp, #20
 8004724:	bd30      	pop	{r4, r5, pc}
 8004726:	bf00      	nop
 8004728:	0800ac68 	.word	0x0800ac68
 800472c:	08004625 	.word	0x08004625
 8004730:	080045f1 	.word	0x080045f1

08004734 <vApplicationTickHook>:
  APP_SRIO_ServicePrepare();

  // start next SRIO scan - IRQ notification to SRIO_ServiceFinish()
  MIOS32_SRIO_ScanStart(SRIO_ServiceFinish);
#endif
}
 8004734:	4770      	bx	lr

08004736 <vApplicationIdleHook>:

/////////////////////////////////////////////////////////////////////////////
// Idle Hook (called by FreeRTOS when nothing else to do)
/////////////////////////////////////////////////////////////////////////////
void vApplicationIdleHook(void)
{
 8004736:	b508      	push	{r3, lr}
  // branch endless to application
  while( 1 ) {
    APP_Background();
 8004738:	f7ff fdc2 	bl	80042c0 <APP_Background>
 800473c:	e7fc      	b.n	8004738 <vApplicationIdleHook+0x2>
	...

08004740 <_abort>:
// This function aborts any operations, but keeps MIDI alive (for uploading
// a new firmware)
// If MIDI isn't enabled, the status LED will be flashed
/////////////////////////////////////////////////////////////////////////////
void _abort(void)
{
 8004740:	b570      	push	{r4, r5, r6, lr}
  // stop other tasks from running
  portENTER_CRITICAL();
 8004742:	f000 fbf1 	bl	8004f28 <vPortEnterCritical>

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
 8004746:	2400      	movs	r4, #0
  while( 1 ) {
    ++delay_ctr;

    if( (delay_ctr % 100) == 0 ) {
 8004748:	2664      	movs	r6, #100	; 0x64
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);

    if( (delay_ctr % 10000) == 0 ) {
 800474a:	f242 7510 	movw	r5, #10000	; 0x2710

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
  while( 1 ) {
    ++delay_ctr;
 800474e:	3401      	adds	r4, #1

    if( (delay_ctr % 100) == 0 ) {
 8004750:	fbb4 f3f6 	udiv	r3, r4, r6
 8004754:	fb06 4313 	mls	r3, r6, r3, r4
 8004758:	b90b      	cbnz	r3, 800475e <_abort+0x1e>
      // handle timeout/expire counters and USB packages
      MIOS32_MIDI_Periodic_mS();
 800475a:	f001 fbeb 	bl	8005f34 <MIOS32_MIDI_Periodic_mS>
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 800475e:	4808      	ldr	r0, [pc, #32]	; (8004780 <_abort+0x40>)
 8004760:	f001 fa4e 	bl	8005c00 <MIOS32_MIDI_Receive_Handler>

    if( (delay_ctr % 10000) == 0 ) {
 8004764:	fbb4 f3f5 	udiv	r3, r4, r5
 8004768:	fb05 4313 	mls	r3, r5, r3, r4
 800476c:	2b00      	cmp	r3, #0
 800476e:	d1ee      	bne.n	800474e <_abort+0xe>
      // toggle board LED
      MIOS32_BOARD_LED_Set(1, ~MIOS32_BOARD_LED_Get());
 8004770:	f002 fce2 	bl	8007138 <MIOS32_BOARD_LED_Get>
 8004774:	43c1      	mvns	r1, r0
 8004776:	2001      	movs	r0, #1
 8004778:	f002 fcca 	bl	8007110 <MIOS32_BOARD_LED_Set>
 800477c:	e7e7      	b.n	800474e <_abort+0xe>
 800477e:	bf00      	nop
 8004780:	080042e1 	.word	0x080042e1

08004784 <HardFault_Handler_c>:

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 8004784:	b510      	push	{r4, lr}
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 8004786:	6803      	ldr	r3, [r0, #0]

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 8004788:	b088      	sub	sp, #32
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 800478a:	9307      	str	r3, [sp, #28]
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 800478c:	6843      	ldr	r3, [r0, #4]
  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 800478e:	4c33      	ldr	r4, [pc, #204]	; (800485c <HardFault_Handler_c+0xd8>)
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 8004790:	9306      	str	r3, [sp, #24]
  stacked_r2 = ((unsigned long) hardfault_args[2]);
 8004792:	6883      	ldr	r3, [r0, #8]
 8004794:	9305      	str	r3, [sp, #20]
  stacked_r3 = ((unsigned long) hardfault_args[3]);
 8004796:	68c3      	ldr	r3, [r0, #12]
 8004798:	9304      	str	r3, [sp, #16]

  stacked_r12 = ((unsigned long) hardfault_args[4]);
 800479a:	6903      	ldr	r3, [r0, #16]
 800479c:	9303      	str	r3, [sp, #12]
  stacked_lr = ((unsigned long) hardfault_args[5]);
 800479e:	6943      	ldr	r3, [r0, #20]
 80047a0:	9302      	str	r3, [sp, #8]
  stacked_pc = ((unsigned long) hardfault_args[6]);
 80047a2:	6983      	ldr	r3, [r0, #24]
 80047a4:	9301      	str	r3, [sp, #4]
  stacked_psr = ((unsigned long) hardfault_args[7]);
 80047a6:	69c3      	ldr	r3, [r0, #28]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 80047a8:	4620      	mov	r0, r4
  stacked_r3 = ((unsigned long) hardfault_args[3]);

  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
 80047aa:	9300      	str	r3, [sp, #0]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 80047ac:	f001 f86c 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("!!! HARD FAULT !!!\n");
 80047b0:	482b      	ldr	r0, [pc, #172]	; (8004860 <HardFault_Handler_c+0xdc>)
 80047b2:	f001 f869 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("==================\n");
 80047b6:	4620      	mov	r0, r4
 80047b8:	f001 f866 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R0 = %08x\n", stacked_r0);
 80047bc:	9907      	ldr	r1, [sp, #28]
 80047be:	4829      	ldr	r0, [pc, #164]	; (8004864 <HardFault_Handler_c+0xe0>)
 80047c0:	f001 f862 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R1 = %08x\n", stacked_r1);
 80047c4:	9906      	ldr	r1, [sp, #24]
 80047c6:	4828      	ldr	r0, [pc, #160]	; (8004868 <HardFault_Handler_c+0xe4>)
 80047c8:	f001 f85e 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R2 = %08x\n", stacked_r2);
 80047cc:	9905      	ldr	r1, [sp, #20]
 80047ce:	4827      	ldr	r0, [pc, #156]	; (800486c <HardFault_Handler_c+0xe8>)
 80047d0:	f001 f85a 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R3 = %08x\n", stacked_r3);
 80047d4:	9904      	ldr	r1, [sp, #16]
 80047d6:	4826      	ldr	r0, [pc, #152]	; (8004870 <HardFault_Handler_c+0xec>)
 80047d8:	f001 f856 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R12 = %08x\n", stacked_r12);
 80047dc:	9903      	ldr	r1, [sp, #12]
 80047de:	4825      	ldr	r0, [pc, #148]	; (8004874 <HardFault_Handler_c+0xf0>)
 80047e0:	f001 f852 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("LR = %08x\n", stacked_lr);
 80047e4:	9902      	ldr	r1, [sp, #8]
 80047e6:	4824      	ldr	r0, [pc, #144]	; (8004878 <HardFault_Handler_c+0xf4>)
 80047e8:	f001 f84e 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PC = %08x\n", stacked_pc);
 80047ec:	9901      	ldr	r1, [sp, #4]
 80047ee:	4823      	ldr	r0, [pc, #140]	; (800487c <HardFault_Handler_c+0xf8>)
 80047f0:	f001 f84a 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PSR = %08x\n", stacked_psr);
 80047f4:	9900      	ldr	r1, [sp, #0]
 80047f6:	4822      	ldr	r0, [pc, #136]	; (8004880 <HardFault_Handler_c+0xfc>)
 80047f8:	f001 f846 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("BFAR = %08x\n", (*((volatile unsigned long *)(0xE000ED38))));
 80047fc:	4b21      	ldr	r3, [pc, #132]	; (8004884 <HardFault_Handler_c+0x100>)
 80047fe:	4822      	ldr	r0, [pc, #136]	; (8004888 <HardFault_Handler_c+0x104>)
 8004800:	6819      	ldr	r1, [r3, #0]
 8004802:	f001 f841 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("CFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED28))));
 8004806:	4b21      	ldr	r3, [pc, #132]	; (800488c <HardFault_Handler_c+0x108>)
 8004808:	4821      	ldr	r0, [pc, #132]	; (8004890 <HardFault_Handler_c+0x10c>)
 800480a:	6819      	ldr	r1, [r3, #0]
 800480c:	f001 f83c 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("HFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED2C))));
 8004810:	4b20      	ldr	r3, [pc, #128]	; (8004894 <HardFault_Handler_c+0x110>)
 8004812:	4821      	ldr	r0, [pc, #132]	; (8004898 <HardFault_Handler_c+0x114>)
 8004814:	6819      	ldr	r1, [r3, #0]
 8004816:	f001 f837 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("DFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED30))));
 800481a:	4b20      	ldr	r3, [pc, #128]	; (800489c <HardFault_Handler_c+0x118>)
 800481c:	4820      	ldr	r0, [pc, #128]	; (80048a0 <HardFault_Handler_c+0x11c>)
 800481e:	6819      	ldr	r1, [r3, #0]
 8004820:	f001 f832 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("AFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED3C))));
 8004824:	4b1f      	ldr	r3, [pc, #124]	; (80048a4 <HardFault_Handler_c+0x120>)
 8004826:	4820      	ldr	r0, [pc, #128]	; (80048a8 <HardFault_Handler_c+0x124>)
 8004828:	6819      	ldr	r1, [r3, #0]
 800482a:	f001 f82d 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>

#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 800482e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8004832:	f000 fed6 	bl	80055e2 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 8004836:	2000      	movs	r0, #0
 8004838:	f000 fed7 	bl	80055ea <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 800483c:	2000      	movs	r0, #0
 800483e:	f000 fdf5 	bl	800542c <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 8004842:	f000 fe5b 	bl	80054fc <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 8004846:	2000      	movs	r0, #0
 8004848:	4601      	mov	r1, r0
 800484a:	f000 fdf5 	bl	8005438 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("!! HARD FAULT !!");
 800484e:	4817      	ldr	r0, [pc, #92]	; (80048ac <HardFault_Handler_c+0x128>)
 8004850:	f000 fe86 	bl	8005560 <MIOS32_LCD_PrintString>
#endif

  _abort();
 8004854:	f7ff ff74 	bl	8004740 <_abort>
}
 8004858:	b008      	add	sp, #32
 800485a:	bd10      	pop	{r4, pc}
 800485c:	0800acc4 	.word	0x0800acc4
 8004860:	0800acd8 	.word	0x0800acd8
 8004864:	0800acec 	.word	0x0800acec
 8004868:	0800acf7 	.word	0x0800acf7
 800486c:	0800ad02 	.word	0x0800ad02
 8004870:	0800ad0d 	.word	0x0800ad0d
 8004874:	0800ad18 	.word	0x0800ad18
 8004878:	0800ad24 	.word	0x0800ad24
 800487c:	0800ad2f 	.word	0x0800ad2f
 8004880:	0800ad3a 	.word	0x0800ad3a
 8004884:	e000ed38 	.word	0xe000ed38
 8004888:	0800ad46 	.word	0x0800ad46
 800488c:	e000ed28 	.word	0xe000ed28
 8004890:	0800ad53 	.word	0x0800ad53
 8004894:	e000ed2c 	.word	0xe000ed2c
 8004898:	0800ad60 	.word	0x0800ad60
 800489c:	e000ed30 	.word	0xe000ed30
 80048a0:	0800ad6d 	.word	0x0800ad6d
 80048a4:	e000ed3c 	.word	0xe000ed3c
 80048a8:	0800ad7a 	.word	0x0800ad7a
 80048ac:	0800ad87 	.word	0x0800ad87

080048b0 <HardFault_Handler>:


void HardFault_Handler(void)
{
  __asm("TST LR, #4");
 80048b0:	f01e 0f04 	tst.w	lr, #4
  __asm("ITE EQ");
 80048b4:	bf0c      	ite	eq
  __asm("MRSEQ R0, MSP");
 80048b6:	f3ef 8008 	mrseq	r0, MSP
  __asm("MRSNE R0, PSP");
 80048ba:	f3ef 8009 	mrsne	r0, PSP
  __asm("B HardFault_Handler_c");
 80048be:	f7ff bf61 	b.w	8004784 <HardFault_Handler_c>
}
 80048c2:	4770      	bx	lr

080048c4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80048c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80048c6:	b085      	sub	sp, #20
 80048c8:	9303      	str	r3, [sp, #12]
 80048ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80048cc:	9002      	str	r0, [sp, #8]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 80048ce:	2048      	movs	r0, #72	; 0x48
 80048d0:	9300      	str	r3, [sp, #0]
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80048d2:	460e      	mov	r6, r1
 80048d4:	4614      	mov	r4, r2
 80048d6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 80048d8:	f000 fbfc 	bl	80050d4 <pvPortMalloc>

	if( pxNewTCB != NULL )
 80048dc:	9b00      	ldr	r3, [sp, #0]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 80048de:	4605      	mov	r5, r0

	if( pxNewTCB != NULL )
 80048e0:	2800      	cmp	r0, #0
 80048e2:	f000 809b 	beq.w	8004a1c <xTaskGenericCreate+0x158>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 80048e6:	b91b      	cbnz	r3, 80048f0 <xTaskGenericCreate+0x2c>
 80048e8:	00a0      	lsls	r0, r4, #2
 80048ea:	f000 fbf3 	bl	80050d4 <pvPortMalloc>
 80048ee:	4603      	mov	r3, r0
 80048f0:	632b      	str	r3, [r5, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 80048f2:	b91b      	cbnz	r3, 80048fc <xTaskGenericCreate+0x38>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 80048f4:	4628      	mov	r0, r5
 80048f6:	f000 fbb7 	bl	8005068 <vPortFree>
 80048fa:	e08f      	b.n	8004a1c <xTaskGenericCreate+0x158>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 80048fc:	00a2      	lsls	r2, r4, #2
 80048fe:	21a5      	movs	r1, #165	; 0xa5
 8004900:	4618      	mov	r0, r3
 8004902:	f005 fdf8 	bl	800a4f6 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 8004906:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8004908:	3c01      	subs	r4, #1
 800490a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 800490e:	f023 0307 	bic.w	r3, r3, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8004912:	4631      	mov	r1, r6
 8004914:	2210      	movs	r2, #16
 8004916:	f105 0034 	add.w	r0, r5, #52	; 0x34
 800491a:	9300      	str	r3, [sp, #0]
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 800491c:	2400      	movs	r4, #0
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 800491e:	f005 fe01 	bl	800a524 <strncpy>
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8004922:	1d2e      	adds	r6, r5, #4
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 8004924:	2f04      	cmp	r7, #4
 8004926:	bf34      	ite	cc
 8004928:	463a      	movcc	r2, r7
 800492a:	2204      	movcs	r2, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
 800492c:	62ea      	str	r2, [r5, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 800492e:	646a      	str	r2, [r5, #68]	; 0x44
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 8004930:	f885 4043 	strb.w	r4, [r5, #67]	; 0x43
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8004934:	4630      	mov	r0, r6
 8004936:	9201      	str	r2, [sp, #4]
 8004938:	f000 fa6b 	bl	8004e12 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 800493c:	f105 0018 	add.w	r0, r5, #24
 8004940:	f000 fa67 	bl	8004e12 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8004944:	9a01      	ldr	r2, [sp, #4]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004946:	9b00      	ldr	r3, [sp, #0]
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8004948:	f1c2 0205 	rsb	r2, r2, #5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800494c:	4618      	mov	r0, r3
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 800494e:	61aa      	str	r2, [r5, #24]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004950:	9902      	ldr	r1, [sp, #8]
 8004952:	9a03      	ldr	r2, [sp, #12]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8004954:	612d      	str	r5, [r5, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8004956:	626d      	str	r5, [r5, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004958:	f000 fa95 	bl	8004e86 <pxPortInitialiseStack>
 800495c:	6028      	str	r0, [r5, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
 800495e:	f000 fae3 	bl	8004f28 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8004962:	4b31      	ldr	r3, [pc, #196]	; (8004a28 <xTaskGenericCreate+0x164>)
 8004964:	681a      	ldr	r2, [r3, #0]
 8004966:	3201      	adds	r2, #1
 8004968:	601a      	str	r2, [r3, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800496a:	681b      	ldr	r3, [r3, #0]
 800496c:	2b01      	cmp	r3, #1
 800496e:	d126      	bne.n	80049be <xTaskGenericCreate+0xfa>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 8004970:	4b2e      	ldr	r3, [pc, #184]	; (8004a2c <xTaskGenericCreate+0x168>)
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8004972:	4a2f      	ldr	r2, [pc, #188]	; (8004a30 <xTaskGenericCreate+0x16c>)
		{
			uxCurrentNumberOfTasks++;
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 8004974:	601d      	str	r5, [r3, #0]
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8004976:	2314      	movs	r3, #20
 8004978:	fb03 2004 	mla	r0, r3, r4, r2

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800497c:	3401      	adds	r4, #1
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 800497e:	9201      	str	r2, [sp, #4]
 8004980:	9300      	str	r3, [sp, #0]
 8004982:	f000 fa3b 	bl	8004dfc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8004986:	2c05      	cmp	r4, #5
 8004988:	9a01      	ldr	r2, [sp, #4]
 800498a:	9b00      	ldr	r3, [sp, #0]
 800498c:	d1f4      	bne.n	8004978 <xTaskGenericCreate+0xb4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 800498e:	4b29      	ldr	r3, [pc, #164]	; (8004a34 <xTaskGenericCreate+0x170>)
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8004990:	4c29      	ldr	r4, [pc, #164]	; (8004a38 <xTaskGenericCreate+0x174>)
	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8004992:	4618      	mov	r0, r3
 8004994:	9300      	str	r3, [sp, #0]
 8004996:	f000 fa31 	bl	8004dfc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 800499a:	4620      	mov	r0, r4
 800499c:	f000 fa2e 	bl	8004dfc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 80049a0:	4826      	ldr	r0, [pc, #152]	; (8004a3c <xTaskGenericCreate+0x178>)
 80049a2:	f000 fa2b 	bl	8004dfc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 80049a6:	4826      	ldr	r0, [pc, #152]	; (8004a40 <xTaskGenericCreate+0x17c>)
 80049a8:	f000 fa28 	bl	8004dfc <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 80049ac:	4825      	ldr	r0, [pc, #148]	; (8004a44 <xTaskGenericCreate+0x180>)
 80049ae:	f000 fa25 	bl	8004dfc <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80049b2:	9b00      	ldr	r3, [sp, #0]
 80049b4:	4a24      	ldr	r2, [pc, #144]	; (8004a48 <xTaskGenericCreate+0x184>)
 80049b6:	6013      	str	r3, [r2, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80049b8:	4b24      	ldr	r3, [pc, #144]	; (8004a4c <xTaskGenericCreate+0x188>)
 80049ba:	601c      	str	r4, [r3, #0]
 80049bc:	e008      	b.n	80049d0 <xTaskGenericCreate+0x10c>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 80049be:	4b24      	ldr	r3, [pc, #144]	; (8004a50 <xTaskGenericCreate+0x18c>)
 80049c0:	681b      	ldr	r3, [r3, #0]
 80049c2:	b92b      	cbnz	r3, 80049d0 <xTaskGenericCreate+0x10c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 80049c4:	4b19      	ldr	r3, [pc, #100]	; (8004a2c <xTaskGenericCreate+0x168>)
 80049c6:	681a      	ldr	r2, [r3, #0]
 80049c8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80049ca:	42ba      	cmp	r2, r7
					{
						pxCurrentTCB = pxNewTCB;
 80049cc:	bf98      	it	ls
 80049ce:	601d      	strls	r5, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 80049d0:	4a20      	ldr	r2, [pc, #128]	; (8004a54 <xTaskGenericCreate+0x190>)
 80049d2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80049d4:	6811      	ldr	r1, [r2, #0]
 80049d6:	428b      	cmp	r3, r1
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 80049d8:	bf88      	it	hi
 80049da:	6013      	strhi	r3, [r2, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 80049dc:	4a1e      	ldr	r2, [pc, #120]	; (8004a58 <xTaskGenericCreate+0x194>)
 80049de:	6811      	ldr	r1, [r2, #0]
 80049e0:	3101      	adds	r1, #1
 80049e2:	6011      	str	r1, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 80049e4:	4a1d      	ldr	r2, [pc, #116]	; (8004a5c <xTaskGenericCreate+0x198>)
 80049e6:	6811      	ldr	r1, [r2, #0]
 80049e8:	428b      	cmp	r3, r1
 80049ea:	bf88      	it	hi
 80049ec:	6013      	strhi	r3, [r2, #0]
 80049ee:	4a10      	ldr	r2, [pc, #64]	; (8004a30 <xTaskGenericCreate+0x16c>)
 80049f0:	2014      	movs	r0, #20
 80049f2:	fb00 2003 	mla	r0, r0, r3, r2
 80049f6:	4631      	mov	r1, r6
 80049f8:	f000 fa0e 	bl	8004e18 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 80049fc:	f000 faa0 	bl	8004f40 <vPortExitCritical>
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
 8004a00:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004a02:	b103      	cbz	r3, 8004a06 <xTaskGenericCreate+0x142>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 8004a04:	601d      	str	r5, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
 8004a06:	4b12      	ldr	r3, [pc, #72]	; (8004a50 <xTaskGenericCreate+0x18c>)
 8004a08:	681b      	ldr	r3, [r3, #0]
 8004a0a:	b153      	cbz	r3, 8004a22 <xTaskGenericCreate+0x15e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8004a0c:	4b07      	ldr	r3, [pc, #28]	; (8004a2c <xTaskGenericCreate+0x168>)
 8004a0e:	681b      	ldr	r3, [r3, #0]
 8004a10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004a12:	42bb      	cmp	r3, r7
 8004a14:	d205      	bcs.n	8004a22 <xTaskGenericCreate+0x15e>
			{
				portYIELD_WITHIN_API();
 8004a16:	f000 fa7f 	bl	8004f18 <vPortYieldFromISR>
 8004a1a:	e002      	b.n	8004a22 <xTaskGenericCreate+0x15e>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004a1c:	f04f 30ff 	mov.w	r0, #4294967295
 8004a20:	e000      	b.n	8004a24 <xTaskGenericCreate+0x160>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
 8004a22:	2001      	movs	r0, #1
			}
		}
	}

	return xReturn;
}
 8004a24:	b005      	add	sp, #20
 8004a26:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004a28:	200007a0 	.word	0x200007a0
 8004a2c:	2000074c 	.word	0x2000074c
 8004a30:	200006e4 	.word	0x200006e4
 8004a34:	20000774 	.word	0x20000774
 8004a38:	20000788 	.word	0x20000788
 8004a3c:	20000750 	.word	0x20000750
 8004a40:	200006bc 	.word	0x200006bc
 8004a44:	200006d0 	.word	0x200006d0
 8004a48:	200006b0 	.word	0x200006b0
 8004a4c:	20000768 	.word	0x20000768
 8004a50:	200006b4 	.word	0x200006b4
 8004a54:	200007a4 	.word	0x200007a4
 8004a58:	20000770 	.word	0x20000770
 8004a5c:	2000076c 	.word	0x2000076c

08004a60 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8004a60:	b51f      	push	{r0, r1, r2, r3, r4, lr}
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 8004a62:	2400      	movs	r4, #0
 8004a64:	4623      	mov	r3, r4
 8004a66:	480c      	ldr	r0, [pc, #48]	; (8004a98 <vTaskStartScheduler+0x38>)
 8004a68:	490c      	ldr	r1, [pc, #48]	; (8004a9c <vTaskStartScheduler+0x3c>)
 8004a6a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004a6e:	9400      	str	r4, [sp, #0]
 8004a70:	9401      	str	r4, [sp, #4]
 8004a72:	9402      	str	r4, [sp, #8]
 8004a74:	9403      	str	r4, [sp, #12]
 8004a76:	f7ff ff25 	bl	80048c4 <xTaskGenericCreate>

	if( xReturn == pdPASS )
 8004a7a:	2801      	cmp	r0, #1
void vTaskStartScheduler( void )
{
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 8004a7c:	4603      	mov	r3, r0

	if( xReturn == pdPASS )
 8004a7e:	d109      	bne.n	8004a94 <vTaskStartScheduler+0x34>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8004a80:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004a84:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 8004a88:	4a05      	ldr	r2, [pc, #20]	; (8004aa0 <vTaskStartScheduler+0x40>)
 8004a8a:	6013      	str	r3, [r2, #0]
		xTickCount = ( portTickType ) 0;
 8004a8c:	4b05      	ldr	r3, [pc, #20]	; (8004aa4 <vTaskStartScheduler+0x44>)
 8004a8e:	601c      	str	r4, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 8004a90:	f000 fa22 	bl	8004ed8 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
 8004a94:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8004a96:	bf00      	nop
 8004a98:	08004c55 	.word	0x08004c55
 8004a9c:	0800ad98 	.word	0x0800ad98
 8004aa0:	200006b4 	.word	0x200006b4
 8004aa4:	20000764 	.word	0x20000764

08004aa8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8004aa8:	4b02      	ldr	r3, [pc, #8]	; (8004ab4 <vTaskSuspendAll+0xc>)
 8004aaa:	681a      	ldr	r2, [r3, #0]
 8004aac:	3201      	adds	r2, #1
 8004aae:	601a      	str	r2, [r3, #0]
}
 8004ab0:	4770      	bx	lr
 8004ab2:	bf00      	nop
 8004ab4:	20000748 	.word	0x20000748

08004ab8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
 8004ab8:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
 8004aba:	f000 fa35 	bl	8004f28 <vPortEnterCritical>
	{
		xTicks = xTickCount;
 8004abe:	4b03      	ldr	r3, [pc, #12]	; (8004acc <xTaskGetTickCount+0x14>)
 8004ac0:	681c      	ldr	r4, [r3, #0]
	}
	portEXIT_CRITICAL();
 8004ac2:	f000 fa3d 	bl	8004f40 <vPortExitCritical>

	return xTicks;
}
 8004ac6:	4620      	mov	r0, r4
 8004ac8:	bd10      	pop	{r4, pc}
 8004aca:	bf00      	nop
 8004acc:	20000764 	.word	0x20000764

08004ad0 <vTaskIncrementTick>:
void vTaskIncrementTick( void )
{
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004ad0:	4b26      	ldr	r3, [pc, #152]	; (8004b6c <vTaskIncrementTick+0x9c>)
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 8004ad2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004ad4:	681b      	ldr	r3, [r3, #0]
 8004ad6:	2b00      	cmp	r3, #0
 8004ad8:	d13c      	bne.n	8004b54 <vTaskIncrementTick+0x84>
	{
		++xTickCount;
 8004ada:	4b25      	ldr	r3, [pc, #148]	; (8004b70 <vTaskIncrementTick+0xa0>)
 8004adc:	681a      	ldr	r2, [r3, #0]
 8004ade:	3201      	adds	r2, #1
 8004ae0:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
 8004ae2:	681b      	ldr	r3, [r3, #0]
 8004ae4:	2b00      	cmp	r3, #0
 8004ae6:	d128      	bne.n	8004b3a <vTaskIncrementTick+0x6a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004ae8:	4a22      	ldr	r2, [pc, #136]	; (8004b74 <vTaskIncrementTick+0xa4>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004aea:	4b23      	ldr	r3, [pc, #140]	; (8004b78 <vTaskIncrementTick+0xa8>)
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004aec:	6811      	ldr	r1, [r2, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004aee:	6818      	ldr	r0, [r3, #0]
 8004af0:	6010      	str	r0, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
 8004af2:	6019      	str	r1, [r3, #0]
			xNumOfOverflows++;
 8004af4:	4b21      	ldr	r3, [pc, #132]	; (8004b7c <vTaskIncrementTick+0xac>)
 8004af6:	681a      	ldr	r2, [r3, #0]
 8004af8:	3201      	adds	r2, #1
 8004afa:	601a      	str	r2, [r3, #0]
 8004afc:	e01d      	b.n	8004b3a <vTaskIncrementTick+0x6a>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8004afe:	6839      	ldr	r1, [r7, #0]
 8004b00:	685a      	ldr	r2, [r3, #4]
 8004b02:	4291      	cmp	r1, r2
 8004b04:	d32c      	bcc.n	8004b60 <vTaskIncrementTick+0x90>
 8004b06:	1d1a      	adds	r2, r3, #4
 8004b08:	4610      	mov	r0, r2
 8004b0a:	9201      	str	r2, [sp, #4]
 8004b0c:	9300      	str	r3, [sp, #0]
 8004b0e:	f000 f9aa 	bl	8004e66 <vListRemove>
 8004b12:	9b00      	ldr	r3, [sp, #0]
 8004b14:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004b16:	b122      	cbz	r2, 8004b22 <vTaskIncrementTick+0x52>
 8004b18:	f103 0018 	add.w	r0, r3, #24
 8004b1c:	f000 f9a3 	bl	8004e66 <vListRemove>
 8004b20:	9b00      	ldr	r3, [sp, #0]
 8004b22:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8004b24:	6823      	ldr	r3, [r4, #0]
 8004b26:	9901      	ldr	r1, [sp, #4]
 8004b28:	4298      	cmp	r0, r3
 8004b2a:	bf88      	it	hi
 8004b2c:	6020      	strhi	r0, [r4, #0]
 8004b2e:	2314      	movs	r3, #20
 8004b30:	fb03 6000 	mla	r0, r3, r0, r6
 8004b34:	f000 f970 	bl	8004e18 <vListInsertEnd>
 8004b38:	e003      	b.n	8004b42 <vTaskIncrementTick+0x72>
 8004b3a:	4d0e      	ldr	r5, [pc, #56]	; (8004b74 <vTaskIncrementTick+0xa4>)
 8004b3c:	4f0c      	ldr	r7, [pc, #48]	; (8004b70 <vTaskIncrementTick+0xa0>)
 8004b3e:	4c10      	ldr	r4, [pc, #64]	; (8004b80 <vTaskIncrementTick+0xb0>)
 8004b40:	4e10      	ldr	r6, [pc, #64]	; (8004b84 <vTaskIncrementTick+0xb4>)
 8004b42:	682b      	ldr	r3, [r5, #0]
 8004b44:	681b      	ldr	r3, [r3, #0]
 8004b46:	b15b      	cbz	r3, 8004b60 <vTaskIncrementTick+0x90>
 8004b48:	682b      	ldr	r3, [r5, #0]
 8004b4a:	68db      	ldr	r3, [r3, #12]
 8004b4c:	68db      	ldr	r3, [r3, #12]
 8004b4e:	2b00      	cmp	r3, #0
 8004b50:	d1d5      	bne.n	8004afe <vTaskIncrementTick+0x2e>
 8004b52:	e005      	b.n	8004b60 <vTaskIncrementTick+0x90>
	}
	else
	{
		++uxMissedTicks;
 8004b54:	4b0c      	ldr	r3, [pc, #48]	; (8004b88 <vTaskIncrementTick+0xb8>)
 8004b56:	681a      	ldr	r2, [r3, #0]
 8004b58:	3201      	adds	r2, #1
 8004b5a:	601a      	str	r2, [r3, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
 8004b5c:	f7ff fdea 	bl	8004734 <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
 8004b60:	4b09      	ldr	r3, [pc, #36]	; (8004b88 <vTaskIncrementTick+0xb8>)
 8004b62:	681b      	ldr	r3, [r3, #0]
 8004b64:	b90b      	cbnz	r3, 8004b6a <vTaskIncrementTick+0x9a>
		{
			vApplicationTickHook();
 8004b66:	f7ff fde5 	bl	8004734 <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8004b6a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004b6c:	20000748 	.word	0x20000748
 8004b70:	20000764 	.word	0x20000764
 8004b74:	200006b0 	.word	0x200006b0
 8004b78:	20000768 	.word	0x20000768
 8004b7c:	200006ac 	.word	0x200006ac
 8004b80:	2000076c 	.word	0x2000076c
 8004b84:	200006e4 	.word	0x200006e4
 8004b88:	200006a8 	.word	0x200006a8

08004b8c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8004b8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
 8004b8e:	f000 f9cb 	bl	8004f28 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8004b92:	4b28      	ldr	r3, [pc, #160]	; (8004c34 <xTaskResumeAll+0xa8>)
 8004b94:	681a      	ldr	r2, [r3, #0]
 8004b96:	3a01      	subs	r2, #1
 8004b98:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004b9a:	681d      	ldr	r5, [r3, #0]
 8004b9c:	2d00      	cmp	r5, #0
 8004b9e:	d144      	bne.n	8004c2a <xTaskResumeAll+0x9e>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 8004ba0:	4b25      	ldr	r3, [pc, #148]	; (8004c38 <xTaskResumeAll+0xac>)
 8004ba2:	681c      	ldr	r4, [r3, #0]
 8004ba4:	2c00      	cmp	r4, #0
 8004ba6:	d041      	beq.n	8004c2c <xTaskResumeAll+0xa0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8004ba8:	4f24      	ldr	r7, [pc, #144]	; (8004c3c <xTaskResumeAll+0xb0>)
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
 8004baa:	4e25      	ldr	r6, [pc, #148]	; (8004c40 <xTaskResumeAll+0xb4>)
 8004bac:	e01b      	b.n	8004be6 <xTaskResumeAll+0x5a>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
 8004bae:	f104 0018 	add.w	r0, r4, #24
 8004bb2:	f000 f958 	bl	8004e66 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 8004bb6:	1d21      	adds	r1, r4, #4
 8004bb8:	4608      	mov	r0, r1
 8004bba:	9101      	str	r1, [sp, #4]
 8004bbc:	f000 f953 	bl	8004e66 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8004bc0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004bc2:	6833      	ldr	r3, [r6, #0]
 8004bc4:	9901      	ldr	r1, [sp, #4]
 8004bc6:	4298      	cmp	r0, r3
 8004bc8:	4b1e      	ldr	r3, [pc, #120]	; (8004c44 <xTaskResumeAll+0xb8>)
 8004bca:	bf88      	it	hi
 8004bcc:	6030      	strhi	r0, [r6, #0]
 8004bce:	2214      	movs	r2, #20
 8004bd0:	fb02 3000 	mla	r0, r2, r0, r3
 8004bd4:	f000 f920 	bl	8004e18 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004bd8:	4a1b      	ldr	r2, [pc, #108]	; (8004c48 <xTaskResumeAll+0xbc>)
 8004bda:	6813      	ldr	r3, [r2, #0]
 8004bdc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004bde:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
 8004be0:	429a      	cmp	r2, r3
 8004be2:	bf28      	it	cs
 8004be4:	2501      	movcs	r5, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8004be6:	683b      	ldr	r3, [r7, #0]
 8004be8:	b11b      	cbz	r3, 8004bf2 <xTaskResumeAll+0x66>
 8004bea:	68fb      	ldr	r3, [r7, #12]
 8004bec:	68dc      	ldr	r4, [r3, #12]
 8004bee:	2c00      	cmp	r4, #0
 8004bf0:	d1dd      	bne.n	8004bae <xTaskResumeAll+0x22>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 8004bf2:	4c16      	ldr	r4, [pc, #88]	; (8004c4c <xTaskResumeAll+0xc0>)
 8004bf4:	6823      	ldr	r3, [r4, #0]
 8004bf6:	b92b      	cbnz	r3, 8004c04 <xTaskResumeAll+0x78>
 8004bf8:	e008      	b.n	8004c0c <xTaskResumeAll+0x80>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
 8004bfa:	f7ff ff69 	bl	8004ad0 <vTaskIncrementTick>
						--uxMissedTicks;
 8004bfe:	6823      	ldr	r3, [r4, #0]
 8004c00:	3b01      	subs	r3, #1
 8004c02:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 8004c04:	6823      	ldr	r3, [r4, #0]
 8004c06:	2b00      	cmp	r3, #0
 8004c08:	d1f7      	bne.n	8004bfa <xTaskResumeAll+0x6e>
 8004c0a:	e007      	b.n	8004c1c <xTaskResumeAll+0x90>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8004c0c:	2d01      	cmp	r5, #1
 8004c0e:	d005      	beq.n	8004c1c <xTaskResumeAll+0x90>
 8004c10:	4a0f      	ldr	r2, [pc, #60]	; (8004c50 <xTaskResumeAll+0xc4>)
 8004c12:	6812      	ldr	r2, [r2, #0]
 8004c14:	2a01      	cmp	r2, #1
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8004c16:	bf18      	it	ne
 8004c18:	461c      	movne	r4, r3
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8004c1a:	d107      	bne.n	8004c2c <xTaskResumeAll+0xa0>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 8004c1c:	4b0c      	ldr	r3, [pc, #48]	; (8004c50 <xTaskResumeAll+0xc4>)
 8004c1e:	2200      	movs	r2, #0
 8004c20:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8004c22:	f000 f979 	bl	8004f18 <vPortYieldFromISR>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 8004c26:	2401      	movs	r4, #1
 8004c28:	e000      	b.n	8004c2c <xTaskResumeAll+0xa0>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8004c2a:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
 8004c2c:	f000 f988 	bl	8004f40 <vPortExitCritical>

	return xAlreadyYielded;
}
 8004c30:	4620      	mov	r0, r4
 8004c32:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004c34:	20000748 	.word	0x20000748
 8004c38:	200007a0 	.word	0x200007a0
 8004c3c:	20000750 	.word	0x20000750
 8004c40:	2000076c 	.word	0x2000076c
 8004c44:	200006e4 	.word	0x200006e4
 8004c48:	2000074c 	.word	0x2000074c
 8004c4c:	200006a8 	.word	0x200006a8
 8004c50:	2000079c 	.word	0x2000079c

08004c54 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8004c54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8004c56:	4e15      	ldr	r6, [pc, #84]	; (8004cac <prvIdleTask+0x58>)
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004c58:	4d15      	ldr	r5, [pc, #84]	; (8004cb0 <prvIdleTask+0x5c>)

				portENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
 8004c5a:	4f16      	ldr	r7, [pc, #88]	; (8004cb4 <prvIdleTask+0x60>)
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8004c5c:	6833      	ldr	r3, [r6, #0]
 8004c5e:	b1e3      	cbz	r3, 8004c9a <prvIdleTask+0x46>
		{
			vTaskSuspendAll();
 8004c60:	f7ff ff22 	bl	8004aa8 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004c64:	682c      	ldr	r4, [r5, #0]
			xTaskResumeAll();
 8004c66:	f7ff ff91 	bl	8004b8c <xTaskResumeAll>

			if( !xListIsEmpty )
 8004c6a:	b1b4      	cbz	r4, 8004c9a <prvIdleTask+0x46>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
 8004c6c:	f000 f95c 	bl	8004f28 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8004c70:	682c      	ldr	r4, [r5, #0]
 8004c72:	b10c      	cbz	r4, 8004c78 <prvIdleTask+0x24>
 8004c74:	68eb      	ldr	r3, [r5, #12]
 8004c76:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8004c78:	1d20      	adds	r0, r4, #4
 8004c7a:	f000 f8f4 	bl	8004e66 <vListRemove>
					--uxCurrentNumberOfTasks;
 8004c7e:	683b      	ldr	r3, [r7, #0]
 8004c80:	3b01      	subs	r3, #1
 8004c82:	603b      	str	r3, [r7, #0]
					--uxTasksDeleted;
 8004c84:	6833      	ldr	r3, [r6, #0]
 8004c86:	3b01      	subs	r3, #1
 8004c88:	6033      	str	r3, [r6, #0]
				}
				portEXIT_CRITICAL();
 8004c8a:	f000 f959 	bl	8004f40 <vPortExitCritical>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8004c8e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004c90:	f000 f9ea 	bl	8005068 <vPortFree>
		vPortFree( pxTCB );
 8004c94:	4620      	mov	r0, r4
 8004c96:	f000 f9e7 	bl	8005068 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8004c9a:	4a07      	ldr	r2, [pc, #28]	; (8004cb8 <prvIdleTask+0x64>)
 8004c9c:	6813      	ldr	r3, [r2, #0]
 8004c9e:	2b01      	cmp	r3, #1
 8004ca0:	d901      	bls.n	8004ca6 <prvIdleTask+0x52>
			{
				taskYIELD();
 8004ca2:	f000 f939 	bl	8004f18 <vPortYieldFromISR>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8004ca6:	f7ff fd46 	bl	8004736 <vApplicationIdleHook>
		}
		#endif
	}
 8004caa:	e7d7      	b.n	8004c5c <prvIdleTask+0x8>
 8004cac:	200006b8 	.word	0x200006b8
 8004cb0:	200006bc 	.word	0x200006bc
 8004cb4:	200007a0 	.word	0x200007a0
 8004cb8:	200006e4 	.word	0x200006e4

08004cbc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8004cbc:	b570      	push	{r4, r5, r6, lr}
 8004cbe:	4604      	mov	r4, r0
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
 8004cc0:	b1c0      	cbz	r0, 8004cf4 <vTaskDelay+0x38>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8004cc2:	4e0e      	ldr	r6, [pc, #56]	; (8004cfc <vTaskDelay+0x40>)
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
 8004cc4:	f7ff fef0 	bl	8004aa8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8004cc8:	6835      	ldr	r5, [r6, #0]
 8004cca:	1965      	adds	r5, r4, r5

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004ccc:	4c0c      	ldr	r4, [pc, #48]	; (8004d00 <vTaskDelay+0x44>)
 8004cce:	6820      	ldr	r0, [r4, #0]
 8004cd0:	3004      	adds	r0, #4
 8004cd2:	f000 f8c8 	bl	8004e66 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8004cd6:	6823      	ldr	r3, [r4, #0]
 8004cd8:	605d      	str	r5, [r3, #4]

				if( xTimeToWake < xTickCount )
 8004cda:	6833      	ldr	r3, [r6, #0]
 8004cdc:	429d      	cmp	r5, r3
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004cde:	bf34      	ite	cc
 8004ce0:	4b08      	ldrcc	r3, [pc, #32]	; (8004d04 <vTaskDelay+0x48>)
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004ce2:	4b09      	ldrcs	r3, [pc, #36]	; (8004d08 <vTaskDelay+0x4c>)
 8004ce4:	6818      	ldr	r0, [r3, #0]
 8004ce6:	6821      	ldr	r1, [r4, #0]
 8004ce8:	3104      	adds	r1, #4
 8004cea:	f000 f8a2 	bl	8004e32 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
 8004cee:	f7ff ff4d 	bl	8004b8c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 8004cf2:	b908      	cbnz	r0, 8004cf8 <vTaskDelay+0x3c>
		{
			portYIELD_WITHIN_API();
 8004cf4:	f000 f910 	bl	8004f18 <vPortYieldFromISR>
		}
	}
 8004cf8:	bd70      	pop	{r4, r5, r6, pc}
 8004cfa:	bf00      	nop
 8004cfc:	20000764 	.word	0x20000764
 8004d00:	2000074c 	.word	0x2000074c
 8004d04:	20000768 	.word	0x20000768
 8004d08:	200006b0 	.word	0x200006b0

08004d0c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8004d0c:	b538      	push	{r3, r4, r5, lr}
 8004d0e:	460c      	mov	r4, r1
 8004d10:	4605      	mov	r5, r0
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
 8004d12:	f7ff fec9 	bl	8004aa8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
 8004d16:	4a17      	ldr	r2, [pc, #92]	; (8004d74 <vTaskDelayUntil+0x68>)
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004d18:	682b      	ldr	r3, [r5, #0]

			if( xTickCount < *pxPreviousWakeTime )
 8004d1a:	6811      	ldr	r1, [r2, #0]
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004d1c:	18e4      	adds	r4, r4, r3

			if( xTickCount < *pxPreviousWakeTime )
 8004d1e:	4299      	cmp	r1, r3
 8004d20:	d202      	bcs.n	8004d28 <vTaskDelayUntil+0x1c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 8004d22:	429c      	cmp	r4, r3
 8004d24:	d208      	bcs.n	8004d38 <vTaskDelayUntil+0x2c>
 8004d26:	e001      	b.n	8004d2c <vTaskDelayUntil+0x20>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 8004d28:	429c      	cmp	r4, r3
 8004d2a:	d307      	bcc.n	8004d3c <vTaskDelayUntil+0x30>
 8004d2c:	6813      	ldr	r3, [r2, #0]
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8004d2e:	429c      	cmp	r4, r3
 8004d30:	bf94      	ite	ls
 8004d32:	2300      	movls	r3, #0
 8004d34:	2301      	movhi	r3, #1
 8004d36:	e002      	b.n	8004d3e <vTaskDelayUntil+0x32>
 8004d38:	2300      	movs	r3, #0
 8004d3a:	e000      	b.n	8004d3e <vTaskDelayUntil+0x32>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
 8004d3c:	2301      	movs	r3, #1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8004d3e:	602c      	str	r4, [r5, #0]

			if( xShouldDelay )
 8004d40:	b18b      	cbz	r3, 8004d66 <vTaskDelayUntil+0x5a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d42:	4d0d      	ldr	r5, [pc, #52]	; (8004d78 <vTaskDelayUntil+0x6c>)
 8004d44:	6828      	ldr	r0, [r5, #0]
 8004d46:	3004      	adds	r0, #4
 8004d48:	f000 f88d 	bl	8004e66 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8004d4c:	682b      	ldr	r3, [r5, #0]
 8004d4e:	605c      	str	r4, [r3, #4]

				if( xTimeToWake < xTickCount )
 8004d50:	4b08      	ldr	r3, [pc, #32]	; (8004d74 <vTaskDelayUntil+0x68>)
 8004d52:	681b      	ldr	r3, [r3, #0]
 8004d54:	429c      	cmp	r4, r3
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d56:	bf34      	ite	cc
 8004d58:	4b08      	ldrcc	r3, [pc, #32]	; (8004d7c <vTaskDelayUntil+0x70>)
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d5a:	4b09      	ldrcs	r3, [pc, #36]	; (8004d80 <vTaskDelayUntil+0x74>)
 8004d5c:	6818      	ldr	r0, [r3, #0]
 8004d5e:	6829      	ldr	r1, [r5, #0]
 8004d60:	3104      	adds	r1, #4
 8004d62:	f000 f866 	bl	8004e32 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8004d66:	f7ff ff11 	bl	8004b8c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 8004d6a:	b908      	cbnz	r0, 8004d70 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
 8004d6c:	f000 f8d4 	bl	8004f18 <vPortYieldFromISR>
		}
	}
 8004d70:	bd38      	pop	{r3, r4, r5, pc}
 8004d72:	bf00      	nop
 8004d74:	20000764 	.word	0x20000764
 8004d78:	2000074c 	.word	0x2000074c
 8004d7c:	20000768 	.word	0x20000768
 8004d80:	200006b0 	.word	0x200006b0

08004d84 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8004d84:	4b18      	ldr	r3, [pc, #96]	; (8004de8 <vTaskSwitchContext+0x64>)

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8004d86:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8004d88:	681b      	ldr	r3, [r3, #0]
 8004d8a:	b133      	cbz	r3, 8004d9a <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8004d8c:	2201      	movs	r2, #1
 8004d8e:	4b17      	ldr	r3, [pc, #92]	; (8004dec <vTaskSwitchContext+0x68>)
 8004d90:	e028      	b.n	8004de4 <vTaskSwitchContext+0x60>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
 8004d92:	6818      	ldr	r0, [r3, #0]
 8004d94:	3801      	subs	r0, #1
 8004d96:	6018      	str	r0, [r3, #0]
 8004d98:	e002      	b.n	8004da0 <vTaskSwitchContext+0x1c>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8004d9a:	4b15      	ldr	r3, [pc, #84]	; (8004df0 <vTaskSwitchContext+0x6c>)
 8004d9c:	4915      	ldr	r1, [pc, #84]	; (8004df4 <vTaskSwitchContext+0x70>)
 8004d9e:	2214      	movs	r2, #20
 8004da0:	f8d3 c000 	ldr.w	ip, [r3]
 8004da4:	4813      	ldr	r0, [pc, #76]	; (8004df4 <vTaskSwitchContext+0x70>)
 8004da6:	fb02 fc0c 	mul.w	ip, r2, ip
 8004daa:	f851 400c 	ldr.w	r4, [r1, ip]
 8004dae:	2c00      	cmp	r4, #0
 8004db0:	d0ef      	beq.n	8004d92 <vTaskSwitchContext+0xe>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8004db2:	4b0f      	ldr	r3, [pc, #60]	; (8004df0 <vTaskSwitchContext+0x6c>)
 8004db4:	f04f 0c14 	mov.w	ip, #20
 8004db8:	6819      	ldr	r1, [r3, #0]
 8004dba:	fb0c fc01 	mul.w	ip, ip, r1
 8004dbe:	eb00 030c 	add.w	r3, r0, ip
 8004dc2:	685a      	ldr	r2, [r3, #4]
 8004dc4:	f10c 0c08 	add.w	ip, ip, #8
 8004dc8:	6852      	ldr	r2, [r2, #4]
 8004dca:	4460      	add	r0, ip
 8004dcc:	4282      	cmp	r2, r0
 8004dce:	605a      	str	r2, [r3, #4]
 8004dd0:	bf04      	itt	eq
 8004dd2:	6852      	ldreq	r2, [r2, #4]
 8004dd4:	605a      	streq	r2, [r3, #4]
 8004dd6:	4b07      	ldr	r3, [pc, #28]	; (8004df4 <vTaskSwitchContext+0x70>)
 8004dd8:	2214      	movs	r2, #20
 8004dda:	fb02 3101 	mla	r1, r2, r1, r3
 8004dde:	684b      	ldr	r3, [r1, #4]
 8004de0:	68da      	ldr	r2, [r3, #12]
 8004de2:	4b05      	ldr	r3, [pc, #20]	; (8004df8 <vTaskSwitchContext+0x74>)
 8004de4:	601a      	str	r2, [r3, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
 8004de6:	bd10      	pop	{r4, pc}
 8004de8:	20000748 	.word	0x20000748
 8004dec:	2000079c 	.word	0x2000079c
 8004df0:	2000076c 	.word	0x2000076c
 8004df4:	200006e4 	.word	0x200006e4
 8004df8:	2000074c 	.word	0x2000074c

08004dfc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004dfc:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004e00:	f04f 32ff 	mov.w	r2, #4294967295
 8004e04:	6082      	str	r2, [r0, #8]
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004e06:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8004e08:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8004e0a:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = 0;
 8004e0c:	2300      	movs	r3, #0
 8004e0e:	6003      	str	r3, [r0, #0]
}
 8004e10:	4770      	bx	lr

08004e12 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8004e12:	2300      	movs	r3, #0
 8004e14:	6103      	str	r3, [r0, #16]
}
 8004e16:	4770      	bx	lr

08004e18 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8004e18:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004e1a:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8004e1c:	608b      	str	r3, [r1, #8]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004e1e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004e20:	685a      	ldr	r2, [r3, #4]
 8004e22:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004e24:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004e26:	6803      	ldr	r3, [r0, #0]

	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8004e28:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004e2a:	3301      	adds	r3, #1
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004e2c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8004e2e:	6003      	str	r3, [r0, #0]
}
 8004e30:	4770      	bx	lr

08004e32 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8004e32:	680a      	ldr	r2, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004e34:	f1b2 3fff 	cmp.w	r2, #4294967295
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8004e38:	bf0c      	ite	eq
 8004e3a:	6903      	ldreq	r3, [r0, #16]
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004e3c:	f100 0308 	addne.w	r3, r0, #8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004e40:	d101      	bne.n	8004e46 <vListInsert+0x14>
 8004e42:	e006      	b.n	8004e52 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004e44:	685b      	ldr	r3, [r3, #4]
 8004e46:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8004e4a:	f8dc c000 	ldr.w	ip, [ip]
 8004e4e:	4594      	cmp	ip, r2
 8004e50:	d9f8      	bls.n	8004e44 <vListInsert+0x12>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004e52:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004e54:	6108      	str	r0, [r1, #16]
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004e56:	6091      	str	r1, [r2, #8]
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004e58:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004e5a:	6059      	str	r1, [r3, #4]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8004e5c:	608b      	str	r3, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004e5e:	6803      	ldr	r3, [r0, #0]
 8004e60:	3301      	adds	r3, #1
 8004e62:	6003      	str	r3, [r0, #0]
}
 8004e64:	4770      	bx	lr

08004e66 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004e66:	6843      	ldr	r3, [r0, #4]
 8004e68:	6882      	ldr	r2, [r0, #8]
 8004e6a:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8004e6c:	6882      	ldr	r2, [r0, #8]
 8004e6e:	6053      	str	r3, [r2, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8004e70:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8004e72:	6859      	ldr	r1, [r3, #4]
 8004e74:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8004e76:	bf08      	it	eq
 8004e78:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8004e7a:	2200      	movs	r2, #0
 8004e7c:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8004e7e:	681a      	ldr	r2, [r3, #0]
 8004e80:	3a01      	subs	r2, #1
 8004e82:	601a      	str	r2, [r3, #0]
}
 8004e84:	4770      	bx	lr

08004e86 <pxPortInitialiseStack>:
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8004e86:	1f03      	subs	r3, r0, #4
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8004e88:	f04f 7c80 	mov.w	ip, #16777216	; 0x1000000
 8004e8c:	f840 cc04 	str.w	ip, [r0, #-4]
	pxTopOfStack--;
 8004e90:	1f18      	subs	r0, r3, #4
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8004e92:	f843 1c04 	str.w	r1, [r3, #-4]
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
 8004e96:	2100      	movs	r1, #0
 8004e98:	f840 1c04 	str.w	r1, [r0, #-4]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8004e9c:	f840 2c18 	str.w	r2, [r0, #-24]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8004ea0:	f1a3 003c 	sub.w	r0, r3, #60	; 0x3c

	return pxTopOfStack;
}
 8004ea4:	4770      	bx	lr
	...

08004ea8 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8004ea8:	4b06      	ldr	r3, [pc, #24]	; (8004ec4 <pxCurrentTCBConst2>)
 8004eaa:	6819      	ldr	r1, [r3, #0]
 8004eac:	6808      	ldr	r0, [r1, #0]
 8004eae:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004eb2:	f380 8809 	msr	PSP, r0
 8004eb6:	f04f 0000 	mov.w	r0, #0
 8004eba:	f380 8811 	msr	BASEPRI, r0
 8004ebe:	f04e 0e0d 	orr.w	lr, lr, #13
 8004ec2:	4770      	bx	lr

08004ec4 <pxCurrentTCBConst2>:
 8004ec4:	2000074c 	.word	0x2000074c

08004ec8 <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8004ec8:	4802      	ldr	r0, [pc, #8]	; (8004ed4 <vPortStartFirstTask+0xc>)
 8004eca:	6800      	ldr	r0, [r0, #0]
 8004ecc:	6800      	ldr	r0, [r0, #0]
 8004ece:	f380 8808 	msr	MSP, r0
 8004ed2:	df00      	svc	0
 8004ed4:	e000ed08 	.word	0xe000ed08

08004ed8 <xPortStartScheduler>:
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004ed8:	4b0b      	ldr	r3, [pc, #44]	; (8004f08 <xPortStartScheduler+0x30>)

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8004eda:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004edc:	681a      	ldr	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004ede:	2400      	movs	r4, #0
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004ee0:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8004ee4:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8004ee6:	681a      	ldr	r2, [r3, #0]
 8004ee8:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8004eec:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004eee:	4a07      	ldr	r2, [pc, #28]	; (8004f0c <xPortStartScheduler+0x34>)
 8004ef0:	4b07      	ldr	r3, [pc, #28]	; (8004f10 <xPortStartScheduler+0x38>)
 8004ef2:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8004ef4:	2207      	movs	r2, #7
 8004ef6:	3b04      	subs	r3, #4
 8004ef8:	601a      	str	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004efa:	4b06      	ldr	r3, [pc, #24]	; (8004f14 <xPortStartScheduler+0x3c>)
 8004efc:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8004efe:	f7ff ffe3 	bl	8004ec8 <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 8004f02:	4620      	mov	r0, r4
 8004f04:	bd10      	pop	{r4, pc}
 8004f06:	bf00      	nop
 8004f08:	e000ed20 	.word	0xe000ed20
 8004f0c:	0001193f 	.word	0x0001193f
 8004f10:	e000e014 	.word	0xe000e014
 8004f14:	20000000 	.word	0x20000000

08004f18 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004f18:	4b02      	ldr	r3, [pc, #8]	; (8004f24 <vPortYieldFromISR+0xc>)
 8004f1a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004f1e:	601a      	str	r2, [r3, #0]
}
 8004f20:	4770      	bx	lr
 8004f22:	bf00      	nop
 8004f24:	e000ed04 	.word	0xe000ed04

08004f28 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
 8004f28:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004f2c:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8004f30:	4b02      	ldr	r3, [pc, #8]	; (8004f3c <vPortEnterCritical+0x14>)
 8004f32:	681a      	ldr	r2, [r3, #0]
 8004f34:	3201      	adds	r2, #1
 8004f36:	601a      	str	r2, [r3, #0]
}
 8004f38:	4770      	bx	lr
 8004f3a:	bf00      	nop
 8004f3c:	20000000 	.word	0x20000000

08004f40 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 8004f40:	4a04      	ldr	r2, [pc, #16]	; (8004f54 <vPortExitCritical+0x14>)
 8004f42:	6813      	ldr	r3, [r2, #0]
 8004f44:	3b01      	subs	r3, #1
 8004f46:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004f48:	b91b      	cbnz	r3, 8004f52 <vPortExitCritical+0x12>
	{
		portENABLE_INTERRUPTS();
 8004f4a:	f04f 0000 	mov.w	r0, #0
 8004f4e:	f380 8811 	msr	BASEPRI, r0
	}
}
 8004f52:	4770      	bx	lr
 8004f54:	20000000 	.word	0x20000000

08004f58 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8004f58:	f3ef 8009 	mrs	r0, PSP
 8004f5c:	4b0c      	ldr	r3, [pc, #48]	; (8004f90 <pxCurrentTCBConst>)
 8004f5e:	681a      	ldr	r2, [r3, #0]
 8004f60:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004f64:	6010      	str	r0, [r2, #0]
 8004f66:	e92d 4008 	stmdb	sp!, {r3, lr}
 8004f6a:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004f6e:	f380 8811 	msr	BASEPRI, r0
 8004f72:	f7ff ff07 	bl	8004d84 <vTaskSwitchContext>
 8004f76:	f04f 0000 	mov.w	r0, #0
 8004f7a:	f380 8811 	msr	BASEPRI, r0
 8004f7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8004f82:	6819      	ldr	r1, [r3, #0]
 8004f84:	6808      	ldr	r0, [r1, #0]
 8004f86:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004f8a:	f380 8809 	msr	PSP, r0
 8004f8e:	4770      	bx	lr

08004f90 <pxCurrentTCBConst>:
 8004f90:	2000074c 	.word	0x2000074c

08004f94 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8004f94:	b508      	push	{r3, lr}
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004f96:	4b07      	ldr	r3, [pc, #28]	; (8004fb4 <xPortSysTickHandler+0x20>)
 8004f98:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004f9c:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8004f9e:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004fa2:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8004fa6:	f7ff fd93 	bl	8004ad0 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8004faa:	f04f 0000 	mov.w	r0, #0
 8004fae:	f380 8811 	msr	BASEPRI, r0
}
 8004fb2:	bd08      	pop	{r3, pc}
 8004fb4:	e000ed04 	.word	0xe000ed04

08004fb8 <umm_make_new_block>:

// ----------------------------------------------------------------------------

static void umm_make_new_block( unsigned short int c,
                                unsigned short int blocks,
                                unsigned short int freemask ) {
 8004fb8:	b5f0      	push	{r4, r5, r6, r7, lr}

     UMM_NBLOCK(c+blocks) = UMM_NBLOCK(c) & UMM_BLOCKNO_MASK;
 8004fba:	240c      	movs	r4, #12
 8004fbc:	fb04 fc00 	mul.w	ip, r4, r0
 8004fc0:	1809      	adds	r1, r1, r0
 8004fc2:	4b0b      	ldr	r3, [pc, #44]	; (8004ff0 <umm_make_new_block+0x38>)
 8004fc4:	fb04 f501 	mul.w	r5, r4, r1
 8004fc8:	f833 600c 	ldrh.w	r6, [r3, ip]
 8004fcc:	195f      	adds	r7, r3, r5
 8004fce:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
 8004fd2:	535e      	strh	r6, [r3, r5]
     UMM_PBLOCK(c+blocks) = c;
 8004fd4:	8078      	strh	r0, [r7, #2]

     UMM_PBLOCK(UMM_NBLOCK(c) & UMM_BLOCKNO_MASK) = (c+blocks);
 8004fd6:	f833 000c 	ldrh.w	r0, [r3, ip]
 8004fda:	b289      	uxth	r1, r1
 8004fdc:	0440      	lsls	r0, r0, #17
 8004fde:	0c40      	lsrs	r0, r0, #17
 8004fe0:	fb04 3400 	mla	r4, r4, r0, r3
 8004fe4:	8061      	strh	r1, [r4, #2]
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
 8004fe6:	ea42 0101 	orr.w	r1, r2, r1
 8004fea:	f823 100c 	strh.w	r1, [r3, ip]
}
 8004fee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004ff0:	20000c3c 	.word	0x20000c3c

08004ff4 <umm_disconnect_from_free_list>:
// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 8004ff4:	210c      	movs	r1, #12
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
}

// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
 8004ff6:	b510      	push	{r4, lr}
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 8004ff8:	4348      	muls	r0, r1
 8004ffa:	4b0a      	ldr	r3, [pc, #40]	; (8005024 <umm_disconnect_from_free_list+0x30>)
 8004ffc:	181a      	adds	r2, r3, r0
 8004ffe:	f8b2 c006 	ldrh.w	ip, [r2, #6]
 8005002:	8894      	ldrh	r4, [r2, #4]
 8005004:	fb01 3c0c 	mla	ip, r1, ip, r3
 8005008:	f8ac 4004 	strh.w	r4, [ip, #4]
    UMM_PFREE(UMM_NFREE(c)) = UMM_PFREE(c);
 800500c:	f8b2 c004 	ldrh.w	ip, [r2, #4]
 8005010:	88d2      	ldrh	r2, [r2, #6]
 8005012:	fb01 310c 	mla	r1, r1, ip, r3
 8005016:	80ca      	strh	r2, [r1, #6]

    // And clear the free block indicator

    UMM_NBLOCK(c) &= (~UMM_FREELIST_MASK);
 8005018:	5a1a      	ldrh	r2, [r3, r0]
 800501a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800501e:	521a      	strh	r2, [r3, r0]
}
 8005020:	bd10      	pop	{r4, pc}
 8005022:	bf00      	nop
 8005024:	20000c3c 	.word	0x20000c3c

08005028 <umm_assimilate_up>:

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 8005028:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 800502a:	250c      	movs	r5, #12
 800502c:	fb05 f600 	mul.w	r6, r5, r0
 8005030:	4c0c      	ldr	r4, [pc, #48]	; (8005064 <umm_assimilate_up+0x3c>)

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 8005032:	4607      	mov	r7, r0

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 8005034:	5ba0      	ldrh	r0, [r4, r6]
 8005036:	fb05 f300 	mul.w	r3, r5, r0
 800503a:	5ee3      	ldrsh	r3, [r4, r3]
 800503c:	2b00      	cmp	r3, #0
 800503e:	da0f      	bge.n	8005060 <umm_assimilate_up+0x38>

    DBG_LOG_DEBUG( "Assimilate up to next block, which is FREE\n" );

    // Disconnect the next block from the FREE list

    umm_disconnect_from_free_list( UMM_NBLOCK(c) );
 8005040:	f7ff ffd8 	bl	8004ff4 <umm_disconnect_from_free_list>

    // Assimilate the next block with this one

    UMM_PBLOCK(UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK) = c;
 8005044:	5ba3      	ldrh	r3, [r4, r6]
 8005046:	436b      	muls	r3, r5
 8005048:	5ae3      	ldrh	r3, [r4, r3]
 800504a:	045b      	lsls	r3, r3, #17
 800504c:	0c5b      	lsrs	r3, r3, #17
 800504e:	fb05 4303 	mla	r3, r5, r3, r4
 8005052:	805f      	strh	r7, [r3, #2]
    UMM_NBLOCK(c) = UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK;
 8005054:	5ba3      	ldrh	r3, [r4, r6]
 8005056:	435d      	muls	r5, r3
 8005058:	5b63      	ldrh	r3, [r4, r5]
 800505a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800505e:	53a3      	strh	r3, [r4, r6]
  } 
}
 8005060:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005062:	bf00      	nop
 8005064:	20000c3c 	.word	0x20000c3c

08005068 <vPortFree>:
    return( UMM_PBLOCK(c) );
}

// ----------------------------------------------------------------------------

void umm_free( void *ptr ) {
 8005068:	b570      	push	{r4, r5, r6, lr}
 800506a:	4606      	mov	r6, r0

  unsigned short int c;

  // If we're being asked to free a NULL pointer, well that's just silly!

  if( (void *)0 == ptr ) {
 800506c:	2800      	cmp	r0, #0
 800506e:	d02e      	beq.n	80050ce <vPortFree+0x66>
  //
  UMM_CRITICAL_ENTRY();

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 8005070:	4c17      	ldr	r4, [pc, #92]	; (80050d0 <vPortFree+0x68>)
 8005072:	250c      	movs	r5, #12
 8005074:	1b36      	subs	r6, r6, r4
  // NOTE:  See the new umm_info() function that you can use to see if a ptr is
  //        on the free list!

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 8005076:	f7ff fd17 	bl	8004aa8 <vTaskSuspendAll>

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 800507a:	fbb6 f6f5 	udiv	r6, r6, r5
 800507e:	b2b6      	uxth	r6, r6

  DBG_LOG_DEBUG( "Freeing block %6d\n", c );

  // Now let's assimilate this block with the next one if possible.

  umm_assimilate_up( c );
 8005080:	4630      	mov	r0, r6
 8005082:	f7ff ffd1 	bl	8005028 <umm_assimilate_up>

  // Then assimilate with the previous block if possible

  if( UMM_NBLOCK(UMM_PBLOCK(c)) & UMM_FREELIST_MASK ) {
 8005086:	fb05 f306 	mul.w	r3, r5, r6
 800508a:	18e2      	adds	r2, r4, r3
 800508c:	8850      	ldrh	r0, [r2, #2]
 800508e:	4368      	muls	r0, r5
 8005090:	5e21      	ldrsh	r1, [r4, r0]
 8005092:	2900      	cmp	r1, #0
 8005094:	da0b      	bge.n	80050ae <vPortFree+0x46>

// ----------------------------------------------------------------------------

static unsigned short int umm_assimilate_down( unsigned short int c, unsigned short int freemask ) {

    UMM_NBLOCK(UMM_PBLOCK(c)) = UMM_NBLOCK(c) | freemask;
 8005096:	5ae1      	ldrh	r1, [r4, r3]
 8005098:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 800509c:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 80050a0:	5221      	strh	r1, [r4, r0]
    UMM_PBLOCK(UMM_NBLOCK(c)) = UMM_PBLOCK(c);
 80050a2:	5ae3      	ldrh	r3, [r4, r3]
 80050a4:	8852      	ldrh	r2, [r2, #2]
 80050a6:	fb05 4403 	mla	r4, r5, r3, r4
 80050aa:	8062      	strh	r2, [r4, #2]
 80050ac:	e00d      	b.n	80050ca <vPortFree+0x62>
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 80050ae:	88a1      	ldrh	r1, [r4, #4]
 80050b0:	fb05 4501 	mla	r5, r5, r1, r4
    UMM_NFREE(c)            = UMM_NFREE(0);
 80050b4:	8091      	strh	r1, [r2, #4]
    UMM_PFREE(c)            = 0;
 80050b6:	2100      	movs	r1, #0
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 80050b8:	80ee      	strh	r6, [r5, #6]
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
    UMM_NFREE(0)            = c;
 80050ba:	80a6      	strh	r6, [r4, #4]

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
 80050bc:	80d1      	strh	r1, [r2, #6]
    UMM_NFREE(0)            = c;

    UMM_NBLOCK(c)          |= UMM_FREELIST_MASK;
 80050be:	5ae2      	ldrh	r2, [r4, r3]
 80050c0:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 80050c4:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 80050c8:	52e2      	strh	r2, [r4, r3]
  }
#endif

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 80050ca:	f7ff fd5f 	bl	8004b8c <xTaskResumeAll>
}
 80050ce:	bd70      	pop	{r4, r5, r6, pc}
 80050d0:	20000c3c 	.word	0x20000c3c

080050d4 <pvPortMalloc>:

// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {
 80050d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80050d6:	4606      	mov	r6, r0
  // the very first thing we do is figure out if we're being asked to allocate
  // a size of 0 - and if we are we'll simply return a null pointer. if not
  // then reduce the size by 1 byte so that the subsequent calculations on
  // the number of blocks to allocate are easier...

  if( 0 == size ) {
 80050d8:	2800      	cmp	r0, #0
 80050da:	d07f      	beq.n	80051dc <pvPortMalloc+0x108>
    return( (void *)NULL );
  }

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 80050dc:	f7ff fce4 	bl	8004aa8 <vTaskSuspendAll>
  //
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
 80050e0:	2e08      	cmp	r6, #8
 80050e2:	d907      	bls.n	80050f4 <pvPortMalloc+0x20>
    return( 1 );

  // If it's for more than that, then we need to figure out the number of
  // additional whole blocks the size of an umm_block are required.

  size -= ( 1 + (sizeof(((umm_block *)0)->body)) );
 80050e4:	f1a6 0109 	sub.w	r1, r6, #9

  return( 2 + size/(sizeof(umm_block)) );
 80050e8:	230c      	movs	r3, #12
 80050ea:	fbb1 f1f3 	udiv	r1, r1, r3
 80050ee:	3102      	adds	r1, #2
 80050f0:	b289      	uxth	r1, r1
 80050f2:	e000      	b.n	80050f6 <pvPortMalloc+0x22>
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
    return( 1 );
 80050f4:	2101      	movs	r1, #1
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 80050f6:	483a      	ldr	r0, [pc, #232]	; (80051e0 <pvPortMalloc+0x10c>)

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;
 80050f8:	f647 73ff 	movw	r3, #32767	; 0x7fff
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 80050fc:	8884      	ldrh	r4, [r0, #4]
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 80050fe:	2500      	movs	r5, #0
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
 8005100:	4622      	mov	r2, r4
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 8005102:	f04f 0e0c 	mov.w	lr, #12
 8005106:	e018      	b.n	800513a <pvPortMalloc+0x66>
    blockSize = (UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK) - cf;
 8005108:	f830 500c 	ldrh.w	r5, [r0, ip]
 800510c:	046d      	lsls	r5, r5, #17
 800510e:	ebc4 4555 	rsb	r5, r4, r5, lsr #17
 8005112:	b2ad      	uxth	r5, r5
#if defined UMM_FIRST_FIT
    // This is the first block that fits!
    if( (blockSize >= blocks) )
        break;
#elif defined UMM_BEST_FIT
    if( (blockSize >= blocks) && (blockSize < bestSize) ) {
 8005114:	428d      	cmp	r5, r1
 8005116:	bf34      	ite	cc
 8005118:	f04f 0c00 	movcc.w	ip, #0
 800511c:	f04f 0c01 	movcs.w	ip, #1
 8005120:	429d      	cmp	r5, r3
 8005122:	bf2c      	ite	cs
 8005124:	f04f 0c00 	movcs.w	ip, #0
 8005128:	f00c 0c01 	andcc.w	ip, ip, #1
 800512c:	f1bc 0f00 	cmp.w	ip, #0
 8005130:	bf18      	it	ne
 8005132:	4622      	movne	r2, r4
 8005134:	bf18      	it	ne
 8005136:	462b      	movne	r3, r5
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 8005138:	4634      	mov	r4, r6
  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 800513a:	fb0e fc04 	mul.w	ip, lr, r4
 800513e:	eb00 060c 	add.w	r6, r0, ip
 8005142:	88b6      	ldrh	r6, [r6, #4]
 8005144:	2e00      	cmp	r6, #0
 8005146:	d1df      	bne.n	8005108 <pvPortMalloc+0x34>
#endif

    cf = UMM_NFREE(cf);
  }

  if( 0x7FFF != bestSize ) {
 8005148:	f647 70ff 	movw	r0, #32767	; 0x7fff
 800514c:	4283      	cmp	r3, r0
 800514e:	bf18      	it	ne
 8005150:	461d      	movne	r5, r3
 8005152:	bf18      	it	ne
 8005154:	4614      	movne	r4, r2
    cf        = bestBlock;
    blockSize = bestSize;
  }

  if( UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK ) {
 8005156:	220c      	movs	r2, #12
 8005158:	4362      	muls	r2, r4
 800515a:	4b21      	ldr	r3, [pc, #132]	; (80051e0 <pvPortMalloc+0x10c>)
 800515c:	5a9a      	ldrh	r2, [r3, r2]
 800515e:	0452      	lsls	r2, r2, #17
 8005160:	0c56      	lsrs	r6, r2, #17
 8005162:	b182      	cbz	r2, 8005186 <pvPortMalloc+0xb2>
    // This is an existing block in the memory heap, we just need to split off
    // what we need, unlink it from the free list and mark it as in use, and
    // link the rest of the block back into the freelist as if it was a new
    // block on the free list...

    if( blockSize == blocks ) {
 8005164:	428d      	cmp	r5, r1
 8005166:	d103      	bne.n	8005170 <pvPortMalloc+0x9c>
      // It's an exact fit and we don't neet to split off a block.
      DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - exact\n", blocks, cf );

      // Disconnect this block from the FREE list

      umm_disconnect_from_free_list( cf );
 8005168:	4620      	mov	r0, r4
 800516a:	f7ff ff43 	bl	8004ff4 <umm_disconnect_from_free_list>
 800516e:	e02e      	b.n	80051ce <pvPortMalloc+0xfa>

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 8005170:	1a6d      	subs	r5, r5, r1
 8005172:	b2ad      	uxth	r5, r5
 8005174:	4620      	mov	r0, r4
 8005176:	4629      	mov	r1, r5
 8005178:	f44f 4200 	mov.w	r2, #32768	; 0x8000

     cf += blockSize-blocks;
 800517c:	192c      	adds	r4, r5, r4

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 800517e:	f7ff ff1b 	bl	8004fb8 <umm_make_new_block>

     cf += blockSize-blocks;
 8005182:	b2a4      	uxth	r4, r4
 8005184:	e023      	b.n	80051ce <pvPortMalloc+0xfa>
    // We're at the end of the heap - allocate a new block, but check to see if
    // there's enough memory left for the requested block! Actually, we may need
    // one more than that if we're initializing the umm_heap for the first
    // time, which happens in the next conditional...

    if( UMM_NUMBLOCKS <= cf+blocks+1 ) {
 8005186:	1862      	adds	r2, r4, r1
 8005188:	f5b2 7f55 	cmp.w	r2, #852	; 0x354
 800518c:	db06      	blt.n	800519c <pvPortMalloc+0xc8>
      DBG_LOG_WARNING(  "Can't allocate %5d blocks at %5d\n", blocks, cf );
 800518e:	4622      	mov	r2, r4
 8005190:	4814      	ldr	r0, [pc, #80]	; (80051e4 <pvPortMalloc+0x110>)
 8005192:	f000 fb79 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>

      // Release the critical section...
      //
      UMM_CRITICAL_EXIT();
 8005196:	f7ff fcf9 	bl	8004b8c <xTaskResumeAll>

      return( (void *)NULL );
 800519a:	e01f      	b.n	80051dc <pvPortMalloc+0x108>

    // Now check to see if we need to initialize the free list...this assumes
    // that the BSS is set to 0 on startup. We should rarely get to the end of
    // the free list so this is the "cheapest" place to put the initialization!

    if( 0 == cf ) {
 800519c:	b91c      	cbnz	r4, 80051a6 <pvPortMalloc+0xd2>
      DBG_LOG_DEBUG( "Initializing malloc free block pointer\n" );
      UMM_NBLOCK(0) = 1;
 800519e:	2201      	movs	r2, #1
 80051a0:	801a      	strh	r2, [r3, #0]
      UMM_NFREE(0)  = 1;
 80051a2:	809a      	strh	r2, [r3, #4]
      cf            = 1;
 80051a4:	3401      	adds	r4, #1
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 80051a6:	220c      	movs	r2, #12
 80051a8:	fb02 f304 	mul.w	r3, r2, r4
 80051ac:	4e0c      	ldr	r6, [pc, #48]	; (80051e0 <pvPortMalloc+0x10c>)
 80051ae:	1865      	adds	r5, r4, r1
 80051b0:	18f1      	adds	r1, r6, r3
 80051b2:	88c8      	ldrh	r0, [r1, #6]
 80051b4:	b2af      	uxth	r7, r5
 80051b6:	fb02 6000 	mla	r0, r2, r0, r6

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 80051ba:	fb02 6505 	mla	r5, r2, r5, r6
      cf            = 1;
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 80051be:	8087      	strh	r7, [r0, #4]

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 80051c0:	4628      	mov	r0, r5
 80051c2:	9301      	str	r3, [sp, #4]
 80051c4:	f005 f98c 	bl	800a4e0 <memcpy>

    UMM_NBLOCK(cf)           = cf+blocks;
 80051c8:	9b01      	ldr	r3, [sp, #4]
    UMM_PBLOCK(cf+blocks)    = cf;
 80051ca:	806c      	strh	r4, [r5, #2]

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );

    UMM_NBLOCK(cf)           = cf+blocks;
 80051cc:	52f7      	strh	r7, [r6, r3]
    UMM_PBLOCK(cf+blocks)    = cf;
  }

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 80051ce:	f7ff fcdd 	bl	8004b8c <xTaskResumeAll>

  return( (void *)&UMM_DATA(cf) );
 80051d2:	4b03      	ldr	r3, [pc, #12]	; (80051e0 <pvPortMalloc+0x10c>)
 80051d4:	260c      	movs	r6, #12
 80051d6:	fb06 3604 	mla	r6, r6, r4, r3
 80051da:	3604      	adds	r6, #4
}
 80051dc:	4630      	mov	r0, r6
 80051de:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80051e0:	20000c3c 	.word	0x20000c3c
 80051e4:	0800ae9c 	.word	0x0800ae9c

080051e8 <Reset_Handler>:
 * @param  None
 * @retval : None
*/

void Reset_Handler(void)
{
 80051e8:	4668      	mov	r0, sp
 80051ea:	f020 0107 	bic.w	r1, r0, #7
 80051ee:	468d      	mov	sp, r1
 80051f0:	b501      	push	{r0, lr}
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 80051f2:	4a0a      	ldr	r2, [pc, #40]	; (800521c <Reset_Handler+0x34>)
 80051f4:	4b0a      	ldr	r3, [pc, #40]	; (8005220 <Reset_Handler+0x38>)
 80051f6:	490b      	ldr	r1, [pc, #44]	; (8005224 <Reset_Handler+0x3c>)
 80051f8:	e003      	b.n	8005202 <Reset_Handler+0x1a>
  {
    *(pulDest++) = *(pulSrc++);
 80051fa:	f852 0b04 	ldr.w	r0, [r2], #4
 80051fe:	f843 0b04 	str.w	r0, [r3], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8005202:	428b      	cmp	r3, r1
 8005204:	d3f9      	bcc.n	80051fa <Reset_Handler+0x12>
 8005206:	4b08      	ldr	r3, [pc, #32]	; (8005228 <Reset_Handler+0x40>)
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8005208:	4908      	ldr	r1, [pc, #32]	; (800522c <Reset_Handler+0x44>)
  {
    *(pulDest++) = 0;
 800520a:	2200      	movs	r2, #0
 800520c:	e001      	b.n	8005212 <Reset_Handler+0x2a>
 800520e:	f843 2b04 	str.w	r2, [r3], #4
  for(pulDest = &_sdata; pulDest < &_edata; )
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8005212:	428b      	cmp	r3, r1
 8005214:	d3fb      	bcc.n	800520e <Reset_Handler+0x26>
  {
    *(pulDest++) = 0;
  }

  /* Call the application's entry point.*/
  main();
 8005216:	f7ff fa29 	bl	800466c <main>
 800521a:	e7fe      	b.n	800521a <Reset_Handler+0x32>
 800521c:	0800b1b0 	.word	0x0800b1b0
 8005220:	20000000 	.word	0x20000000
 8005224:	20000058 	.word	0x20000058
 8005228:	20000058 	.word	0x20000058
 800522c:	200037b0 	.word	0x200037b0

08005230 <_init>:
}

// dummy for newer gcc versions
void _init()
{
}
 8005230:	4770      	bx	lr

08005232 <Default_Handler>:
 * @param  None     
 * @retval : None       
*/

void Default_Handler(void) 
{
 8005232:	e7fe      	b.n	8005232 <Default_Handler>

08005234 <MIOS32_SRIO_Init>:
//! Initializes SPI pins and peripheral
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
 8005234:	b538      	push	{r3, r4, r5, lr}
  // currently only mode 0 supported
  if( mode != 0 )
 8005236:	bb50      	cbnz	r0, 800528e <MIOS32_SRIO_Init+0x5a>
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 8005238:	4b16      	ldr	r3, [pc, #88]	; (8005294 <MIOS32_SRIO_Init+0x60>)

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 800523a:	4d17      	ldr	r5, [pc, #92]	; (8005298 <MIOS32_SRIO_Init+0x64>)
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 800523c:	f8df e05c 	ldr.w	lr, [pc, #92]	; 800529c <MIOS32_SRIO_Init+0x68>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 8005240:	f8df c05c 	ldr.w	ip, [pc, #92]	; 80052a0 <MIOS32_SRIO_Init+0x6c>
    mios32_srio_din_changed[i] = 0;   // no change
 8005244:	4917      	ldr	r1, [pc, #92]	; (80052a4 <MIOS32_SRIO_Init+0x70>)
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 8005246:	6018      	str	r0, [r3, #0]

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 8005248:	4603      	mov	r3, r0
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 800524a:	22ff      	movs	r2, #255	; 0xff

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 800524c:	542b      	strb	r3, [r5, r0]
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 800524e:	f80e 2000 	strb.w	r2, [lr, r0]
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 8005252:	f80c 2000 	strb.w	r2, [ip, r0]
    mios32_srio_din_changed[i] = 0;   // no change
 8005256:	540b      	strb	r3, [r1, r0]
 8005258:	3001      	adds	r0, #1

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 800525a:	2400      	movs	r4, #0
  srio_scan_finished_hook = NULL;

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 800525c:	2810      	cmp	r0, #16
 800525e:	d1f4      	bne.n	800524a <MIOS32_SRIO_Init+0x16>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
    mios32_srio_din_changed[i] = 0;   // no change
  }

  // initial state of RCLK
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8005260:	2001      	movs	r0, #1
 8005262:	4602      	mov	r2, r0
 8005264:	4621      	mov	r1, r4
 8005266:	f001 fb17 	bl	8006898 <MIOS32_SPI_RC_PinSet>

  // init GPIO structure
  // using 2 MHz instead of 50 MHz to avoid fast transients which can cause flickering!
  // optionally using open drain mode for cheap and sufficient levelshifting from 3.3V to 5V
#if MIOS32_SRIO_OUTPUTS_OD
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 800526a:	2103      	movs	r1, #3
 800526c:	2001      	movs	r0, #1
 800526e:	f001 fa63 	bl	8006738 <MIOS32_SPI_IO_Init>
#else
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK);
#endif

  // init SPI port for baudrate of ca. 2 uS period @ 72 MHz
  MIOS32_SPI_TransferModeInit(MIOS32_SRIO_SPI, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_64);
 8005272:	2205      	movs	r2, #5
 8005274:	2001      	movs	r0, #1
 8005276:	2103      	movs	r1, #3
 8005278:	f001 fdac 	bl	8006dd4 <MIOS32_SPI_TransferModeInit>

  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;
 800527c:	4b0a      	ldr	r3, [pc, #40]	; (80052a8 <MIOS32_SRIO_Init+0x74>)
 800527e:	2201      	movs	r2, #1
 8005280:	701a      	strb	r2, [r3, #0]

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 8005282:	4b0a      	ldr	r3, [pc, #40]	; (80052ac <MIOS32_SRIO_Init+0x78>)
  debounce_ctr = 0;
  
  return 0;
 8005284:	4620      	mov	r0, r4
  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 8005286:	701c      	strb	r4, [r3, #0]
  debounce_ctr = 0;
 8005288:	4b09      	ldr	r3, [pc, #36]	; (80052b0 <MIOS32_SRIO_Init+0x7c>)
 800528a:	701c      	strb	r4, [r3, #0]
  
  return 0;
 800528c:	e001      	b.n	8005292 <MIOS32_SRIO_Init+0x5e>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800528e:	f04f 30ff 	mov.w	r0, #4294967295
  // initial debounce time (debouncing disabled)
  debounce_time = 0;
  debounce_ctr = 0;
  
  return 0;
}
 8005292:	bd38      	pop	{r3, r4, r5, pc}
 8005294:	200007a8 	.word	0x200007a8
 8005298:	20003448 	.word	0x20003448
 800529c:	20003468 	.word	0x20003468
 80052a0:	20003458 	.word	0x20003458
 80052a4:	20003438 	.word	0x20003438
 80052a8:	200007ad 	.word	0x200007ad
 80052ac:	200007ac 	.word	0x200007ac
 80052b0:	200007ae 	.word	0x200007ae

080052b4 <MIOS32_SRIO_DebounceStart>:
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 80052b4:	4b02      	ldr	r3, [pc, #8]	; (80052c0 <MIOS32_SRIO_DebounceStart+0xc>)
  return 0; // no error
}
 80052b6:	2000      	movs	r0, #0
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 80052b8:	781a      	ldrb	r2, [r3, #0]
 80052ba:	4b02      	ldr	r3, [pc, #8]	; (80052c4 <MIOS32_SRIO_DebounceStart+0x10>)
 80052bc:	701a      	strb	r2, [r3, #0]
  return 0; // no error
}
 80052be:	4770      	bx	lr
 80052c0:	200007ac 	.word	0x200007ac
 80052c4:	200007ae 	.word	0x200007ae

080052c8 <MIOS32_DIN_Init>:
s32 MIOS32_DIN_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 80052c8:	b960      	cbnz	r0, 80052e4 <MIOS32_DIN_Init+0x1c>
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 80052ca:	f8df c020 	ldr.w	ip, [pc, #32]	; 80052ec <MIOS32_DIN_Init+0x24>
    mios32_srio_din_changed[i] = 0;
 80052ce:	4a08      	ldr	r2, [pc, #32]	; (80052f0 <MIOS32_DIN_Init+0x28>)
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 80052d0:	21ff      	movs	r1, #255	; 0xff
    mios32_srio_din_changed[i] = 0;
 80052d2:	4603      	mov	r3, r0
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 80052d4:	f80c 1000 	strb.w	r1, [ip, r0]
    mios32_srio_din_changed[i] = 0;
 80052d8:	5413      	strb	r3, [r2, r0]
 80052da:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 80052dc:	2810      	cmp	r0, #16
 80052de:	d1f9      	bne.n	80052d4 <MIOS32_DIN_Init+0xc>
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
 80052e0:	2000      	movs	r0, #0
 80052e2:	e001      	b.n	80052e8 <MIOS32_DIN_Init+0x20>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80052e4:	f04f 30ff 	mov.w	r0, #4294967295
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
}
 80052e8:	4770      	bx	lr
 80052ea:	bf00      	nop
 80052ec:	20003468 	.word	0x20003468
 80052f0:	20003438 	.word	0x20003438

080052f4 <MIOS32_DIN_SRChangedGetAndClear>:
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 80052f4:	280f      	cmp	r0, #15
//! \param[in] mask pin mask (8bit value)
//! \return 8bit value which contains the selected (masked) change flags
//! \return no error status (-1)! - if unavailable SR selected, 0x00 will be returned
/////////////////////////////////////////////////////////////////////////////
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
 80052f6:	b570      	push	{r4, r5, r6, lr}
 80052f8:	4604      	mov	r4, r0
 80052fa:	460e      	mov	r6, r1
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 80052fc:	d80c      	bhi.n	8005318 <MIOS32_DIN_SRChangedGetAndClear+0x24>
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
 80052fe:	f001 f9cf 	bl	80066a0 <MIOS32_IRQ_Disable>
  changed = mios32_srio_din_changed[sr] & mask;
 8005302:	4b07      	ldr	r3, [pc, #28]	; (8005320 <MIOS32_DIN_SRChangedGetAndClear+0x2c>)
 8005304:	5d1d      	ldrb	r5, [r3, r4]
  mios32_srio_din_changed[sr] &= ~mask;
 8005306:	5d1a      	ldrb	r2, [r3, r4]
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
  changed = mios32_srio_din_changed[sr] & mask;
 8005308:	ea06 0505 	and.w	r5, r6, r5
  mios32_srio_din_changed[sr] &= ~mask;
 800530c:	ea22 0606 	bic.w	r6, r2, r6
 8005310:	551e      	strb	r6, [r3, r4]
  MIOS32_IRQ_Enable();
 8005312:	f001 f9db 	bl	80066cc <MIOS32_IRQ_Enable>

  return changed;
 8005316:	e000      	b.n	800531a <MIOS32_DIN_SRChangedGetAndClear+0x26>
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;
 8005318:	2500      	movs	r5, #0
  changed = mios32_srio_din_changed[sr] & mask;
  mios32_srio_din_changed[sr] &= ~mask;
  MIOS32_IRQ_Enable();

  return changed;
}
 800531a:	4628      	mov	r0, r5
 800531c:	bd70      	pop	{r4, r5, r6, pc}
 800531e:	bf00      	nop
 8005320:	20003438 	.word	0x20003438

08005324 <MIOS32_DIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_Handler(void *_callback)
{
 8005324:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005326:	4606      	mov	r6, r0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
    return -1;
 8005328:	f04f 30ff 	mov.w	r0, #4294967295
#if MIOS32_SRIO_NUM_SR == 0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
 800532c:	b1fe      	cbz	r6, 800536e <MIOS32_DIN_Handler+0x4a>
 800532e:	2400      	movs	r4, #0

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
    
    // check if there are pin changes (mask all pins)
    changed = MIOS32_DIN_SRChangedGetAndClear(sr, 0xff);
 8005330:	4620      	mov	r0, r4
 8005332:	21ff      	movs	r1, #255	; 0xff
 8005334:	f7ff ffde 	bl	80052f4 <MIOS32_DIN_SRChangedGetAndClear>
 8005338:	4607      	mov	r7, r0

    // any pin change at this SR?
    if( !changed )
 800533a:	b1a0      	cbz	r0, 8005366 <MIOS32_DIN_Handler+0x42>
 800533c:	2500      	movs	r5, #0

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 800533e:	00e3      	lsls	r3, r4, #3
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
 8005340:	fa57 f205 	asrs.w	r2, r7, r5
 8005344:	f012 0f01 	tst.w	r2, #1
 8005348:	d00a      	beq.n	8005360 <MIOS32_DIN_Handler+0x3c>
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 800534a:	4a09      	ldr	r2, [pc, #36]	; (8005370 <MIOS32_DIN_Handler+0x4c>)
 800534c:	18e8      	adds	r0, r5, r3
 800534e:	5d11      	ldrb	r1, [r2, r4]
 8005350:	9301      	str	r3, [sp, #4]
 8005352:	4129      	asrs	r1, r5
 8005354:	f001 0101 	and.w	r1, r1, #1
 8005358:	47b0      	blx	r6

	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
 800535a:	f7ff ffab 	bl	80052b4 <MIOS32_SRIO_DebounceStart>
 800535e:	9b01      	ldr	r3, [sp, #4]
    // any pin change at this SR?
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
 8005360:	3501      	adds	r5, #1
 8005362:	2d08      	cmp	r5, #8
 8005364:	d1ec      	bne.n	8005340 <MIOS32_DIN_Handler+0x1c>
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
 8005366:	3401      	adds	r4, #1
 8005368:	2c10      	cmp	r4, #16
 800536a:	d1e1      	bne.n	8005330 <MIOS32_DIN_Handler+0xc>
	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
      }
  }

  return 0;
 800536c:	2000      	movs	r0, #0
}
 800536e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005370:	20003468 	.word	0x20003468

08005374 <MIOS32_DOUT_Init>:
s32 MIOS32_DOUT_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 8005374:	b938      	cbnz	r0, 8005386 <MIOS32_DOUT_Init+0x12>
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
 8005376:	4a05      	ldr	r2, [pc, #20]	; (800538c <MIOS32_DOUT_Init+0x18>)
 8005378:	4603      	mov	r3, r0
 800537a:	5413      	strb	r3, [r2, r0]
 800537c:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 800537e:	2810      	cmp	r0, #16
 8005380:	d1fb      	bne.n	800537a <MIOS32_DOUT_Init+0x6>
    mios32_srio_dout[i] = 0;
  }

  return 0;
 8005382:	2000      	movs	r0, #0
 8005384:	e001      	b.n	800538a <MIOS32_DOUT_Init+0x16>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005386:	f04f 30ff 	mov.w	r0, #4294967295
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
  }

  return 0;
}
 800538a:	4770      	bx	lr
 800538c:	20003448 	.word	0x20003448

08005390 <MIOS32_ENC_Init>:
//! Initializes encoder driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Init(u32 mode)
{
 8005390:	b510      	push	{r4, lr}
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 8005392:	bb20      	cbnz	r0, 80053de <MIOS32_ENC_Init+0x4e>
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 8005394:	4c13      	ldr	r4, [pc, #76]	; (80053e4 <MIOS32_ENC_Init+0x54>)

    enc_state[i].state = 0xf; // all pins released
 8005396:	4914      	ldr	r1, [pc, #80]	; (80053e8 <MIOS32_ENC_Init+0x58>)
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 8005398:	4602      	mov	r2, r0
 800539a:	f804 2020 	strb.w	r2, [r4, r0, lsl #2]

    enc_state[i].state = 0xf; // all pins released
 800539e:	f811 3030 	ldrb.w	r3, [r1, r0, lsl #3]
    enc_state[i].decinc = 0;
 80053a2:	f043 030f 	orr.w	r3, r3, #15
 80053a6:	f36f 1304 	bfc	r3, #4, #1
 80053aa:	f801 3030 	strb.w	r3, [r1, r0, lsl #3]
    enc_state[i].incrementer = 0;
 80053ae:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
 80053b2:	f893 c003 	ldrb.w	ip, [r3, #3]
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 80053b6:	3001      	adds	r0, #1
    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
 80053b8:	f00c 0cf0 	and.w	ip, ip, #240	; 0xf0
 80053bc:	f36f 1c07 	bfc	ip, #4, #4
 80053c0:	f883 c003 	strb.w	ip, [r3, #3]
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 80053c4:	f893 c005 	ldrb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 80053c8:	2840      	cmp	r0, #64	; 0x40
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 80053ca:	f36f 0c03 	bfc	ip, #0, #4
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder

    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
 80053ce:	705a      	strb	r2, [r3, #1]
    enc_state[i].accelerator = 0;
 80053d0:	709a      	strb	r2, [r3, #2]
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
 80053d2:	711a      	strb	r2, [r3, #4]
    enc_state[i].predivider = 0;
 80053d4:	f883 c005 	strb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 80053d8:	d1df      	bne.n	800539a <MIOS32_ENC_Init+0xa>
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
 80053da:	2000      	movs	r0, #0
 80053dc:	e001      	b.n	80053e2 <MIOS32_ENC_Init+0x52>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80053de:	f04f 30ff 	mov.w	r0, #4294967295
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
}
 80053e2:	bd10      	pop	{r4, pc}
 80053e4:	20003478 	.word	0x20003478
 80053e8:	20003578 	.word	0x20003578

080053ec <MIOS32_ENC_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Handler(void *_callback)
{
 80053ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80053ee:	4605      	mov	r5, r0
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
    return -1;
 80053f0:	f04f 30ff 	mov.w	r0, #4294967295
  u8 enc;
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
 80053f4:	b1bd      	cbz	r5, 8005426 <MIOS32_ENC_Handler+0x3a>
 80053f6:	2400      	movs	r4, #0
  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
    if( (incrementer = enc_state[enc].incrementer) ) {
 80053f8:	4f0b      	ldr	r7, [pc, #44]	; (8005428 <MIOS32_ENC_Handler+0x3c>)
      enc_state[enc].incrementer = 0;
 80053fa:	4626      	mov	r6, r4

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
 80053fc:	f001 f950 	bl	80066a0 <MIOS32_IRQ_Disable>
    if( (incrementer = enc_state[enc].incrementer) ) {
 8005400:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
 8005404:	f993 1001 	ldrsb.w	r1, [r3, #1]
 8005408:	b139      	cbz	r1, 800541a <MIOS32_ENC_Handler+0x2e>
      enc_state[enc].incrementer = 0;
 800540a:	705e      	strb	r6, [r3, #1]
      MIOS32_IRQ_Enable();
 800540c:	9101      	str	r1, [sp, #4]
 800540e:	f001 f95d 	bl	80066cc <MIOS32_IRQ_Enable>

      // call the hook
      callback(enc, incrementer);
 8005412:	4620      	mov	r0, r4
 8005414:	9901      	ldr	r1, [sp, #4]
 8005416:	47a8      	blx	r5
 8005418:	e001      	b.n	800541e <MIOS32_ENC_Handler+0x32>
    } else {
      MIOS32_IRQ_Enable();
 800541a:	f001 f957 	bl	80066cc <MIOS32_IRQ_Enable>
 800541e:	3401      	adds	r4, #1
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
 8005420:	2c40      	cmp	r4, #64	; 0x40
 8005422:	d1eb      	bne.n	80053fc <MIOS32_ENC_Handler+0x10>
    } else {
      MIOS32_IRQ_Enable();
    }
  }

  return 0; // no error
 8005424:	2000      	movs	r0, #0
}
 8005426:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005428:	20003578 	.word	0x20003578

0800542c <MIOS32_LCD_DeviceSet>:
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 800542c:	4b01      	ldr	r3, [pc, #4]	; (8005434 <MIOS32_LCD_DeviceSet+0x8>)
 800542e:	7018      	strb	r0, [r3, #0]

  return 0; // no error
}
 8005430:	2000      	movs	r0, #0
 8005432:	4770      	bx	lr
 8005434:	200007af 	.word	0x200007af

08005438 <MIOS32_LCD_CursorSet>:
//! \param[in] column number
//! \param[in] line number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorSet(u16 column, u16 line)
{
 8005438:	b508      	push	{r3, lr}
  // set character position
  mios32_lcd_column = column;
 800543a:	4b0b      	ldr	r3, [pc, #44]	; (8005468 <MIOS32_LCD_CursorSet+0x30>)
 800543c:	8018      	strh	r0, [r3, #0]
  mios32_lcd_line = line;
 800543e:	4b0b      	ldr	r3, [pc, #44]	; (800546c <MIOS32_LCD_CursorSet+0x34>)
 8005440:	8019      	strh	r1, [r3, #0]

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
  if( font_bitmap.width ) {
 8005442:	4b0b      	ldr	r3, [pc, #44]	; (8005470 <MIOS32_LCD_CursorSet+0x38>)
 8005444:	889a      	ldrh	r2, [r3, #4]
 8005446:	b112      	cbz	r2, 800544e <MIOS32_LCD_CursorSet+0x16>
    font_width = font_bitmap.width;
 8005448:	b2d2      	uxtb	r2, r2
    font_height = font_bitmap.height;
 800544a:	799b      	ldrb	r3, [r3, #6]
 800544c:	e001      	b.n	8005452 <MIOS32_LCD_CursorSet+0x1a>
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
 800544e:	2308      	movs	r3, #8
  // set character position
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
 8005450:	2206      	movs	r2, #6
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 8005452:	4342      	muls	r2, r0
 8005454:	f8df c01c 	ldr.w	ip, [pc, #28]	; 8005474 <MIOS32_LCD_CursorSet+0x3c>
  mios32_lcd_y = line * font_height;
 8005458:	434b      	muls	r3, r1
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 800545a:	f8ac 2000 	strh.w	r2, [ip]
  mios32_lcd_y = line * font_height;
 800545e:	4a06      	ldr	r2, [pc, #24]	; (8005478 <MIOS32_LCD_CursorSet+0x40>)
 8005460:	8013      	strh	r3, [r2, #0]

  // forward new cursor position to app driver
  return APP_LCD_CursorSet(column, line);
 8005462:	f004 fff5 	bl	800a450 <APP_LCD_CursorSet>
}
 8005466:	bd08      	pop	{r3, pc}
 8005468:	20003786 	.word	0x20003786
 800546c:	2000378c 	.word	0x2000378c
 8005470:	20003778 	.word	0x20003778
 8005474:	20003790 	.word	0x20003790
 8005478:	20003784 	.word	0x20003784

0800547c <MIOS32_LCD_GCursorSet>:
//! \param[in] x position
//! \param[in] y position
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_GCursorSet(u16 x, u16 y)
{
 800547c:	b508      	push	{r3, lr}
  mios32_lcd_x = x;
 800547e:	4b03      	ldr	r3, [pc, #12]	; (800548c <MIOS32_LCD_GCursorSet+0x10>)
 8005480:	8018      	strh	r0, [r3, #0]
  mios32_lcd_y = y;
 8005482:	4b03      	ldr	r3, [pc, #12]	; (8005490 <MIOS32_LCD_GCursorSet+0x14>)
 8005484:	8019      	strh	r1, [r3, #0]

  // forward new cursor position to app driver
  return APP_LCD_GCursorSet(x, y);
 8005486:	f004 fff5 	bl	800a474 <APP_LCD_GCursorSet>
}
 800548a:	bd08      	pop	{r3, pc}
 800548c:	20003790 	.word	0x20003790
 8005490:	20003784 	.word	0x20003784

08005494 <MIOS32_LCD_CursorMapSet>:
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
    mios32_lcd_cursor_map[i] = map_table[i];
 8005494:	4a04      	ldr	r2, [pc, #16]	; (80054a8 <MIOS32_LCD_CursorMapSet+0x14>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 8005496:	2300      	movs	r3, #0
    mios32_lcd_cursor_map[i] = map_table[i];
 8005498:	5cc1      	ldrb	r1, [r0, r3]
 800549a:	5499      	strb	r1, [r3, r2]
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 800549c:	3301      	adds	r3, #1
 800549e:	2b04      	cmp	r3, #4
 80054a0:	d1fa      	bne.n	8005498 <MIOS32_LCD_CursorMapSet+0x4>
    mios32_lcd_cursor_map[i] = map_table[i];

  return 0; // no error
}
 80054a2:	2000      	movs	r0, #0
 80054a4:	4770      	bx	lr
 80054a6:	bf00      	nop
 80054a8:	20003788 	.word	0x20003788

080054ac <MIOS32_LCD_Init>:
//! Initializes LCD driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Init(u32 mode)
{
 80054ac:	b513      	push	{r0, r1, r4, lr}
 80054ae:	4604      	mov	r4, r0
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80054b0:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_Init(u32 mode)
{
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
 80054b4:	b9d4      	cbnz	r4, 80054ec <MIOS32_LCD_Init+0x40>
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 80054b6:	4b0e      	ldr	r3, [pc, #56]	; (80054f0 <MIOS32_LCD_Init+0x44>)

  // disable font bitmap
  font_bitmap.width = 0;

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 80054b8:	a802      	add	r0, sp, #8
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 80054ba:	701c      	strb	r4, [r3, #0]

  // disable font bitmap
  font_bitmap.width = 0;
 80054bc:	4b0d      	ldr	r3, [pc, #52]	; (80054f4 <MIOS32_LCD_Init+0x48>)
 80054be:	809c      	strh	r4, [r3, #4]

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 80054c0:	4b0d      	ldr	r3, [pc, #52]	; (80054f8 <MIOS32_LCD_Init+0x4c>)
 80054c2:	681b      	ldr	r3, [r3, #0]
 80054c4:	f840 3d04 	str.w	r3, [r0, #-4]!
  MIOS32_LCD_CursorMapSet(cursor_map);
 80054c8:	f7ff ffe4 	bl	8005494 <MIOS32_LCD_CursorMapSet>
  // note: this has to be done before APP_LCD_Init() is called, so that
  // the driver is able to modify the default cursor mapping
  // usage example: "dog" LCDs

  // call application specific init function
  if( (ret=APP_LCD_Init(mode)) < 0 )
 80054cc:	4620      	mov	r0, r4
 80054ce:	f004 ff51 	bl	800a374 <APP_LCD_Init>
 80054d2:	2800      	cmp	r0, #0
 80054d4:	db0a      	blt.n	80054ec <MIOS32_LCD_Init+0x40>
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
  // -> forward to app_lcd
  return APP_LCD_Clear();
 80054d6:	f004 ffb5 	bl	800a444 <APP_LCD_Clear>

  // clear screen
  MIOS32_LCD_Clear();

  // set character and graphical cursor to initial position
  MIOS32_LCD_CursorSet(0, 0);
 80054da:	4621      	mov	r1, r4
 80054dc:	4620      	mov	r0, r4
 80054de:	f7ff ffab 	bl	8005438 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_GCursorSet(0, 0);
 80054e2:	4620      	mov	r0, r4
 80054e4:	4621      	mov	r1, r4
 80054e6:	f7ff ffc9 	bl	800547c <MIOS32_LCD_GCursorSet>

  return 0; // no error
 80054ea:	4620      	mov	r0, r4
}
 80054ec:	bd1c      	pop	{r2, r3, r4, pc}
 80054ee:	bf00      	nop
 80054f0:	2000378e 	.word	0x2000378e
 80054f4:	20003778 	.word	0x20003778
 80054f8:	0800aec0 	.word	0x0800aec0

080054fc <MIOS32_LCD_Clear>:
/////////////////////////////////////////////////////////////////////////////
//! Clear Screen
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
 80054fc:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_Clear();
 80054fe:	f004 ffa1 	bl	800a444 <APP_LCD_Clear>
}
 8005502:	bd08      	pop	{r3, pc}

08005504 <MIOS32_LCD_PrintChar>:
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 8005504:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 8005506:	4b13      	ldr	r3, [pc, #76]	; (8005554 <MIOS32_LCD_PrintChar+0x50>)
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 8005508:	4684      	mov	ip, r0
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 800550a:	781b      	ldrb	r3, [r3, #0]
 800550c:	2b01      	cmp	r3, #1
 800550e:	d117      	bne.n	8005540 <MIOS32_LCD_PrintChar+0x3c>
    if( !font_bitmap.width )
 8005510:	4b11      	ldr	r3, [pc, #68]	; (8005558 <MIOS32_LCD_PrintChar+0x54>)
      return -1;    // font not initialized yet!
 8005512:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_PrintChar(char c)
{
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
 8005516:	889a      	ldrh	r2, [r3, #4]
 8005518:	b1d2      	cbz	r2, 8005550 <MIOS32_LCD_PrintChar+0x4c>
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 800551a:	f10d 0e04 	add.w	lr, sp, #4
 800551e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8005522:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
 8005526:	88da      	ldrh	r2, [r3, #6]
 8005528:	8919      	ldrh	r1, [r3, #8]
 800552a:	08d2      	lsrs	r2, r2, #3
 800552c:	434a      	muls	r2, r1
 800552e:	fb0c 0c02 	mla	ip, ip, r2, r0

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 8005532:	f8cd c004 	str.w	ip, [sp, #4]
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
    status = APP_LCD_BitmapPrint(bitmap);
 8005536:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 800553a:	f004 ffa4 	bl	800a486 <APP_LCD_BitmapPrint>
 800553e:	e001      	b.n	8005544 <MIOS32_LCD_PrintChar+0x40>
  } else {
    status = APP_LCD_Data(c);
 8005540:	f004 feb4 	bl	800a2ac <APP_LCD_Data>
  }

  if( status >= 0 ) {
 8005544:	2800      	cmp	r0, #0
 8005546:	db03      	blt.n	8005550 <MIOS32_LCD_PrintChar+0x4c>
    // increment cursor
    ++mios32_lcd_column;
 8005548:	4b04      	ldr	r3, [pc, #16]	; (800555c <MIOS32_LCD_PrintChar+0x58>)
 800554a:	881a      	ldrh	r2, [r3, #0]
 800554c:	3201      	adds	r2, #1
 800554e:	801a      	strh	r2, [r3, #0]
  }

  return status;
}
 8005550:	b005      	add	sp, #20
 8005552:	bd00      	pop	{pc}
 8005554:	2000378e 	.word	0x2000378e
 8005558:	20003778 	.word	0x20003778
 800555c:	20003786 	.word	0x20003786

08005560 <MIOS32_LCD_PrintString>:
//! Prints a \\0 (zero) terminated string
//! \param[in] str pointer to string
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
 8005560:	b538      	push	{r3, r4, r5, lr}
 8005562:	4605      	mov	r5, r0
  s32 status = 0;
 8005564:	2400      	movs	r4, #0

  while( *str != '\0' )
 8005566:	e002      	b.n	800556e <MIOS32_LCD_PrintString+0xe>
    status |= MIOS32_LCD_PrintChar(*str++);
 8005568:	f7ff ffcc 	bl	8005504 <MIOS32_LCD_PrintChar>
 800556c:	4304      	orrs	r4, r0
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
  s32 status = 0;

  while( *str != '\0' )
 800556e:	f815 0b01 	ldrb.w	r0, [r5], #1
 8005572:	2800      	cmp	r0, #0
 8005574:	d1f8      	bne.n	8005568 <MIOS32_LCD_PrintString+0x8>
    status |= MIOS32_LCD_PrintChar(*str++);

  return status;
}
 8005576:	4620      	mov	r0, r4
 8005578:	bd38      	pop	{r3, r4, r5, pc}
	...

0800557c <MIOS32_LCD_PrintBootMessage>:
//! The message is automatically print by the programming model after each reset.<BR>
//! It will also be returned on a SysEx query.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintBootMessage(void)
{
 800557c:	b538      	push	{r3, r4, r5, lr}
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 800557e:	4b0c      	ldr	r3, [pc, #48]	; (80055b0 <MIOS32_LCD_PrintBootMessage+0x34>)
 8005580:	2400      	movs	r4, #0
 8005582:	701c      	strb	r4, [r3, #0]
s32 MIOS32_LCD_PrintBootMessage(void)
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
 8005584:	4621      	mov	r1, r4
 8005586:	4620      	mov	r0, r4
 8005588:	f7ff ff56 	bl	8005438 <MIOS32_LCD_CursorSet>
 800558c:	4605      	mov	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 800558e:	4809      	ldr	r0, [pc, #36]	; (80055b4 <MIOS32_LCD_PrintBootMessage+0x38>)
 8005590:	f7ff ffe6 	bl	8005560 <MIOS32_LCD_PrintString>
  status |= MIOS32_LCD_CursorSet(0, 1);
 8005594:	2101      	movs	r1, #1
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 8005596:	ea40 0505 	orr.w	r5, r0, r5
  status |= MIOS32_LCD_CursorSet(0, 1);
 800559a:	4620      	mov	r0, r4
 800559c:	f7ff ff4c 	bl	8005438 <MIOS32_LCD_CursorSet>
 80055a0:	4305      	orrs	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE2);
 80055a2:	4805      	ldr	r0, [pc, #20]	; (80055b8 <MIOS32_LCD_PrintBootMessage+0x3c>)
 80055a4:	f7ff ffdc 	bl	8005560 <MIOS32_LCD_PrintString>
 80055a8:	ea45 0000 	orr.w	r0, r5, r0

  return status;
}
 80055ac:	bd38      	pop	{r3, r4, r5, pc}
 80055ae:	bf00      	nop
 80055b0:	200007af 	.word	0x200007af
 80055b4:	0800aec4 	.word	0x0800aec4
 80055b8:	0800aed5 	.word	0x0800aed5

080055bc <MIOS32_LCD_PrintFormattedString>:
//! \param[in] *format zero-terminated format string - 64 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
 80055bc:	b40f      	push	{r0, r1, r2, r3}
 80055be:	b510      	push	{r4, lr}
 80055c0:	b092      	sub	sp, #72	; 0x48
 80055c2:	aa14      	add	r2, sp, #80	; 0x50
 80055c4:	f852 1b04 	ldr.w	r1, [r2], #4
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
  vsprintf((char *)buffer, format, args);
 80055c8:	ac01      	add	r4, sp, #4
 80055ca:	4620      	mov	r0, r4
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
 80055cc:	9211      	str	r2, [sp, #68]	; 0x44
  vsprintf((char *)buffer, format, args);
 80055ce:	f003 fa0a 	bl	80089e6 <vsprintf>
  return MIOS32_LCD_PrintString(buffer);
 80055d2:	4620      	mov	r0, r4
 80055d4:	f7ff ffc4 	bl	8005560 <MIOS32_LCD_PrintString>
}
 80055d8:	b012      	add	sp, #72	; 0x48
 80055da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80055de:	b004      	add	sp, #16
 80055e0:	4770      	bx	lr

080055e2 <MIOS32_LCD_BColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_BColourSet(u32 rgb)
{
 80055e2:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_BColourSet(rgb);
 80055e4:	f004 ff49 	bl	800a47a <APP_LCD_BColourSet>
}
 80055e8:	bd08      	pop	{r3, pc}

080055ea <MIOS32_LCD_FColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_FColourSet(u32 rgb)
{
 80055ea:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_FColourSet(rgb);
 80055ec:	f004 ff48 	bl	800a480 <APP_LCD_FColourSet>
}
 80055f0:	bd08      	pop	{r3, pc}
	...

080055f4 <MIOS32_MIDI_Init>:
//! Initializes MIDI layer
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
 80055f4:	b538      	push	{r3, r4, r5, lr}
 80055f6:	4604      	mov	r4, r0
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80055f8:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 80055fc:	2c00      	cmp	r4, #0
 80055fe:	d12c      	bne.n	800565a <MIOS32_MIDI_Init+0x66>
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
 8005600:	4a16      	ldr	r2, [pc, #88]	; (800565c <MIOS32_MIDI_Init+0x68>)
 8005602:	2310      	movs	r3, #16
 8005604:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 8005606:	4a16      	ldr	r2, [pc, #88]	; (8005660 <MIOS32_MIDI_Init+0x6c>)
  timeout_callback_func = NULL;
  debug_command_callback_func = NULL;

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 8005608:	4620      	mov	r0, r4
  if( mode != 0 )
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 800560a:	7013      	strb	r3, [r2, #0]

  // disable callback functions
  direct_rx_callback_func = NULL;
 800560c:	4b15      	ldr	r3, [pc, #84]	; (8005664 <MIOS32_MIDI_Init+0x70>)
 800560e:	601c      	str	r4, [r3, #0]
  direct_tx_callback_func = NULL;
 8005610:	4b15      	ldr	r3, [pc, #84]	; (8005668 <MIOS32_MIDI_Init+0x74>)
 8005612:	601c      	str	r4, [r3, #0]
  sysex_callback_func = NULL;
 8005614:	4b15      	ldr	r3, [pc, #84]	; (800566c <MIOS32_MIDI_Init+0x78>)
 8005616:	601c      	str	r4, [r3, #0]
  timeout_callback_func = NULL;
 8005618:	4b15      	ldr	r3, [pc, #84]	; (8005670 <MIOS32_MIDI_Init+0x7c>)
 800561a:	601c      	str	r4, [r3, #0]
  debug_command_callback_func = NULL;
 800561c:	4b15      	ldr	r3, [pc, #84]	; (8005674 <MIOS32_MIDI_Init+0x80>)
 800561e:	601c      	str	r4, [r3, #0]

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 8005620:	f002 fc54 	bl	8007ecc <MIOS32_USB_MIDI_Init>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;
 8005624:	0fc5      	lsrs	r5, r0, #31
  if( MIOS32_USB_MIDI_Init(0) < 0 )
    ret |= (1 << 0);
#endif

#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
 8005626:	4620      	mov	r0, r4
 8005628:	f000 fd2c 	bl	8006084 <MIOS32_UART_MIDI_Init>
 800562c:	2800      	cmp	r0, #0
    ret |= (1 << 1);
 800562e:	bfb8      	it	lt
 8005630:	f045 0502 	orrlt.w	r5, r5, #2
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 8005634:	2000      	movs	r0, #0
 8005636:	f000 fec3 	bl	80063c0 <MIOS32_IIC_MIDI_Init>
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
 800563a:	4a0f      	ldr	r2, [pc, #60]	; (8005678 <MIOS32_MIDI_Init+0x84>)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
    ret |= (1 << 1);
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 800563c:	2800      	cmp	r0, #0
    ret |= (1 << 2);
 800563e:	bfb8      	it	lt
 8005640:	f045 0504 	orrlt.w	r5, r5, #4
#endif

  last_sysex_port = DEFAULT;
 8005644:	2300      	movs	r3, #0
 8005646:	7013      	strb	r3, [r2, #0]
  sysex_state.ALL = 0;
 8005648:	4a0c      	ldr	r2, [pc, #48]	; (800567c <MIOS32_MIDI_Init+0x88>)

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
  sysex_timeout_ctr_flags.ALL = 0;

  return -ret;
 800564a:	4268      	negs	r0, r5
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
  sysex_state.ALL = 0;
 800564c:	7013      	strb	r3, [r2, #0]

  // TODO: allow to change device ID (read from flash, resp. BSL based EEPROM emulation)
  sysex_device_id = 0x00;
 800564e:	4a0c      	ldr	r2, [pc, #48]	; (8005680 <MIOS32_MIDI_Init+0x8c>)
 8005650:	7013      	strb	r3, [r2, #0]

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
 8005652:	4a0c      	ldr	r2, [pc, #48]	; (8005684 <MIOS32_MIDI_Init+0x90>)
 8005654:	8013      	strh	r3, [r2, #0]
  sysex_timeout_ctr_flags.ALL = 0;
 8005656:	4a0c      	ldr	r2, [pc, #48]	; (8005688 <MIOS32_MIDI_Init+0x94>)
 8005658:	6013      	str	r3, [r2, #0]

  return -ret;
}
 800565a:	bd38      	pop	{r3, r4, r5, pc}
 800565c:	20000004 	.word	0x20000004
 8005660:	20000005 	.word	0x20000005
 8005664:	200007b8 	.word	0x200007b8
 8005668:	200007b0 	.word	0x200007b0
 800566c:	200007d4 	.word	0x200007d4
 8005670:	200007d8 	.word	0x200007d8
 8005674:	200007cc 	.word	0x200007cc
 8005678:	200007bc 	.word	0x200007bc
 800567c:	200007c4 	.word	0x200007c4
 8005680:	200007bd 	.word	0x200007bd
 8005684:	200007be 	.word	0x200007be
 8005688:	200007d0 	.word	0x200007d0

0800568c <MIOS32_MIDI_SendPackage>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 800568c:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] package MIDI package
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
 8005690:	b570      	push	{r4, r5, r6, lr}
 8005692:	4605      	mov	r5, r0
 8005694:	460c      	mov	r4, r1
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8005696:	d104      	bne.n	80056a2 <MIOS32_MIDI_SendPackage+0x16>
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
 8005698:	2801      	cmp	r0, #1
 800569a:	bf0c      	ite	eq
 800569c:	4b16      	ldreq	r3, [pc, #88]	; (80056f8 <MIOS32_MIDI_SendPackage+0x6c>)
 800569e:	4b17      	ldrne	r3, [pc, #92]	; (80056fc <MIOS32_MIDI_SendPackage+0x70>)
 80056a0:	781d      	ldrb	r5, [r3, #0]

  // insert subport number into package
  package.cable = port & 0xf;

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 80056a2:	4b17      	ldr	r3, [pc, #92]	; (8005700 <MIOS32_MIDI_SendPackage+0x74>)
  if( !(port & 0xf0) ) {
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
  }

  // insert subport number into package
  package.cable = port & 0xf;
 80056a4:	f005 060f 	and.w	r6, r5, #15

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 80056a8:	681b      	ldr	r3, [r3, #0]
 80056aa:	b12b      	cbz	r3, 80056b8 <MIOS32_MIDI_SendPackage+0x2c>
 80056ac:	f366 1407 	bfi	r4, r6, #4, #4
    s32 status;
    if( (status=direct_tx_callback_func(port, package)) )
 80056b0:	4628      	mov	r0, r5
 80056b2:	4621      	mov	r1, r4
 80056b4:	4798      	blx	r3
 80056b6:	b9e8      	cbnz	r0, 80056f4 <MIOS32_MIDI_SendPackage+0x68>
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 80056b8:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 80056bc:	2d20      	cmp	r5, #32
 80056be:	d00c      	beq.n	80056da <MIOS32_MIDI_SendPackage+0x4e>
 80056c0:	2d30      	cmp	r5, #48	; 0x30
 80056c2:	d011      	beq.n	80056e8 <MIOS32_MIDI_SendPackage+0x5c>
 80056c4:	2d10      	cmp	r5, #16
      return -1; // IIC_MIDI has been disabled
#endif
      
    default:
      // invalid port
      return -1;
 80056c6:	bf18      	it	ne
 80056c8:	f04f 30ff 	movne.w	r0, #4294967295
    if( (status=direct_tx_callback_func(port, package)) )
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 80056cc:	d112      	bne.n	80056f4 <MIOS32_MIDI_SendPackage+0x68>
 80056ce:	f366 1407 	bfi	r4, r6, #4, #4
    case USB0://..15
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      return MIOS32_USB_MIDI_PackageSend(package);
 80056d2:	4620      	mov	r0, r4
 80056d4:	f002 fc6c 	bl	8007fb0 <MIOS32_USB_MIDI_PackageSend>
 80056d8:	e00c      	b.n	80056f4 <MIOS32_MIDI_SendPackage+0x68>
 80056da:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // USB has been disabled
#endif

    case UART0://..15
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
      return MIOS32_UART_MIDI_PackageSend(package.cable, package);
 80056de:	4630      	mov	r0, r6
 80056e0:	4621      	mov	r1, r4
 80056e2:	f000 fd89 	bl	80061f8 <MIOS32_UART_MIDI_PackageSend>
 80056e6:	e005      	b.n	80056f4 <MIOS32_MIDI_SendPackage+0x68>
 80056e8:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // UART_MIDI has been disabled
#endif

    case IIC0://..15
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      return MIOS32_IIC_MIDI_PackageSend(package.cable, package);
 80056ec:	4630      	mov	r0, r6
 80056ee:	4621      	mov	r1, r4
 80056f0:	f000 fe6b 	bl	80063ca <MIOS32_IIC_MIDI_PackageSend>
      
    default:
      // invalid port
      return -1;
  }
}
 80056f4:	bd70      	pop	{r4, r5, r6, pc}
 80056f6:	bf00      	nop
 80056f8:	20000005 	.word	0x20000005
 80056fc:	20000004 	.word	0x20000004
 8005700:	200007b0 	.word	0x200007b0

08005704 <MIOS32_MIDI_SendEvent>:
//! \param[in] evnt2 third MIDI byte
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendEvent(mios32_midi_port_t port, u8 evnt0, u8 evnt1, u8 evnt2)
{
 8005704:	b508      	push	{r3, lr}

  // MEMO: don't optimize this function by calling MIOS32_MIDI_SendSpecialEvent
  // from here, because the 4 * u8 parameter list of this function leads
  // to best compile results (4*u8 combined to a single u32)

  package.type  = evnt0 >> 4;
 8005706:	f04f 0c00 	mov.w	ip, #0
 800570a:	ea4f 1e11 	mov.w	lr, r1, lsr #4
 800570e:	f36e 0c03 	bfi	ip, lr, #0, #4
  package.evnt0 = evnt0;
 8005712:	f361 2c0f 	bfi	ip, r1, #8, #8
  package.evnt1 = evnt1;
 8005716:	f362 4c17 	bfi	ip, r2, #16, #8
  package.evnt2 = evnt2;
 800571a:	f363 6c1f 	bfi	ip, r3, #24, #8
  return MIOS32_MIDI_SendPackage(port, package);
 800571e:	4661      	mov	r1, ip
 8005720:	f7ff ffb4 	bl	800568c <MIOS32_MIDI_SendPackage>
}
 8005724:	bd08      	pop	{r3, pc}

08005726 <MIOS32_MIDI_SendNoteOn>:

s32 MIOS32_MIDI_SendNoteOff(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x80 | chn, note, vel); }

s32 MIOS32_MIDI_SendNoteOn(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x90 | chn, note, vel); }
 8005726:	b508      	push	{r3, lr}
 8005728:	f041 0190 	orr.w	r1, r1, #144	; 0x90
 800572c:	f7ff ffea 	bl	8005704 <MIOS32_MIDI_SendEvent>
 8005730:	bd08      	pop	{r3, pc}

08005732 <MIOS32_MIDI_SendCC>:

s32 MIOS32_MIDI_SendPolyPressure(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xa0 | chn, note, val); }

s32 MIOS32_MIDI_SendCC(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 cc_number, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xb0 | chn, cc_number,   val); }
 8005732:	b508      	push	{r3, lr}
 8005734:	f041 01b0 	orr.w	r1, r1, #176	; 0xb0
 8005738:	f7ff ffe4 	bl	8005704 <MIOS32_MIDI_SendEvent>
 800573c:	bd08      	pop	{r3, pc}

0800573e <MIOS32_MIDI_SendSysEx>:
//! \param[in] count number of bytes
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendSysEx(mios32_midi_port_t port, u8 *stream, u32 count)
{
 800573e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005740:	b085      	sub	sp, #20
 8005742:	4617      	mov	r7, r2
 8005744:	9003      	str	r0, [sp, #12]
 8005746:	460d      	mov	r5, r1
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 8005748:	2600      	movs	r6, #0
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 800574a:	2306      	movs	r3, #6
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 800574c:	2207      	movs	r2, #7
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 800574e:	f04f 0c04 	mov.w	ip, #4
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 8005752:	e040      	b.n	80057d6 <MIOS32_MIDI_SendSysEx+0x98>
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 8005754:	1bb9      	subs	r1, r7, r6
 8005756:	2902      	cmp	r1, #2
 8005758:	d014      	beq.n	8005784 <MIOS32_MIDI_SendSysEx+0x46>
 800575a:	2903      	cmp	r1, #3
 800575c:	d01f      	beq.n	800579e <MIOS32_MIDI_SendSysEx+0x60>
 800575e:	2901      	cmp	r1, #1
 8005760:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 8005762:	bf18      	it	ne
 8005764:	f36c 0403 	bfine	r4, ip, #0, #4
 8005768:	f106 0601 	add.w	r6, r6, #1
	package.evnt0 = stream[offset++];
 800576c:	bf18      	it	ne
 800576e:	f361 240f 	bfine	r4, r1, #8, #8

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 8005772:	d11a      	bne.n	80057aa <MIOS32_MIDI_SendSysEx+0x6c>
      case 1: 
	package.type = 0x5; // SysEx ends with following single byte. 
 8005774:	2005      	movs	r0, #5
 8005776:	f360 0403 	bfi	r4, r0, #0, #4
	package.evnt0 = stream[offset++];
 800577a:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = 0x00;
 800577e:	f36f 4417 	bfc	r4, #16, #8
 8005782:	e009      	b.n	8005798 <MIOS32_MIDI_SendSysEx+0x5a>
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
	package.evnt0 = stream[offset++];
 8005784:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 8005786:	f363 0403 	bfi	r4, r3, #0, #4
	package.evnt0 = stream[offset++];
 800578a:	3601      	adds	r6, #1
 800578c:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = stream[offset++];
 8005790:	5da9      	ldrb	r1, [r5, r6]
 8005792:	3601      	adds	r6, #1
 8005794:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = 0x00;
 8005798:	f36f 641f 	bfc	r4, #24, #8
	break;
 800579c:	e00d      	b.n	80057ba <MIOS32_MIDI_SendSysEx+0x7c>
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
	package.evnt0 = stream[offset++];
 800579e:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 80057a0:	f362 0403 	bfi	r4, r2, #0, #4
	package.evnt0 = stream[offset++];
 80057a4:	f361 240f 	bfi	r4, r1, #8, #8
 80057a8:	3601      	adds	r6, #1
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
 80057aa:	5da9      	ldrb	r1, [r5, r6]
 80057ac:	3601      	adds	r6, #1
 80057ae:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = stream[offset++];
 80057b2:	5da9      	ldrb	r1, [r5, r6]
 80057b4:	3601      	adds	r6, #1
 80057b6:	f361 641f 	bfi	r4, r1, #24, #8
    }

    res=MIOS32_MIDI_SendPackage(port, package);
 80057ba:	9803      	ldr	r0, [sp, #12]
 80057bc:	4621      	mov	r1, r4
 80057be:	9201      	str	r2, [sp, #4]
 80057c0:	9302      	str	r3, [sp, #8]
 80057c2:	f8cd c000 	str.w	ip, [sp]
 80057c6:	f7ff ff61 	bl	800568c <MIOS32_MIDI_SendPackage>

    // expection? (e.g., port not available)
    if( res < 0 )
 80057ca:	2800      	cmp	r0, #0
 80057cc:	9a01      	ldr	r2, [sp, #4]
 80057ce:	9b02      	ldr	r3, [sp, #8]
 80057d0:	f8dd c000 	ldr.w	ip, [sp]
 80057d4:	db02      	blt.n	80057dc <MIOS32_MIDI_SendSysEx+0x9e>
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 80057d6:	42be      	cmp	r6, r7
 80057d8:	d3bc      	bcc.n	8005754 <MIOS32_MIDI_SendSysEx+0x16>
    // expection? (e.g., port not available)
    if( res < 0 )
      return res;
  }

  return 0;
 80057da:	2000      	movs	r0, #0
}
 80057dc:	b005      	add	sp, #20
 80057de:	bdf0      	pop	{r4, r5, r6, r7, pc}

080057e0 <MIOS32_MIDI_SYSEX_SendAckStr>:

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 80057e0:	b510      	push	{r4, lr}
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 80057e2:	23f0      	movs	r3, #240	; 0xf0

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 80057e4:	b0a0      	sub	sp, #128	; 0x80
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 80057e6:	f88d 3000 	strb.w	r3, [sp]
 80057ea:	2300      	movs	r3, #0
 80057ec:	f88d 3001 	strb.w	r3, [sp, #1]
 80057f0:	f88d 3002 	strb.w	r3, [sp, #2]
 80057f4:	337e      	adds	r3, #126	; 0x7e
 80057f6:	f88d 3003 	strb.w	r3, [sp, #3]
 80057fa:	2332      	movs	r3, #50	; 0x32
 80057fc:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005800:	4b0e      	ldr	r3, [pc, #56]	; (800583c <MIOS32_MIDI_SYSEX_SendAckStr+0x5c>)
}

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
 8005802:	f10d 0c6b 	add.w	ip, sp, #107	; 0x6b

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005806:	781b      	ldrb	r3, [r3, #0]
 8005808:	f88d 3005 	strb.w	r3, [sp, #5]

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;
 800580c:	230f      	movs	r3, #15
 800580e:	f88d 3006 	strb.w	r3, [sp, #6]
 8005812:	466b      	mov	r3, sp
 8005814:	1dda      	adds	r2, r3, #7
 8005816:	e003      	b.n	8005820 <MIOS32_MIDI_SYSEX_SendAckStr+0x40>

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
    *sysex_buffer_ptr++ = str[i];
 8005818:	f802 4b01 	strb.w	r4, [r2], #1

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
 800581c:	4562      	cmp	r2, ip
 800581e:	d003      	beq.n	8005828 <MIOS32_MIDI_SYSEX_SendAckStr+0x48>
 8005820:	f811 4b01 	ldrb.w	r4, [r1], #1
 8005824:	2c00      	cmp	r4, #0
 8005826:	d1f7      	bne.n	8005818 <MIOS32_MIDI_SYSEX_SendAckStr+0x38>
    *sysex_buffer_ptr++ = str[i];

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005828:	21f7      	movs	r1, #247	; 0xf7
 800582a:	f802 1b01 	strb.w	r1, [r2], #1

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 800582e:	1ad2      	subs	r2, r2, r3
 8005830:	4669      	mov	r1, sp
 8005832:	f7ff ff84 	bl	800573e <MIOS32_MIDI_SendSysEx>
}
 8005836:	b020      	add	sp, #128	; 0x80
 8005838:	bd10      	pop	{r4, pc}
 800583a:	bf00      	nop
 800583c:	200007bd 	.word	0x200007bd

08005840 <MIOS32_MIDI_SYSEX_SendAck>:
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 8005840:	b500      	push	{lr}
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005842:	23f0      	movs	r3, #240	; 0xf0
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 8005844:	b089      	sub	sp, #36	; 0x24
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005846:	f88d 3000 	strb.w	r3, [sp]
 800584a:	2300      	movs	r3, #0
 800584c:	f88d 3001 	strb.w	r3, [sp, #1]
 8005850:	f88d 3002 	strb.w	r3, [sp, #2]
 8005854:	337e      	adds	r3, #126	; 0x7e
 8005856:	f88d 3003 	strb.w	r3, [sp, #3]
 800585a:	2332      	movs	r3, #50	; 0x32
 800585c:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005860:	4b08      	ldr	r3, [pc, #32]	; (8005884 <MIOS32_MIDI_SYSEX_SendAck+0x44>)

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
 8005862:	f88d 1006 	strb.w	r1, [sp, #6]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005866:	781b      	ldrb	r3, [r3, #0]

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;
 8005868:	f88d 2007 	strb.w	r2, [sp, #7]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 800586c:	f88d 3005 	strb.w	r3, [sp, #5]

  // send footer
  *sysex_buffer_ptr++ = 0xf7;

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 8005870:	4669      	mov	r1, sp
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005872:	23f7      	movs	r3, #247	; 0xf7

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 8005874:	2209      	movs	r2, #9
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005876:	f88d 3008 	strb.w	r3, [sp, #8]

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 800587a:	f7ff ff60 	bl	800573e <MIOS32_MIDI_SendSysEx>
}
 800587e:	b009      	add	sp, #36	; 0x24
 8005880:	bd00      	pop	{pc}
 8005882:	bf00      	nop
 8005884:	200007bd 	.word	0x200007bd

08005888 <MIOS32_MIDI_SendDebugMessage>:
//! \param[in] *format zero-terminated format string - 128 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendDebugMessage(char *format, ...)
{
 8005888:	b40f      	push	{r0, r1, r2, r3}
 800588a:	b530      	push	{r4, r5, lr}
 800588c:	b0a5      	sub	sp, #148	; 0x94
 800588e:	9c28      	ldr	r4, [sp, #160]	; 0xa0

  // failsave: if format string is longer than 100 chars, break here
  // note that this is a weak protection: if %s is used, or a lot of other format tokens,
  // the resulting string could still lead to a buffer overflow
  // other the other hand we don't want to allocate too many byte for buffer[] to save stack
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
 8005890:	ad02      	add	r5, sp, #8
  if( strlen(format) > 100 ) {
 8005892:	4620      	mov	r0, r4
 8005894:	f004 fe3e 	bl	800a514 <strlen>
 8005898:	2864      	cmp	r0, #100	; 0x64
 800589a:	d91e      	bls.n	80058da <MIOS32_MIDI_SendDebugMessage+0x52>
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
 800589c:	4628      	mov	r0, r5
 800589e:	4920      	ldr	r1, [pc, #128]	; (8005920 <MIOS32_MIDI_SendDebugMessage+0x98>)
 80058a0:	f004 fe31 	bl	800a506 <strcpy>
    vsprintf(str, format, args);
  }

  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 80058a4:	23f0      	movs	r3, #240	; 0xf0
 80058a6:	f88d 3000 	strb.w	r3, [sp]
 80058aa:	2300      	movs	r3, #0
 80058ac:	f88d 3001 	strb.w	r3, [sp, #1]
 80058b0:	f88d 3002 	strb.w	r3, [sp, #2]
 80058b4:	337e      	adds	r3, #126	; 0x7e
 80058b6:	f88d 3003 	strb.w	r3, [sp, #3]
 80058ba:	2332      	movs	r3, #50	; 0x32
 80058bc:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80058c0:	4b18      	ldr	r3, [pc, #96]	; (8005924 <MIOS32_MIDI_SendDebugMessage+0x9c>)

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
 80058c2:	2208      	movs	r2, #8
  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80058c4:	781b      	ldrb	r3, [r3, #0]
 80058c6:	f88d 3005 	strb.w	r3, [sp, #5]

  // debug message: ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_DEBUG;
 80058ca:	230d      	movs	r3, #13
 80058cc:	f88d 3006 	strb.w	r3, [sp, #6]

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string
 80058d0:	3333      	adds	r3, #51	; 0x33
 80058d2:	f88d 3007 	strb.w	r3, [sp, #7]
 80058d6:	ab02      	add	r3, sp, #8
 80058d8:	e00f      	b.n	80058fa <MIOS32_MIDI_SendDebugMessage+0x72>
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 80058da:	aa29      	add	r2, sp, #164	; 0xa4
    vsprintf(str, format, args);
 80058dc:	4628      	mov	r0, r5
 80058de:	4621      	mov	r1, r4
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 80058e0:	9223      	str	r2, [sp, #140]	; 0x8c
    vsprintf(str, format, args);
 80058e2:	f003 f880 	bl	80089e6 <vsprintf>
 80058e6:	e7dd      	b.n	80058a4 <MIOS32_MIDI_SendDebugMessage+0x1c>

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
 80058e8:	3201      	adds	r2, #1
 80058ea:	b292      	uxth	r2, r2
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 80058ec:	f000 007f 	and.w	r0, r0, #127	; 0x7f
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 80058f0:	2a88      	cmp	r2, #136	; 0x88
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 80058f2:	f803 0c01 	strb.w	r0, [r3, #-1]
 80058f6:	4619      	mov	r1, r3
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 80058f8:	d004      	beq.n	8005904 <MIOS32_MIDI_SendDebugMessage+0x7c>
 80058fa:	4619      	mov	r1, r3
 80058fc:	f813 0b01 	ldrb.w	r0, [r3], #1
 8005900:	2800      	cmp	r0, #0
 8005902:	d1f1      	bne.n	80058e8 <MIOS32_MIDI_SendDebugMessage+0x60>
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005904:	23f7      	movs	r3, #247	; 0xf7
 8005906:	700b      	strb	r3, [r1, #0]
  ++len;

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 8005908:	4b07      	ldr	r3, [pc, #28]	; (8005928 <MIOS32_MIDI_SendDebugMessage+0xa0>)
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
  ++len;
 800590a:	3201      	adds	r2, #1

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 800590c:	7818      	ldrb	r0, [r3, #0]
 800590e:	b292      	uxth	r2, r2
 8005910:	4669      	mov	r1, sp
 8005912:	f7ff ff14 	bl	800573e <MIOS32_MIDI_SendSysEx>
}
 8005916:	b025      	add	sp, #148	; 0x94
 8005918:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800591c:	b004      	add	sp, #16
 800591e:	4770      	bx	lr
 8005920:	0800af08 	.word	0x0800af08
 8005924:	200007bd 	.word	0x200007bd
 8005928:	20000005 	.word	0x20000005

0800592c <MIOS32_MIDI_SYSEX_Cmd>:

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 800592c:	b530      	push	{r4, r5, lr}
 800592e:	460b      	mov	r3, r1
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 8005930:	4959      	ldr	r1, [pc, #356]	; (8005a98 <MIOS32_MIDI_SYSEX_Cmd+0x16c>)

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 8005932:	b08b      	sub	sp, #44	; 0x2c
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 8005934:	7809      	ldrb	r1, [r1, #0]

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 8005936:	4604      	mov	r4, r0
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 8005938:	290d      	cmp	r1, #13
 800593a:	d05e      	beq.n	80059fa <MIOS32_MIDI_SYSEX_Cmd+0xce>
 800593c:	d801      	bhi.n	8005942 <MIOS32_MIDI_SYSEX_Cmd+0x16>
 800593e:	b139      	cbz	r1, 8005950 <MIOS32_MIDI_SYSEX_Cmd+0x24>
 8005940:	e09d      	b.n	8005a7e <MIOS32_MIDI_SYSEX_Cmd+0x152>
 8005942:	290e      	cmp	r1, #14
 8005944:	f000 80a5 	beq.w	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
 8005948:	290f      	cmp	r1, #15
 800594a:	f040 8098 	bne.w	8005a7e <MIOS32_MIDI_SYSEX_Cmd+0x152>
 800594e:	e08a      	b.n	8005a66 <MIOS32_MIDI_SYSEX_Cmd+0x13a>
static s32 MIOS32_MIDI_SYSEX_Cmd_Query(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 query_req = 0;
  char str_buffer[40];

  switch( cmd_state ) {
 8005950:	b11b      	cbz	r3, 800595a <MIOS32_MIDI_SYSEX_Cmd+0x2e>
 8005952:	2b01      	cmp	r3, #1
 8005954:	4b51      	ldr	r3, [pc, #324]	; (8005a9c <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 8005956:	d102      	bne.n	800595e <MIOS32_MIDI_SYSEX_Cmd+0x32>
 8005958:	e056      	b.n	8005a08 <MIOS32_MIDI_SYSEX_Cmd+0xdc>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      query_req = 0;
 800595a:	4a50      	ldr	r2, [pc, #320]	; (8005a9c <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 800595c:	e098      	b.n	8005a90 <MIOS32_MIDI_SYSEX_Cmd+0x164>
    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      query_req = midi_in;
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      switch( query_req ) {
 800595e:	781b      	ldrb	r3, [r3, #0]
 8005960:	2b05      	cmp	r3, #5
 8005962:	d025      	beq.n	80059b0 <MIOS32_MIDI_SYSEX_Cmd+0x84>
 8005964:	d80a      	bhi.n	800597c <MIOS32_MIDI_SYSEX_Cmd+0x50>
 8005966:	2b02      	cmp	r3, #2
 8005968:	d017      	beq.n	800599a <MIOS32_MIDI_SYSEX_Cmd+0x6e>
 800596a:	d802      	bhi.n	8005972 <MIOS32_MIDI_SYSEX_Cmd+0x46>
 800596c:	2b01      	cmp	r3, #1
 800596e:	d140      	bne.n	80059f2 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 8005970:	e011      	b.n	8005996 <MIOS32_MIDI_SYSEX_Cmd+0x6a>
 8005972:	2b03      	cmp	r3, #3
 8005974:	d013      	beq.n	800599e <MIOS32_MIDI_SYSEX_Cmd+0x72>
 8005976:	2b04      	cmp	r3, #4
 8005978:	d13b      	bne.n	80059f2 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 800597a:	e012      	b.n	80059a2 <MIOS32_MIDI_SYSEX_Cmd+0x76>
 800597c:	2b08      	cmp	r3, #8
 800597e:	d02f      	beq.n	80059e0 <MIOS32_MIDI_SYSEX_Cmd+0xb4>
 8005980:	d804      	bhi.n	800598c <MIOS32_MIDI_SYSEX_Cmd+0x60>
 8005982:	2b06      	cmp	r3, #6
 8005984:	d01e      	beq.n	80059c4 <MIOS32_MIDI_SYSEX_Cmd+0x98>
 8005986:	2b07      	cmp	r3, #7
 8005988:	d133      	bne.n	80059f2 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 800598a:	e01e      	b.n	80059ca <MIOS32_MIDI_SYSEX_Cmd+0x9e>
 800598c:	2b09      	cmp	r3, #9
 800598e:	d029      	beq.n	80059e4 <MIOS32_MIDI_SYSEX_Cmd+0xb8>
 8005990:	2b7f      	cmp	r3, #127	; 0x7f
 8005992:	d12e      	bne.n	80059f2 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 8005994:	e02a      	b.n	80059ec <MIOS32_MIDI_SYSEX_Cmd+0xc0>
        case 0x01: // operating system
	  MIOS32_MIDI_SYSEX_SendAckStr(port, "MIOS32");
 8005996:	4942      	ldr	r1, [pc, #264]	; (8005aa0 <MIOS32_MIDI_SYSEX_Cmd+0x174>)
 8005998:	e025      	b.n	80059e6 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x02: // Board
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_BOARD_STR);
 800599a:	4942      	ldr	r1, [pc, #264]	; (8005aa4 <MIOS32_MIDI_SYSEX_Cmd+0x178>)
 800599c:	e023      	b.n	80059e6 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x03: // Core Family
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_FAMILY_STR);
 800599e:	4942      	ldr	r1, [pc, #264]	; (8005aa8 <MIOS32_MIDI_SYSEX_Cmd+0x17c>)
 80059a0:	e021      	b.n	80059e6 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
 80059a2:	f000 fd5b 	bl	800645c <MIOS32_SYS_ChipIDGet>
 80059a6:	466d      	mov	r5, sp
 80059a8:	4602      	mov	r2, r0
 80059aa:	4940      	ldr	r1, [pc, #256]	; (8005aac <MIOS32_MIDI_SYSEX_Cmd+0x180>)
 80059ac:	4668      	mov	r0, sp
 80059ae:	e012      	b.n	80059d6 <MIOS32_MIDI_SYSEX_Cmd+0xaa>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 80059b0:	4668      	mov	r0, sp
 80059b2:	f000 fd69 	bl	8006488 <MIOS32_SYS_SerialNumberGet>
 80059b6:	2800      	cmp	r0, #0
 80059b8:	466d      	mov	r5, sp
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
 80059ba:	bfbc      	itt	lt
 80059bc:	4620      	movlt	r0, r4
 80059be:	493c      	ldrlt	r1, [pc, #240]	; (8005ab0 <MIOS32_MIDI_SYSEX_Cmd+0x184>)
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 80059c0:	da0b      	bge.n	80059da <MIOS32_MIDI_SYSEX_Cmd+0xae>
 80059c2:	e010      	b.n	80059e6 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
	  break;
        case 0x06: // Flash Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_FlashSizeGet());
 80059c4:	f000 fd50 	bl	8006468 <MIOS32_SYS_FlashSizeGet>
 80059c8:	e001      	b.n	80059ce <MIOS32_MIDI_SYSEX_Cmd+0xa2>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  break;
        case 0x07: // RAM Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_RAMSizeGet());
 80059ca:	f000 fd55 	bl	8006478 <MIOS32_SYS_RAMSizeGet>
 80059ce:	4939      	ldr	r1, [pc, #228]	; (8005ab4 <MIOS32_MIDI_SYSEX_Cmd+0x188>)
 80059d0:	4602      	mov	r2, r0
 80059d2:	466d      	mov	r5, sp
 80059d4:	4668      	mov	r0, sp
 80059d6:	f002 fff7 	bl	80089c8 <sprintf>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
 80059da:	4620      	mov	r0, r4
 80059dc:	4669      	mov	r1, sp
 80059de:	e002      	b.n	80059e6 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x08: // Application Name Line #1
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE1);
 80059e0:	4935      	ldr	r1, [pc, #212]	; (8005ab8 <MIOS32_MIDI_SYSEX_Cmd+0x18c>)
 80059e2:	e000      	b.n	80059e6 <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x09: // Application Name Line #2
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE2);
 80059e4:	4935      	ldr	r1, [pc, #212]	; (8005abc <MIOS32_MIDI_SYSEX_Cmd+0x190>)
 80059e6:	f7ff fefb 	bl	80057e0 <MIOS32_MIDI_SYSEX_SendAckStr>
 80059ea:	e052      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
#if MIOS32_MIDI_BSL_ENHANCEMENTS
	  // release halt state (or sending upload request) instead of reseting the core
	  BSL_SYSEX_ReleaseHaltState();
#else
	  // reset core (this will send an upload request)
	  MIOS32_SYS_Reset();
 80059ec:	f000 fcfa 	bl	80063e4 <MIOS32_SYS_Reset>
 80059f0:	e04f      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  // but other core families could contain an empty stumb!
#endif
	  break;
        default: 
	  // unknown query
	  MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNKNOWN_QUERY);
 80059f2:	4620      	mov	r0, r4
 80059f4:	210e      	movs	r1, #14
 80059f6:	220d      	movs	r2, #13
 80059f8:	e03e      	b.n	8005a78 <MIOS32_MIDI_SYSEX_Cmd+0x14c>
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Debug(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 debug_req = 0xff;

  switch( cmd_state ) {
 80059fa:	b11b      	cbz	r3, 8005a04 <MIOS32_MIDI_SYSEX_Cmd+0xd8>
 80059fc:	2b01      	cmp	r3, #1
 80059fe:	4d30      	ldr	r5, [pc, #192]	; (8005ac0 <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 8005a00:	d114      	bne.n	8005a2c <MIOS32_MIDI_SYSEX_Cmd+0x100>
 8005a02:	e003      	b.n	8005a0c <MIOS32_MIDI_SYSEX_Cmd+0xe0>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
 8005a04:	4b2e      	ldr	r3, [pc, #184]	; (8005ac0 <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 8005a06:	22ff      	movs	r2, #255	; 0xff
 8005a08:	701a      	strb	r2, [r3, #0]
 8005a0a:	e042      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005a0c:	782b      	ldrb	r3, [r5, #0]
 8005a0e:	2bff      	cmp	r3, #255	; 0xff
	debug_req = midi_in;
 8005a10:	bf08      	it	eq
 8005a12:	702a      	strbeq	r2, [r5, #0]
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005a14:	d03d      	beq.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	debug_req = midi_in;
      } else {
	switch( debug_req ) {
 8005a16:	2b00      	cmp	r3, #0
 8005a18:	d13b      	bne.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  case 0x00: // input string
	    if( debug_command_callback_func != NULL )
 8005a1a:	4b2a      	ldr	r3, [pc, #168]	; (8005ac4 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 8005a1c:	681b      	ldr	r3, [r3, #0]
 8005a1e:	2b00      	cmp	r3, #0
 8005a20:	d037      	beq.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	      debug_command_callback_func(last_sysex_port, (char)midi_in);
 8005a22:	4929      	ldr	r1, [pc, #164]	; (8005ac8 <MIOS32_MIDI_SYSEX_Cmd+0x19c>)
 8005a24:	7808      	ldrb	r0, [r1, #0]
 8005a26:	4611      	mov	r1, r2
 8005a28:	4798      	blx	r3
 8005a2a:	e032      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	}
      }
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      if( debug_req == 0x00 ) {
 8005a2c:	782a      	ldrb	r2, [r5, #0]
 8005a2e:	b9ba      	cbnz	r2, 8005a60 <MIOS32_MIDI_SYSEX_Cmd+0x134>
	// send acknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8005a30:	210f      	movs	r1, #15
 8005a32:	f7ff ff05 	bl	8005840 <MIOS32_MIDI_SYSEX_SendAck>

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
 8005a36:	782b      	ldrb	r3, [r5, #0]
 8005a38:	2b00      	cmp	r3, #0
 8005a3a:	d12a      	bne.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
 8005a3c:	4b21      	ldr	r3, [pc, #132]	; (8005ac4 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 8005a3e:	681b      	ldr	r3, [r3, #0]
 8005a40:	2b00      	cmp	r3, #0
 8005a42:	d126      	bne.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 8005a44:	4b21      	ldr	r3, [pc, #132]	; (8005acc <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 8005a46:	2c01      	cmp	r4, #1
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 8005a48:	781d      	ldrb	r5, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 8005a4a:	4821      	ldr	r0, [pc, #132]	; (8005ad0 <MIOS32_MIDI_SYSEX_Cmd+0x1a4>)
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
    return -1;

  debug_port = port;
 8005a4c:	bf18      	it	ne
 8005a4e:	701c      	strbne	r4, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 8005a50:	4621      	mov	r1, r4
 8005a52:	f7ff ff19 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 8005a56:	2d01      	cmp	r5, #1
    return -1;

  debug_port = port;
 8005a58:	bf1c      	itt	ne
 8005a5a:	4b1c      	ldrne	r3, [pc, #112]	; (8005acc <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
 8005a5c:	701d      	strbne	r5, [r3, #0]
 8005a5e:	e018      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  MIOS32_MIDI_DebugPortSet(prev_debug_port);
	}

      } else {
	// send disacknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNSUPPORTED_DEBUG);
 8005a60:	210e      	movs	r1, #14
 8005a62:	2210      	movs	r2, #16
 8005a64:	e008      	b.n	8005a78 <MIOS32_MIDI_SYSEX_Cmd+0x14c>
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
 8005a66:	4a1b      	ldr	r2, [pc, #108]	; (8005ad4 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
/////////////////////////////////////////////////////////////////////////////
// Command 0F: Ping (just send back acknowledge if no additional byte has been received)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {
 8005a68:	b113      	cbz	r3, 8005a70 <MIOS32_MIDI_SYSEX_Cmd+0x144>
 8005a6a:	2b01      	cmp	r3, #1
 8005a6c:	4a19      	ldr	r2, [pc, #100]	; (8005ad4 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 8005a6e:	d101      	bne.n	8005a74 <MIOS32_MIDI_SYSEX_Cmd+0x148>
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      sysex_state.PING_BYTE_RECEIVED = 1;
 8005a70:	6053      	str	r3, [r2, #4]
 8005a72:	e00e      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      // TODO: send 0xf7 if merger enabled

      // send acknowledge if no additional byte has been received
      // to avoid feedback loop if two cores are directly connected
      if( !sysex_state.PING_BYTE_RECEIVED )
 8005a74:	6852      	ldr	r2, [r2, #4]
 8005a76:	b962      	cbnz	r2, 8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8005a78:	f7ff fee2 	bl	8005840 <MIOS32_MIDI_SYSEX_SendAck>
 8005a7c:	e009      	b.n	8005a92 <MIOS32_MIDI_SYSEX_Cmd+0x166>
      MIOS32_MIDI_SYSEX_Cmd_Ping(port, cmd_state, midi_in);
      break;
    default:
      // unknown command
      // TODO: send 0xf7 if merger enabled
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
 8005a7e:	210e      	movs	r1, #14
 8005a80:	460a      	mov	r2, r1
 8005a82:	4620      	mov	r0, r4
 8005a84:	f7ff fedc 	bl	8005840 <MIOS32_MIDI_SYSEX_SendAck>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005a88:	4a12      	ldr	r2, [pc, #72]	; (8005ad4 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 8005a8a:	2300      	movs	r3, #0
 8005a8c:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005a8e:	4a02      	ldr	r2, [pc, #8]	; (8005a98 <MIOS32_MIDI_SYSEX_Cmd+0x16c>)
 8005a90:	7013      	strb	r3, [r2, #0]
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
      MIOS32_MIDI_SYSEX_CmdFinished();      
  }

  return 0; // no error
}
 8005a92:	2000      	movs	r0, #0
 8005a94:	b00b      	add	sp, #44	; 0x2c
 8005a96:	bd30      	pop	{r4, r5, pc}
 8005a98:	200007b4 	.word	0x200007b4
 8005a9c:	200007c0 	.word	0x200007c0
 8005aa0:	0800af5b 	.word	0x0800af5b
 8005aa4:	0800af62 	.word	0x0800af62
 8005aa8:	0800af72 	.word	0x0800af72
 8005aac:	0800af7c 	.word	0x0800af7c
 8005ab0:	0800af81 	.word	0x0800af81
 8005ab4:	0800af83 	.word	0x0800af83
 8005ab8:	0800aec4 	.word	0x0800aec4
 8005abc:	0800aed5 	.word	0x0800aed5
 8005ac0:	20000006 	.word	0x20000006
 8005ac4:	200007cc 	.word	0x200007cc
 8005ac8:	200007bc 	.word	0x200007bc
 8005acc:	20000005 	.word	0x20000005
 8005ad0:	0800af86 	.word	0x0800af86
 8005ad4:	200007c4 	.word	0x200007c4

08005ad8 <MIOS32_MIDI_SYSEX_Parser>:
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005ad8:	29f7      	cmp	r1, #247	; 0xf7

/////////////////////////////////////////////////////////////////////////////
// This function parses an incoming sysex stream for MIOS32 commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
 8005ada:	b510      	push	{r4, lr}
 8005adc:	460a      	mov	r2, r1
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005ade:	d85c      	bhi.n	8005b9a <MIOS32_MIDI_SYSEX_Parser+0xc2>
    return 0;

  // TODO: here we could send an error notification, that multiple devices are trying to access the device
  if( sysex_state.MY_SYSEX && port != last_sysex_port )
 8005ae0:	4b2f      	ldr	r3, [pc, #188]	; (8005ba0 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005ae2:	781c      	ldrb	r4, [r3, #0]
 8005ae4:	f004 0308 	and.w	r3, r4, #8
 8005ae8:	b2db      	uxtb	r3, r3
 8005aea:	b11b      	cbz	r3, 8005af4 <MIOS32_MIDI_SYSEX_Parser+0x1c>
 8005aec:	492d      	ldr	r1, [pc, #180]	; (8005ba4 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005aee:	7809      	ldrb	r1, [r1, #0]
 8005af0:	4281      	cmp	r1, r0
 8005af2:	d14f      	bne.n	8005b94 <MIOS32_MIDI_SYSEX_Parser+0xbc>
  // USB upload is only allowed via USB0
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
 8005af4:	f1a0 0111 	sub.w	r1, r0, #17
 8005af8:	b2c9      	uxtb	r1, r1
 8005afa:	2906      	cmp	r1, #6
 8005afc:	d94a      	bls.n	8005b94 <MIOS32_MIDI_SYSEX_Parser+0xbc>
    return -1;

  last_sysex_port = port;
 8005afe:	4929      	ldr	r1, [pc, #164]	; (8005ba4 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005b00:	7008      	strb	r0, [r1, #0]

  // branch depending on state
  if( !sysex_state.MY_SYSEX ) {
 8005b02:	bb0b      	cbnz	r3, 8005b48 <MIOS32_MIDI_SYSEX_Parser+0x70>
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
 8005b04:	4b26      	ldr	r3, [pc, #152]	; (8005ba0 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b06:	781b      	ldrb	r3, [r3, #0]
 8005b08:	f003 0307 	and.w	r3, r3, #7
 8005b0c:	2b04      	cmp	r3, #4
 8005b0e:	d803      	bhi.n	8005b18 <MIOS32_MIDI_SYSEX_Parser+0x40>
 8005b10:	4925      	ldr	r1, [pc, #148]	; (8005ba8 <MIOS32_MIDI_SYSEX_Parser+0xd0>)
 8005b12:	5cc9      	ldrb	r1, [r1, r3]
 8005b14:	4291      	cmp	r1, r2
 8005b16:	d123      	bne.n	8005b60 <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005b18:	f004 0407 	and.w	r4, r4, #7
 8005b1c:	2c05      	cmp	r4, #5
 8005b1e:	d103      	bne.n	8005b28 <MIOS32_MIDI_SYSEX_Parser+0x50>
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
 8005b20:	4922      	ldr	r1, [pc, #136]	; (8005bac <MIOS32_MIDI_SYSEX_Parser+0xd4>)
 8005b22:	7809      	ldrb	r1, [r1, #0]
 8005b24:	4291      	cmp	r1, r2
 8005b26:	d11b      	bne.n	8005b60 <MIOS32_MIDI_SYSEX_Parser+0x88>
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005b28:	3301      	adds	r3, #1
 8005b2a:	f003 0207 	and.w	r2, r3, #7
 8005b2e:	4b1c      	ldr	r3, [pc, #112]	; (8005ba0 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b30:	2a05      	cmp	r2, #5
 8005b32:	7819      	ldrb	r1, [r3, #0]
 8005b34:	f362 0102 	bfi	r1, r2, #0, #3
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005b38:	bf84      	itt	hi
 8005b3a:	b2ca      	uxtbhi	r2, r1
 8005b3c:	f042 0208 	orrhi.w	r2, r2, #8
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005b40:	7019      	strb	r1, [r3, #0]
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005b42:	bf88      	it	hi
 8005b44:	701a      	strbhi	r2, [r3, #0]
 8005b46:	e028      	b.n	8005b9a <MIOS32_MIDI_SYSEX_Parser+0xc2>
      }
    }
  } else {
    // check for end of SysEx message or invalid status byte
    if( midi_in >= 0x80 ) {
 8005b48:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005b4c:	d00e      	beq.n	8005b6c <MIOS32_MIDI_SYSEX_Parser+0x94>
      if( midi_in == 0xf7 && sysex_state.CMD ) {
 8005b4e:	2af7      	cmp	r2, #247	; 0xf7
 8005b50:	d106      	bne.n	8005b60 <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005b52:	f004 0410 	and.w	r4, r4, #16
 8005b56:	b2e4      	uxtb	r4, r4
 8005b58:	b114      	cbz	r4, 8005b60 <MIOS32_MIDI_SYSEX_Parser+0x88>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
 8005b5a:	2102      	movs	r1, #2
 8005b5c:	f7ff fee6 	bl	800592c <MIOS32_MIDI_SYSEX_Cmd>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005b60:	4b0f      	ldr	r3, [pc, #60]	; (8005ba0 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b62:	2000      	movs	r0, #0
 8005b64:	7018      	strb	r0, [r3, #0]
  sysex_cmd = 0;
 8005b66:	4b12      	ldr	r3, [pc, #72]	; (8005bb0 <MIOS32_MIDI_SYSEX_Parser+0xd8>)
 8005b68:	7018      	strb	r0, [r3, #0]
 8005b6a:	e017      	b.n	8005b9c <MIOS32_MIDI_SYSEX_Parser+0xc4>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
      }
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
 8005b6c:	f004 0410 	and.w	r4, r4, #16
 8005b70:	b2e4      	uxtb	r4, r4
 8005b72:	b95c      	cbnz	r4, 8005b8c <MIOS32_MIDI_SYSEX_Parser+0xb4>
	sysex_state.CMD = 1;
 8005b74:	4b0a      	ldr	r3, [pc, #40]	; (8005ba0 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b76:	7819      	ldrb	r1, [r3, #0]
 8005b78:	f041 0110 	orr.w	r1, r1, #16
 8005b7c:	7019      	strb	r1, [r3, #0]
	sysex_cmd = midi_in;
 8005b7e:	4b0c      	ldr	r3, [pc, #48]	; (8005bb0 <MIOS32_MIDI_SYSEX_Parser+0xd8>)
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005b80:	4621      	mov	r1, r4
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
 8005b82:	701a      	strb	r2, [r3, #0]
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005b84:	f7ff fed2 	bl	800592c <MIOS32_MIDI_SYSEX_Cmd>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005b88:	4620      	mov	r0, r4
 8005b8a:	e007      	b.n	8005b9c <MIOS32_MIDI_SYSEX_Parser+0xc4>
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
      }
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
 8005b8c:	2101      	movs	r1, #1
 8005b8e:	f7ff fecd 	bl	800592c <MIOS32_MIDI_SYSEX_Cmd>
 8005b92:	e002      	b.n	8005b9a <MIOS32_MIDI_SYSEX_Parser+0xc2>
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
    return -1;
 8005b94:	f04f 30ff 	mov.w	r0, #4294967295
 8005b98:	e000      	b.n	8005b9c <MIOS32_MIDI_SYSEX_Parser+0xc4>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005b9a:	2000      	movs	r0, #0
}
 8005b9c:	bd10      	pop	{r4, pc}
 8005b9e:	bf00      	nop
 8005ba0:	200007c4 	.word	0x200007c4
 8005ba4:	200007bc 	.word	0x200007bc
 8005ba8:	0800b024 	.word	0x0800b024
 8005bac:	200007bd 	.word	0x200007bd
 8005bb0:	200007b4 	.word	0x200007b4

08005bb4 <MIOS32_MIDI_TimeOut>:

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005bb4:	b510      	push	{r4, lr}
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005bb6:	4a0d      	ldr	r2, [pc, #52]	; (8005bec <MIOS32_MIDI_TimeOut+0x38>)

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005bb8:	4604      	mov	r4, r0
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005bba:	7813      	ldrb	r3, [r2, #0]
 8005bbc:	f003 0308 	and.w	r3, r3, #8
 8005bc0:	b2db      	uxtb	r3, r3
 8005bc2:	b13b      	cbz	r3, 8005bd4 <MIOS32_MIDI_TimeOut+0x20>
 8005bc4:	4b0a      	ldr	r3, [pc, #40]	; (8005bf0 <MIOS32_MIDI_TimeOut+0x3c>)
 8005bc6:	781b      	ldrb	r3, [r3, #0]
 8005bc8:	4283      	cmp	r3, r0
 8005bca:	d103      	bne.n	8005bd4 <MIOS32_MIDI_TimeOut+0x20>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005bcc:	2300      	movs	r3, #0
 8005bce:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005bd0:	4a08      	ldr	r2, [pc, #32]	; (8005bf4 <MIOS32_MIDI_TimeOut+0x40>)
 8005bd2:	7013      	strb	r3, [r2, #0]
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
    MIOS32_MIDI_SYSEX_CmdFinished();

  // optional hook to application
  if( timeout_callback_func != NULL )
 8005bd4:	4b08      	ldr	r3, [pc, #32]	; (8005bf8 <MIOS32_MIDI_TimeOut+0x44>)
 8005bd6:	681b      	ldr	r3, [r3, #0]
 8005bd8:	b10b      	cbz	r3, 8005bde <MIOS32_MIDI_TimeOut+0x2a>
    timeout_callback_func(port);
 8005bda:	4620      	mov	r0, r4
 8005bdc:	4798      	blx	r3

#if 1
  // this debug message should always be active, so that common users are informed about the exception
  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_Receive_Handler] Timeout on port 0x%02x\n", port);
 8005bde:	4621      	mov	r1, r4
 8005be0:	4806      	ldr	r0, [pc, #24]	; (8005bfc <MIOS32_MIDI_TimeOut+0x48>)
 8005be2:	f7ff fe51 	bl	8005888 <MIOS32_MIDI_SendDebugMessage>
#endif

  return 0; // no error
}
 8005be6:	2000      	movs	r0, #0
 8005be8:	bd10      	pop	{r4, pc}
 8005bea:	bf00      	nop
 8005bec:	200007c4 	.word	0x200007c4
 8005bf0:	200007bc 	.word	0x200007bc
 8005bf4:	200007b4 	.word	0x200007b4
 8005bf8:	200007d8 	.word	0x200007d8
 8005bfc:	0800afd4 	.word	0x0800afd4

08005c00 <MIOS32_MIDI_Receive_Handler>:
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c00:	b5f0      	push	{r4, r5, r6, r7, lr}

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005c02:	2200      	movs	r2, #0
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c04:	b089      	sub	sp, #36	; 0x24
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005c06:	2101      	movs	r1, #1
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c08:	4605      	mov	r5, r0
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005c0a:	9104      	str	r1, [sp, #16]

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005c0c:	9201      	str	r2, [sp, #4]
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
 8005c0e:	9203      	str	r2, [sp, #12]
  u8 port;
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
 8005c10:	4613      	mov	r3, r2
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005c12:	4fc5      	ldr	r7, [pc, #788]	; (8005f28 <MIOS32_MIDI_Receive_Handler+0x328>)
 8005c14:	e000      	b.n	8005c18 <MIOS32_MIDI_Receive_Handler+0x18>

      MIOS32_MIDI_TimeOut(timeout_port);
      sysex_timeout_ctr_flags.ALL = 0;
      again = 0;
    }
  } while( again );
 8005c16:	9b05      	ldr	r3, [sp, #20]
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8005c18:	1c5a      	adds	r2, r3, #1
 8005c1a:	b2d2      	uxtb	r2, r2
 8005c1c:	9205      	str	r2, [sp, #20]
 8005c1e:	2b0b      	cmp	r3, #11
 8005c20:	d851      	bhi.n	8005cc6 <MIOS32_MIDI_Receive_Handler+0xc6>
 8005c22:	e8df f003 	tbb	[pc, r3]
 8005c26:	0e06      	.short	0x0e06
 8005c28:	26201a14 	.word	0x26201a14
 8005c2c:	3e38322c 	.word	0x3e38322c
 8005c30:	4a44      	.short	0x4a44
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      case 0: status = MIOS32_USB_MIDI_PackageReceive(&package); port = USB0 + package.cable; break;
 8005c32:	a807      	add	r0, sp, #28
 8005c34:	f002 f9d6 	bl	8007fe4 <MIOS32_USB_MIDI_PackageReceive>
 8005c38:	9c07      	ldr	r4, [sp, #28]
 8005c3a:	f3c4 1403 	ubfx	r4, r4, #4, #4
 8005c3e:	3410      	adds	r4, #16
 8005c40:	e052      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 0: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART0_ASSIGNMENT == 1
      case 1: status = MIOS32_UART_MIDI_PackageReceive(0, &package); port = UART0; break;
 8005c42:	2000      	movs	r0, #0
 8005c44:	a907      	add	r1, sp, #28
 8005c46:	f000 fae3 	bl	8006210 <MIOS32_UART_MIDI_PackageReceive>
 8005c4a:	2420      	movs	r4, #32
 8005c4c:	e04c      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 1: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART1_ASSIGNMENT == 1
      case 2: status = MIOS32_UART_MIDI_PackageReceive(1, &package); port = UART1; break;
 8005c4e:	2001      	movs	r0, #1
 8005c50:	a907      	add	r1, sp, #28
 8005c52:	f000 fadd 	bl	8006210 <MIOS32_UART_MIDI_PackageReceive>
 8005c56:	2421      	movs	r4, #33	; 0x21
 8005c58:	e046      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 2: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART2_ASSIGNMENT == 1
      case 3: status = MIOS32_UART_MIDI_PackageReceive(2, &package); port = UART2; break;
 8005c5a:	2002      	movs	r0, #2
 8005c5c:	a907      	add	r1, sp, #28
 8005c5e:	f000 fad7 	bl	8006210 <MIOS32_UART_MIDI_PackageReceive>
 8005c62:	2422      	movs	r4, #34	; 0x22
 8005c64:	e040      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 3: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 4: status = MIOS32_IIC_MIDI_PackageReceive(0, &package); port = IIC0; break;
 8005c66:	2000      	movs	r0, #0
 8005c68:	a907      	add	r1, sp, #28
 8005c6a:	f000 fbb1 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005c6e:	2430      	movs	r4, #48	; 0x30
 8005c70:	e03a      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 4: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 5: status = MIOS32_IIC_MIDI_PackageReceive(1, &package); port = IIC1; break;
 8005c72:	2001      	movs	r0, #1
 8005c74:	a907      	add	r1, sp, #28
 8005c76:	f000 fbab 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005c7a:	2431      	movs	r4, #49	; 0x31
 8005c7c:	e034      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 5: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 6: status = MIOS32_IIC_MIDI_PackageReceive(2, &package); port = IIC2; break;
 8005c7e:	2002      	movs	r0, #2
 8005c80:	a907      	add	r1, sp, #28
 8005c82:	f000 fba5 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005c86:	2432      	movs	r4, #50	; 0x32
 8005c88:	e02e      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 6: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 7: status = MIOS32_IIC_MIDI_PackageReceive(3, &package); port = IIC3; break;
 8005c8a:	2003      	movs	r0, #3
 8005c8c:	a907      	add	r1, sp, #28
 8005c8e:	f000 fb9f 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005c92:	2433      	movs	r4, #51	; 0x33
 8005c94:	e028      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 7: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 8: status = MIOS32_IIC_MIDI_PackageReceive(4, &package); port = IIC4; break;
 8005c96:	2004      	movs	r0, #4
 8005c98:	a907      	add	r1, sp, #28
 8005c9a:	f000 fb99 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005c9e:	2434      	movs	r4, #52	; 0x34
 8005ca0:	e022      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 8: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 9: status = MIOS32_IIC_MIDI_PackageReceive(5, &package); port = IIC5; break;
 8005ca2:	2005      	movs	r0, #5
 8005ca4:	a907      	add	r1, sp, #28
 8005ca6:	f000 fb93 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005caa:	2435      	movs	r4, #53	; 0x35
 8005cac:	e01c      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 9: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 10: status = MIOS32_IIC_MIDI_PackageReceive(6, &package); port = IIC6; break;
 8005cae:	2006      	movs	r0, #6
 8005cb0:	a907      	add	r1, sp, #28
 8005cb2:	f000 fb8d 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005cb6:	2436      	movs	r4, #54	; 0x36
 8005cb8:	e016      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 10: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 11: status = MIOS32_IIC_MIDI_PackageReceive(7, &package); port = IIC7; break;
 8005cba:	2007      	movs	r0, #7
 8005cbc:	a907      	add	r1, sp, #28
 8005cbe:	f000 fb87 	bl	80063d0 <MIOS32_IIC_MIDI_PackageReceive>
 8005cc2:	2437      	movs	r4, #55	; 0x37
 8005cc4:	e010      	b.n	8005ce8 <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
 8005cc6:	9a01      	ldr	r2, [sp, #4]
 8005cc8:	9903      	ldr	r1, [sp, #12]
 8005cca:	1e13      	subs	r3, r2, #0
 8005ccc:	bf18      	it	ne
 8005cce:	2301      	movne	r3, #1
 8005cd0:	2909      	cmp	r1, #9
 8005cd2:	bf8c      	ite	hi
 8005cd4:	2300      	movhi	r3, #0
 8005cd6:	f003 0301 	andls.w	r3, r3, #1
 8005cda:	2b00      	cmp	r3, #0
 8005cdc:	f000 811f 	beq.w	8005f1e <MIOS32_MIDI_Receive_Handler+0x31e>
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
 8005ce0:	2200      	movs	r2, #0
 8005ce2:	9201      	str	r2, [sp, #4]
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
 8005ce4:	9205      	str	r2, [sp, #20]
 8005ce6:	e0e8      	b.n	8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
	}
	status = -1; // empty round - no message
    }

    // timeout detected by interface?
    if( status == -10 ) {
 8005ce8:	f110 0f0a 	cmn.w	r0, #10
 8005cec:	d104      	bne.n	8005cf8 <MIOS32_MIDI_Receive_Handler+0xf8>
      MIOS32_MIDI_TimeOut(port);
 8005cee:	4620      	mov	r0, r4
 8005cf0:	f7ff ff60 	bl	8005bb4 <MIOS32_MIDI_TimeOut>
      again = 0;
 8005cf4:	2300      	movs	r3, #0
 8005cf6:	e112      	b.n	8005f1e <MIOS32_MIDI_Receive_Handler+0x31e>
    } else if( status >= 0 ) { // message received?
 8005cf8:	2800      	cmp	r0, #0
 8005cfa:	f2c0 80de 	blt.w	8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005cfe:	9901      	ldr	r1, [sp, #4]
      ++total_packages_forwarded;
 8005d00:	9a03      	ldr	r2, [sp, #12]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d02:	1c4b      	adds	r3, r1, #1
 8005d04:	b2db      	uxtb	r3, r3
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d06:	9907      	ldr	r1, [sp, #28]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d08:	9301      	str	r3, [sp, #4]
      ++total_packages_forwarded;
 8005d0a:	1c53      	adds	r3, r2, #1
 8005d0c:	b2db      	uxtb	r3, r3

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d0e:	f36f 1107 	bfc	r1, #4, #4
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;
 8005d12:	9303      	str	r3, [sp, #12]

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005d14:	f001 030f 	and.w	r3, r1, #15
 8005d18:	f103 0208 	add.w	r2, r3, #8
 8005d1c:	f002 020f 	and.w	r2, r2, #15
 8005d20:	2a06      	cmp	r2, #6
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d22:	9107      	str	r1, [sp, #28]

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005d24:	d804      	bhi.n	8005d30 <MIOS32_MIDI_Receive_Handler+0x130>
	if( callback_package != NULL )
	  callback_package(port, package);
 8005d26:	4620      	mov	r0, r4
      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
 8005d28:	2d00      	cmp	r5, #0
 8005d2a:	f040 80c5 	bne.w	8005eb8 <MIOS32_MIDI_Receive_Handler+0x2b8>
 8005d2e:	e0c4      	b.n	8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;

	switch( package.type ) {
 8005d30:	1e9a      	subs	r2, r3, #2
 8005d32:	2a0d      	cmp	r2, #13
 8005d34:	f200 80c1 	bhi.w	8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005d38:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005d3c:	00710071 	.word	0x00710071
 8005d40:	006d000e 	.word	0x006d000e
 8005d44:	00740074 	.word	0x00740074
 8005d48:	00bf00bf 	.word	0x00bf00bf
 8005d4c:	00bf00bf 	.word	0x00bf00bf
 8005d50:	00bf00bf 	.word	0x00bf00bf
 8005d54:	000e00bf 	.word	0x000e00bf
	    break;

	  case 0x4: // SysEx starts or continues (3 bytes)
	  case 0xf: // Single byte is interpreted as SysEx as well (I noticed that portmidi sometimes sends single bytes!)

	    if( package.evnt0 >= 0xf8 ) { // relevant for package type 0xf
 8005d58:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005d5c:	29f7      	cmp	r1, #247	; 0xf7
 8005d5e:	d85e      	bhi.n	8005e1e <MIOS32_MIDI_Receive_Handler+0x21e>
	      if( callback_package != NULL )
		callback_package(port, package); // -> realtime event is forwarded as event
	      break;
	    }

	    if( package.evnt0 == 0xf0 ) {
 8005d60:	29f0      	cmp	r1, #240	; 0xf0
 8005d62:	d11c      	bne.n	8005d9e <MIOS32_MIDI_Receive_Handler+0x19e>
	      // cheap timeout mechanism - see comments above the sysex_timeout_ctr declaration
	      if( !sysex_timeout_ctr_flags.ALL ) {
 8005d64:	4a71      	ldr	r2, [pc, #452]	; (8005f2c <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005d66:	6813      	ldr	r3, [r2, #0]
 8005d68:	b9cb      	cbnz	r3, 8005d9e <MIOS32_MIDI_Receive_Handler+0x19e>
		switch( port & 0xf0 ) {
 8005d6a:	f004 02f0 	and.w	r2, r4, #240	; 0xf0
 8005d6e:	2a10      	cmp	r2, #16
 8005d70:	d002      	beq.n	8005d78 <MIOS32_MIDI_Receive_Handler+0x178>
 8005d72:	2a30      	cmp	r2, #48	; 0x30
 8005d74:	d113      	bne.n	8005d9e <MIOS32_MIDI_Receive_Handler+0x19e>
 8005d76:	e009      	b.n	8005d8c <MIOS32_MIDI_Receive_Handler+0x18c>
		  case USB0://..15
		    sysex_timeout_ctr = 0;
 8005d78:	4a6d      	ldr	r2, [pc, #436]	; (8005f30 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005d7a:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.usb_receives = (1 << (port & 0xf));
 8005d7c:	2201      	movs	r2, #1
 8005d7e:	f004 030f 	and.w	r3, r4, #15
 8005d82:	fa12 f303 	lsls.w	r3, r2, r3
 8005d86:	4a69      	ldr	r2, [pc, #420]	; (8005f2c <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005d88:	8013      	strh	r3, [r2, #0]
		    break;
 8005d8a:	e008      	b.n	8005d9e <MIOS32_MIDI_Receive_Handler+0x19e>
		  case UART0://..15
		    // already done in MIOS32_UART_MIDI_PackageReceive()
		    break;
		  case IIC0://..15
		    sysex_timeout_ctr = 0;
 8005d8c:	4a68      	ldr	r2, [pc, #416]	; (8005f30 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005d8e:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.iic_receives = (1 << (port & 0xf));
 8005d90:	2201      	movs	r2, #1
 8005d92:	f004 030f 	and.w	r3, r4, #15
 8005d96:	fa12 f303 	lsls.w	r3, r2, r3
 8005d9a:	4a64      	ldr	r2, [pc, #400]	; (8005f2c <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005d9c:	8053      	strh	r3, [r2, #2]
		    // no timeout protection for remaining interfaces (yet)
		}
	      }
	    }

	    MIOS32_MIDI_SYSEX_Parser(port, package.evnt0); // -> forward to MIOS32 SysEx Parser
 8005d9e:	4620      	mov	r0, r4
 8005da0:	f7ff fe9a 	bl	8005ad8 <MIOS32_MIDI_SYSEX_Parser>
	    if( package.type != 0x0f ) {
 8005da4:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8005da8:	f003 030f 	and.w	r3, r3, #15
 8005dac:	2b0f      	cmp	r3, #15
 8005dae:	d009      	beq.n	8005dc4 <MIOS32_MIDI_Receive_Handler+0x1c4>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
 8005db0:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005db4:	4620      	mov	r0, r4
 8005db6:	f7ff fe8f 	bl	8005ad8 <MIOS32_MIDI_SYSEX_Parser>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
 8005dba:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005dbe:	4620      	mov	r0, r4
 8005dc0:	f7ff fe8a 	bl	8005ad8 <MIOS32_MIDI_SYSEX_Parser>
	    }

	    if( sysex_callback_func != NULL ) {
 8005dc4:	683e      	ldr	r6, [r7, #0]
 8005dc6:	b1de      	cbz	r6, 8005e00 <MIOS32_MIDI_Receive_Handler+0x200>
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005dc8:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005dcc:	4620      	mov	r0, r4
 8005dce:	47b0      	blx	r6
	      if( package.type != 0x0f ) {
 8005dd0:	f89d 301c 	ldrb.w	r3, [sp, #28]
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005dd4:	b2c6      	uxtb	r6, r0
	      if( package.type != 0x0f ) {
 8005dd6:	f003 030f 	and.w	r3, r3, #15
 8005dda:	2b0f      	cmp	r3, #15
 8005ddc:	d010      	beq.n	8005e00 <MIOS32_MIDI_Receive_Handler+0x200>
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005dde:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005de2:	683b      	ldr	r3, [r7, #0]
 8005de4:	4620      	mov	r0, r4
 8005de6:	4798      	blx	r3
 8005de8:	4602      	mov	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005dea:	683b      	ldr	r3, [r7, #0]
 8005dec:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005df0:	9200      	str	r2, [sp, #0]
 8005df2:	4620      	mov	r0, r4
 8005df4:	4798      	blx	r3
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
	      if( package.type != 0x0f ) {
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005df6:	9a00      	ldr	r2, [sp, #0]
 8005df8:	4302      	orrs	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005dfa:	ea42 0606 	orr.w	r6, r2, r6
 8005dfe:	b2f6      	uxtb	r6, r6
	      }
	    }

	    if( callback_package != NULL && !filter_sysex )
 8005e00:	1e2b      	subs	r3, r5, #0
 8005e02:	bf18      	it	ne
 8005e04:	2301      	movne	r3, #1
 8005e06:	2e00      	cmp	r6, #0
 8005e08:	bf14      	ite	ne
 8005e0a:	2600      	movne	r6, #0
 8005e0c:	f003 0601 	andeq.w	r6, r3, #1
 8005e10:	2e00      	cmp	r6, #0
 8005e12:	d052      	beq.n	8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005e14:	e04e      	b.n	8005eb4 <MIOS32_MIDI_Receive_Handler+0x2b4>
	      callback_package(port, package);

	    break;

	  case 0x5:   // Single-byte System Common Message or SysEx ends with following single byte. 
	    if( package.evnt0 >= 0xf8 ) {
 8005e16:	f89d 201d 	ldrb.w	r2, [sp, #29]
 8005e1a:	2af7      	cmp	r2, #247	; 0xf7
 8005e1c:	d902      	bls.n	8005e24 <MIOS32_MIDI_Receive_Handler+0x224>
	      if( callback_package != NULL )
 8005e1e:	2d00      	cmp	r5, #0
 8005e20:	d148      	bne.n	8005eb4 <MIOS32_MIDI_Receive_Handler+0x2b4>
 8005e22:	e04a      	b.n	8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
	    }
	    // no >= 0xf8 event: continue!

	  case 0x6:   // SysEx ends with following two bytes.
	  case 0x7: { // SysEx ends with following three bytes.
	    u8 num_bytes = package.type - 0x5 + 1;
 8005e24:	3b04      	subs	r3, #4
 8005e26:	b2db      	uxtb	r3, r3
 8005e28:	9302      	str	r3, [sp, #8]
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
 8005e2a:	2b00      	cmp	r3, #0
 8005e2c:	d079      	beq.n	8005f22 <MIOS32_MIDI_Receive_Handler+0x322>
	      current_byte = package.evnt0;
 8005e2e:	f89d 601d 	ldrb.w	r6, [sp, #29]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005e32:	4620      	mov	r0, r4
 8005e34:	4631      	mov	r1, r6
 8005e36:	f7ff fe4f 	bl	8005ad8 <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005e3a:	683b      	ldr	r3, [r7, #0]
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005e3c:	461a      	mov	r2, r3
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005e3e:	b11b      	cbz	r3, 8005e48 <MIOS32_MIDI_Receive_Handler+0x248>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005e40:	4620      	mov	r0, r4
 8005e42:	4631      	mov	r1, r6
 8005e44:	4798      	blx	r3
 8005e46:	b2c2      	uxtb	r2, r0
	    }

	    if( num_bytes >= 2 ) {
 8005e48:	9b02      	ldr	r3, [sp, #8]
 8005e4a:	2b01      	cmp	r3, #1
 8005e4c:	d024      	beq.n	8005e98 <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt1;
 8005e4e:	f89d 601e 	ldrb.w	r6, [sp, #30]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005e52:	4620      	mov	r0, r4
 8005e54:	4631      	mov	r1, r6
 8005e56:	9200      	str	r2, [sp, #0]
 8005e58:	f7ff fe3e 	bl	8005ad8 <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005e5c:	683b      	ldr	r3, [r7, #0]
 8005e5e:	9a00      	ldr	r2, [sp, #0]
 8005e60:	b133      	cbz	r3, 8005e70 <MIOS32_MIDI_Receive_Handler+0x270>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005e62:	4620      	mov	r0, r4
 8005e64:	4631      	mov	r1, r6
 8005e66:	4798      	blx	r3
 8005e68:	9a00      	ldr	r2, [sp, #0]
 8005e6a:	ea40 0202 	orr.w	r2, r0, r2
 8005e6e:	b2d2      	uxtb	r2, r2
	    }

	    if( num_bytes >= 3 ) {
 8005e70:	9902      	ldr	r1, [sp, #8]
 8005e72:	2902      	cmp	r1, #2
 8005e74:	d010      	beq.n	8005e98 <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt2;
 8005e76:	f89d 601f 	ldrb.w	r6, [sp, #31]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005e7a:	4620      	mov	r0, r4
 8005e7c:	4631      	mov	r1, r6
 8005e7e:	9200      	str	r2, [sp, #0]
 8005e80:	f7ff fe2a 	bl	8005ad8 <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005e84:	683b      	ldr	r3, [r7, #0]
 8005e86:	9a00      	ldr	r2, [sp, #0]
 8005e88:	b133      	cbz	r3, 8005e98 <MIOS32_MIDI_Receive_Handler+0x298>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005e8a:	4620      	mov	r0, r4
 8005e8c:	4631      	mov	r1, r6
 8005e8e:	4798      	blx	r3
 8005e90:	9a00      	ldr	r2, [sp, #0]
 8005e92:	ea40 0202 	orr.w	r2, r0, r2
 8005e96:	b2d2      	uxtb	r2, r2
	    }

	    // reset timeout protection if required
	    if( current_byte == 0xf7 )
 8005e98:	2ef7      	cmp	r6, #247	; 0xf7
 8005e9a:	d102      	bne.n	8005ea2 <MIOS32_MIDI_Receive_Handler+0x2a2>
	      sysex_timeout_ctr_flags.ALL = 0;
 8005e9c:	4b23      	ldr	r3, [pc, #140]	; (8005f2c <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005e9e:	2100      	movs	r1, #0
 8005ea0:	6019      	str	r1, [r3, #0]

	    // forward as package if not filtered
	    if( callback_package != NULL && !filter_sysex )
 8005ea2:	1e2b      	subs	r3, r5, #0
 8005ea4:	bf18      	it	ne
 8005ea6:	2301      	movne	r3, #1
 8005ea8:	2a00      	cmp	r2, #0
 8005eaa:	bf14      	ite	ne
 8005eac:	2300      	movne	r3, #0
 8005eae:	f003 0301 	andeq.w	r3, r3, #1
 8005eb2:	b113      	cbz	r3, 8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
	      callback_package(port, package);
 8005eb4:	9907      	ldr	r1, [sp, #28]
 8005eb6:	4620      	mov	r0, r4
 8005eb8:	47a8      	blx	r5
	}	  
      }
    }

    // timeout detected by this handler?
    if( sysex_timeout_ctr_flags.ALL && sysex_timeout_ctr > 1000 ) {
 8005eba:	4b1c      	ldr	r3, [pc, #112]	; (8005f2c <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005ebc:	681a      	ldr	r2, [r3, #0]
 8005ebe:	b33a      	cbz	r2, 8005f10 <MIOS32_MIDI_Receive_Handler+0x310>
 8005ec0:	491b      	ldr	r1, [pc, #108]	; (8005f30 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005ec2:	880a      	ldrh	r2, [r1, #0]
 8005ec4:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 8005ec8:	d922      	bls.n	8005f10 <MIOS32_MIDI_Receive_Handler+0x310>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
 8005eca:	8819      	ldrh	r1, [r3, #0]
 8005ecc:	b161      	cbz	r1, 8005ee8 <MIOS32_MIDI_Receive_Handler+0x2e8>
 8005ece:	2200      	movs	r2, #0
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
 8005ed0:	fa51 f302 	asrs.w	r3, r1, r2
 8005ed4:	f013 0301 	ands.w	r3, r3, #1
 8005ed8:	d103      	bne.n	8005ee2 <MIOS32_MIDI_Receive_Handler+0x2e2>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005eda:	3201      	adds	r2, #1
 8005edc:	2a10      	cmp	r2, #16
 8005ede:	d1f7      	bne.n	8005ed0 <MIOS32_MIDI_Receive_Handler+0x2d0>
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005ee0:	461a      	mov	r2, r3
	timeout_port = USB0 + i;
 8005ee2:	3210      	adds	r2, #16
 8005ee4:	b2d0      	uxtb	r0, r2
 8005ee6:	e00d      	b.n	8005f04 <MIOS32_MIDI_Receive_Handler+0x304>
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
 8005ee8:	8858      	ldrh	r0, [r3, #2]
 8005eea:	b158      	cbz	r0, 8005f04 <MIOS32_MIDI_Receive_Handler+0x304>
 8005eec:	460b      	mov	r3, r1
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
 8005eee:	fa50 f203 	asrs.w	r2, r0, r3
 8005ef2:	f012 0201 	ands.w	r2, r2, #1
 8005ef6:	d103      	bne.n	8005f00 <MIOS32_MIDI_Receive_Handler+0x300>
	if( i >= 16 ) // failsafe
	  i = 0;
	timeout_port = USB0 + i;
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005ef8:	3301      	adds	r3, #1
 8005efa:	2b10      	cmp	r3, #16
 8005efc:	d1f7      	bne.n	8005eee <MIOS32_MIDI_Receive_Handler+0x2ee>
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005efe:	4613      	mov	r3, r2
	timeout_port = IIC0 + i;
 8005f00:	3330      	adds	r3, #48	; 0x30
 8005f02:	b2d8      	uxtb	r0, r3
      }

      MIOS32_MIDI_TimeOut(timeout_port);
 8005f04:	f7ff fe56 	bl	8005bb4 <MIOS32_MIDI_TimeOut>
      sysex_timeout_ctr_flags.ALL = 0;
 8005f08:	4b08      	ldr	r3, [pc, #32]	; (8005f2c <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005f0a:	2200      	movs	r2, #0
 8005f0c:	601a      	str	r2, [r3, #0]
 8005f0e:	e003      	b.n	8005f18 <MIOS32_MIDI_Receive_Handler+0x318>
      again = 0;
    }
  } while( again );
 8005f10:	9a04      	ldr	r2, [sp, #16]
 8005f12:	2a00      	cmp	r2, #0
 8005f14:	f47f ae7f 	bne.w	8005c16 <MIOS32_MIDI_Receive_Handler+0x16>

  return 0;
}
 8005f18:	2000      	movs	r0, #0
 8005f1a:	b009      	add	sp, #36	; 0x24
 8005f1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
	} else {
	  again = 0; // no more interfaces to be processed
 8005f1e:	9304      	str	r3, [sp, #16]
 8005f20:	e7cb      	b.n	8005eba <MIOS32_MIDI_Receive_Handler+0x2ba>
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005f22:	9a02      	ldr	r2, [sp, #8]
 8005f24:	e7bd      	b.n	8005ea2 <MIOS32_MIDI_Receive_Handler+0x2a2>
 8005f26:	bf00      	nop
 8005f28:	200007d4 	.word	0x200007d4
 8005f2c:	200007d0 	.word	0x200007d0
 8005f30:	200007be 	.word	0x200007be

08005f34 <MIOS32_MIDI_Periodic_mS>:
//! by a task in the programming model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Periodic_mS(void)
{
 8005f34:	b510      	push	{r4, lr}
  s32 status = 0;

#ifndef MIOS32_DONT_USE_USB_MIDI
  status |= MIOS32_USB_MIDI_Periodic_mS();
 8005f36:	f002 f881 	bl	800803c <MIOS32_USB_MIDI_Periodic_mS>
 8005f3a:	4604      	mov	r4, r0
#endif

#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
 8005f3c:	f000 f8ca 	bl	80060d4 <MIOS32_UART_MIDI_Periodic_mS>
 8005f40:	ea40 0404 	orr.w	r4, r0, r4
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005f44:	f000 fa3f 	bl	80063c6 <MIOS32_IIC_MIDI_Periodic_mS>
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005f48:	4b05      	ldr	r3, [pc, #20]	; (8005f60 <MIOS32_MIDI_Periodic_mS+0x2c>)
 8005f4a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005f4e:	881a      	ldrh	r2, [r3, #0]
#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005f50:	ea44 0000 	orr.w	r0, r4, r0
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005f54:	428a      	cmp	r2, r1
 8005f56:	d001      	beq.n	8005f5c <MIOS32_MIDI_Periodic_mS+0x28>
    ++sysex_timeout_ctr;
 8005f58:	3201      	adds	r2, #1
 8005f5a:	801a      	strh	r2, [r3, #0]

  return status;
}
 8005f5c:	bd10      	pop	{r4, pc}
 8005f5e:	bf00      	nop
 8005f60:	200007be 	.word	0x200007be

08005f64 <MIOS32_MIDI_SendByteToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_byte received MIDI byte
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendByteToRxCallback(mios32_midi_port_t port, u8 midi_byte)
{
 8005f64:	b508      	push	{r3, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL )
 8005f66:	4b03      	ldr	r3, [pc, #12]	; (8005f74 <MIOS32_MIDI_SendByteToRxCallback+0x10>)
 8005f68:	681b      	ldr	r3, [r3, #0]
 8005f6a:	b10b      	cbz	r3, 8005f70 <MIOS32_MIDI_SendByteToRxCallback+0xc>
    return direct_rx_callback_func(port, midi_byte);
 8005f6c:	4798      	blx	r3
 8005f6e:	e000      	b.n	8005f72 <MIOS32_MIDI_SendByteToRxCallback+0xe>
  return 0; // no error
 8005f70:	4618      	mov	r0, r3
}
 8005f72:	bd08      	pop	{r3, pc}
 8005f74:	200007b8 	.word	0x200007b8

08005f78 <MIOS32_MIDI_SendPackageToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005f78:	b5f0      	push	{r4, r5, r6, r7, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005f7a:	4e13      	ldr	r6, [pc, #76]	; (8005fc8 <MIOS32_MIDI_SendPackageToRxCallback+0x50>)
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005f7c:	b085      	sub	sp, #20
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005f7e:	6834      	ldr	r4, [r6, #0]
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005f80:	4607      	mov	r7, r0
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005f82:	b1ec      	cbz	r4, 8005fc0 <MIOS32_MIDI_SendPackageToRxCallback+0x48>
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005f84:	f3c1 6307 	ubfx	r3, r1, #24, #8
 8005f88:	f88d 300e 	strb.w	r3, [sp, #14]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005f8c:	4b0f      	ldr	r3, [pc, #60]	; (8005fcc <MIOS32_MIDI_SendPackageToRxCallback+0x54>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005f8e:	f3c1 4207 	ubfx	r2, r1, #16, #8
 8005f92:	f3c1 2007 	ubfx	r0, r1, #8, #8
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
 8005f96:	2400      	movs	r4, #0
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005f98:	f001 010f 	and.w	r1, r1, #15
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005f9c:	f88d 200d 	strb.w	r2, [sp, #13]
 8005fa0:	f88d 000c 	strb.w	r0, [sp, #12]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005fa4:	5c5a      	ldrb	r2, [r3, r1]
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005fa6:	4625      	mov	r5, r4
 8005fa8:	e008      	b.n	8005fbc <MIOS32_MIDI_SendPackageToRxCallback+0x44>
      status |= direct_rx_callback_func(port, buffer[i]);
 8005faa:	ab03      	add	r3, sp, #12
 8005fac:	5d59      	ldrb	r1, [r3, r5]
 8005fae:	4638      	mov	r0, r7
 8005fb0:	9201      	str	r2, [sp, #4]
 8005fb2:	6833      	ldr	r3, [r6, #0]
 8005fb4:	4798      	blx	r3
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005fb6:	9a01      	ldr	r2, [sp, #4]
      status |= direct_rx_callback_func(port, buffer[i]);
 8005fb8:	4304      	orrs	r4, r0
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005fba:	3501      	adds	r5, #1
 8005fbc:	4295      	cmp	r5, r2
 8005fbe:	dbf4      	blt.n	8005faa <MIOS32_MIDI_SendPackageToRxCallback+0x32>
      status |= direct_rx_callback_func(port, buffer[i]);
    return status;
  }
  return 0; // no error
}
 8005fc0:	4620      	mov	r0, r4
 8005fc2:	b005      	add	sp, #20
 8005fc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005fc6:	bf00      	nop
 8005fc8:	200007b8 	.word	0x200007b8
 8005fcc:	0800aef8 	.word	0x0800aef8

08005fd0 <MIOS32_OSC_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_OSC_Init(u32 mode)
{
  if( mode > 0 )
    return -1; // only mode 0 supported yet
 8005fd0:	2800      	cmp	r0, #0
 8005fd2:	bf14      	ite	ne
 8005fd4:	f04f 30ff 	movne.w	r0, #4294967295
 8005fd8:	2000      	moveq	r0, #0

  return 0; // no error
}
 8005fda:	4770      	bx	lr

08005fdc <MIOS32_COM_Init>:
s32 MIOS32_COM_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 8005fdc:	b938      	cbnz	r0, 8005fee <MIOS32_COM_Init+0x12>
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 8005fde:	4b05      	ldr	r3, [pc, #20]	; (8005ff4 <MIOS32_COM_Init+0x18>)

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 8005fe0:	4a05      	ldr	r2, [pc, #20]	; (8005ff8 <MIOS32_COM_Init+0x1c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 8005fe2:	6018      	str	r0, [r3, #0]

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 8005fe4:	2310      	movs	r3, #16
 8005fe6:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_COM_DEBUG_PORT;
 8005fe8:	4a04      	ldr	r2, [pc, #16]	; (8005ffc <MIOS32_COM_Init+0x20>)
 8005fea:	7013      	strb	r3, [r2, #0]
#if MIOS32_UART0_ASSIGNMENT == 2 || MIOS32_UART1_ASSIGNMENT == 2 || MIOS32_UART2_ASSIGNMENT == 2 || MIOS32_UART3_ASSIGNMENT == 2
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
 8005fec:	e001      	b.n	8005ff2 <MIOS32_COM_Init+0x16>
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005fee:	f04f 30ff 	mov.w	r0, #4294967295
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
}
 8005ff2:	4770      	bx	lr
 8005ff4:	200007dc 	.word	0x200007dc
 8005ff8:	20000007 	.word	0x20000007
 8005ffc:	20000008 	.word	0x20000008

08006000 <MIOS32_COM_SendBuffer>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8006000:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] len buffer length
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
 8006004:	b508      	push	{r3, lr}
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8006006:	d104      	bne.n	8006012 <MIOS32_COM_SendBuffer+0x12>
    port = (port == COM_DEBUG) ? debug_port : default_port;
 8006008:	2801      	cmp	r0, #1
 800600a:	bf0c      	ite	eq
 800600c:	4b06      	ldreq	r3, [pc, #24]	; (8006028 <MIOS32_COM_SendBuffer+0x28>)
 800600e:	4b07      	ldrne	r3, [pc, #28]	; (800602c <MIOS32_COM_SendBuffer+0x2c>)
 8006010:	7818      	ldrb	r0, [r3, #0]
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 8006012:	0903      	lsrs	r3, r0, #4
 8006014:	2b02      	cmp	r3, #2
    case 1:
#if !defined(MIOS32_DONT_USE_USB) && defined(MIOS32_USE_USB_COM)
      return MIOS32_USB_COM_TxBufferPutMore(port & 0xf, buffer, len);
#else
      return -1; // USB has been disabled
 8006016:	bf18      	it	ne
 8006018:	f04f 30ff 	movne.w	r0, #4294967295
  if( !(port & 0xf0) ) {
    port = (port == COM_DEBUG) ? debug_port : default_port;
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 800601c:	d103      	bne.n	8006026 <MIOS32_COM_SendBuffer+0x26>
      return -1; // USB has been disabled
#endif

    case 2:
#if !defined(MIOS32_DONT_USE_UART)
      return MIOS32_UART_TxBufferPutMore(port & 0xf, buffer, len);
 800601e:	f000 000f 	and.w	r0, r0, #15
 8006022:	f002 f9e9 	bl	80083f8 <MIOS32_UART_TxBufferPutMore>
      
    default:
      // invalid port
      return -1;
  }
}
 8006026:	bd08      	pop	{r3, pc}
 8006028:	20000008 	.word	0x20000008
 800602c:	20000007 	.word	0x20000007

08006030 <MIOS32_COM_SendChar>:
//! \param[in] c character
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendChar(mios32_com_port_t port, char c)
{
 8006030:	b507      	push	{r0, r1, r2, lr}
 8006032:	ab02      	add	r3, sp, #8
 8006034:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return MIOS32_COM_SendBuffer(port, (u8 *)&c, 1);
 8006038:	4619      	mov	r1, r3
 800603a:	2201      	movs	r2, #1
 800603c:	f7ff ffe0 	bl	8006000 <MIOS32_COM_SendBuffer>
}
 8006040:	bd0e      	pop	{r1, r2, r3, pc}

08006042 <MIOS32_COM_Receive_Handler>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_Receive_Handler(void)
{
  u8 port = DEFAULT;

  u8 intf = 0; // interface to be checked
 8006042:	2300      	movs	r3, #0
 8006044:	e000      	b.n	8006048 <MIOS32_COM_Receive_Handler+0x6>
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8006046:	4613      	mov	r3, r2
 8006048:	1c5a      	adds	r2, r3, #1
 800604a:	2b04      	cmp	r3, #4
 800604c:	b2d2      	uxtb	r2, r2
 800604e:	d9fa      	bls.n	8006046 <MIOS32_COM_Receive_Handler+0x4>
	receive_callback_func(port, (u8)status);
    }
  } while( again );

  return 0;
}
 8006050:	2000      	movs	r0, #0
 8006052:	4770      	bx	lr

08006054 <MIOS32_UART_MIDI_RS_Reset>:
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 8006054:	2801      	cmp	r0, #1
//! \return -1 if port not available
//! \return < 0 on errors
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
 8006056:	b510      	push	{r4, lr}
 8006058:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
    return -1; // port not available
 800605a:	bf88      	it	hi
 800605c:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 8006060:	d80b      	bhi.n	800607a <MIOS32_UART_MIDI_RS_Reset+0x26>
    return -1; // port not available

  MIOS32_IRQ_Disable();
 8006062:	f000 fb1d 	bl	80066a0 <MIOS32_IRQ_Disable>
  rs_last[uart_port] = 0xff;
 8006066:	4b05      	ldr	r3, [pc, #20]	; (800607c <MIOS32_UART_MIDI_RS_Reset+0x28>)
 8006068:	22ff      	movs	r2, #255	; 0xff
 800606a:	551a      	strb	r2, [r3, r4]
  rs_expire_ctr[uart_port] = 0;
 800606c:	4b04      	ldr	r3, [pc, #16]	; (8006080 <MIOS32_UART_MIDI_RS_Reset+0x2c>)
 800606e:	2200      	movs	r2, #0
 8006070:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
  MIOS32_IRQ_Enable();
 8006074:	f000 fb2a 	bl	80066cc <MIOS32_IRQ_Enable>

  return 0;
 8006078:	2000      	movs	r0, #0
#endif
}
 800607a:	bd10      	pop	{r4, pc}
 800607c:	200007e0 	.word	0x200007e0
 8006080:	20000800 	.word	0x20000800

08006084 <MIOS32_UART_MIDI_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Init(u32 mode)
{
 8006084:	b510      	push	{r4, lr}
 8006086:	4604      	mov	r4, r0
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8006088:	f04f 30ff 	mov.w	r0, #4294967295
#else
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
 800608c:	b9ec      	cbnz	r4, 80060ca <MIOS32_UART_MIDI_Init+0x46>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 800608e:	4b0f      	ldr	r3, [pc, #60]	; (80060cc <MIOS32_UART_MIDI_Init+0x48>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 8006090:	22ff      	movs	r2, #255	; 0xff
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 8006092:	601c      	str	r4, [r3, #0]
  midix->running_status = 0x00;
 8006094:	711c      	strb	r4, [r3, #4]
  midix->expected_bytes = 0x00;
 8006096:	715c      	strb	r4, [r3, #5]
  midix->wait_bytes = 0x00;
 8006098:	719c      	strb	r4, [r3, #6]
  midix->sysex_ctr = 0x00;
 800609a:	71dc      	strb	r4, [r3, #7]
  midix->timeout_ctr = 0;
 800609c:	811c      	strh	r4, [r3, #8]
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 800609e:	60dc      	str	r4, [r3, #12]
  midix->running_status = 0x00;
 80060a0:	741c      	strb	r4, [r3, #16]
  midix->expected_bytes = 0x00;
 80060a2:	745c      	strb	r4, [r3, #17]
  midix->wait_bytes = 0x00;
 80060a4:	749c      	strb	r4, [r3, #18]
  midix->sysex_ctr = 0x00;
 80060a6:	74dc      	strb	r4, [r3, #19]
  midix->timeout_ctr = 0;
 80060a8:	829c      	strh	r4, [r3, #20]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060aa:	4b09      	ldr	r3, [pc, #36]	; (80060d0 <MIOS32_UART_MIDI_Init+0x4c>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 80060ac:	4620      	mov	r0, r4
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060ae:	701a      	strb	r2, [r3, #0]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 80060b0:	f7ff ffd0 	bl	8006054 <MIOS32_UART_MIDI_RS_Reset>
 80060b4:	2001      	movs	r0, #1
 80060b6:	f7ff ffcd 	bl	8006054 <MIOS32_UART_MIDI_RS_Reset>

  // if any MIDI assignment:
#if MIOS32_UART0_ASSIGNMENT == 1 || MIOS32_UART1_ASSIGNMENT == 1 || MIOS32_UART2_ASSIGNMENT == 1
  // initialize U(S)ART interface
  if( MIOS32_UART_Init(0) < 0 )
 80060ba:	4620      	mov	r0, r4
 80060bc:	f002 f806 	bl	80080cc <MIOS32_UART_Init>
    return -1; // initialisation of U(S)ART Interface failed
 80060c0:	2800      	cmp	r0, #0
 80060c2:	bfb4      	ite	lt
 80060c4:	f04f 30ff 	movlt.w	r0, #4294967295
 80060c8:	2000      	movge	r0, #0
#endif

  return 0; // no error
#endif
}
 80060ca:	bd10      	pop	{r4, pc}
 80060cc:	200007e4 	.word	0x200007e4
 80060d0:	200007fc 	.word	0x200007fc

080060d4 <MIOS32_UART_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Periodic_mS(void)
{
 80060d4:	b508      	push	{r3, lr}
#if MIOS32_UART_NUM
  u8 uart_port;

  MIOS32_IRQ_Disable();
 80060d6:	f000 fae3 	bl	80066a0 <MIOS32_IRQ_Disable>
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 80060da:	4b12      	ldr	r3, [pc, #72]	; (8006124 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 80060dc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80060e0:	881a      	ldrh	r2, [r3, #0]
 80060e2:	428a      	cmp	r2, r1
 80060e4:	d001      	beq.n	80060ea <MIOS32_UART_MIDI_Periodic_mS+0x16>
      ++rs_expire_ctr[uart_port];
 80060e6:	3201      	adds	r2, #1
 80060e8:	801a      	strh	r2, [r3, #0]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 80060ea:	4b0f      	ldr	r3, [pc, #60]	; (8006128 <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 80060ec:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80060f0:	891a      	ldrh	r2, [r3, #8]
 80060f2:	428a      	cmp	r2, r1
 80060f4:	d001      	beq.n	80060fa <MIOS32_UART_MIDI_Periodic_mS+0x26>
      ++midi_rec[uart_port].timeout_ctr;
 80060f6:	3201      	adds	r2, #1
 80060f8:	811a      	strh	r2, [r3, #8]
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 80060fa:	4b0a      	ldr	r3, [pc, #40]	; (8006124 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 80060fc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006100:	885a      	ldrh	r2, [r3, #2]
 8006102:	428a      	cmp	r2, r1
 8006104:	d001      	beq.n	800610a <MIOS32_UART_MIDI_Periodic_mS+0x36>
      ++rs_expire_ctr[uart_port];
 8006106:	3201      	adds	r2, #1
 8006108:	805a      	strh	r2, [r3, #2]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 800610a:	4b07      	ldr	r3, [pc, #28]	; (8006128 <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 800610c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006110:	8a9a      	ldrh	r2, [r3, #20]
 8006112:	428a      	cmp	r2, r1
 8006114:	d001      	beq.n	800611a <MIOS32_UART_MIDI_Periodic_mS+0x46>
      ++midi_rec[uart_port].timeout_ctr;
 8006116:	3201      	adds	r2, #1
 8006118:	829a      	strh	r2, [r3, #20]
  }
  MIOS32_IRQ_Enable();
 800611a:	f000 fad7 	bl	80066cc <MIOS32_IRQ_Enable>
  // (atomic operation not required in MIOS32_UART_MIDI_PackageSend_NonBlocking() due to single-byte accesses)
#endif

  return 0; // no error
}
 800611e:	2000      	movs	r0, #0
 8006120:	bd08      	pop	{r3, pc}
 8006122:	bf00      	nop
 8006124:	20000800 	.word	0x20000800
 8006128:	200007e4 	.word	0x200007e4

0800612c <MIOS32_UART_MIDI_PackageSend_NonBlocking>:
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 800612c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 800612e:	2801      	cmp	r0, #1
 8006130:	f3c1 2607 	ubfx	r6, r1, #8, #8
 8006134:	f001 030f 	and.w	r3, r1, #15
 8006138:	f3c1 4207 	ubfx	r2, r1, #16, #8
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 800613c:	4604      	mov	r4, r0
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 800613e:	b2f7      	uxtb	r7, r6
 8006140:	f3c1 6107 	ubfx	r1, r1, #24, #8
 8006144:	d844      	bhi.n	80061d0 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa4>
 8006146:	e046      	b.n	80061d6 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xaa>

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};

    if( rs_expire_ctr[uart_port] > 1000 ) {
 8006148:	4826      	ldr	r0, [pc, #152]	; (80061e4 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xb8>)
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 800614a:	f88d 6004 	strb.w	r6, [sp, #4]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 800614e:	f830 c014 	ldrh.w	ip, [r0, r4, lsl #1]
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 8006152:	f88d 2005 	strb.w	r2, [sp, #5]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 8006156:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 800615a:	f88d 1006 	strb.w	r1, [sp, #6]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 800615e:	d903      	bls.n	8006168 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x3c>
      // the current RS is expired each second to ensure that a status byte will be sent
      // if the MIDI cable is (re)connected during runtime
      MIOS32_UART_MIDI_RS_Reset(uart_port);
 8006160:	4620      	mov	r0, r4
 8006162:	f7ff ff77 	bl	8006054 <MIOS32_UART_MIDI_RS_Reset>
 8006166:	e022      	b.n	80061ae <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
#if 0
      // for optional monitoring of the optimisation
      MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS 0x%02x expired!\n", uart_port);
#endif
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
 8006168:	f8df c07c 	ldr.w	ip, [pc, #124]	; 80061e8 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xbc>
 800616c:	f89c c000 	ldrb.w	ip, [ip]
 8006170:	fa4c fc04 	asr.w	ip, ip, r4
 8006174:	f01c 0f01 	tst.w	ip, #1
 8006178:	d019      	beq.n	80061ae <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
 800617a:	2b07      	cmp	r3, #7
 800617c:	dd17      	ble.n	80061ae <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  package.cin >= NoteOff && package.cin <= PitchBend &&
 800617e:	2b0e      	cmp	r3, #14
 8006180:	bfcc      	ite	gt
 8006182:	2300      	movgt	r3, #0
 8006184:	2301      	movle	r3, #1
 8006186:	2d01      	cmp	r5, #1
 8006188:	bf94      	ite	ls
 800618a:	2300      	movls	r3, #0
 800618c:	f003 0301 	andhi.w	r3, r3, #1
 8006190:	b16b      	cbz	r3, 80061ae <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
 8006192:	4b16      	ldr	r3, [pc, #88]	; (80061ec <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)
 8006194:	5d1b      	ldrb	r3, [r3, r4]
 8006196:	42bb      	cmp	r3, r7
 8006198:	d106      	bne.n	80061a8 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x7c>
	  buffer[0] = package.evnt1;
	  buffer[1] = package.evnt2;
	  --len;
 800619a:	3d01      	subs	r5, #1
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
	  package.cin >= NoteOff && package.cin <= PitchBend &&
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
	  buffer[0] = package.evnt1;
 800619c:	f88d 2004 	strb.w	r2, [sp, #4]
	  buffer[1] = package.evnt2;
 80061a0:	f88d 1005 	strb.w	r1, [sp, #5]
	  --len;
 80061a4:	b2ed      	uxtb	r5, r5
 80061a6:	e002      	b.n	80061ae <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  // for optional monitoring of the optimisation
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS optimized (%02x) %02x %02x\n", uart_port, package.evnt0, package.evnt1, package.evnt2);
#endif
	} else {
	  // new running status
	  rs_expire_ctr[uart_port] = 0;
 80061a8:	2300      	movs	r3, #0
 80061aa:	f820 3014 	strh.w	r3, [r0, r4, lsl #1]
      }
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
 80061ae:	2ff7      	cmp	r7, #247	; 0xf7
      rs_last[uart_port] = package.evnt0;
 80061b0:	bf98      	it	ls
 80061b2:	4b0e      	ldrls	r3, [pc, #56]	; (80061ec <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80061b4:	4620      	mov	r0, r4
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;
 80061b6:	bf98      	it	ls
 80061b8:	551e      	strbls	r6, [r3, r4]


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80061ba:	a901      	add	r1, sp, #4
 80061bc:	462a      	mov	r2, r5
 80061be:	f002 f91b 	bl	80083f8 <MIOS32_UART_TxBufferPutMore>
 80061c2:	3002      	adds	r0, #2
 80061c4:	2802      	cmp	r0, #2
 80061c6:	bf9c      	itt	ls
 80061c8:	4b09      	ldrls	r3, [pc, #36]	; (80061f0 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc4>)
 80061ca:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
 80061ce:	d901      	bls.n	80061d4 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 80061d0:	f04f 30ff 	mov.w	r0, #4294967295

  } else {
    return 0; // no bytes to send -> no error
  }
#endif
}
 80061d4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
 80061d6:	4807      	ldr	r0, [pc, #28]	; (80061f4 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc8>)
 80061d8:	5cc5      	ldrb	r5, [r0, r3]
      case -2: return -2; // buffer full, request retry
      default: return -1; // UART error
    }

  } else {
    return 0; // no bytes to send -> no error
 80061da:	4628      	mov	r0, r5
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
 80061dc:	2d00      	cmp	r5, #0
 80061de:	d1b3      	bne.n	8006148 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x1c>
 80061e0:	e7f8      	b.n	80061d4 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 80061e2:	bf00      	nop
 80061e4:	20000800 	.word	0x20000800
 80061e8:	200007fc 	.word	0x200007fc
 80061ec:	200007e0 	.word	0x200007e0
 80061f0:	0800b02c 	.word	0x0800b02c
 80061f4:	0800aef8 	.word	0x0800aef8

080061f8 <MIOS32_UART_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: UART_MIDI device not available
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend(u8 uart_port, mios32_midi_package_t package)
{
 80061f8:	b538      	push	{r3, r4, r5, lr}
 80061fa:	4605      	mov	r5, r0
 80061fc:	460c      	mov	r4, r1
  s32 error;

  while( (error=MIOS32_UART_MIDI_PackageSend_NonBlocking(uart_port, package)) == -2);
 80061fe:	4628      	mov	r0, r5
 8006200:	4621      	mov	r1, r4
 8006202:	f7ff ff93 	bl	800612c <MIOS32_UART_MIDI_PackageSend_NonBlocking>
 8006206:	f110 0f02 	cmn.w	r0, #2
 800620a:	d0f8      	beq.n	80061fe <MIOS32_UART_MIDI_PackageSend+0x6>

  return error;
}
 800620c:	bd38      	pop	{r3, r4, r5, pc}
	...

08006210 <MIOS32_UART_MIDI_PackageReceive>:
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 8006210:	2801      	cmp	r0, #1
//! \return -1: no package in buffer
//! \return -10: incoming MIDI package timed out (incomplete package received)
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageReceive(u8 uart_port, mios32_midi_package_t *package)
{
 8006212:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006214:	4604      	mov	r4, r0
 8006216:	460e      	mov	r6, r1
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled - accordingly no package in buffer
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;
 8006218:	bf88      	it	hi
 800621a:	f04f 30ff 	movhi.w	r0, #4294967295
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 800621e:	f200 80c5 	bhi.w	80063ac <MIOS32_UART_MIDI_PackageReceive+0x19c>
 8006222:	e09e      	b.n	8006362 <MIOS32_UART_MIDI_PackageReceive+0x152>
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
    u8 byte = (u8)status;
 8006224:	b2c0      	uxtb	r0, r0

    if( byte & 0x80 ) { // new MIDI status
 8006226:	f010 0f80 	tst.w	r0, #128	; 0x80
 800622a:	d048      	beq.n	80062be <MIOS32_UART_MIDI_PackageReceive+0xae>
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
 800622c:	28f7      	cmp	r0, #247	; 0xf7
 800622e:	d908      	bls.n	8006242 <MIOS32_UART_MIDI_PackageReceive+0x32>
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
 8006230:	6833      	ldr	r3, [r6, #0]
 8006232:	f043 030f 	orr.w	r3, r3, #15
 8006236:	6033      	str	r3, [r6, #0]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
 8006238:	2300      	movs	r3, #0
    if( byte & 0x80 ) { // new MIDI status
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
	package->evnt0 = byte;
 800623a:	7070      	strb	r0, [r6, #1]
	package->evnt1 = 0x00;
 800623c:	70b3      	strb	r3, [r6, #2]
	package->evnt2 = 0x00;
 800623e:	70f3      	strb	r3, [r6, #3]
 8006240:	e0b5      	b.n	80063ae <MIOS32_UART_MIDI_PackageReceive+0x19e>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 8006242:	f3c0 1302 	ubfx	r3, r0, #4, #3
 8006246:	5cfb      	ldrb	r3, [r7, r3]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
 8006248:	7128      	strb	r0, [r5, #4]
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 800624a:	716b      	strb	r3, [r5, #5]

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 800624c:	2b00      	cmp	r3, #0
 800624e:	d12e      	bne.n	80062ae <MIOS32_UART_MIDI_PackageReceive+0x9e>
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 8006250:	4958      	ldr	r1, [pc, #352]	; (80063b4 <MIOS32_UART_MIDI_PackageReceive+0x1a4>)
 8006252:	f000 020f 	and.w	r2, r0, #15
 8006256:	5c8a      	ldrb	r2, [r1, r2]

	  if( byte == 0xf0 ) {
 8006258:	28f0      	cmp	r0, #240	; 0xf0
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 800625a:	716a      	strb	r2, [r5, #5]

	  if( byte == 0xf0 ) {
 800625c:	d103      	bne.n	8006266 <MIOS32_UART_MIDI_PackageReceive+0x56>
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
	    midix->sysex_ctr = 0x01;
 800625e:	2201      	movs	r2, #1

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];

	  if( byte == 0xf0 ) {
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
 8006260:	7068      	strb	r0, [r5, #1]
	    midix->sysex_ctr = 0x01;
 8006262:	71ea      	strb	r2, [r5, #7]
 8006264:	e024      	b.n	80062b0 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	  } else if( byte == 0xf7 ) {
 8006266:	28f7      	cmp	r0, #247	; 0xf7
 8006268:	d122      	bne.n	80062b0 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	    switch( midix->sysex_ctr ) {
 800626a:	79ea      	ldrb	r2, [r5, #7]
 800626c:	b11a      	cbz	r2, 8006276 <MIOS32_UART_MIDI_PackageReceive+0x66>
 800626e:	2a01      	cmp	r2, #1
 8006270:	782a      	ldrb	r2, [r5, #0]
 8006272:	d110      	bne.n	8006296 <MIOS32_UART_MIDI_PackageReceive+0x86>
 8006274:	e008      	b.n	8006288 <MIOS32_UART_MIDI_PackageReceive+0x78>
 	      case 0:
		midix->package.cin = 5; // 5: SysEx ends with single byte
 8006276:	782b      	ldrb	r3, [r5, #0]
 8006278:	2105      	movs	r1, #5
 800627a:	f361 0303 	bfi	r3, r1, #0, #4
 800627e:	702b      	strb	r3, [r5, #0]
		midix->package.evnt0 = 0xf7;
 8006280:	7068      	strb	r0, [r5, #1]
		midix->package.evnt1 = 0x00;
 8006282:	70aa      	strb	r2, [r5, #2]
		midix->package.evnt2 = 0x00;
 8006284:	70ea      	strb	r2, [r5, #3]
		break;
 8006286:	e00c      	b.n	80062a2 <MIOS32_UART_MIDI_PackageReceive+0x92>
	      case 1:
		midix->package.cin = 6; // 6: SysEx ends with two bytes
 8006288:	2106      	movs	r1, #6
 800628a:	f361 0203 	bfi	r2, r1, #0, #4
 800628e:	702a      	strb	r2, [r5, #0]
		// midix->package.evnt0 = // already stored
		midix->package.evnt1 = 0xf7;
 8006290:	70a8      	strb	r0, [r5, #2]
		midix->package.evnt2 = 0x00;
 8006292:	70eb      	strb	r3, [r5, #3]
		break;
 8006294:	e005      	b.n	80062a2 <MIOS32_UART_MIDI_PackageReceive+0x92>
	      default:
		midix->package.cin = 7; // 7: SysEx ends with three bytes
 8006296:	4613      	mov	r3, r2
 8006298:	2207      	movs	r2, #7
 800629a:	f362 0303 	bfi	r3, r2, #0, #4
 800629e:	702b      	strb	r3, [r5, #0]
		// midix->package.evnt0 = // already stored
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
 80062a0:	70e8      	strb	r0, [r5, #3]
		break;
	    }
	    *package = midix->package;
 80062a2:	682b      	ldr	r3, [r5, #0]
 80062a4:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
 80062a6:	2300      	movs	r3, #0
 80062a8:	71eb      	strb	r3, [r5, #7]
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
		break;
	    }
	    *package = midix->package;
	    package_complete = 1; // -> forward to caller
 80062aa:	3301      	adds	r3, #1
 80062ac:	e000      	b.n	80062b0 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 80062ae:	2300      	movs	r3, #0
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
	  }
	}

	midix->wait_bytes = midix->expected_bytes;
 80062b0:	796a      	ldrb	r2, [r5, #5]
 80062b2:	71aa      	strb	r2, [r5, #6]
	midix->timeout_ctr = 0; // reset timeout counter
 80062b4:	2200      	movs	r2, #0
 80062b6:	812a      	strh	r2, [r5, #8]
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80062b8:	2b00      	cmp	r3, #0
 80062ba:	d057      	beq.n	800636c <MIOS32_UART_MIDI_PackageReceive+0x15c>
 80062bc:	e077      	b.n	80063ae <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 80062be:	792b      	ldrb	r3, [r5, #4]
 80062c0:	2bf0      	cmp	r3, #240	; 0xf0
 80062c2:	d117      	bne.n	80062f4 <MIOS32_UART_MIDI_PackageReceive+0xe4>
	switch( ++midix->sysex_ctr ) {
 80062c4:	79eb      	ldrb	r3, [r5, #7]
 80062c6:	3301      	adds	r3, #1
 80062c8:	b2db      	uxtb	r3, r3
 80062ca:	2b01      	cmp	r3, #1
 80062cc:	71eb      	strb	r3, [r5, #7]
 80062ce:	d002      	beq.n	80062d6 <MIOS32_UART_MIDI_PackageReceive+0xc6>
 80062d0:	2b02      	cmp	r3, #2
 80062d2:	d104      	bne.n	80062de <MIOS32_UART_MIDI_PackageReceive+0xce>
 80062d4:	e001      	b.n	80062da <MIOS32_UART_MIDI_PackageReceive+0xca>
  	  case 1:
	    midix->package.evnt0 = byte; 
 80062d6:	7068      	strb	r0, [r5, #1]
	    break;
 80062d8:	e048      	b.n	800636c <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  case 2: 
	    midix->package.evnt1 = byte; 
 80062da:	70a8      	strb	r0, [r5, #2]
	    break;
 80062dc:	e046      	b.n	800636c <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  default: // 3
	    midix->package.evnt2 = byte;

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 80062de:	782b      	ldrb	r3, [r5, #0]
 80062e0:	2204      	movs	r2, #4
 80062e2:	f362 0303 	bfi	r3, r2, #0, #4
	    break;
	  case 2: 
	    midix->package.evnt1 = byte; 
	    break;
	  default: // 3
	    midix->package.evnt2 = byte;
 80062e6:	70e8      	strb	r0, [r5, #3]

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 80062e8:	702b      	strb	r3, [r5, #0]
	    *package = midix->package;
 80062ea:	682b      	ldr	r3, [r5, #0]
 80062ec:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
 80062ee:	2300      	movs	r3, #0
 80062f0:	71eb      	strb	r3, [r5, #7]
 80062f2:	e05c      	b.n	80063ae <MIOS32_UART_MIDI_PackageReceive+0x19e>
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
 80062f4:	79ab      	ldrb	r3, [r5, #6]
 80062f6:	b923      	cbnz	r3, 8006302 <MIOS32_UART_MIDI_PackageReceive+0xf2>
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 80062f8:	796a      	ldrb	r2, [r5, #5]
	  midix->timeout_ctr = 0; // reset timeout counter
 80062fa:	812b      	strh	r3, [r5, #8]
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 80062fc:	3a01      	subs	r2, #1
 80062fe:	71aa      	strb	r2, [r5, #6]
 8006300:	e001      	b.n	8006306 <MIOS32_UART_MIDI_PackageReceive+0xf6>
	  midix->timeout_ctr = 0; // reset timeout counter
	} else {
	  --midix->wait_bytes;
 8006302:	3b01      	subs	r3, #1
 8006304:	71ab      	strb	r3, [r5, #6]
	}

	if( midix->expected_bytes == 1 ) {
 8006306:	796b      	ldrb	r3, [r5, #5]
 8006308:	2b01      	cmp	r3, #1
 800630a:	d103      	bne.n	8006314 <MIOS32_UART_MIDI_PackageReceive+0x104>
	  midix->package.evnt1 = byte;
	  midix->package.evnt2 = 0x00;
 800630c:	3b01      	subs	r3, #1
	} else {
	  --midix->wait_bytes;
	}

	if( midix->expected_bytes == 1 ) {
	  midix->package.evnt1 = byte;
 800630e:	70a8      	strb	r0, [r5, #2]
	  midix->package.evnt2 = 0x00;
 8006310:	70eb      	strb	r3, [r5, #3]
 8006312:	e004      	b.n	800631e <MIOS32_UART_MIDI_PackageReceive+0x10e>
	} else {
	  if( midix->wait_bytes )
 8006314:	79ab      	ldrb	r3, [r5, #6]
 8006316:	b10b      	cbz	r3, 800631c <MIOS32_UART_MIDI_PackageReceive+0x10c>
	    midix->package.evnt1 = byte;
 8006318:	70a8      	strb	r0, [r5, #2]
 800631a:	e000      	b.n	800631e <MIOS32_UART_MIDI_PackageReceive+0x10e>
	  else
	    midix->package.evnt2 = byte;
 800631c:	70e8      	strb	r0, [r5, #3]
	}
	
	if( !midix->wait_bytes ) {
 800631e:	79ab      	ldrb	r3, [r5, #6]
 8006320:	bb23      	cbnz	r3, 800636c <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  if( (midix->running_status & 0xf0) != 0xf0 ) {
 8006322:	792b      	ldrb	r3, [r5, #4]
 8006324:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8006328:	2af0      	cmp	r2, #240	; 0xf0
 800632a:	d002      	beq.n	8006332 <MIOS32_UART_MIDI_PackageReceive+0x122>
	    midix->package.cin = midix->running_status >> 4; // common MIDI message
 800632c:	091a      	lsrs	r2, r3, #4
 800632e:	782b      	ldrb	r3, [r5, #0]
 8006330:	e00b      	b.n	800634a <MIOS32_UART_MIDI_PackageReceive+0x13a>
	  } else {
	    switch( midix->expected_bytes ) { // MEMO: == 0 comparison was a bug in original MBHP_USB code
 8006332:	796b      	ldrb	r3, [r5, #5]
 8006334:	b11b      	cbz	r3, 800633e <MIOS32_UART_MIDI_PackageReceive+0x12e>
 8006336:	2b01      	cmp	r3, #1
 8006338:	782b      	ldrb	r3, [r5, #0]
 800633a:	d105      	bne.n	8006348 <MIOS32_UART_MIDI_PackageReceive+0x138>
 800633c:	e002      	b.n	8006344 <MIOS32_UART_MIDI_PackageReceive+0x134>
  	      case 0: 
		midix->package.cin = 5; // 5: SysEx common with one byte
 800633e:	782b      	ldrb	r3, [r5, #0]
 8006340:	2205      	movs	r2, #5
 8006342:	e002      	b.n	800634a <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      case 1: 
		midix->package.cin = 2; // 2: SysEx common with two bytes
 8006344:	2202      	movs	r2, #2
 8006346:	e000      	b.n	800634a <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      default: 
		midix->package.cin = 3; // 3: SysEx common with three bytes
 8006348:	2203      	movs	r2, #3
 800634a:	f362 0303 	bfi	r3, r2, #0, #4
 800634e:	702b      	strb	r3, [r5, #0]
		break;
	    }
	  }

	  midix->package.evnt0 = midix->running_status;
 8006350:	230c      	movs	r3, #12
 8006352:	4363      	muls	r3, r4
 8006354:	4a18      	ldr	r2, [pc, #96]	; (80063b8 <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 8006356:	18d1      	adds	r1, r2, r3
 8006358:	7908      	ldrb	r0, [r1, #4]
 800635a:	7048      	strb	r0, [r1, #1]
	  // midix->package.evnt1 = // already stored
	  // midix->package.evnt2 = // already stored
	  *package = midix->package;
 800635c:	58d3      	ldr	r3, [r2, r3]
 800635e:	6033      	str	r3, [r6, #0]
 8006360:	e025      	b.n	80063ae <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 8006362:	4b15      	ldr	r3, [pc, #84]	; (80063b8 <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 8006364:	250c      	movs	r5, #12
 8006366:	fb05 3504 	mla	r5, r5, r4, r3
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 800636a:	4f14      	ldr	r7, [pc, #80]	; (80063bc <MIOS32_UART_MIDI_PackageReceive+0x1ac>)
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 800636c:	4620      	mov	r0, r4
 800636e:	f001 ff51 	bl	8008214 <MIOS32_UART_RxBufferGet>
 8006372:	2800      	cmp	r0, #0
 8006374:	f6bf af56 	bge.w	8006224 <MIOS32_UART_MIDI_PackageReceive+0x14>
 8006378:	2000      	movs	r0, #0
      }
    }
  }

  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
 800637a:	230c      	movs	r3, #12
 800637c:	435c      	muls	r4, r3
 800637e:	490e      	ldr	r1, [pc, #56]	; (80063b8 <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 8006380:	190b      	adds	r3, r1, r4
 8006382:	799a      	ldrb	r2, [r3, #6]
 8006384:	b16a      	cbz	r2, 80063a2 <MIOS32_UART_MIDI_PackageReceive+0x192>
 8006386:	891a      	ldrh	r2, [r3, #8]
 8006388:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 800638c:	d909      	bls.n	80063a2 <MIOS32_UART_MIDI_PackageReceive+0x192>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 800638e:	2200      	movs	r2, #0
 8006390:	510a      	str	r2, [r1, r4]
  midix->running_status = 0x00;
 8006392:	711a      	strb	r2, [r3, #4]
  midix->expected_bytes = 0x00;
 8006394:	715a      	strb	r2, [r3, #5]
  midix->wait_bytes = 0x00;
 8006396:	719a      	strb	r2, [r3, #6]
  midix->sysex_ctr = 0x00;
 8006398:	71da      	strb	r2, [r3, #7]
  midix->timeout_ctr = 0;
 800639a:	811a      	strh	r2, [r3, #8]
  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
    // stop waiting
    MIOS32_UART_MIDI_RecordReset(uart_port);
    // notify that incomplete package has been received
    return -10;
 800639c:	f06f 0009 	mvn.w	r0, #9
 80063a0:	e004      	b.n	80063ac <MIOS32_UART_MIDI_PackageReceive+0x19c>
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 80063a2:	2800      	cmp	r0, #0
 80063a4:	bf0c      	ite	eq
 80063a6:	f04f 30ff 	moveq.w	r0, #4294967295
 80063aa:	2000      	movne	r0, #0
#endif
}
 80063ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80063ae:	2001      	movs	r0, #1
 80063b0:	e7e3      	b.n	800637a <MIOS32_UART_MIDI_PackageReceive+0x16a>
 80063b2:	bf00      	nop
 80063b4:	0800aee8 	.word	0x0800aee8
 80063b8:	200007e4 	.word	0x200007e4
 80063bc:	0800b01c 	.word	0x0800b01c

080063c0 <MIOS32_IIC_MIDI_Init>:
  // TODO: send optimisation flag to IIC_MIDI device once it has been scanned!
#endif

  return 0; // no error
#endif
}
 80063c0:	f04f 30ff 	mov.w	r0, #4294967295
 80063c4:	4770      	bx	lr

080063c6 <MIOS32_IIC_MIDI_Periodic_mS>:
s32 MIOS32_IIC_MIDI_Periodic_mS(void)
{
  // currently only a dummy - RS optimisation handled by IIC_MIDI device

  return 0;
}
 80063c6:	2000      	movs	r0, #0
 80063c8:	4770      	bx	lr

080063ca <MIOS32_IIC_MIDI_PackageSend>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageSend(u8 iic_port, mios32_midi_package_t package)
{
  return _MIOS32_IIC_MIDI_PackageSend(iic_port, package, 0); // blocking mode
}
 80063ca:	f04f 30ff 	mov.w	r0, #4294967295
 80063ce:	4770      	bx	lr

080063d0 <MIOS32_IIC_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageReceive(u8 iic_port, mios32_midi_package_t *package)
{
  return _MIOS32_IIC_MIDI_PackageReceive(iic_port, package, 0); // blocking
}
 80063d0:	f04f 30ff 	mov.w	r0, #4294967295
 80063d4:	4770      	bx	lr

080063d6 <MIOS32_IIC_BS_Init>:
  if( MIOS32_IIC_BS_ScanBankSticks() < 0 )
    return -2; // we don't expect that any other task accesses the IIC port yet!

  return 0; // no error
#endif
}
 80063d6:	f04f 30ff 	mov.w	r0, #4294967295
 80063da:	4770      	bx	lr

080063dc <MIOS32_MF_Init>:
    mf_state[i].config.cfg.pwm_duty_cycle_up = 1;
  }

  return 0;
#endif
}
 80063dc:	f04f 30ff 	mov.w	r0, #4294967295
 80063e0:	4770      	bx	lr
	...

080063e4 <MIOS32_SYS_Reset>:
//!   <LI>reset STM32
//! </UL>
//! \return < 0 if reset failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Reset(void)
{
 80063e4:	b508      	push	{r3, lr}
  // disable all RTOS tasks
#ifndef MIOS32_DONT_USE_FREERTOS
  portENTER_CRITICAL(); // port specific FreeRTOS function to disable tasks (nested)
 80063e6:	f7fe fd9f 	bl	8004f28 <vPortEnterCritical>

  // print reboot message if LCD enabled
#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 80063ea:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80063ee:	f7ff f8f8 	bl	80055e2 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 80063f2:	2000      	movs	r0, #0
 80063f4:	f7ff f8f9 	bl	80055ea <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 80063f8:	2000      	movs	r0, #0
 80063fa:	f7ff f817 	bl	800542c <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 80063fe:	f7ff f87d 	bl	80054fc <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 8006402:	2000      	movs	r0, #0
 8006404:	4601      	mov	r1, r0
 8006406:	f7ff f817 	bl	8005438 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("Bootloader Mode "); // 16 chars
 800640a:	4811      	ldr	r0, [pc, #68]	; (8006450 <MIOS32_SYS_Reset+0x6c>)
 800640c:	f7ff f8a8 	bl	8005560 <MIOS32_LCD_PrintString>
#endif

  // wait until all MIDI OUT buffers are empty (TODO)

  // disable all interrupts
  MIOS32_IRQ_Disable();
 8006410:	f000 f946 	bl	80066a0 <MIOS32_IRQ_Disable>

  // turn off all board LEDs
  MIOS32_BOARD_LED_Set(0xffffffff, 0x00000000);
 8006414:	2100      	movs	r1, #0
 8006416:	f04f 30ff 	mov.w	r0, #4294967295
 800641a:	f000 fe79 	bl	8007110 <MIOS32_BOARD_LED_Set>
#else
  //  NVIC_GenerateSystemReset();
#ifdef MIOS32_BOARD_STM32_PRIMER
  RCC_APB2PeriphResetCmd(0xfffffff0, ENABLE); // Primer: don't reset GPIOA/AF + GPIOB due to USB detach pin
#else
  RCC_APB2PeriphResetCmd(0xfffffff8, ENABLE); // MBHP_CORE_STM32: don't reset GPIOA/AF due to USB pins
 800641e:	f06f 0007 	mvn.w	r0, #7
 8006422:	2101      	movs	r1, #1
 8006424:	f002 ffd2 	bl	80093cc <RCC_APB2PeriphResetCmd>
#endif
  RCC_APB1PeriphResetCmd(0xff7fffff, ENABLE); // don't reset USB, so that the connection can survive!
 8006428:	f46f 0000 	mvn.w	r0, #8388608	; 0x800000
 800642c:	2101      	movs	r1, #1
 800642e:	f002 ffdb 	bl	80093e8 <RCC_APB1PeriphResetCmd>
  RCC_APB2PeriphResetCmd(0xffffffff, DISABLE);
 8006432:	f04f 30ff 	mov.w	r0, #4294967295
 8006436:	2100      	movs	r1, #0
 8006438:	f002 ffc8 	bl	80093cc <RCC_APB2PeriphResetCmd>
  RCC_APB1PeriphResetCmd(0xffffffff, DISABLE);
 800643c:	f04f 30ff 	mov.w	r0, #4294967295
 8006440:	2100      	movs	r1, #0
 8006442:	f002 ffd1 	bl	80093e8 <RCC_APB1PeriphResetCmd>
  // not available in v3.0.0 library anymore? - copy from v2.0.1
  SCB->AIRCR = NVIC_AIRCR_VECTKEY | (1 << NVIC_VECTRESET);
#endif
#if 1
  // and this is the code for v3.3.0
  SCB->AIRCR = (0x5fa << SCB_AIRCR_VECTKEY_Pos) | (1 << SCB_AIRCR_VECTRESET_Pos);
 8006446:	4a03      	ldr	r2, [pc, #12]	; (8006454 <MIOS32_SYS_Reset+0x70>)
 8006448:	4b03      	ldr	r3, [pc, #12]	; (8006458 <MIOS32_SYS_Reset+0x74>)
 800644a:	60da      	str	r2, [r3, #12]
 800644c:	e7fe      	b.n	800644c <MIOS32_SYS_Reset+0x68>
 800644e:	bf00      	nop
 8006450:	0800b038 	.word	0x0800b038
 8006454:	05fa0001 	.word	0x05fa0001
 8006458:	e000ed00 	.word	0xe000ed00

0800645c <MIOS32_SYS_ChipIDGet>:
//! \return the chip ID
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_ChipIDGet(void)
{
  // stored in DBGMCU_IDCODE register
  return MEM32(0xe0042000);
 800645c:	4b01      	ldr	r3, [pc, #4]	; (8006464 <MIOS32_SYS_ChipIDGet+0x8>)
 800645e:	6818      	ldr	r0, [r3, #0]
}
 8006460:	4770      	bx	lr
 8006462:	bf00      	nop
 8006464:	e0042000 	.word	0xe0042000

08006468 <MIOS32_SYS_FlashSizeGet>:
//! \return the Flash size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_FlashSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e0) * 0x400;
 8006468:	4b02      	ldr	r3, [pc, #8]	; (8006474 <MIOS32_SYS_FlashSizeGet+0xc>)
 800646a:	8818      	ldrh	r0, [r3, #0]
 800646c:	b280      	uxth	r0, r0
 800646e:	0280      	lsls	r0, r0, #10
}
 8006470:	4770      	bx	lr
 8006472:	bf00      	nop
 8006474:	1ffff7e0 	.word	0x1ffff7e0

08006478 <MIOS32_SYS_RAMSizeGet>:
//! \return the RAM size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_RAMSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e2) * 0x400;
 8006478:	4b02      	ldr	r3, [pc, #8]	; (8006484 <MIOS32_SYS_RAMSizeGet+0xc>)
 800647a:	8818      	ldrh	r0, [r3, #0]
 800647c:	b280      	uxth	r0, r0
 800647e:	0280      	lsls	r0, r0, #10
}
 8006480:	4770      	bx	lr
 8006482:	bf00      	nop
 8006484:	1ffff7e2 	.word	0x1ffff7e2

08006488 <MIOS32_SYS_SerialNumberGet>:
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 8006488:	2300      	movs	r3, #0
    u8 b = MEM8(0x1ffff7e8 + (i/2));
 800648a:	4a0b      	ldr	r2, [pc, #44]	; (80064b8 <MIOS32_SYS_SerialNumberGet+0x30>)
 800648c:	1059      	asrs	r1, r3, #1
 800648e:	188a      	adds	r2, r1, r2
 8006490:	7812      	ldrb	r2, [r2, #0]
    if( !(i & 1) )
 8006492:	f013 0f01 	tst.w	r3, #1
      b >>= 4;
 8006496:	bf08      	it	eq
 8006498:	0912      	lsreq	r2, r2, #4
    b &= 0x0f;
 800649a:	f002 020f 	and.w	r2, r2, #15

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
 800649e:	2a09      	cmp	r2, #9
 80064a0:	bf94      	ite	ls
 80064a2:	2130      	movls	r1, #48	; 0x30
 80064a4:	2137      	movhi	r1, #55	; 0x37
 80064a6:	188a      	adds	r2, r1, r2
 80064a8:	54c2      	strb	r2, [r0, r3]
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 80064aa:	3301      	adds	r3, #1
 80064ac:	2b18      	cmp	r3, #24
 80064ae:	d1ec      	bne.n	800648a <MIOS32_SYS_SerialNumberGet+0x2>
      b >>= 4;
    b &= 0x0f;

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
  }
  str[i] = 0;
 80064b0:	2300      	movs	r3, #0
 80064b2:	7603      	strb	r3, [r0, #24]

  return 0; // no error
}
 80064b4:	4618      	mov	r0, r3
 80064b6:	4770      	bx	lr
 80064b8:	1ffff7e8 	.word	0x1ffff7e8

080064bc <MIOS32_SYS_TimeSet>:
//! Note that this format isn't completely compatible to the NTP timestamp format,
//! as the fraction has only mS accuracy
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_TimeSet(mios32_sys_time_t t)
{
 80064bc:	b507      	push	{r0, r1, r2, lr}
 80064be:	466b      	mov	r3, sp
 80064c0:	e883 0003 	stmia.w	r3, {r0, r1}
  // taken from STM32 example "RTC/Calendar"
  // adapted to clock RTC via HSE  oscillator

  // Enable PWR and BKP clocks
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 80064c4:	2101      	movs	r1, #1
 80064c6:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 80064ca:	f002 ff71 	bl	80093b0 <RCC_APB1PeriphClockCmd>

  // Allow access to BKP Domain
  PWR_BackupAccessCmd(ENABLE);
 80064ce:	2001      	movs	r0, #1
 80064d0:	f003 f82a 	bl	8009528 <PWR_BackupAccessCmd>

  // Reset Backup Domain
  BKP_DeInit();
 80064d4:	f003 f820 	bl	8009518 <BKP_DeInit>

  // Select HSE (divided by 128) as RTC Clock Source
  RCC_RTCCLKConfig(RCC_RTCCLKSource_HSE_Div128);
 80064d8:	f44f 7040 	mov.w	r0, #768	; 0x300
 80064dc:	f002 feea 	bl	80092b4 <RCC_RTCCLKConfig>

  // Enable RTC Clock
  RCC_RTCCLKCmd(ENABLE);
 80064e0:	2001      	movs	r0, #1
 80064e2:	f002 feef 	bl	80092c4 <RCC_RTCCLKCmd>

  // Wait for RTC registers synchronization
  RTC_WaitForSynchro();
 80064e6:	f003 f809 	bl	80094fc <RTC_WaitForSynchro>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 80064ea:	f002 ffff 	bl	80094ec <RTC_WaitForLastTask>

  // Enable the RTC Second
  RTC_ITConfig(RTC_IT_SEC, ENABLE);
 80064ee:	2001      	movs	r0, #1
 80064f0:	4601      	mov	r1, r0
 80064f2:	f002 ffb9 	bl	8009468 <RTC_ITConfig>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 80064f6:	f002 fff9 	bl	80094ec <RTC_WaitForLastTask>

  // Set RTC prescaler: set RTC period to 1sec
  RTC_SetPrescaler(RTC_PREDIVIDER-1);
 80064fa:	4806      	ldr	r0, [pc, #24]	; (8006514 <MIOS32_SYS_TimeSet+0x58>)
 80064fc:	f002 ffe6 	bl	80094cc <RTC_SetPrescaler>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 8006500:	f002 fff4 	bl	80094ec <RTC_WaitForLastTask>

  // Change the current time
  // (fraction not taken into account here)
  RTC_SetCounter(t.seconds);
 8006504:	9800      	ldr	r0, [sp, #0]
 8006506:	f002 ffd3 	bl	80094b0 <RTC_SetCounter>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800650a:	f002 ffef 	bl	80094ec <RTC_WaitForLastTask>

  return 0; // no error
}
 800650e:	2000      	movs	r0, #0
 8006510:	bd0e      	pop	{r1, r2, r3, pc}
 8006512:	bf00      	nop
 8006514:	00016e35 	.word	0x00016e35

08006518 <MIOS32_SYS_Init>:
//! </UL>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
 8006518:	b530      	push	{r4, r5, lr}
 800651a:	4605      	mov	r5, r0
 800651c:	b085      	sub	sp, #20
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800651e:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
 8006522:	2d00      	cmp	r5, #0
 8006524:	d177      	bne.n	8006616 <MIOS32_SYS_Init+0xfe>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8006526:	ac03      	add	r4, sp, #12
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
 8006528:	2101      	movs	r1, #1
 800652a:	207d      	movs	r0, #125	; 0x7d
 800652c:	f002 ff32 	bl	8009394 <RCC_APB2PeriphClockCmd>
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8006530:	4620      	mov	r0, r4
 8006532:	f002 fab9 	bl	8008aa8 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 8006536:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8006538:	4621      	mov	r1, r4
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 800653a:	f88d 300f 	strb.w	r3, [sp, #15]
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800653e:	4837      	ldr	r0, [pc, #220]	; (800661c <MIOS32_SYS_Init+0x104>)

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
 8006540:	f24e 73ff 	movw	r3, #59391	; 0xe7ff
 8006544:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8006548:	f002 fa55 	bl	80089f6 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 800654c:	f04f 33ff 	mov.w	r3, #4294967295
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8006550:	4621      	mov	r1, r4
 8006552:	4833      	ldr	r0, [pc, #204]	; (8006620 <MIOS32_SYS_Init+0x108>)
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 8006554:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8006558:	f002 fa4d 	bl	80089f6 <GPIO_Init>
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 800655c:	4621      	mov	r1, r4
 800655e:	4831      	ldr	r0, [pc, #196]	; (8006624 <MIOS32_SYS_Init+0x10c>)
 8006560:	f002 fa49 	bl	80089f6 <GPIO_Init>
  GPIO_Init(GPIOB, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8006564:	4621      	mov	r1, r4
 8006566:	4830      	ldr	r0, [pc, #192]	; (8006628 <MIOS32_SYS_Init+0x110>)
 8006568:	f002 fa45 	bl	80089f6 <GPIO_Init>
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 800656c:	f002 fe6c 	bl	8009248 <RCC_GetSYSCLKSource>
 8006570:	2808      	cmp	r0, #8
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;
 8006572:	bf08      	it	eq
 8006574:	462c      	moveq	r4, r5
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 8006576:	d033      	beq.n	80065e0 <MIOS32_SYS_Init+0xc8>
    // Start with the clocks in their expected state
    RCC_DeInit();
 8006578:	f002 fe10 	bl	800919c <RCC_DeInit>

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);
 800657c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8006580:	f002 fe2c 	bl	80091dc <RCC_HSEConfig>

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 8006584:	f002 ff5a 	bl	800943c <RCC_WaitForHSEStartUp>

    if( HSEStartUpStatus == SUCCESS ) {
 8006588:	2801      	cmp	r0, #1

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 800658a:	4604      	mov	r4, r0

    if( HSEStartUpStatus == SUCCESS ) {
 800658c:	d128      	bne.n	80065e0 <MIOS32_SYS_Init+0xc8>
      // Enable Prefetch Buffer
      FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 800658e:	2010      	movs	r0, #16
 8006590:	f002 fad6 	bl	8008b40 <FLASH_PrefetchBufferCmd>

      // Flash 2 wait state
      FLASH_SetLatency(FLASH_Latency_2);
 8006594:	2002      	movs	r0, #2
 8006596:	f002 fac9 	bl	8008b2c <FLASH_SetLatency>

      // HCLK = SYSCLK
      RCC_HCLKConfig(RCC_SYSCLK_Div1);
 800659a:	4628      	mov	r0, r5
 800659c:	f002 fe5c 	bl	8009258 <RCC_HCLKConfig>

      // PCLK2 = HCLK
      RCC_PCLK2Config(RCC_HCLK_Div1);
 80065a0:	4628      	mov	r0, r5
 80065a2:	f002 fe6d 	bl	8009280 <RCC_PCLK2Config>

      // PCLK1 = HCLK/2
      RCC_PCLK1Config(RCC_HCLK_Div2);
 80065a6:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80065aa:	f002 fe5f 	bl	800926c <RCC_PCLK1Config>

      // ADCCLK = PCLK2/6
      RCC_ADCCLKConfig(RCC_PCLK2_Div6);
 80065ae:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80065b2:	f002 fe75 	bl	80092a0 <RCC_ADCCLKConfig>
      // PLL configuration: PLLCLK = (PLL2 / 5) * 9 = 72 MHz
      RCC_PREDIV1Config(RCC_PREDIV1_Source_PLL2, RCC_PREDIV1_Div5);
      RCC_PLLConfig(RCC_PLLSource_PREDIV1, RCC_PLLMul_9);
#else
      // PLLCLK = 12MHz * 6 = 72 MHz
      RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_6);
 80065b6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80065ba:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 80065be:	f002 fe29 	bl	8009214 <RCC_PLLConfig>
#endif

      // Enable PLL
      RCC_PLLCmd(ENABLE);
 80065c2:	4620      	mov	r0, r4
 80065c4:	f002 fe30 	bl	8009228 <RCC_PLLCmd>

      // Wait till PLL is ready
      while( RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET );
 80065c8:	2039      	movs	r0, #57	; 0x39
 80065ca:	f002 ff21 	bl	8009410 <RCC_GetFlagStatus>
 80065ce:	2800      	cmp	r0, #0
 80065d0:	d0fa      	beq.n	80065c8 <MIOS32_SYS_Init+0xb0>

      // Select PLL as system clock source
      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 80065d2:	2002      	movs	r0, #2
 80065d4:	f002 fe2e 	bl	8009234 <RCC_SYSCLKConfig>

      // Wait till PLL is used as system clock source
      while( RCC_GetSYSCLKSource() != 0x08 );
 80065d8:	f002 fe36 	bl	8009248 <RCC_GetSYSCLKSource>
 80065dc:	2808      	cmp	r0, #8
 80065de:	d1fb      	bne.n	80065d8 <MIOS32_SYS_Init+0xc0>
    }
  }

  // Set the Vector Table base address as specified in .ld file (-> mios32_sys_isr_vector)
  NVIC_SetVectorTable((u32)&mios32_sys_isr_vector, 0x0);
 80065e0:	2100      	movs	r1, #0
 80065e2:	4812      	ldr	r0, [pc, #72]	; (800662c <MIOS32_SYS_Init+0x114>)
 80065e4:	f002 ffb0 	bl	8009548 <NVIC_SetVectorTable>
  NVIC_PriorityGroupConfig(MIOS32_IRQ_PRIGROUP);
 80065e8:	f44f 7040 	mov.w	r0, #768	; 0x300
 80065ec:	f002 ffa2 	bl	8009534 <NVIC_PriorityGroupConfig>

  // Configure HCLK clock as SysTick clock source
  SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );
 80065f0:	2004      	movs	r0, #4
 80065f2:	f002 ffb5 	bl	8009560 <SysTick_CLKSourceConfig>

  // configure debug control register DBGMCU_CR (we want to stop timers in CPU HALT mode)
  // flags can be overruled in mios32_config.h
  MEM32(0xe0042004) = MIOS32_SYS_STM32_DBGMCU_CR;
 80065f6:	4a0e      	ldr	r2, [pc, #56]	; (8006630 <MIOS32_SYS_Init+0x118>)
 80065f8:	4b0e      	ldr	r3, [pc, #56]	; (8006634 <MIOS32_SYS_Init+0x11c>)
 80065fa:	601a      	str	r2, [r3, #0]

  // initialize system clock
  mios32_sys_time_t t = { .seconds=0, .fraction_ms=0 };
 80065fc:	2300      	movs	r3, #0
 80065fe:	9301      	str	r3, [sp, #4]
 8006600:	9302      	str	r3, [sp, #8]
  MIOS32_SYS_TimeSet(t);
 8006602:	ab01      	add	r3, sp, #4
 8006604:	e893 0003 	ldmia.w	r3, {r0, r1}
 8006608:	f7ff ff58 	bl	80064bc <MIOS32_SYS_TimeSet>

  // error during clock configuration?
  return HSEStartUpStatus == SUCCESS ? 0 : -1;
 800660c:	2c01      	cmp	r4, #1
 800660e:	bf14      	ite	ne
 8006610:	f04f 30ff 	movne.w	r0, #4294967295
 8006614:	2000      	moveq	r0, #0
}
 8006616:	b005      	add	sp, #20
 8006618:	bd30      	pop	{r4, r5, pc}
 800661a:	bf00      	nop
 800661c:	40010800 	.word	0x40010800
 8006620:	40011000 	.word	0x40011000
 8006624:	40011400 	.word	0x40011400
 8006628:	40010c00 	.word	0x40010c00
 800662c:	08004000 	.word	0x08004000
 8006630:	001fff00 	.word	0x001fff00
 8006634:	e0042004 	.word	0xe0042004

08006638 <MIOS32_SYS_TimeGet>:
//!   int milliseconds = t.fraction_ms;
//! \endcode
//! \return the system time in a mios32_sys_time_t structure
/////////////////////////////////////////////////////////////////////////////
mios32_sys_time_t MIOS32_SYS_TimeGet(void)
{
 8006638:	b570      	push	{r4, r5, r6, lr}
 800663a:	4604      	mov	r4, r0
  // therefore interrupts are disabled
  // Disadvantage: bad for interrupt latency...
  // However, expected execution time is ca. 500 nS for two loops (best case),
  // and 750 nS for three loops (worst case)

  MIOS32_IRQ_Disable();
 800663c:	f000 f830 	bl	80066a0 <MIOS32_IRQ_Disable>
  seconds = divider = 0;
 8006640:	2200      	movs	r2, #0
 8006642:	4611      	mov	r1, r2
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
 8006644:	4b12      	ldr	r3, [pc, #72]	; (8006690 <MIOS32_SYS_TimeGet+0x58>)
 8006646:	e001      	b.n	800664c <MIOS32_SYS_TimeGet+0x14>
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 8006648:	462a      	mov	r2, r5
  MIOS32_IRQ_Disable();
  seconds = divider = 0;
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
 800664a:	4631      	mov	r1, r6
 800664c:	8b18      	ldrh	r0, [r3, #24]
 800664e:	8b9e      	ldrh	r6, [r3, #28]
 8006650:	b2b6      	uxth	r6, r6
 8006652:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 8006656:	8a18      	ldrh	r0, [r3, #16]
 8006658:	8a9d      	ldrh	r5, [r3, #20]
  } while( seconds != last_seconds && divider != last_divider );
 800665a:	1a71      	subs	r1, r6, r1
 800665c:	bf18      	it	ne
 800665e:	2101      	movne	r1, #1
  seconds = divider = 0;
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 8006660:	b2ad      	uxth	r5, r5
 8006662:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
  } while( seconds != last_seconds && divider != last_divider );
 8006666:	4295      	cmp	r5, r2
 8006668:	bf0c      	ite	eq
 800666a:	2200      	moveq	r2, #0
 800666c:	f001 0201 	andne.w	r2, r1, #1
 8006670:	2a00      	cmp	r2, #0
 8006672:	d1e9      	bne.n	8006648 <MIOS32_SYS_TimeGet+0x10>
  MIOS32_IRQ_Enable();
 8006674:	f000 f82a 	bl	80066cc <MIOS32_IRQ_Enable>

  mios32_sys_time_t t = {
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
 8006678:	4b06      	ldr	r3, [pc, #24]	; (8006694 <MIOS32_SYS_TimeGet+0x5c>)
 800667a:	4a07      	ldr	r2, [pc, #28]	; (8006698 <MIOS32_SYS_TimeGet+0x60>)
 800667c:	435d      	muls	r5, r3
 800667e:	4b07      	ldr	r3, [pc, #28]	; (800669c <MIOS32_SYS_TimeGet+0x64>)
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
  } while( seconds != last_seconds && divider != last_divider );
  MIOS32_IRQ_Enable();
 8006680:	6026      	str	r6, [r4, #0]

  mios32_sys_time_t t = {
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
 8006682:	18eb      	adds	r3, r5, r3
 8006684:	fbb3 f3f2 	udiv	r3, r3, r2
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
  } while( seconds != last_seconds && divider != last_divider );
  MIOS32_IRQ_Enable();
 8006688:	6063      	str	r3, [r4, #4]
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
  };

  return t;
}
 800668a:	4620      	mov	r0, r4
 800668c:	bd70      	pop	{r4, r5, r6, pc}
 800668e:	bf00      	nop
 8006690:	40002800 	.word	0x40002800
 8006694:	fffffc18 	.word	0xfffffc18
 8006698:	00016e36 	.word	0x00016e36
 800669c:	05967f08 	.word	0x05967f08

080066a0 <MIOS32_IRQ_Disable>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Disable(void)
{
  // get current priority if nested level == 0
  if( !nested_ctr ) {
 80066a0:	4b08      	ldr	r3, [pc, #32]	; (80066c4 <MIOS32_IRQ_Disable+0x24>)
 80066a2:	681b      	ldr	r3, [r3, #0]
 80066a4:	b91b      	cbnz	r3, 80066ae <MIOS32_IRQ_Disable+0xe>
    __asm volatile (			   \
 80066a6:	f3ef 8210 	mrs	r2, PRIMASK
 80066aa:	4b07      	ldr	r3, [pc, #28]	; (80066c8 <MIOS32_IRQ_Disable+0x28>)
 80066ac:	601a      	str	r2, [r3, #0]
		    : "=r" (prev_primask)  \
		    );
  }

  // disable interrupts
  __asm volatile ( \
 80066ae:	f04f 0001 	mov.w	r0, #1
 80066b2:	f380 8810 	msr	PRIMASK, r0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 80066b6:	4b03      	ldr	r3, [pc, #12]	; (80066c4 <MIOS32_IRQ_Disable+0x24>)

  return 0; // no error
}
 80066b8:	2000      	movs	r0, #0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 80066ba:	681a      	ldr	r2, [r3, #0]
 80066bc:	3201      	adds	r2, #1
 80066be:	601a      	str	r2, [r3, #0]

  return 0; // no error
}
 80066c0:	4770      	bx	lr
 80066c2:	bf00      	nop
 80066c4:	20000808 	.word	0x20000808
 80066c8:	20000804 	.word	0x20000804

080066cc <MIOS32_IRQ_Enable>:
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 80066cc:	4a06      	ldr	r2, [pc, #24]	; (80066e8 <MIOS32_IRQ_Enable+0x1c>)
    return -1; // nesting error
 80066ce:	f04f 30ff 	mov.w	r0, #4294967295
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 80066d2:	6813      	ldr	r3, [r2, #0]
 80066d4:	b13b      	cbz	r3, 80066e6 <MIOS32_IRQ_Enable+0x1a>
    return -1; // nesting error

  // decrease nesting level
  --nested_ctr;
 80066d6:	3b01      	subs	r3, #1
 80066d8:	6013      	str	r3, [r2, #0]

  // set back previous priority once nested level reached 0 again
  if( nested_ctr == 0 ) {
 80066da:	b91b      	cbnz	r3, 80066e4 <MIOS32_IRQ_Enable+0x18>
    __asm volatile ( \
 80066dc:	4b03      	ldr	r3, [pc, #12]	; (80066ec <MIOS32_IRQ_Enable+0x20>)
 80066de:	681b      	ldr	r3, [r3, #0]
 80066e0:	f383 8810 	msr	PRIMASK, r3
		    "	msr primask, %0\n" \
		    :: "r" (prev_primask)  \
		    );
  }

  return 0; // no error
 80066e4:	2000      	movs	r0, #0
}
 80066e6:	4770      	bx	lr
 80066e8:	20000808 	.word	0x20000808
 80066ec:	20000804 	.word	0x20000804

080066f0 <MIOS32_IRQ_Install>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 80066f0:	290f      	cmp	r1, #15
    return -1; // invalid priority
 80066f2:	bf88      	it	hi
 80066f4:	f04f 30ff 	movhi.w	r0, #4294967295
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 80066f8:	d818      	bhi.n	800672c <MIOS32_IRQ_Install+0x3c>
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
 80066fa:	4b0d      	ldr	r3, [pc, #52]	; (8006730 <MIOS32_IRQ_Install+0x40>)
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 80066fc:	b242      	sxtb	r2, r0
 80066fe:	68db      	ldr	r3, [r3, #12]
 8006700:	0952      	lsrs	r2, r2, #5
 8006702:	43db      	mvns	r3, r3
 8006704:	f3c3 2302 	ubfx	r3, r3, #8, #3
  u32 tmppre = (4 - tmppriority);
 8006708:	f1c3 0304 	rsb	r3, r3, #4
  tmppriority = priority << tmppre;
 800670c:	4099      	lsls	r1, r3
  tmppriority = tmppriority << 4;
  NVIC->IP[IRQn] = tmppriority;
 800670e:	4b09      	ldr	r3, [pc, #36]	; (8006734 <MIOS32_IRQ_Install+0x44>)
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
  u32 tmppre = (4 - tmppriority);
  tmppriority = priority << tmppre;
  tmppriority = tmppriority << 4;
 8006710:	0109      	lsls	r1, r1, #4
  NVIC->IP[IRQn] = tmppriority;
 8006712:	18c3      	adds	r3, r0, r3
 8006714:	b2c9      	uxtb	r1, r1
 8006716:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
 800671a:	f000 001f 	and.w	r0, r0, #31
 800671e:	2301      	movs	r3, #1
 8006720:	fa13 f000 	lsls.w	r0, r3, r0
 8006724:	4b03      	ldr	r3, [pc, #12]	; (8006734 <MIOS32_IRQ_Install+0x44>)
 8006726:	f843 0022 	str.w	r0, [r3, r2, lsl #2]

  NVIC_EnableIRQ(IRQn);

  return 0; // no error
 800672a:	2000      	movs	r0, #0
}
 800672c:	4770      	bx	lr
 800672e:	bf00      	nop
 8006730:	e000ed00 	.word	0xe000ed00
 8006734:	e000e100 	.word	0xe000e100

08006738 <MIOS32_SPI_IO_Init>:
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported pin driver mode
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_IO_Init(u8 spi, mios32_spi_pin_driver_t spi_pin_driver)
{
 8006738:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800673a:	4604      	mov	r4, r0
 800673c:	460d      	mov	r5, r1
  // init GPIO structure
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800673e:	a801      	add	r0, sp, #4
 8006740:	f002 f9b2 	bl	8008aa8 <GPIO_StructInit>

  // select pin driver and output mode
  u32 af_mode;
  u32 gp_mode;

  switch( spi_pin_driver ) {
 8006744:	2d03      	cmp	r5, #3
 8006746:	f200 809e 	bhi.w	8006886 <MIOS32_SPI_IO_Init+0x14e>
 800674a:	e8df f005 	tbb	[pc, r5]
 800674e:	0802      	.short	0x0802
 8006750:	140e      	.short	0x140e
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8006752:	2303      	movs	r3, #3
 8006754:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 8006758:	2510      	movs	r5, #16
  u32 gp_mode;

  switch( spi_pin_driver ) {
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_PP;
 800675a:	3315      	adds	r3, #21
      gp_mode = GPIO_Mode_Out_PP;
      break;
 800675c:	e010      	b.n	8006780 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800675e:	2303      	movs	r3, #3
 8006760:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 8006764:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_OD;
 8006766:	3319      	adds	r3, #25
      gp_mode = GPIO_Mode_Out_OD;
      break;
 8006768:	e00a      	b.n	8006780 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800676a:	2302      	movs	r3, #2
 800676c:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 8006770:	2510      	movs	r5, #16
      gp_mode = GPIO_Mode_Out_OD;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_PP;
 8006772:	3316      	adds	r3, #22
      gp_mode = GPIO_Mode_Out_PP;
      break;
 8006774:	e004      	b.n	8006780 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8006776:	2302      	movs	r3, #2
 8006778:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 800677c:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_OD;
 800677e:	331a      	adds	r3, #26

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 8006780:	2c01      	cmp	r4, #1
 8006782:	d030      	beq.n	80067e6 <MIOS32_SPI_IO_Init+0xae>
 8006784:	d305      	bcc.n	8006792 <MIOS32_SPI_IO_Init+0x5a>
 8006786:	2c02      	cmp	r4, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 8006788:	bf18      	it	ne
 800678a:	f06f 0001 	mvnne.w	r0, #1

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 800678e:	d17c      	bne.n	800688a <MIOS32_SPI_IO_Init+0x152>
 8006790:	e04c      	b.n	800682c <MIOS32_SPI_IO_Init+0xf4>
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 8006792:	ac02      	add	r4, sp, #8
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 8006794:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 8006798:	2320      	movs	r3, #32
 800679a:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
 800679e:	483b      	ldr	r0, [pc, #236]	; (800688c <MIOS32_SPI_IO_Init+0x154>)
 80067a0:	4621      	mov	r1, r4
 80067a2:	f002 f928 	bl	80089f6 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 80067a6:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 80067a8:	4838      	ldr	r0, [pc, #224]	; (800688c <MIOS32_SPI_IO_Init+0x154>)
 80067aa:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 80067ac:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 80067b0:	f002 f921 	bl	80089f6 <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 80067b4:	2310      	movs	r3, #16
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 80067b6:	4835      	ldr	r0, [pc, #212]	; (800688c <MIOS32_SPI_IO_Init+0x154>)
 80067b8:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 80067ba:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 80067be:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 80067c2:	f002 f918 	bl	80089f6 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 80067c6:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 80067ca:	4831      	ldr	r0, [pc, #196]	; (8006890 <MIOS32_SPI_IO_Init+0x158>)
 80067cc:	4621      	mov	r1, r4
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 80067ce:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 80067d2:	f002 f910 	bl	80089f6 <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80067d6:	2348      	movs	r3, #72	; 0x48
 80067d8:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MISO_PIN;
 80067dc:	2340      	movs	r3, #64	; 0x40
 80067de:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
 80067e2:	482a      	ldr	r0, [pc, #168]	; (800688c <MIOS32_SPI_IO_Init+0x154>)
 80067e4:	e04a      	b.n	800687c <MIOS32_SPI_IO_Init+0x144>
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 80067e6:	ac02      	add	r4, sp, #8
    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 80067e8:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 80067ec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80067f0:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 80067f4:	4827      	ldr	r0, [pc, #156]	; (8006894 <MIOS32_SPI_IO_Init+0x15c>)
 80067f6:	4621      	mov	r1, r4
 80067f8:	f002 f8fd 	bl	80089f6 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 80067fc:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 8006800:	4824      	ldr	r0, [pc, #144]	; (8006894 <MIOS32_SPI_IO_Init+0x15c>)
 8006802:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 8006804:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 8006808:	f002 f8f5 	bl	80089f6 <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 800680c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 8006810:	4820      	ldr	r0, [pc, #128]	; (8006894 <MIOS32_SPI_IO_Init+0x15c>)
 8006812:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 8006814:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 8006818:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 800681c:	f002 f8eb 	bl	80089f6 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
#endif
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8006820:	2348      	movs	r3, #72	; 0x48
 8006822:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MISO_PIN;
 8006826:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800682a:	e024      	b.n	8006876 <MIOS32_SPI_IO_Init+0x13e>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
 800682c:	ac02      	add	r4, sp, #8
 800682e:	2340      	movs	r3, #64	; 0x40
 8006830:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 8006834:	4817      	ldr	r0, [pc, #92]	; (8006894 <MIOS32_SPI_IO_Init+0x15c>)
 8006836:	4621      	mov	r1, r4
    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 8006838:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 800683c:	f002 f8db 	bl	80089f6 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 8006840:	2320      	movs	r3, #32
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 8006842:	4814      	ldr	r0, [pc, #80]	; (8006894 <MIOS32_SPI_IO_Init+0x15c>)
 8006844:	4621      	mov	r1, r4
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 8006846:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 800684a:	f002 f8d4 	bl	80089f6 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 800684e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 8006852:	480f      	ldr	r0, [pc, #60]	; (8006890 <MIOS32_SPI_IO_Init+0x158>)
 8006854:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 8006856:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 800685a:	f002 f8cc 	bl	80089f6 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 800685e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 8006862:	480b      	ldr	r0, [pc, #44]	; (8006890 <MIOS32_SPI_IO_Init+0x158>)
 8006864:	4621      	mov	r1, r4
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 8006866:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 800686a:	f002 f8c4 	bl	80089f6 <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800686e:	2348      	movs	r3, #72	; 0x48
 8006870:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 8006874:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 8006876:	4807      	ldr	r0, [pc, #28]	; (8006894 <MIOS32_SPI_IO_Init+0x15c>)
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 8006878:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 800687c:	4621      	mov	r1, r4
 800687e:	f002 f8ba 	bl	80089f6 <GPIO_Init>

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006882:	2000      	movs	r0, #0
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);

      break;
 8006884:	e001      	b.n	800688a <MIOS32_SPI_IO_Init+0x152>
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
      break;

    default:
      return -3; // unsupported pin driver mode
 8006886:	f06f 0002 	mvn.w	r0, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 800688a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 800688c:	40010800 	.word	0x40010800
 8006890:	40011000 	.word	0x40011000
 8006894:	40010c00 	.word	0x40010c00

08006898 <MIOS32_SPI_RC_PinSet>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 8006898:	2801      	cmp	r0, #1
 800689a:	d017      	beq.n	80068cc <MIOS32_SPI_RC_PinSet+0x34>
 800689c:	d305      	bcc.n	80068aa <MIOS32_SPI_RC_PinSet+0x12>
 800689e:	2802      	cmp	r0, #2
      }
      break;
#endif

    default:
      return -2; // unsupported SPI port
 80068a0:	bf18      	it	ne
 80068a2:	f06f 0101 	mvnne.w	r1, #1
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 80068a6:	d137      	bne.n	8006918 <MIOS32_SPI_RC_PinSet+0x80>
 80068a8:	e01a      	b.n	80068e0 <MIOS32_SPI_RC_PinSet+0x48>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 80068aa:	b111      	cbz	r1, 80068b2 <MIOS32_SPI_RC_PinSet+0x1a>
 80068ac:	2901      	cmp	r1, #1
 80068ae:	d131      	bne.n	8006914 <MIOS32_SPI_RC_PinSet+0x7c>
 80068b0:	e006      	b.n	80068c0 <MIOS32_SPI_RC_PinSet+0x28>
        case 0:
	  if( pin_value )
 80068b2:	b112      	cbz	r2, 80068ba <MIOS32_SPI_RC_PinSet+0x22>
	    MIOS32_SPI0_RCLK1_PORT->BSRR = MIOS32_SPI0_RCLK1_PIN;
 80068b4:	2210      	movs	r2, #16
 80068b6:	4b19      	ldr	r3, [pc, #100]	; (800691c <MIOS32_SPI_RC_PinSet+0x84>)
 80068b8:	e01a      	b.n	80068f0 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
 80068ba:	2110      	movs	r1, #16
 80068bc:	4b17      	ldr	r3, [pc, #92]	; (800691c <MIOS32_SPI_RC_PinSet+0x84>)
 80068be:	e026      	b.n	800690e <MIOS32_SPI_RC_PinSet+0x76>

        case 1:
	  if( pin_value )
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
	  else
	    MIOS32_SPI0_RCLK2_PORT->BRR  = MIOS32_SPI0_RCLK2_PIN;
 80068c0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 80068c4:	b312      	cbz	r2, 800690c <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
 80068c6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80068ca:	e01b      	b.n	8006904 <MIOS32_SPI_RC_PinSet+0x6c>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 80068cc:	bb11      	cbnz	r1, 8006914 <MIOS32_SPI_RC_PinSet+0x7c>
        case 0:
	  if( pin_value )
 80068ce:	b11a      	cbz	r2, 80068d8 <MIOS32_SPI_RC_PinSet+0x40>
	    MIOS32_SPI1_RCLK1_PORT->BSRR = MIOS32_SPI1_RCLK1_PIN;
 80068d0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80068d4:	4b12      	ldr	r3, [pc, #72]	; (8006920 <MIOS32_SPI_RC_PinSet+0x88>)
 80068d6:	e00b      	b.n	80068f0 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI1_RCLK1_PORT->BRR  = MIOS32_SPI1_RCLK1_PIN;
 80068d8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80068dc:	4b10      	ldr	r3, [pc, #64]	; (8006920 <MIOS32_SPI_RC_PinSet+0x88>)
 80068de:	e016      	b.n	800690e <MIOS32_SPI_RC_PinSet+0x76>

    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 80068e0:	b111      	cbz	r1, 80068e8 <MIOS32_SPI_RC_PinSet+0x50>
 80068e2:	2901      	cmp	r1, #1
 80068e4:	d116      	bne.n	8006914 <MIOS32_SPI_RC_PinSet+0x7c>
 80068e6:	e008      	b.n	80068fa <MIOS32_SPI_RC_PinSet+0x62>
        case 0:
	  if( pin_value )
 80068e8:	b122      	cbz	r2, 80068f4 <MIOS32_SPI_RC_PinSet+0x5c>
	    MIOS32_SPI2_RCLK1_PORT->BSRR = MIOS32_SPI2_RCLK1_PIN;
 80068ea:	4b0e      	ldr	r3, [pc, #56]	; (8006924 <MIOS32_SPI_RC_PinSet+0x8c>)
 80068ec:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80068f0:	611a      	str	r2, [r3, #16]
 80068f2:	e011      	b.n	8006918 <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
 80068f4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80068f8:	e008      	b.n	800690c <MIOS32_SPI_RC_PinSet+0x74>

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 80068fa:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 80068fe:	b12a      	cbz	r2, 800690c <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 8006900:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8006904:	4b07      	ldr	r3, [pc, #28]	; (8006924 <MIOS32_SPI_RC_PinSet+0x8c>)

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006906:	2100      	movs	r1, #0
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 8006908:	611a      	str	r2, [r3, #16]
 800690a:	e005      	b.n	8006918 <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 800690c:	4b05      	ldr	r3, [pc, #20]	; (8006924 <MIOS32_SPI_RC_PinSet+0x8c>)
 800690e:	6159      	str	r1, [r3, #20]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006910:	4611      	mov	r1, r2
 8006912:	e001      	b.n	8006918 <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
	  break;

        default:
	  return -3; // unsupported RC pin
 8006914:	f06f 0102 	mvn.w	r1, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 8006918:	4608      	mov	r0, r1
 800691a:	4770      	bx	lr
 800691c:	40010800 	.word	0x40010800
 8006920:	40010c00 	.word	0x40010c00
 8006924:	40011000 	.word	0x40011000

08006928 <MIOS32_SPI_TransferByte>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 8006928:	2801      	cmp	r0, #1
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported SPI mode configured via MIOS32_SPI_TransferModeInit()
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
 800692a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 800692c:	f000 823c 	beq.w	8006da8 <MIOS32_SPI_TransferByte+0x480>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI0_PTR;
 8006930:	bf38      	it	cc
 8006932:	f8df 3490 	ldrcc.w	r3, [pc, #1168]	; 8006dc4 <MIOS32_SPI_TransferByte+0x49c>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 8006936:	f0c0 8238 	bcc.w	8006daa <MIOS32_SPI_TransferByte+0x482>
 800693a:	2802      	cmp	r0, #2
      return in_data; // END of SW emulation - EXIT here!
#endif
    } break;

    default:
      return -2; // unsupported SPI port
 800693c:	bf18      	it	ne
 800693e:	f06f 0001 	mvnne.w	r0, #1
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 8006942:	f040 823d 	bne.w	8006dc0 <MIOS32_SPI_TransferByte+0x498>
#else
    // Software Emulation
    {
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
 8006946:	f8df 3480 	ldr.w	r3, [pc, #1152]	; 8006dc8 <MIOS32_SPI_TransferByte+0x4a0>
 800694a:	781b      	ldrb	r3, [r3, #0]
 800694c:	2b03      	cmp	r3, #3
 800694e:	f200 8235 	bhi.w	8006dbc <MIOS32_SPI_TransferByte+0x494>
 8006952:	e8df f013 	tbh	[pc, r3, lsl #1]
 8006956:	0004      	.short	0x0004
 8006958:	01180096 	.word	0x01180096
 800695c:	01a8      	.short	0x01a8
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 800695e:	f8df 346c 	ldr.w	r3, [pc, #1132]	; 8006dcc <MIOS32_SPI_TransferByte+0x4a4>
 8006962:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006966:	bf0c      	ite	eq
 8006968:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 800696c:	2220      	movne	r2, #32
 800696e:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006970:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006972:	f011 0f40 	tst.w	r1, #64	; 0x40
 8006976:	bf0c      	ite	eq
 8006978:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 800697c:	2020      	movne	r0, #32
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 800697e:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006980:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 8006982:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006984:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006986:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006988:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 800698a:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 800698c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 800698e:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006992:	bf18      	it	ne
 8006994:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006996:	f011 0f20 	tst.w	r1, #32
 800699a:	bf0c      	ite	eq
 800699c:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069a0:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069a2:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069a4:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069a6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 80069a8:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 80069aa:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069ac:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 80069ae:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 80069b2:	bf18      	it	ne
 80069b4:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 80069b6:	f011 0f10 	tst.w	r1, #16
 80069ba:	bf0c      	ite	eq
 80069bc:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069c0:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069c2:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069c4:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069c6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 80069c8:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 80069ca:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069ce:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 80069d0:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 80069d4:	bf18      	it	ne
 80069d6:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 80069da:	f011 0f08 	tst.w	r1, #8
 80069de:	bf0c      	ite	eq
 80069e0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069e4:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069e6:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069e8:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069ea:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 80069ec:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 80069ee:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 80069f0:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 80069f4:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 80069f8:	bf18      	it	ne
 80069fa:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 80069fc:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a00:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006a02:	bf0c      	ite	eq
 8006a04:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a08:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a0a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a0c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a0e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a10:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006a12:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a14:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a16:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a18:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006a1c:	bf18      	it	ne
 8006a1e:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006a20:	f011 0f02 	tst.w	r1, #2
 8006a24:	bf0c      	ite	eq
 8006a26:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a2a:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a2c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a2e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a30:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006a32:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006a34:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a36:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006a38:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006a3c:	bf18      	it	ne
 8006a3e:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006a40:	f011 0f01 	tst.w	r1, #1
 8006a44:	bf0c      	ite	eq
 8006a46:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006a4a:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a4c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a4e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a50:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006a52:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006a54:	6899      	ldr	r1, [r3, #8]
 8006a56:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a5a:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006a5e:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a60:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006a62:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a66:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a6a:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006a6e:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006a72:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_1;
 8006a76:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006a78:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a7a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a7c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a7e:	615a      	str	r2, [r3, #20]
	  break;
 8006a80:	e19e      	b.n	8006dc0 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006a82:	4bd2      	ldr	r3, [pc, #840]	; (8006dcc <MIOS32_SPI_TransferByte+0x4a4>)
 8006a84:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006a86:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006a8a:	bf0c      	ite	eq
 8006a8c:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a90:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a92:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  break;

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006a96:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006a98:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a9a:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a9c:	bf0c      	ite	eq
 8006a9e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006aa2:	2020      	movne	r0, #32

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006aa4:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006aa6:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006aa8:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006aaa:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006aac:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006aae:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006ab0:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006ab4:	bf18      	it	ne
 8006ab6:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006ab8:	f011 0f20 	tst.w	r1, #32
 8006abc:	bf0c      	ite	eq
 8006abe:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ac2:	2020      	movne	r0, #32
 8006ac4:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ac6:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006ac8:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006aca:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006acc:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006ad0:	bf18      	it	ne
 8006ad2:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006ad4:	f011 0f10 	tst.w	r1, #16
 8006ad8:	bf0c      	ite	eq
 8006ada:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ade:	2020      	movne	r0, #32
 8006ae0:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ae2:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006ae4:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006ae8:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006aea:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006aee:	bf18      	it	ne
 8006af0:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006af4:	f011 0f08 	tst.w	r1, #8
 8006af8:	bf0c      	ite	eq
 8006afa:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006afe:	2020      	movne	r0, #32
 8006b00:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b02:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b04:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b06:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b0a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006b0e:	bf18      	it	ne
 8006b10:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006b12:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b16:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006b18:	bf0c      	ite	eq
 8006b1a:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b1e:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006b20:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006b22:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b24:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b26:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b28:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b2a:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006b2e:	bf18      	it	ne
 8006b30:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006b32:	f011 0f02 	tst.w	r1, #2
 8006b36:	bf0c      	ite	eq
 8006b38:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b3c:	2020      	movne	r0, #32
 8006b3e:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b40:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b42:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b44:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b46:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006b4a:	bf18      	it	ne
 8006b4c:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006b4e:	f011 0f01 	tst.w	r1, #1
 8006b52:	bf0c      	ite	eq
 8006b54:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006b58:	2120      	movne	r1, #32
 8006b5a:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b5c:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006b5e:	689b      	ldr	r3, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b60:	9a01      	ldr	r2, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006b62:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b66:	ea43 0606 	orr.w	r6, r3, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b6a:	ea46 0505 	orr.w	r5, r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006b6e:	ea45 0404 	orr.w	r4, r5, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b72:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b76:	ea4c 0c02 	orr.w	ip, ip, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b7a:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006b7e:	ea47 0000 	orr.w	r0, r7, r0
 8006b82:	b2c0      	uxtb	r0, r0
	  break;
 8006b84:	e11c      	b.n	8006dc0 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006b86:	4b91      	ldr	r3, [pc, #580]	; (8006dcc <MIOS32_SPI_TransferByte+0x4a4>)
 8006b88:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006b8c:	bf0c      	ite	eq
 8006b8e:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006b92:	2220      	movne	r2, #32
 8006b94:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006b96:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006b98:	f011 0f40 	tst.w	r1, #64	; 0x40
 8006b9c:	bf0c      	ite	eq
 8006b9e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ba2:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006ba4:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ba6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ba8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006baa:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bac:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006bae:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006bb0:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bb2:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006bb4:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006bb8:	bf18      	it	ne
 8006bba:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006bbc:	f011 0f20 	tst.w	r1, #32
 8006bc0:	bf0c      	ite	eq
 8006bc2:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006bc6:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bc8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bca:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bcc:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006bce:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006bd0:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bd2:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006bd4:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006bd8:	bf18      	it	ne
 8006bda:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006bdc:	f011 0f10 	tst.w	r1, #16
 8006be0:	bf0c      	ite	eq
 8006be2:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006be6:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006be8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bea:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bec:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006bee:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006bf0:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bf4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006bf6:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006bfa:	bf18      	it	ne
 8006bfc:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006c00:	f011 0f08 	tst.w	r1, #8
 8006c04:	bf0c      	ite	eq
 8006c06:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c0a:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c0c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c0e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c10:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006c12:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c14:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c16:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c1a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006c1e:	bf18      	it	ne
 8006c20:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006c22:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c26:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006c28:	bf0c      	ite	eq
 8006c2a:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c2e:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c30:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c32:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c34:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c36:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006c38:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c3a:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c3c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c3e:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006c42:	bf18      	it	ne
 8006c44:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006c46:	f011 0f02 	tst.w	r1, #2
 8006c4a:	bf0c      	ite	eq
 8006c4c:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c50:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c52:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c54:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c56:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006c58:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c5a:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c5c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c5e:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006c62:	bf18      	it	ne
 8006c64:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006c66:	f011 0f01 	tst.w	r1, #1
 8006c6a:	bf0c      	ite	eq
 8006c6c:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006c70:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c72:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c74:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c76:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006c78:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c7a:	6899      	ldr	r1, [r3, #8]
 8006c7c:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c80:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006c84:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c86:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006c88:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c8c:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c90:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c94:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c98:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_0;
 8006c9c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c9e:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006ca0:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006ca2:	615a      	str	r2, [r3, #20]
 8006ca4:	e07e      	b.n	8006da4 <MIOS32_SPI_TransferByte+0x47c>
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006ca6:	4b49      	ldr	r3, [pc, #292]	; (8006dcc <MIOS32_SPI_TransferByte+0x4a4>)
 8006ca8:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006cac:	bf0c      	ite	eq
 8006cae:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006cb2:	2220      	movne	r2, #32
 8006cb4:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006cb6:	2240      	movs	r2, #64	; 0x40
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006cb8:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
 8006cbc:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006cbe:	bf0c      	ite	eq
 8006cc0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006cc4:	2020      	movne	r0, #32
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006cc6:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cc8:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006cca:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ccc:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006cce:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cd0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006cd2:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006cd6:	bf18      	it	ne
 8006cd8:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006cda:	f011 0f20 	tst.w	r1, #32
 8006cde:	bf0c      	ite	eq
 8006ce0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ce4:	2020      	movne	r0, #32
 8006ce6:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ce8:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006cea:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cec:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006cee:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006cf2:	bf18      	it	ne
 8006cf4:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006cf6:	f011 0f10 	tst.w	r1, #16
 8006cfa:	bf0c      	ite	eq
 8006cfc:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d00:	2020      	movne	r0, #32
 8006d02:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d04:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006d06:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d0a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006d0c:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006d10:	bf18      	it	ne
 8006d12:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006d16:	f011 0f08 	tst.w	r1, #8
 8006d1a:	bf0c      	ite	eq
 8006d1c:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d20:	2020      	movne	r0, #32
 8006d22:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d24:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d26:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006d28:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d2c:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006d30:	bf18      	it	ne
 8006d32:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006d34:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d38:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006d3a:	bf0c      	ite	eq
 8006d3c:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d40:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006d42:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006d44:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d46:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d48:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d4a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d4c:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006d50:	bf18      	it	ne
 8006d52:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006d54:	f011 0f02 	tst.w	r1, #2
 8006d58:	bf0c      	ite	eq
 8006d5a:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d5e:	2020      	movne	r0, #32
 8006d60:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d62:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006d64:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d66:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006d68:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006d6c:	bf18      	it	ne
 8006d6e:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006d70:	f011 0f01 	tst.w	r1, #1
 8006d74:	bf0c      	ite	eq
 8006d76:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006d7a:	2120      	movne	r1, #32
 8006d7c:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d7e:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006d80:	6899      	ldr	r1, [r3, #8]
 8006d82:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006d86:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006d8a:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006d8c:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d90:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d92:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d96:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006d9a:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006d9e:	ea47 0000 	orr.w	r0, r7, r0
 8006da2:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
 8006da4:	611a      	str	r2, [r3, #16]

        default:
	  return -3; // unsupported SPI mode
      }

      return in_data; // END of SW emulation - EXIT here!
 8006da6:	e00b      	b.n	8006dc0 <MIOS32_SPI_TransferByte+0x498>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI1_PTR;
 8006da8:	4b09      	ldr	r3, [pc, #36]	; (8006dd0 <MIOS32_SPI_TransferByte+0x4a8>)
    default:
      return -2; // unsupported SPI port
  }

  // send byte
  spi_ptr->DR = b;
 8006daa:	8199      	strh	r1, [r3, #12]

  if( spi_ptr->SR ); // dummy read due to undocumented pipelining issue :-/
 8006dac:	891a      	ldrh	r2, [r3, #8]
  // We use a bus access instead of NOPs to avoid any risk for back-to-back transactions
  // over AHB (if SPI1/SPI2 pointers are used, there is still a risk for such a scenario,
  // e.g. if DMA loads the bus!)

  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );
 8006dae:	891a      	ldrh	r2, [r3, #8]
 8006db0:	f012 0f80 	tst.w	r2, #128	; 0x80
 8006db4:	d1fb      	bne.n	8006dae <MIOS32_SPI_TransferByte+0x486>

  // return received byte
  return spi_ptr->DR;
 8006db6:	8998      	ldrh	r0, [r3, #12]
 8006db8:	b280      	uxth	r0, r0
 8006dba:	e001      	b.n	8006dc0 <MIOS32_SPI_TransferByte+0x498>
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        default:
	  return -3; // unsupported SPI mode
 8006dbc:	f06f 0002 	mvn.w	r0, #2
  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );

  // return received byte
  return spi_ptr->DR;
}
 8006dc0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8006dc2:	bf00      	nop
 8006dc4:	40013000 	.word	0x40013000
 8006dc8:	20000818 	.word	0x20000818
 8006dcc:	40010c00 	.word	0x40010c00
 8006dd0:	40003800 	.word	0x40003800

08006dd4 <MIOS32_SPI_TransferModeInit>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006dd4:	b530      	push	{r4, r5, lr}
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006dd6:	2300      	movs	r3, #0
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006dd8:	b087      	sub	sp, #28
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006dda:	f8ad 3004 	strh.w	r3, [sp, #4]
  SPI_InitStructure.SPI_Mode          = SPI_Mode_Master;
 8006dde:	f44f 7382 	mov.w	r3, #260	; 0x104
 8006de2:	f8ad 3006 	strh.w	r3, [sp, #6]
  SPI_InitStructure.SPI_DataSize      = SPI_DataSize_8b;
 8006de6:	2300      	movs	r3, #0
 8006de8:	f8ad 3008 	strh.w	r3, [sp, #8]
  SPI_InitStructure.SPI_NSS           = SPI_NSS_Soft;
 8006dec:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006df0:	f8ad 300e 	strh.w	r3, [sp, #14]
  SPI_InitStructure.SPI_FirstBit      = SPI_FirstBit_MSB;
 8006df4:	2300      	movs	r3, #0
 8006df6:	f8ad 3012 	strh.w	r3, [sp, #18]
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 8006dfa:	2307      	movs	r3, #7
 8006dfc:	f8ad 3014 	strh.w	r3, [sp, #20]

  switch( spi_mode ) {
 8006e00:	2903      	cmp	r1, #3
 8006e02:	d85f      	bhi.n	8006ec4 <MIOS32_SPI_TransferModeInit+0xf0>
 8006e04:	e8df f001 	tbb	[pc, r1]
 8006e08:	0d080602 	.word	0x0d080602
    case MIOS32_SPI_MODE_CLK0_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006e0c:	2300      	movs	r3, #0
 8006e0e:	f8ad 300a 	strh.w	r3, [sp, #10]
 8006e12:	e00a      	b.n	8006e2a <MIOS32_SPI_TransferModeInit+0x56>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK0_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006e14:	2300      	movs	r3, #0
 8006e16:	e005      	b.n	8006e24 <MIOS32_SPI_TransferModeInit+0x50>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006e18:	2302      	movs	r3, #2
 8006e1a:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8006e1e:	2300      	movs	r3, #0
 8006e20:	e003      	b.n	8006e2a <MIOS32_SPI_TransferModeInit+0x56>
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006e22:	2302      	movs	r3, #2
 8006e24:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006e28:	2301      	movs	r3, #1
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006e2a:	2a07      	cmp	r2, #7
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006e2c:	f8ad 300c 	strh.w	r3, [sp, #12]
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected
 8006e30:	bf88      	it	hi
 8006e32:	f06f 0002 	mvnhi.w	r0, #2
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006e36:	d847      	bhi.n	8006ec8 <MIOS32_SPI_TransferModeInit+0xf4>
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006e38:	2801      	cmp	r0, #1
 8006e3a:	d019      	beq.n	8006e70 <MIOS32_SPI_TransferModeInit+0x9c>
 8006e3c:	d305      	bcc.n	8006e4a <MIOS32_SPI_TransferModeInit+0x76>
 8006e3e:	2802      	cmp	r0, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 8006e40:	bf18      	it	ne
 8006e42:	f06f 0001 	mvnne.w	r0, #1
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006e46:	d13f      	bne.n	8006ec8 <MIOS32_SPI_TransferModeInit+0xf4>
 8006e48:	e02b      	b.n	8006ea2 <MIOS32_SPI_TransferModeInit+0xce>
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e4a:	4c20      	ldr	r4, [pc, #128]	; (8006ecc <MIOS32_SPI_TransferModeInit+0xf8>)
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e4c:	f002 0207 	and.w	r2, r2, #7
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e50:	8825      	ldrh	r5, [r4, #0]
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e52:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006e54:	4620      	mov	r0, r4
 8006e56:	a901      	add	r1, sp, #4
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e58:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006e5c:	f001 ff38 	bl	8008cd0 <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006e60:	8820      	ldrh	r0, [r4, #0]
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e62:	b2ad      	uxth	r5, r5
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006e64:	4045      	eors	r5, r0
 8006e66:	f015 0003 	ands.w	r0, r5, #3
 8006e6a:	d02d      	beq.n	8006ec8 <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006e6c:	2000      	movs	r0, #0
 8006e6e:	e014      	b.n	8006e9a <MIOS32_SPI_TransferModeInit+0xc6>

    case 1: {
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e70:	4b16      	ldr	r3, [pc, #88]	; (8006ecc <MIOS32_SPI_TransferModeInit+0xf8>)
 8006e72:	881c      	ldrh	r4, [r3, #0]
 8006e74:	b2a4      	uxth	r4, r4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
 8006e76:	b11a      	cbz	r2, 8006e80 <MIOS32_SPI_TransferModeInit+0xac>
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006e78:	f002 0207 	and.w	r2, r2, #7
 8006e7c:	3a01      	subs	r2, #1
 8006e7e:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006e80:	4813      	ldr	r0, [pc, #76]	; (8006ed0 <MIOS32_SPI_TransferModeInit+0xfc>)
 8006e82:	a901      	add	r1, sp, #4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006e84:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006e88:	f001 ff22 	bl	8008cd0 <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006e8c:	4b0f      	ldr	r3, [pc, #60]	; (8006ecc <MIOS32_SPI_TransferModeInit+0xf8>)
 8006e8e:	8818      	ldrh	r0, [r3, #0]
 8006e90:	4044      	eors	r4, r0
 8006e92:	f014 0003 	ands.w	r0, r4, #3
 8006e96:	d017      	beq.n	8006ec8 <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006e98:	2001      	movs	r0, #1
 8006e9a:	21ff      	movs	r1, #255	; 0xff
 8006e9c:	f7ff fd44 	bl	8006928 <MIOS32_SPI_TransferByte>
 8006ea0:	e00e      	b.n	8006ec0 <MIOS32_SPI_TransferModeInit+0xec>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // no clock prescaler for SW emulated SPI
      // remember mode settings
      sw_spi2_mode = spi_mode;
 8006ea2:	4b0c      	ldr	r3, [pc, #48]	; (8006ed4 <MIOS32_SPI_TransferModeInit+0x100>)
 8006ea4:	7019      	strb	r1, [r3, #0]

      // set clock idle level
      switch( sw_spi2_mode ) {
 8006ea6:	2903      	cmp	r1, #3
 8006ea8:	d80c      	bhi.n	8006ec4 <MIOS32_SPI_TransferModeInit+0xf0>
 8006eaa:	e8df f001 	tbb	[pc, r1]
 8006eae:	0202      	.short	0x0202
 8006eb0:	0606      	.short	0x0606
        case MIOS32_SPI_MODE_CLK0_PHASE0:
        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_0;
 8006eb2:	4b09      	ldr	r3, [pc, #36]	; (8006ed8 <MIOS32_SPI_TransferModeInit+0x104>)
 8006eb4:	2240      	movs	r2, #64	; 0x40
 8006eb6:	615a      	str	r2, [r3, #20]
 8006eb8:	e002      	b.n	8006ec0 <MIOS32_SPI_TransferModeInit+0xec>
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006eba:	4b07      	ldr	r3, [pc, #28]	; (8006ed8 <MIOS32_SPI_TransferModeInit+0x104>)
 8006ebc:	2240      	movs	r2, #64	; 0x40
 8006ebe:	611a      	str	r2, [r3, #16]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006ec0:	2000      	movs	r0, #0
	  MIOS32_SPI2_SET_SCLK_0;
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  break;
 8006ec2:	e001      	b.n	8006ec8 <MIOS32_SPI_TransferModeInit+0xf4>
        default:
	  return -4; // invalid SPI clock/phase mode
 8006ec4:	f06f 0003 	mvn.w	r0, #3
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 8006ec8:	b007      	add	sp, #28
 8006eca:	bd30      	pop	{r4, r5, pc}
 8006ecc:	40013000 	.word	0x40013000
 8006ed0:	40003800 	.word	0x40003800
 8006ed4:	20000818 	.word	0x20000818
 8006ed8:	40010c00 	.word	0x40010c00

08006edc <MIOS32_SPI_Init>:
//! Initializes SPI pins
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
 8006edc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006ede:	4604      	mov	r4, r0
 8006ee0:	b08f      	sub	sp, #60	; 0x3c
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8006ee2:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8006ee6:	2c00      	cmp	r4, #0
 8006ee8:	f040 80bb 	bne.w	8007062 <MIOS32_SPI_Init+0x186>
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006eec:	ad03      	add	r5, sp, #12
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006eee:	4f5e      	ldr	r7, [pc, #376]	; (8007068 <MIOS32_SPI_Init+0x18c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006ef0:	4628      	mov	r0, r5
 8006ef2:	f002 f898 	bl	8009026 <DMA_StructInit>

  // disable callback function
  spi_callback[0] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006ef6:	2201      	movs	r2, #1
 8006ef8:	4621      	mov	r1, r4
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006efa:	603c      	str	r4, [r7, #0]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006efc:	4620      	mov	r0, r4
 8006efe:	f7ff fccb 	bl	8006898 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(0, 1, 1); // spi, rc_pin, pin_value
 8006f02:	2101      	movs	r1, #1
 8006f04:	460a      	mov	r2, r1
 8006f06:	4620      	mov	r0, r4
 8006f08:	f7ff fcc6 	bl	8006898 <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(0, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006f0c:	2103      	movs	r1, #3
 8006f0e:	4620      	mov	r0, r4
 8006f10:	f7ff fc12 	bl	8006738 <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB2 == high speed)
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 8006f14:	2101      	movs	r1, #1
 8006f16:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8006f1a:	f002 fa3b 	bl	8009394 <RCC_APB2PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8006f1e:	2001      	movs	r0, #1
 8006f20:	4601      	mov	r1, r0
 8006f22:	f002 fa29 	bl	8009378 <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
 8006f26:	4851      	ldr	r0, [pc, #324]	; (800706c <MIOS32_SPI_Init+0x190>)
 8006f28:	4621      	mov	r1, r4
 8006f2a:	f002 f889 	bl	8009040 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006f2e:	4b50      	ldr	r3, [pc, #320]	; (8007070 <MIOS32_SPI_Init+0x194>)
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f30:	2680      	movs	r6, #128	; 0x80
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006f32:	9303      	str	r3, [sp, #12]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f34:	484d      	ldr	r0, [pc, #308]	; (800706c <MIOS32_SPI_Init+0x190>)
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f36:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f3a:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f3c:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f3e:	9301      	str	r3, [sp, #4]
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006f40:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8006f42:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006f44:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006f46:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f48:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006f4a:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006f4c:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8006f4e:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8006f50:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f52:	f002 f83d 	bl	8008fd0 <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
 8006f56:	4847      	ldr	r0, [pc, #284]	; (8007074 <MIOS32_SPI_Init+0x198>)
 8006f58:	4621      	mov	r1, r4
 8006f5a:	f002 f871 	bl	8009040 <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006f5e:	f04f 0c10 	mov.w	ip, #16
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006f62:	4844      	ldr	r0, [pc, #272]	; (8007074 <MIOS32_SPI_Init+0x198>)
 8006f64:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006f66:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006f6a:	f8cd c000 	str.w	ip, [sp]
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006f6e:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006f70:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f72:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006f74:	f002 f82c 	bl	8008fd0 <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(0, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8006f78:	2206      	movs	r2, #6
 8006f7a:	2103      	movs	r1, #3
 8006f7c:	4620      	mov	r0, r4
 8006f7e:	f7ff ff29 	bl	8006dd4 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI0_PTR, ENABLE);
 8006f82:	2101      	movs	r1, #1
 8006f84:	483c      	ldr	r0, [pc, #240]	; (8007078 <MIOS32_SPI_Init+0x19c>)
 8006f86:	f001 fed0 	bl	8008d2a <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI0_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8006f8a:	2201      	movs	r2, #1
 8006f8c:	2103      	movs	r1, #3
 8006f8e:	483a      	ldr	r0, [pc, #232]	; (8007078 <MIOS32_SPI_Init+0x19c>)
 8006f90:	f001 fed8 	bl	8008d44 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI0_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8006f94:	2105      	movs	r1, #5
 8006f96:	200c      	movs	r0, #12
 8006f98:	f7ff fbaa 	bl	80066f0 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[1] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006f9c:	2001      	movs	r0, #1
 8006f9e:	4621      	mov	r1, r4
 8006fa0:	4602      	mov	r2, r0
  // SPI1
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI1

  // disable callback function
  spi_callback[1] = NULL;
 8006fa2:	607c      	str	r4, [r7, #4]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006fa4:	f7ff fc78 	bl	8006898 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(1, 1, 1); // spi, rc_pin, pin_value
 8006fa8:	2001      	movs	r0, #1
 8006faa:	4602      	mov	r2, r0
 8006fac:	4601      	mov	r1, r0
 8006fae:	f7ff fc73 	bl	8006898 <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(1, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006fb2:	2103      	movs	r1, #3
 8006fb4:	2001      	movs	r0, #1
 8006fb6:	f7ff fbbf 	bl	8006738 <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB1 == slow speed)
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8006fba:	2101      	movs	r1, #1
 8006fbc:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8006fc0:	f002 f9f6 	bl	80093b0 <RCC_APB1PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8006fc4:	2001      	movs	r0, #1
 8006fc6:	4601      	mov	r1, r0
 8006fc8:	f002 f9d6 	bl	8009378 <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
 8006fcc:	482b      	ldr	r0, [pc, #172]	; (800707c <MIOS32_SPI_Init+0x1a0>)
 8006fce:	4621      	mov	r1, r4
 8006fd0:	f002 f836 	bl	8009040 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006fd4:	9b01      	ldr	r3, [sp, #4]
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8006fd6:	4a2a      	ldr	r2, [pc, #168]	; (8007080 <MIOS32_SPI_Init+0x1a4>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8006fd8:	4828      	ldr	r0, [pc, #160]	; (800707c <MIOS32_SPI_Init+0x1a0>)
 8006fda:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006fdc:	930c      	str	r3, [sp, #48]	; 0x30
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8006fde:	9203      	str	r2, [sp, #12]
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006fe0:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8006fe2:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006fe4:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006fe6:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006fe8:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006fea:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006fec:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8006fee:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8006ff0:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8006ff2:	f001 ffed 	bl	8008fd0 <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
 8006ff6:	4823      	ldr	r0, [pc, #140]	; (8007084 <MIOS32_SPI_Init+0x1a8>)
 8006ff8:	4621      	mov	r1, r4
 8006ffa:	f002 f821 	bl	8009040 <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006ffe:	f8dd c000 	ldr.w	ip, [sp]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8007002:	4820      	ldr	r0, [pc, #128]	; (8007084 <MIOS32_SPI_Init+0x1a8>)
 8007004:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8007006:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 800700a:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 800700c:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800700e:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8007010:	f001 ffde 	bl	8008fd0 <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(1, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8007014:	2206      	movs	r2, #6
 8007016:	2103      	movs	r1, #3
 8007018:	2001      	movs	r0, #1
 800701a:	f7ff fedb 	bl	8006dd4 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI1_PTR, ENABLE);
 800701e:	2101      	movs	r1, #1
 8007020:	4819      	ldr	r0, [pc, #100]	; (8007088 <MIOS32_SPI_Init+0x1ac>)
 8007022:	f001 fe82 	bl	8008d2a <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI1_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8007026:	2201      	movs	r2, #1
 8007028:	2103      	movs	r1, #3
 800702a:	4817      	ldr	r0, [pc, #92]	; (8007088 <MIOS32_SPI_Init+0x1ac>)
 800702c:	f001 fe8a 	bl	8008d44 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI1_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8007030:	2105      	movs	r1, #5
 8007032:	200e      	movs	r0, #14
 8007034:	f7ff fb5c 	bl	80066f0 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[2] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 8007038:	2201      	movs	r2, #1
 800703a:	2002      	movs	r0, #2
 800703c:	4621      	mov	r1, r4
  // SPI2 (software emulated)
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI2

  // disable callback function
  spi_callback[2] = NULL;
 800703e:	60bc      	str	r4, [r7, #8]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 8007040:	f7ff fc2a 	bl	8006898 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(2, 1, 1); // spi, rc_pin, pin_value
 8007044:	2101      	movs	r1, #1
 8007046:	460a      	mov	r2, r1
 8007048:	2002      	movs	r0, #2
 800704a:	f7ff fc25 	bl	8006898 <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(2, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 800704e:	2103      	movs	r1, #3
 8007050:	2002      	movs	r0, #2
 8007052:	f7ff fb71 	bl	8006738 <MIOS32_SPI_IO_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(2, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8007056:	2002      	movs	r0, #2
 8007058:	2103      	movs	r1, #3
 800705a:	2206      	movs	r2, #6
 800705c:	f7ff feba 	bl	8006dd4 <MIOS32_SPI_TransferModeInit>

#endif /* MIOS32_DONT_USE_SPI2 */

  return 0; // no error
 8007060:	4620      	mov	r0, r4
}
 8007062:	b00f      	add	sp, #60	; 0x3c
 8007064:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007066:	bf00      	nop
 8007068:	2000080c 	.word	0x2000080c
 800706c:	4002001c 	.word	0x4002001c
 8007070:	4001300c 	.word	0x4001300c
 8007074:	40020030 	.word	0x40020030
 8007078:	40013000 	.word	0x40013000
 800707c:	40020044 	.word	0x40020044
 8007080:	4000380c 	.word	0x4000380c
 8007084:	40020058 	.word	0x40020058
 8007088:	40003800 	.word	0x40003800

0800708c <DMA1_Channel2_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Called when callback function has been defined and SPI transfer has finished
/////////////////////////////////////////////////////////////////////////////
MIOS32_SPI0_DMA_IRQHANDLER_FUNC
{
 800708c:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI0_DMA_RX_IRQ_FLAGS);
 800708e:	20f0      	movs	r0, #240	; 0xf0
 8007090:	f001 ffea 	bl	8009068 <DMA_ClearFlag>

  if( spi_callback[0] != NULL )
 8007094:	4b02      	ldr	r3, [pc, #8]	; (80070a0 <DMA1_Channel2_IRQHandler+0x14>)
 8007096:	681b      	ldr	r3, [r3, #0]
 8007098:	b103      	cbz	r3, 800709c <DMA1_Channel2_IRQHandler+0x10>
    spi_callback[0]();
 800709a:	4798      	blx	r3
}
 800709c:	bd08      	pop	{r3, pc}
 800709e:	bf00      	nop
 80070a0:	2000080c 	.word	0x2000080c

080070a4 <DMA1_Channel4_IRQHandler>:

MIOS32_SPI1_DMA_IRQHANDLER_FUNC
{
 80070a4:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI1_DMA_RX_IRQ_FLAGS);
 80070a6:	f44f 4070 	mov.w	r0, #61440	; 0xf000
 80070aa:	f001 ffdd 	bl	8009068 <DMA_ClearFlag>

  if( spi_callback[1] != NULL )
 80070ae:	4b02      	ldr	r3, [pc, #8]	; (80070b8 <DMA1_Channel4_IRQHandler+0x14>)
 80070b0:	685b      	ldr	r3, [r3, #4]
 80070b2:	b103      	cbz	r3, 80070b6 <DMA1_Channel4_IRQHandler+0x12>
    spi_callback[1]();
 80070b4:	4798      	blx	r3
}
 80070b6:	bd08      	pop	{r3, pc}
 80070b8:	2000080c 	.word	0x2000080c

080070bc <MIOS32_BOARD_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 80070bc:	b910      	cbnz	r0, 80070c4 <MIOS32_BOARD_Init+0x8>
    return -1; // unsupported mode

  j5_enable_mask = 0;
 80070be:	4b03      	ldr	r3, [pc, #12]	; (80070cc <MIOS32_BOARD_Init+0x10>)
 80070c0:	8018      	strh	r0, [r3, #0]

  return 0; // no error
 80070c2:	e001      	b.n	80070c8 <MIOS32_BOARD_Init+0xc>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80070c4:	f04f 30ff 	mov.w	r0, #4294967295

  j5_enable_mask = 0;

  return 0; // no error
}
 80070c8:	4770      	bx	lr
 80070ca:	bf00      	nop
 80070cc:	2000081a 	.word	0x2000081a

080070d0 <MIOS32_BOARD_LED_Init>:
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 80070d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80070d2:	ad01      	add	r5, sp, #4
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 80070d4:	4604      	mov	r4, r0
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80070d6:	4628      	mov	r0, r5
 80070d8:	f001 fce6 	bl	8008aa8 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80070dc:	2310      	movs	r3, #16
 80070de:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80070e2:	2303      	movs	r3, #3

  // only one LED, connected to PD2
  if( leds & 1 ) {
 80070e4:	f014 0f01 	tst.w	r4, #1
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80070e8:	f88d 3006 	strb.w	r3, [sp, #6]

  // only one LED, connected to PD2
  if( leds & 1 ) {
 80070ec:	d006      	beq.n	80070fc <MIOS32_BOARD_LED_Init+0x2c>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 80070ee:	2304      	movs	r3, #4
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 80070f0:	4806      	ldr	r0, [pc, #24]	; (800710c <MIOS32_BOARD_LED_Init+0x3c>)
 80070f2:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  // only one LED, connected to PD2
  if( leds & 1 ) {
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 80070f4:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 80070f8:	f001 fc7d 	bl	80089f6 <GPIO_Init>
  }

  if( leds & 0xfffffffe)
 80070fc:	f034 0401 	bics.w	r4, r4, #1
    return -2; // LED doesn't exist
 8007100:	bf0c      	ite	eq
 8007102:	4620      	moveq	r0, r4
 8007104:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 8007108:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 800710a:	bf00      	nop
 800710c:	40011400 	.word	0x40011400

08007110 <MIOS32_BOARD_LED_Set>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Set(u32 leds, u32 value)
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( leds & 1 ) {
 8007110:	f010 0f01 	tst.w	r0, #1
 8007114:	d007      	beq.n	8007126 <MIOS32_BOARD_LED_Set+0x16>
    GPIOD->BSRR = (value&1) ? GPIO_Pin_2 : (GPIO_Pin_2 << 16);
 8007116:	f011 0f01 	tst.w	r1, #1
 800711a:	4b06      	ldr	r3, [pc, #24]	; (8007134 <MIOS32_BOARD_LED_Set+0x24>)
 800711c:	bf0c      	ite	eq
 800711e:	f44f 2280 	moveq.w	r2, #262144	; 0x40000
 8007122:	2204      	movne	r2, #4
 8007124:	611a      	str	r2, [r3, #16]
  }

  if( leds & 0xfffffffe)
 8007126:	f030 0001 	bics.w	r0, r0, #1
    return -2; // LED doesn't exist
 800712a:	bf18      	it	ne
 800712c:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 8007130:	4770      	bx	lr
 8007132:	bf00      	nop
 8007134:	40011400 	.word	0x40011400

08007138 <MIOS32_BOARD_LED_Get>:
{
  u32 values = 0;

#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( GPIOD->ODR & GPIO_Pin_2 )
 8007138:	4b02      	ldr	r3, [pc, #8]	; (8007144 <MIOS32_BOARD_LED_Get+0xc>)
 800713a:	68d8      	ldr	r0, [r3, #12]
//! Returns the status of all LEDs
//! \return status of all LEDs
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_BOARD_LED_Get(void)
{
  u32 values = 0;
 800713c:	f3c0 0080 	ubfx	r0, r0, #2, #1
  if( GPIOB->ODR & GPIO_Pin_9 )
    values |= (1 << 1);
#endif

  return values;
}
 8007140:	4770      	bx	lr
 8007142:	bf00      	nop
 8007144:	40011400 	.word	0x40011400

08007148 <MIOS32_BOARD_J5_PinInit>:
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 8007148:	280b      	cmp	r0, #11
//!     <LI>MIOS32_BOARD_PIN_MODE_OUTPUT_OD: pin is used as output in open drain mode
//!   </UL>
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
 800714a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800714c:	4604      	mov	r4, r0
 800714e:	460d      	mov	r5, r1
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported
 8007150:	bf88      	it	hi
 8007152:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 8007156:	d83a      	bhi.n	80071ce <MIOS32_BOARD_J5_PinInit+0x86>
 8007158:	4b1d      	ldr	r3, [pc, #116]	; (80071d0 <MIOS32_BOARD_J5_PinInit+0x88>)
    return -1; // pin not supported

  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
 800715a:	b941      	cbnz	r1, 800716e <MIOS32_BOARD_J5_PinInit+0x26>
    // don't touch
    j5_enable_mask &= ~(1 << pin);
 800715c:	2201      	movs	r2, #1
 800715e:	fa12 f404 	lsls.w	r4, r2, r4
 8007162:	881a      	ldrh	r2, [r3, #0]

    // init IO mode
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
  }

  return 0; // no error
 8007164:	4608      	mov	r0, r1
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
    // don't touch
    j5_enable_mask &= ~(1 << pin);
 8007166:	ea22 0404 	bic.w	r4, r2, r4
 800716a:	801c      	strh	r4, [r3, #0]
 800716c:	e02f      	b.n	80071ce <MIOS32_BOARD_J5_PinInit+0x86>
  } else {
    // enable pin
    j5_enable_mask |= (1 << pin);
 800716e:	2201      	movs	r2, #1
 8007170:	40a2      	lsls	r2, r4
 8007172:	8819      	ldrh	r1, [r3, #0]

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
 8007174:	a801      	add	r0, sp, #4
  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
    // don't touch
    j5_enable_mask &= ~(1 << pin);
  } else {
    // enable pin
    j5_enable_mask |= (1 << pin);
 8007176:	430a      	orrs	r2, r1
 8007178:	801a      	strh	r2, [r3, #0]

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
 800717a:	f001 fc95 	bl	8008aa8 <GPIO_StructInit>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800717e:	2303      	movs	r3, #3
 8007180:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_InitStructure.GPIO_Pin = j5_pin[pin].pin_mask;
 8007184:	4b13      	ldr	r3, [pc, #76]	; (80071d4 <MIOS32_BOARD_J5_PinInit+0x8c>)

    switch( mode ) {
 8007186:	3d01      	subs	r5, #1
    j5_enable_mask |= (1 << pin);

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Pin = j5_pin[pin].pin_mask;
 8007188:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800718c:	889b      	ldrh	r3, [r3, #4]
 800718e:	f8ad 3004 	strh.w	r3, [sp, #4]

    switch( mode ) {
 8007192:	2d05      	cmp	r5, #5
 8007194:	d819      	bhi.n	80071ca <MIOS32_BOARD_J5_PinInit+0x82>
 8007196:	e8df f005 	tbb	[pc, r5]
 800719a:	0503      	.short	0x0503
 800719c:	0d0b0907 	.word	0x0d0b0907
      case MIOS32_BOARD_PIN_MODE_ANALOG:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 80071a0:	2300      	movs	r3, #0
 80071a2:	e008      	b.n	80071b6 <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 80071a4:	2304      	movs	r3, #4
 80071a6:	e006      	b.n	80071b6 <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT_PD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 80071a8:	2328      	movs	r3, #40	; 0x28
 80071aa:	e004      	b.n	80071b6 <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT_PU:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80071ac:	2348      	movs	r3, #72	; 0x48
 80071ae:	e002      	b.n	80071b6 <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_PP:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80071b0:	2310      	movs	r3, #16
 80071b2:	e000      	b.n	80071b6 <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_OD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 80071b4:	2314      	movs	r3, #20
 80071b6:	f88d 3007 	strb.w	r3, [sp, #7]
    // TK: disabled since there are application which have to switch between Input/Output
    // without destroying the current pin value
#endif

    // init IO mode
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
 80071ba:	4b06      	ldr	r3, [pc, #24]	; (80071d4 <MIOS32_BOARD_J5_PinInit+0x8c>)
 80071bc:	a901      	add	r1, sp, #4
 80071be:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 80071c2:	f001 fc18 	bl	80089f6 <GPIO_Init>
  }

  return 0; // no error
 80071c6:	2000      	movs	r0, #0
 80071c8:	e001      	b.n	80071ce <MIOS32_BOARD_J5_PinInit+0x86>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_OD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	break;
      default:
	return -2; // invalid pin mode
 80071ca:	f06f 0001 	mvn.w	r0, #1
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
  }

  return 0; // no error
#endif
}
 80071ce:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 80071d0:	2000081a 	.word	0x2000081a
 80071d4:	0800b04c 	.word	0x0800b04c

080071d8 <MIOS32_BOARD_J5_PinSet>:
s32 MIOS32_BOARD_J5_PinSet(u8 pin, u8 value)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 80071d8:	280b      	cmp	r0, #11
    return -1; // pin not supported
 80071da:	bf88      	it	hi
 80071dc:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinSet(u8 pin, u8 value)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 80071e0:	d818      	bhi.n	8007214 <MIOS32_BOARD_J5_PinSet+0x3c>
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 80071e2:	4b0d      	ldr	r3, [pc, #52]	; (8007218 <MIOS32_BOARD_J5_PinSet+0x40>)
 80071e4:	881b      	ldrh	r3, [r3, #0]
 80071e6:	4103      	asrs	r3, r0
 80071e8:	f013 0f01 	tst.w	r3, #1
    return -2; // pin disabled
 80071ec:	bf08      	it	eq
 80071ee:	f06f 0001 	mvneq.w	r0, #1
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 80071f2:	d00f      	beq.n	8007214 <MIOS32_BOARD_J5_PinSet+0x3c>
 80071f4:	4b09      	ldr	r3, [pc, #36]	; (800721c <MIOS32_BOARD_J5_PinSet+0x44>)
 80071f6:	00c2      	lsls	r2, r0, #3
    return -2; // pin disabled

  if( value )
 80071f8:	b131      	cbz	r1, 8007208 <MIOS32_BOARD_J5_PinSet+0x30>
    j5_pin[pin].port->BSRR = j5_pin[pin].pin_mask;
 80071fa:	f853 1030 	ldr.w	r1, [r3, r0, lsl #3]
 80071fe:	189b      	adds	r3, r3, r2
 8007200:	889b      	ldrh	r3, [r3, #4]
  else
    j5_pin[pin].port->BRR = j5_pin[pin].pin_mask;

  return 0; // no error
 8007202:	2000      	movs	r0, #0

  if( !(j5_enable_mask & (1 << pin)) )
    return -2; // pin disabled

  if( value )
    j5_pin[pin].port->BSRR = j5_pin[pin].pin_mask;
 8007204:	610b      	str	r3, [r1, #16]
 8007206:	e005      	b.n	8007214 <MIOS32_BOARD_J5_PinSet+0x3c>
  else
    j5_pin[pin].port->BRR = j5_pin[pin].pin_mask;
 8007208:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
 800720c:	189b      	adds	r3, r3, r2
 800720e:	889b      	ldrh	r3, [r3, #4]
 8007210:	6143      	str	r3, [r0, #20]

  return 0; // no error
 8007212:	4608      	mov	r0, r1
#endif
}
 8007214:	4770      	bx	lr
 8007216:	bf00      	nop
 8007218:	2000081a 	.word	0x2000081a
 800721c:	0800b04c 	.word	0x0800b04c

08007220 <MIOS32_BOARD_J5_PinGet>:
s32 MIOS32_BOARD_J5_PinGet(u8 pin)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 8007220:	280b      	cmp	r0, #11
    return -1; // pin not supported
 8007222:	bf88      	it	hi
 8007224:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinGet(u8 pin)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 8007228:	d813      	bhi.n	8007252 <MIOS32_BOARD_J5_PinGet+0x32>
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 800722a:	4b0a      	ldr	r3, [pc, #40]	; (8007254 <MIOS32_BOARD_J5_PinGet+0x34>)
 800722c:	881b      	ldrh	r3, [r3, #0]
 800722e:	4103      	asrs	r3, r0
 8007230:	f013 0f01 	tst.w	r3, #1
    return -2; // pin disabled
 8007234:	bf08      	it	eq
 8007236:	f06f 0001 	mvneq.w	r0, #1
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 800723a:	d00a      	beq.n	8007252 <MIOS32_BOARD_J5_PinGet+0x32>
    return -2; // pin disabled

  return (j5_pin[pin].port->IDR & j5_pin[pin].pin_mask) ? 1 : 0;
 800723c:	4b06      	ldr	r3, [pc, #24]	; (8007258 <MIOS32_BOARD_J5_PinGet+0x38>)
 800723e:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
 8007242:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8007246:	8883      	ldrh	r3, [r0, #4]
 8007248:	6892      	ldr	r2, [r2, #8]
 800724a:	4213      	tst	r3, r2
 800724c:	bf0c      	ite	eq
 800724e:	2000      	moveq	r0, #0
 8007250:	2001      	movne	r0, #1
#endif
}
 8007252:	4770      	bx	lr
 8007254:	2000081a 	.word	0x2000081a
 8007258:	0800b04c 	.word	0x0800b04c

0800725c <MIOS32_BOARD_J15_PortInit>:
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 800725c:	2801      	cmp	r0, #1
//!   <LI>1: J15 pins are configured in Open Drain mode (perfect for 3.3V->5V levelshifting)
//! </UL>
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PortInit(u32 mode)
{
 800725e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007260:	4606      	mov	r6, r0
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
    return -1; // unsupported mode
 8007262:	bf88      	it	hi
 8007264:	f04f 30ff 	movhi.w	r0, #4294967295
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 8007268:	d854      	bhi.n	8007314 <MIOS32_BOARD_J15_PortInit+0xb8>
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800726a:	ad01      	add	r5, sp, #4
 800726c:	4628      	mov	r0, r5
 800726e:	f001 fc1b 	bl	8008aa8 <GPIO_StructInit>

  J15_PIN_SCLK_0;
  J15_PIN_RCLK_0;
 8007272:	4c29      	ldr	r4, [pc, #164]	; (8007318 <MIOS32_BOARD_J15_PortInit+0xbc>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 8007274:	4829      	ldr	r0, [pc, #164]	; (800731c <MIOS32_BOARD_J15_PortInit+0xc0>)
  J15_PIN_RCLK_0;
  J15_PIN_RW(0);
 8007276:	4a2a      	ldr	r2, [pc, #168]	; (8007320 <MIOS32_BOARD_J15_PortInit+0xc4>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 8007278:	f44f 7380 	mov.w	r3, #256	; 0x100
  J15_PIN_RCLK_0;
 800727c:	f44f 7700 	mov.w	r7, #512	; 0x200
  J15_PIN_RW(0);
 8007280:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 8007284:	6143      	str	r3, [r0, #20]
  J15_PIN_RCLK_0;
 8007286:	6167      	str	r7, [r4, #20]
  J15_PIN_RW(0);
 8007288:	6111      	str	r1, [r2, #16]
  J15_PIN_E1(0);
 800728a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 800728e:	6122      	str	r2, [r4, #16]
  J15_PIN_E2(0);
 8007290:	f5a2 0280 	sub.w	r2, r2, #4194304	; 0x400000
 8007294:	6122      	str	r2, [r4, #16]
#ifdef MIOS32_BOARD_LCD_E4_PORT
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007296:	2210      	movs	r2, #16
 8007298:	f88d 2007 	strb.w	r2, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 800729c:	4629      	mov	r1, r5
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients
 800729e:	2202      	movs	r2, #2
 80072a0:	f88d 2006 	strb.w	r2, [sp, #6]

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
 80072a4:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80072a8:	f001 fba5 	bl	80089f6 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 80072ac:	4620      	mov	r0, r4
 80072ae:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
 80072b0:	f8ad 7004 	strh.w	r7, [sp, #4]
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 80072b4:	f001 fb9f 	bl	80089f6 <GPIO_Init>

  // configure open-drain pins (if OD option enabled)
  if( mode )
 80072b8:	b116      	cbz	r6, 80072c0 <MIOS32_BOARD_J15_PortInit+0x64>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 80072ba:	2314      	movs	r3, #20
 80072bc:	f88d 3007 	strb.w	r3, [sp, #7]

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
 80072c0:	ac02      	add	r4, sp, #8
 80072c2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80072c6:	f824 3d04 	strh.w	r3, [r4, #-4]!
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);
 80072ca:	4813      	ldr	r0, [pc, #76]	; (8007318 <MIOS32_BOARD_J15_PortInit+0xbc>)
 80072cc:	4621      	mov	r1, r4
 80072ce:	f001 fb92 	bl	80089f6 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 80072d2:	2380      	movs	r3, #128	; 0x80
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 80072d4:	4810      	ldr	r0, [pc, #64]	; (8007318 <MIOS32_BOARD_J15_PortInit+0xbc>)
 80072d6:	4621      	mov	r1, r4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 80072d8:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 80072dc:	f001 fb8b 	bl	80089f6 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 80072e0:	2340      	movs	r3, #64	; 0x40
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 80072e2:	480d      	ldr	r0, [pc, #52]	; (8007318 <MIOS32_BOARD_J15_PortInit+0xbc>)
 80072e4:	4621      	mov	r1, r4
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 80072e6:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 80072ea:	f001 fb84 	bl	80089f6 <GPIO_Init>
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 80072ee:	2304      	movs	r3, #4
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 80072f0:	480b      	ldr	r0, [pc, #44]	; (8007320 <MIOS32_BOARD_J15_PortInit+0xc4>)
 80072f2:	4621      	mov	r1, r4
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 80072f4:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 80072f8:	f001 fb7d 	bl	80089f6 <GPIO_Init>

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80072fc:	2348      	movs	r3, #72	; 0x48
 80072fe:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 8007302:	4805      	ldr	r0, [pc, #20]	; (8007318 <MIOS32_BOARD_J15_PortInit+0xbc>)
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 8007304:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 8007308:	4621      	mov	r1, r4
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 800730a:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 800730e:	f001 fb72 	bl	80089f6 <GPIO_Init>

  return 0; // no error
 8007312:	2000      	movs	r0, #0
#endif
}
 8007314:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007316:	bf00      	nop
 8007318:	40011000 	.word	0x40011000
 800731c:	40010800 	.word	0x40010800
 8007320:	40010c00 	.word	0x40010c00

08007324 <MIOS32_BOARD_J15_DataSet>:
#else
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
 8007324:	492d      	ldr	r1, [pc, #180]	; (80073dc <MIOS32_BOARD_J15_DataSet+0xb8>)
 8007326:	f010 0f80 	tst.w	r0, #128	; 0x80
 800732a:	bf0c      	ite	eq
 800732c:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 8007330:	f44f 7380 	movne.w	r3, #256	; 0x100
 8007334:	610b      	str	r3, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 8007336:	f44f 7280 	mov.w	r2, #256	; 0x100
 800733a:	4b29      	ldr	r3, [pc, #164]	; (80073e0 <MIOS32_BOARD_J15_DataSet+0xbc>)
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
 800733c:	f010 0f40 	tst.w	r0, #64	; 0x40
 8007340:	bf0c      	ite	eq
 8007342:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007346:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 8007348:	f010 0f20 	tst.w	r0, #32
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
 800734c:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800734e:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x40); // D6
 8007350:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 8007354:	bf0c      	ite	eq
 8007356:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 800735a:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 800735c:	f010 0f10 	tst.w	r0, #16

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
 8007360:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007362:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x20); // D5
 8007364:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 8007368:	bf0c      	ite	eq
 800736a:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 800736e:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 8007370:	f010 0f08 	tst.w	r0, #8
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
 8007374:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007376:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x10); // D4
 8007378:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 800737c:	bf0c      	ite	eq
 800737e:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007382:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 8007384:	f010 0f04 	tst.w	r0, #4
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
 8007388:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800738a:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x08); // D3
 800738c:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 8007390:	bf0c      	ite	eq
 8007392:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007396:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 8007398:	f010 0f02 	tst.w	r0, #2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
 800739c:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800739e:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x04); // D2
 80073a0:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 80073a4:	bf0c      	ite	eq
 80073a6:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80073aa:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x01); // D0
 80073ac:	f010 0f01 	tst.w	r0, #1
 80073b0:	bf0c      	ite	eq
 80073b2:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 80073b6:	4610      	movne	r0, r2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
  J15_PIN_SCLK_0; // setup delay
 80073b8:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073ba:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x02); // D1
 80073bc:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 80073c0:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073c2:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x01); // D0
 80073c4:	6108      	str	r0, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 80073c6:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073c8:	611a      	str	r2, [r3, #16]

  // transfer to output register
  J15_PIN_RCLK_1;
 80073ca:	f44f 7300 	mov.w	r3, #512	; 0x200
 80073ce:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_0;

  return 0; // no error
#endif
}
 80073d0:	2000      	movs	r0, #0
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;

  // transfer to output register
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_1;
 80073d2:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
 80073d4:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_0;
 80073d6:	614b      	str	r3, [r1, #20]

  return 0; // no error
#endif
}
 80073d8:	4770      	bx	lr
 80073da:	bf00      	nop
 80073dc:	40011000 	.word	0x40011000
 80073e0:	40010800 	.word	0x40010800

080073e4 <MIOS32_BOARD_J15_RS_Set>:
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 80073e4:	4b04      	ldr	r3, [pc, #16]	; (80073f8 <MIOS32_BOARD_J15_RS_Set+0x14>)
 80073e6:	2800      	cmp	r0, #0
 80073e8:	bf0c      	ite	eq
 80073ea:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 80073ee:	f44f 7080 	movne.w	r0, #256	; 0x100
 80073f2:	6118      	str	r0, [r3, #16]
  J15_PIN_SCLK_0;
#endif

  return 0; // no error
#endif
}
 80073f4:	2000      	movs	r0, #0
 80073f6:	4770      	bx	lr
 80073f8:	40011000 	.word	0x40011000

080073fc <MIOS32_BOARD_J15_RW_Set>:
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80073fc:	4b04      	ldr	r3, [pc, #16]	; (8007410 <MIOS32_BOARD_J15_RW_Set+0x14>)
 80073fe:	2800      	cmp	r0, #0
 8007400:	bf0c      	ite	eq
 8007402:	f44f 2080 	moveq.w	r0, #262144	; 0x40000
 8007406:	2004      	movne	r0, #4
 8007408:	6118      	str	r0, [r3, #16]

  return 0; // no error
#endif
}
 800740a:	2000      	movs	r0, #0
 800740c:	4770      	bx	lr
 800740e:	bf00      	nop
 8007410:	40010c00 	.word	0x40010c00

08007414 <MIOS32_BOARD_J15_E_Set>:
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 8007414:	b128      	cbz	r0, 8007422 <MIOS32_BOARD_J15_E_Set+0xe>
 8007416:	2801      	cmp	r0, #1
      return 0; // no error
#endif

  }

  return -1; // pin not available
 8007418:	bf18      	it	ne
 800741a:	f04f 30ff 	movne.w	r0, #4294967295
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 800741e:	d110      	bne.n	8007442 <MIOS32_BOARD_J15_E_Set+0x2e>
 8007420:	e007      	b.n	8007432 <MIOS32_BOARD_J15_E_Set+0x1e>
    case 0: 
      J15_PIN_E1(e);
 8007422:	4b08      	ldr	r3, [pc, #32]	; (8007444 <MIOS32_BOARD_J15_E_Set+0x30>)
 8007424:	2900      	cmp	r1, #0
 8007426:	bf0c      	ite	eq
 8007428:	f44f 0100 	moveq.w	r1, #8388608	; 0x800000
 800742c:	2180      	movne	r1, #128	; 0x80
 800742e:	6119      	str	r1, [r3, #16]
      return 0; // no error
 8007430:	e007      	b.n	8007442 <MIOS32_BOARD_J15_E_Set+0x2e>

    case 1: 
      J15_PIN_E2(e);
 8007432:	4b04      	ldr	r3, [pc, #16]	; (8007444 <MIOS32_BOARD_J15_E_Set+0x30>)
 8007434:	2900      	cmp	r1, #0
 8007436:	bf0c      	ite	eq
 8007438:	f44f 0180 	moveq.w	r1, #4194304	; 0x400000
 800743c:	2140      	movne	r1, #64	; 0x40
 800743e:	6119      	str	r1, [r3, #16]
      return 0; // no error
 8007440:	2000      	movs	r0, #0

  }

  return -1; // pin not available
#endif
}
 8007442:	4770      	bx	lr
 8007444:	40011000 	.word	0x40011000

08007448 <MIOS32_BOARD_J15_PollUnbusy>:
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 8007448:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 800744a:	4b1a      	ldr	r3, [pc, #104]	; (80074b4 <MIOS32_BOARD_J15_PollUnbusy+0x6c>)
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 800744c:	4f1a      	ldr	r7, [pc, #104]	; (80074b8 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 800744e:	2604      	movs	r6, #4
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 8007450:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8007454:	611a      	str	r2, [r3, #16]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 8007456:	460c      	mov	r4, r1
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007458:	613e      	str	r6, [r7, #16]

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 800745a:	2101      	movs	r1, #1
 800745c:	9301      	str	r3, [sp, #4]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 800745e:	4605      	mov	r5, r0

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 8007460:	f7ff ffd8 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
 8007464:	9b01      	ldr	r3, [sp, #4]
 8007466:	2800      	cmp	r0, #0

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 8007468:	bfa8      	it	ge
 800746a:	461e      	movge	r6, r3

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 800746c:	db1f      	blt.n	80074ae <MIOS32_BOARD_J15_PollUnbusy+0x66>
 800746e:	e012      	b.n	8007496 <MIOS32_BOARD_J15_PollUnbusy+0x4e>
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);
 8007470:	2101      	movs	r1, #1
 8007472:	4628      	mov	r0, r5
 8007474:	f7ff ffce 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
 8007478:	210a      	movs	r1, #10
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 800747a:	4a0f      	ldr	r2, [pc, #60]	; (80074b8 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 800747c:	2304      	movs	r3, #4
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 800747e:	f111 31ff 	adds.w	r1, r1, #4294967295
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007482:	6113      	str	r3, [r2, #16]
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 8007484:	d1f9      	bne.n	800747a <MIOS32_BOARD_J15_PollUnbusy+0x32>
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 8007486:	68b7      	ldr	r7, [r6, #8]
    MIOS32_BOARD_J15_E_Set(lcd, 0);
 8007488:	4628      	mov	r0, r5
 800748a:	f7ff ffc3 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
    if( !busy )
 800748e:	f417 5f80 	tst.w	r7, #4096	; 0x1000
 8007492:	d002      	beq.n	800749a <MIOS32_BOARD_J15_PollUnbusy+0x52>
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
 8007494:	3c01      	subs	r4, #1
 8007496:	2c00      	cmp	r4, #0
 8007498:	d1ea      	bne.n	8007470 <MIOS32_BOARD_J15_PollUnbusy+0x28>
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 800749a:	4b07      	ldr	r3, [pc, #28]	; (80074b8 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 800749c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 80074a0:	2c00      	cmp	r4, #0
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80074a2:	611a      	str	r2, [r3, #16]
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 80074a4:	bf14      	ite	ne
 80074a6:	2000      	movne	r0, #0
 80074a8:	f06f 0001 	mvneq.w	r0, #1
 80074ac:	e001      	b.n	80074b2 <MIOS32_BOARD_J15_PollUnbusy+0x6a>
  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available
 80074ae:	f04f 30ff 	mov.w	r0, #4294967295
  if( poll_ctr == 0 )
    return -2; // timeout error

  return 0; // no error
#endif
}
 80074b2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80074b4:	40011000 	.word	0x40011000
 80074b8:	40010c00 	.word	0x40010c00

080074bc <TIM2_IRQHandler>:
//! Interrupt handlers
//! \note don't call them directly from application
/////////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_ALLOCATE_TIM2_IRQn
TIMER0_IRQ_HANDLER
{
 80074bc:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER0_BASE, TIM_IT_Update) != RESET ) {
 80074be:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80074c2:	2101      	movs	r1, #1
 80074c4:	f001 fe59 	bl	800917a <TIM_GetITStatus>
 80074c8:	b138      	cbz	r0, 80074da <TIM2_IRQHandler+0x1e>
    TIM_ClearITPendingBit(TIMER0_BASE, TIM_IT_Update);
 80074ca:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80074ce:	2101      	movs	r1, #1
 80074d0:	f001 fe5f 	bl	8009192 <TIM_ClearITPendingBit>
    timer_callback[0]();
 80074d4:	4b01      	ldr	r3, [pc, #4]	; (80074dc <TIM2_IRQHandler+0x20>)
 80074d6:	681b      	ldr	r3, [r3, #0]
 80074d8:	4798      	blx	r3
  }
}
 80074da:	bd08      	pop	{r3, pc}
 80074dc:	2000081c 	.word	0x2000081c

080074e0 <TIM3_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM3_IRQn
TIMER1_IRQ_HANDLER
{
 80074e0:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER1_BASE, TIM_IT_Update) != RESET ) {
 80074e2:	4806      	ldr	r0, [pc, #24]	; (80074fc <TIM3_IRQHandler+0x1c>)
 80074e4:	2101      	movs	r1, #1
 80074e6:	f001 fe48 	bl	800917a <TIM_GetITStatus>
 80074ea:	b130      	cbz	r0, 80074fa <TIM3_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER1_BASE, TIM_IT_Update);
 80074ec:	4803      	ldr	r0, [pc, #12]	; (80074fc <TIM3_IRQHandler+0x1c>)
 80074ee:	2101      	movs	r1, #1
 80074f0:	f001 fe4f 	bl	8009192 <TIM_ClearITPendingBit>
    timer_callback[1]();
 80074f4:	4b02      	ldr	r3, [pc, #8]	; (8007500 <TIM3_IRQHandler+0x20>)
 80074f6:	685b      	ldr	r3, [r3, #4]
 80074f8:	4798      	blx	r3
  }
}
 80074fa:	bd08      	pop	{r3, pc}
 80074fc:	40000400 	.word	0x40000400
 8007500:	2000081c 	.word	0x2000081c

08007504 <TIM5_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM5_IRQn
TIMER2_IRQ_HANDLER
{
 8007504:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER2_BASE, TIM_IT_Update) != RESET ) {
 8007506:	4806      	ldr	r0, [pc, #24]	; (8007520 <TIM5_IRQHandler+0x1c>)
 8007508:	2101      	movs	r1, #1
 800750a:	f001 fe36 	bl	800917a <TIM_GetITStatus>
 800750e:	b130      	cbz	r0, 800751e <TIM5_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER2_BASE, TIM_IT_Update);
 8007510:	4803      	ldr	r0, [pc, #12]	; (8007520 <TIM5_IRQHandler+0x1c>)
 8007512:	2101      	movs	r1, #1
 8007514:	f001 fe3d 	bl	8009192 <TIM_ClearITPendingBit>
    timer_callback[2]();
 8007518:	4b02      	ldr	r3, [pc, #8]	; (8007524 <TIM5_IRQHandler+0x20>)
 800751a:	689b      	ldr	r3, [r3, #8]
 800751c:	4798      	blx	r3
  }
}
 800751e:	bd08      	pop	{r3, pc}
 8007520:	40000c00 	.word	0x40000c00
 8007524:	2000081c 	.word	0x2000081c

08007528 <MIOS32_DELAY_Init>:
//!
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
 8007528:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800752a:	4604      	mov	r4, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800752c:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8007530:	b9c4      	cbnz	r4, 8007564 <MIOS32_DELAY_Init+0x3c>
    return -1; // unsupported mode

  // enable timer clock
  if( MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM1 || MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM8 )
    RCC_APB2PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);
 8007532:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8007536:	2101      	movs	r1, #1
 8007538:	f001 ff2c 	bl	8009394 <RCC_APB2PeriphClockCmd>
  else
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
 800753c:	f04f 33ff 	mov.w	r3, #4294967295
 8007540:	f8ad 3008 	strh.w	r3, [sp, #8]
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007544:	4808      	ldr	r0, [pc, #32]	; (8007568 <MIOS32_DELAY_Init+0x40>)
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 8007546:	2347      	movs	r3, #71	; 0x47
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007548:	a901      	add	r1, sp, #4
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 800754a:	f8ad 3004 	strh.w	r3, [sp, #4]
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800754e:	f8ad 400a 	strh.w	r4, [sp, #10]
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8007552:	f8ad 4006 	strh.w	r4, [sp, #6]
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007556:	f001 fd93 	bl	8009080 <TIM_TimeBaseInit>

  // enable counter
  TIM_Cmd(MIOS32_DELAY_TIMER, ENABLE);
 800755a:	4803      	ldr	r0, [pc, #12]	; (8007568 <MIOS32_DELAY_Init+0x40>)
 800755c:	2101      	movs	r1, #1
 800755e:	f001 fdff 	bl	8009160 <TIM_Cmd>

  return 0; // no error
 8007562:	4620      	mov	r0, r4
}
 8007564:	b004      	add	sp, #16
 8007566:	bd10      	pop	{r4, pc}
 8007568:	40012c00 	.word	0x40012c00

0800756c <MIOS32_DELAY_Wait_uS>:
//! \param[in] uS delay (1..65535 microseconds)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Wait_uS(u16 uS)
{
  u16 start = MIOS32_DELAY_TIMER->CNT;
 800756c:	4b04      	ldr	r3, [pc, #16]	; (8007580 <MIOS32_DELAY_Wait_uS+0x14>)
 800756e:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 8007570:	b292      	uxth	r2, r2

  // note that this even works on 16bit counter wrap-arounds
  while( (u16)(MIOS32_DELAY_TIMER->CNT - start) <= uS );
 8007572:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 8007574:	1a89      	subs	r1, r1, r2
 8007576:	b289      	uxth	r1, r1
 8007578:	4281      	cmp	r1, r0
 800757a:	d9fa      	bls.n	8007572 <MIOS32_DELAY_Wait_uS+0x6>

  return 0; // no error
}
 800757c:	2000      	movs	r0, #0
 800757e:	4770      	bx	lr
 8007580:	40012c00 	.word	0x40012c00

08007584 <MIOS32_AIN_Init>:
//! Initializes AIN driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
{
 8007584:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007586:	b095      	sub	sp, #84	; 0x54
  // currently only mode 0 supported
  if( mode != 0 )
 8007588:	2800      	cmp	r0, #0
 800758a:	f040 8104 	bne.w	8007796 <MIOS32_AIN_Init+0x212>
  return -1; // no AIN pins selected
#else
  int i;

  // disable service prepare callback function
  service_prepare_callback = NULL;
 800758e:	4b84      	ldr	r3, [pc, #528]	; (80077a0 <MIOS32_AIN_Init+0x21c>)
 8007590:	4e84      	ldr	r6, [pc, #528]	; (80077a4 <MIOS32_AIN_Init+0x220>)
 8007592:	6018      	str	r0, [r3, #0]
 8007594:	4b84      	ldr	r3, [pc, #528]	; (80077a8 <MIOS32_AIN_Init+0x224>)
/////////////////////////////////////////////////////////////////////////////
//! Initializes AIN driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
 8007596:	f106 021e 	add.w	r2, r6, #30
  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    adc_conversion_values[i] = 0;
 800759a:	2100      	movs	r1, #0
 800759c:	f823 1f02 	strh.w	r1, [r3, #2]!

  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80075a0:	4293      	cmp	r3, r2
 80075a2:	d1fa      	bne.n	800759a <MIOS32_AIN_Init+0x16>
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
    ain_pin_values[i] = 0;
 80075a4:	4981      	ldr	r1, [pc, #516]	; (80077ac <MIOS32_AIN_Init+0x228>)
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
 80075a6:	4a82      	ldr	r2, [pc, #520]	; (80077b0 <MIOS32_AIN_Init+0x22c>)

  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80075a8:	2300      	movs	r3, #0
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
    ain_pin_values[i] = 0;
 80075aa:	2400      	movs	r4, #0
 80075ac:	52cc      	strh	r4, [r1, r3]
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
 80075ae:	52d4      	strh	r4, [r2, r3]
 80075b0:	3302      	adds	r3, #2
    adc_conversion_values[i] = 0;
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
 80075b2:	2b20      	cmp	r3, #32
 80075b4:	d1f9      	bne.n	80075aa <MIOS32_AIN_Init+0x26>
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
 80075b6:	4b7f      	ldr	r3, [pc, #508]	; (80077b4 <MIOS32_AIN_Init+0x230>)
  oversampling_ctr = mux_ctr = 0;


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80075b8:	ad13      	add	r5, sp, #76	; 0x4c
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
 80075ba:	601c      	str	r4, [r3, #0]
  }
  oversampling_ctr = mux_ctr = 0;
 80075bc:	4b7e      	ldr	r3, [pc, #504]	; (80077b8 <MIOS32_AIN_Init+0x234>)


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80075be:	4628      	mov	r0, r5
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
  }
  oversampling_ctr = mux_ctr = 0;
 80075c0:	701c      	strb	r4, [r3, #0]
 80075c2:	4b7e      	ldr	r3, [pc, #504]	; (80077bc <MIOS32_AIN_Init+0x238>)

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 80075c4:	27f0      	movs	r7, #240	; 0xf0
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
  }
  oversampling_ctr = mux_ctr = 0;
 80075c6:	701c      	strb	r4, [r3, #0]


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80075c8:	f001 fa6e 	bl	8008aa8 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80075cc:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AIN;

  // J5A.0..3 -> Channel 10..13 -> Pin C0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x000f) >> 0;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 80075ce:	4629      	mov	r1, r5
 80075d0:	487b      	ldr	r0, [pc, #492]	; (80077c0 <MIOS32_AIN_Init+0x23c>)


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80075d2:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AIN;
 80075d6:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f

  // J5A.0..3 -> Channel 10..13 -> Pin C0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x000f) >> 0;
 80075da:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 80075de:	f001 fa0a 	bl	80089f6 <GPIO_Init>

  // J5B.4..7 -> Channel 0..3 -> Pin A0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x00f0) >> 4;
 80075e2:	210f      	movs	r1, #15
 80075e4:	f8ad 104c 	strh.w	r1, [sp, #76]	; 0x4c
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80075e8:	4876      	ldr	r0, [pc, #472]	; (80077c4 <MIOS32_AIN_Init+0x240>)
 80075ea:	4629      	mov	r1, r5
 80075ec:	f001 fa03 	bl	80089f6 <GPIO_Init>

  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 80075f0:	4629      	mov	r1, r5
 80075f2:	4873      	ldr	r0, [pc, #460]	; (80077c0 <MIOS32_AIN_Init+0x23c>)
  // J5B.4..7 -> Channel 0..3 -> Pin A0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x00f0) >> 4;
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
 80075f4:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 80075f8:	f001 f9fd 	bl	80089f6 <GPIO_Init>

  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 80075fc:	4629      	mov	r1, r5
 80075fe:	4872      	ldr	r0, [pc, #456]	; (80077c8 <MIOS32_AIN_Init+0x244>)
  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
 8007600:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8007604:	f001 f9f7 	bl	80089f6 <GPIO_Init>

  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007608:	4629      	mov	r1, r5
 800760a:	486d      	ldr	r0, [pc, #436]	; (80077c0 <MIOS32_AIN_Init+0x23c>)
  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
  GPIO_Init(GPIOB, &GPIO_InitStructure);

  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
 800760c:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007610:	f001 f9f1 	bl	80089f6 <GPIO_Init>

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007614:	4629      	mov	r1, r5
 8007616:	486b      	ldr	r0, [pc, #428]	; (80077c4 <MIOS32_AIN_Init+0x240>)
  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
 8007618:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
 800761c:	4d6b      	ldr	r5, [pc, #428]	; (80077cc <MIOS32_AIN_Init+0x248>)
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800761e:	f001 f9ea 	bl	80089f6 <GPIO_Init>


  // configure MUX pins if enabled
#if MIOS32_AIN_MUX_PINS >= 0
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007622:	2310      	movs	r3, #16
#endif
#endif


  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 8007624:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8007628:	2101      	movs	r1, #1
  GPIO_Init(GPIOA, &GPIO_InitStructure);


  // configure MUX pins if enabled
#if MIOS32_AIN_MUX_PINS >= 0
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 800762a:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
#endif
#endif


  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 800762e:	f001 feb1 	bl	8009394 <RCC_APB2PeriphClockCmd>
  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
      ADC_RegularChannelConfig(
 8007632:	f8df c19c 	ldr.w	ip, [pc, #412]	; 80077d0 <MIOS32_AIN_Init+0x24c>
  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
 8007636:	702c      	strb	r4, [r5, #0]
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 8007638:	fa57 f304 	asrs.w	r3, r7, r4
 800763c:	f013 0f01 	tst.w	r3, #1
 8007640:	d013      	beq.n	800766a <MIOS32_AIN_Init+0xe6>
      ADC_RegularChannelConfig(
        (num_channels & 1) ? ADC2 : ADC1, 
 8007642:	782a      	ldrb	r2, [r5, #0]
  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
      ADC_RegularChannelConfig(
 8007644:	4863      	ldr	r0, [pc, #396]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 8007646:	f012 0f01 	tst.w	r2, #1
 800764a:	4b63      	ldr	r3, [pc, #396]	; (80077d8 <MIOS32_AIN_Init+0x254>)
 800764c:	bf08      	it	eq
 800764e:	4660      	moveq	r0, ip
 8007650:	0852      	lsrs	r2, r2, #1
 8007652:	5d19      	ldrb	r1, [r3, r4]
 8007654:	3201      	adds	r2, #1
 8007656:	2307      	movs	r3, #7
 8007658:	f8cd c004 	str.w	ip, [sp, #4]
 800765c:	f001 fadb 	bl	8008c16 <ADC_RegularChannelConfig>
        (num_channels & 1) ? ADC2 : ADC1, 
	adc_chn_map[i], 
	(num_channels>>1)+1, 
	ADC_SampleTime_239Cycles5);
      ++num_channels;
 8007660:	782b      	ldrb	r3, [r5, #0]
 8007662:	3301      	adds	r3, #1
 8007664:	702b      	strb	r3, [r5, #0]
 8007666:	f8dd c004 	ldr.w	ip, [sp, #4]
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 800766a:	3401      	adds	r4, #1
 800766c:	2c10      	cmp	r4, #16
 800766e:	d1e3      	bne.n	8007638 <MIOS32_AIN_Init+0xb4>
      ++num_channels;
    }
  }

  // ensure that num_used_channels is an even value to keep ADC2 in synch with ADC1
  num_used_channels = num_channels;
 8007670:	4b56      	ldr	r3, [pc, #344]	; (80077cc <MIOS32_AIN_Init+0x248>)
 8007672:	4a5a      	ldr	r2, [pc, #360]	; (80077dc <MIOS32_AIN_Init+0x258>)
 8007674:	781b      	ldrb	r3, [r3, #0]
  if( num_used_channels & 1 )
 8007676:	f013 0f01 	tst.w	r3, #1
      ++num_channels;
    }
  }

  // ensure that num_used_channels is an even value to keep ADC2 in synch with ADC1
  num_used_channels = num_channels;
 800767a:	7013      	strb	r3, [r2, #0]
  if( num_used_channels & 1 )
 800767c:	d001      	beq.n	8007682 <MIOS32_AIN_Init+0xfe>
      ++num_used_channels;
 800767e:	3301      	adds	r3, #1
 8007680:	7013      	strb	r3, [r2, #0]

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
 8007682:	ad0e      	add	r5, sp, #56	; 0x38
 8007684:	4628      	mov	r0, r5
 8007686:	f001 fa8d 	bl	8008ba4 <ADC_StructInit>
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
 800768a:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
 800768e:	930e      	str	r3, [sp, #56]	; 0x38
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 8007690:	f5a3 23c0 	sub.w	r3, r3, #393216	; 0x60000
 8007694:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8007698:	9311      	str	r3, [sp, #68]	; 0x44
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 800769a:	4b50      	ldr	r3, [pc, #320]	; (80077dc <MIOS32_AIN_Init+0x258>)

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 800769c:	2401      	movs	r4, #1
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 800769e:	781b      	ldrb	r3, [r3, #0]
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 80076a0:	f44f 2260 	mov.w	r2, #917504	; 0xe0000
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80076a4:	40e3      	lsrs	r3, r4
  ADC_Init(ADC1, &ADC_InitStructure);
 80076a6:	484a      	ldr	r0, [pc, #296]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 80076a8:	4629      	mov	r1, r5
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 80076aa:	9210      	str	r2, [sp, #64]	; 0x40
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80076ac:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 80076b0:	f88d 403c 	strb.w	r4, [sp, #60]	; 0x3c
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
  ADC_Init(ADC1, &ADC_InitStructure);
 80076b4:	f001 fa50 	bl	8008b58 <ADC_Init>
  ADC_Init(ADC2, &ADC_InitStructure);
 80076b8:	4846      	ldr	r0, [pc, #280]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 80076ba:	4629      	mov	r1, r5
 80076bc:	f001 fa4c 	bl	8008b58 <ADC_Init>

  // enable ADC2 external trigger conversion (to synch with ADC1)
  ADC_ExternalTrigConvCmd(ADC2, ENABLE);
 80076c0:	4844      	ldr	r0, [pc, #272]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 80076c2:	4621      	mov	r1, r4
 80076c4:	f001 fafa 	bl	8008cbc <ADC_ExternalTrigConvCmd>

  // enable ADC1->DMA request
  ADC_DMACmd(ADC1, ENABLE);
 80076c8:	4841      	ldr	r0, [pc, #260]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 80076ca:	4621      	mov	r1, r4
 80076cc:	f001 fa7d 	bl	8008bca <ADC_DMACmd>


  // ADC1 calibration
  ADC_Cmd(ADC1, ENABLE);
 80076d0:	483f      	ldr	r0, [pc, #252]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 80076d2:	4621      	mov	r1, r4
 80076d4:	f001 fa6f 	bl	8008bb6 <ADC_Cmd>
  ADC_ResetCalibration(ADC1);
 80076d8:	483d      	ldr	r0, [pc, #244]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 80076da:	f001 fa80 	bl	8008bde <ADC_ResetCalibration>
  while( ADC_GetResetCalibrationStatus(ADC1) );
 80076de:	483c      	ldr	r0, [pc, #240]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 80076e0:	f001 fa82 	bl	8008be8 <ADC_GetResetCalibrationStatus>
 80076e4:	2800      	cmp	r0, #0
 80076e6:	d1fa      	bne.n	80076de <MIOS32_AIN_Init+0x15a>
  ADC_StartCalibration(ADC1);
 80076e8:	4839      	ldr	r0, [pc, #228]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 80076ea:	f001 fa81 	bl	8008bf0 <ADC_StartCalibration>
  while( ADC_GetCalibrationStatus(ADC1) );
 80076ee:	4838      	ldr	r0, [pc, #224]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 80076f0:	f001 fa83 	bl	8008bfa <ADC_GetCalibrationStatus>
 80076f4:	2800      	cmp	r0, #0
 80076f6:	d1fa      	bne.n	80076ee <MIOS32_AIN_Init+0x16a>

  // ADC2 calibration
  ADC_Cmd(ADC2, ENABLE);
 80076f8:	4836      	ldr	r0, [pc, #216]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 80076fa:	2101      	movs	r1, #1
 80076fc:	f001 fa5b 	bl	8008bb6 <ADC_Cmd>
  ADC_ResetCalibration(ADC2);
 8007700:	4834      	ldr	r0, [pc, #208]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 8007702:	f001 fa6c 	bl	8008bde <ADC_ResetCalibration>
  while( ADC_GetResetCalibrationStatus(ADC2) );
 8007706:	4833      	ldr	r0, [pc, #204]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 8007708:	f001 fa6e 	bl	8008be8 <ADC_GetResetCalibrationStatus>
 800770c:	2800      	cmp	r0, #0
 800770e:	d1fa      	bne.n	8007706 <MIOS32_AIN_Init+0x182>
  ADC_StartCalibration(ADC2);
 8007710:	4830      	ldr	r0, [pc, #192]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 8007712:	f001 fa6d 	bl	8008bf0 <ADC_StartCalibration>
  while( ADC_GetCalibrationStatus(ADC2) );
 8007716:	482f      	ldr	r0, [pc, #188]	; (80077d4 <MIOS32_AIN_Init+0x250>)
 8007718:	f001 fa6f 	bl	8008bfa <ADC_GetCalibrationStatus>
 800771c:	2800      	cmp	r0, #0
 800771e:	d1fa      	bne.n	8007716 <MIOS32_AIN_Init+0x192>
 8007720:	4604      	mov	r4, r0


  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8007722:	3001      	adds	r0, #1
 8007724:	4601      	mov	r1, r0

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8007726:	ad03      	add	r5, sp, #12
  ADC_StartCalibration(ADC2);
  while( ADC_GetCalibrationStatus(ADC2) );


  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8007728:	f001 fe26 	bl	8009378 <RCC_AHBPeriphClockCmd>

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 800772c:	4628      	mov	r0, r5
 800772e:	f001 fc7a 	bl	8009026 <DMA_StructInit>
  DMA_DeInit(DMA1_Channel1);
 8007732:	482b      	ldr	r0, [pc, #172]	; (80077e0 <MIOS32_AIN_Init+0x25c>)
 8007734:	f001 fbe2 	bl	8008efc <DMA_DeInit>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
 8007738:	4b2a      	ldr	r3, [pc, #168]	; (80077e4 <MIOS32_AIN_Init+0x260>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 800773a:	4829      	ldr	r0, [pc, #164]	; (80077e0 <MIOS32_AIN_Init+0x25c>)

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
 800773c:	9303      	str	r3, [sp, #12]
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 800773e:	4b27      	ldr	r3, [pc, #156]	; (80077dc <MIOS32_AIN_Init+0x258>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 8007740:	4629      	mov	r1, r5
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 8007742:	781b      	ldrb	r3, [r3, #0]
  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
 8007744:	9604      	str	r6, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 8007746:	085b      	lsrs	r3, r3, #1
 8007748:	9306      	str	r3, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800774a:	2380      	movs	r3, #128	; 0x80
 800774c:	9308      	str	r3, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
 800774e:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 8007752:	9309      	str	r3, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
 8007754:	f503 63c0 	add.w	r3, r3, #1536	; 0x600
 8007758:	930a      	str	r3, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 800775a:	f5a3 63fc 	sub.w	r3, r3, #2016	; 0x7e0
 800775e:	930b      	str	r3, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8007760:	f503 53ff 	add.w	r3, r3, #8160	; 0x1fe0
 8007764:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8007766:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8007768:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 800776a:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 800776c:	f001 fc30 	bl	8008fd0 <DMA_Init>
  DMA_Cmd(DMA1_Channel1, ENABLE);
 8007770:	481b      	ldr	r0, [pc, #108]	; (80077e0 <MIOS32_AIN_Init+0x25c>)
 8007772:	2101      	movs	r1, #1
 8007774:	f001 fc64 	bl	8009040 <DMA_Cmd>

  // trigger interrupt when all conversion values have been fetched
  DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);
 8007778:	2201      	movs	r2, #1
 800777a:	4819      	ldr	r0, [pc, #100]	; (80077e0 <MIOS32_AIN_Init+0x25c>)
 800777c:	2102      	movs	r1, #2
 800777e:	f001 fc69 	bl	8009054 <DMA_ITConfig>

  // Configure and enable DMA interrupt
  MIOS32_IRQ_Install(DMA1_Channel1_IRQn, MIOS32_IRQ_AIN_DMA_PRIORITY);
 8007782:	2105      	movs	r1, #5
 8007784:	200b      	movs	r0, #11
 8007786:	f7fe ffb3 	bl	80066f0 <MIOS32_IRQ_Install>

  // finally start initial conversion
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 800778a:	4811      	ldr	r0, [pc, #68]	; (80077d0 <MIOS32_AIN_Init+0x24c>)
 800778c:	2101      	movs	r1, #1
 800778e:	f001 fa38 	bl	8008c02 <ADC_SoftwareStartConvCmd>

  return 0;
 8007792:	4620      	mov	r0, r4
 8007794:	e001      	b.n	800779a <MIOS32_AIN_Init+0x216>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007796:	f04f 30ff 	mov.w	r0, #4294967295
  // finally start initial conversion
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0;
#endif
}
 800779a:	b015      	add	sp, #84	; 0x54
 800779c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800779e:	bf00      	nop
 80077a0:	20000894 	.word	0x20000894
 80077a4:	2000084c 	.word	0x2000084c
 80077a8:	2000084a 	.word	0x2000084a
 80077ac:	20000828 	.word	0x20000828
 80077b0:	20000870 	.word	0x20000870
 80077b4:	2000089c 	.word	0x2000089c
 80077b8:	2000086c 	.word	0x2000086c
 80077bc:	20000848 	.word	0x20000848
 80077c0:	40011000 	.word	0x40011000
 80077c4:	40010800 	.word	0x40010800
 80077c8:	40010c00 	.word	0x40010c00
 80077cc:	20000890 	.word	0x20000890
 80077d0:	40012400 	.word	0x40012400
 80077d4:	40012800 	.word	0x40012800
 80077d8:	0800b0ac 	.word	0x0800b0ac
 80077dc:	20000898 	.word	0x20000898
 80077e0:	40020008 	.word	0x40020008
 80077e4:	4001244c 	.word	0x4001244c

080077e8 <MIOS32_AIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Handler(void *_callback)
{
 80077e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80077ea:	4607      	mov	r7, r0
  // no callback function?
  if( _callback == NULL )
    return -1;
 80077ec:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Handler(void *_callback)
{
  // no callback function?
  if( _callback == NULL )
 80077f0:	2f00      	cmp	r7, #0
 80077f2:	d03e      	beq.n	8007872 <MIOS32_AIN_Handler+0x8a>
#else
  int chn, mux;
  void (*callback)(s32 pin, u16 value) = _callback;

  // exit if scan hasn't been finished yet
  if( mux_ctr || oversampling_ctr )
 80077f4:	4b1f      	ldr	r3, [pc, #124]	; (8007874 <MIOS32_AIN_Handler+0x8c>)
 80077f6:	7818      	ldrb	r0, [r3, #0]
 80077f8:	2800      	cmp	r0, #0
 80077fa:	d139      	bne.n	8007870 <MIOS32_AIN_Handler+0x88>
 80077fc:	4b1e      	ldr	r3, [pc, #120]	; (8007878 <MIOS32_AIN_Handler+0x90>)
 80077fe:	781c      	ldrb	r4, [r3, #0]
 8007800:	2c00      	cmp	r4, #0
 8007802:	d136      	bne.n	8007872 <MIOS32_AIN_Handler+0x8a>
    return 0;

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
 8007804:	4e1d      	ldr	r6, [pc, #116]	; (800787c <MIOS32_AIN_Handler+0x94>)
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
 8007806:	4d1e      	ldr	r5, [pc, #120]	; (8007880 <MIOS32_AIN_Handler+0x98>)
 8007808:	e025      	b.n	8007856 <MIOS32_AIN_Handler+0x6e>

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
 800780a:	2001      	movs	r0, #1
 800780c:	f004 021f 	and.w	r2, r4, #31
 8007810:	fa10 f202 	lsls.w	r2, r0, r2
      if( ain_pin_changed[pin >> 5] & mask ) {
 8007814:	0963      	lsrs	r3, r4, #5
 8007816:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 800781a:	420a      	tst	r2, r1
 800781c:	d01a      	beq.n	8007854 <MIOS32_AIN_Handler+0x6c>
	MIOS32_IRQ_Disable();
 800781e:	9201      	str	r2, [sp, #4]
 8007820:	9300      	str	r3, [sp, #0]
 8007822:	f7fe ff3d 	bl	80066a0 <MIOS32_IRQ_Disable>
	u32 pin_value = ain_pin_values[pin];
	ain_pin_changed[pin>>5] &= ~mask;
 8007826:	9b00      	ldr	r3, [sp, #0]
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
 8007828:	4816      	ldr	r0, [pc, #88]	; (8007884 <MIOS32_AIN_Handler+0x9c>)
	ain_pin_changed[pin>>5] &= ~mask;
 800782a:	9a01      	ldr	r2, [sp, #4]
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
 800782c:	f830 1014 	ldrh.w	r1, [r0, r4, lsl #1]
	ain_pin_changed[pin>>5] &= ~mask;
 8007830:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
	MIOS32_IRQ_Enable();
 8007834:	9101      	str	r1, [sp, #4]
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
	ain_pin_changed[pin>>5] &= ~mask;
 8007836:	ea20 0202 	bic.w	r2, r0, r2
 800783a:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
	MIOS32_IRQ_Enable();
 800783e:	f7fe ff45 	bl	80066cc <MIOS32_IRQ_Enable>

	// call application hook
	// note that due to dual conversion approach, we have to convert the pin number
	// if an uneven number number of channels selected
	u8 app_pin = (num_channels & 1) ? (pin>>1) : pin;
 8007842:	7833      	ldrb	r3, [r6, #0]
 8007844:	9901      	ldr	r1, [sp, #4]
 8007846:	f013 0f01 	tst.w	r3, #1
 800784a:	bf14      	ite	ne
 800784c:	f3c4 0047 	ubfxne	r0, r4, #1, #8
 8007850:	b2e0      	uxtbeq	r0, r4
	callback(app_pin, pin_value);
 8007852:	47b8      	blx	r7
  if( mux_ctr || oversampling_ctr )
    return 0;

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
 8007854:	3401      	adds	r4, #1
 8007856:	7833      	ldrb	r3, [r6, #0]
 8007858:	429c      	cmp	r4, r3
 800785a:	dbd6      	blt.n	800780a <MIOS32_AIN_Handler+0x22>
    }
  }

  // execute optional "service prepare" callback function
  // skip scan if it returns a value >= 1
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
 800785c:	4b0a      	ldr	r3, [pc, #40]	; (8007888 <MIOS32_AIN_Handler+0xa0>)
 800785e:	681b      	ldr	r3, [r3, #0]
 8007860:	b113      	cbz	r3, 8007868 <MIOS32_AIN_Handler+0x80>
 8007862:	4798      	blx	r3
 8007864:	2800      	cmp	r0, #0
 8007866:	dc03      	bgt.n	8007870 <MIOS32_AIN_Handler+0x88>
    return 0; // scan skipped - no error

  // start next scan
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 8007868:	4808      	ldr	r0, [pc, #32]	; (800788c <MIOS32_AIN_Handler+0xa4>)
 800786a:	2101      	movs	r1, #1
 800786c:	f001 f9c9 	bl	8008c02 <ADC_SoftwareStartConvCmd>
  }

  // execute optional "service prepare" callback function
  // skip scan if it returns a value >= 1
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
    return 0; // scan skipped - no error
 8007870:	2000      	movs	r0, #0
  // start next scan
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0; // no error
#endif
}
 8007872:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007874:	2000086c 	.word	0x2000086c
 8007878:	20000848 	.word	0x20000848
 800787c:	20000890 	.word	0x20000890
 8007880:	2000089c 	.word	0x2000089c
 8007884:	20000828 	.word	0x20000828
 8007888:	20000894 	.word	0x20000894
 800788c:	40012400 	.word	0x40012400

08007890 <DMA1_Channel1_IRQHandler>:
//! DMA channel interrupt is triggered when all ADC channels have been converted
//! \note shouldn't be called directly from application
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_AIN_CHANNEL_MASK
void DMA1_Channel1_IRQHandler(void)
{
 8007890:	b5f0      	push	{r4, r5, r6, r7, lr}
  int i;
  u16 *src_ptr, *dst_ptr;

  // clear the pending flag(s)
  DMA_ClearFlag(DMA1_FLAG_TC1 | DMA1_FLAG_TE1 | DMA1_FLAG_HT1 | DMA1_FLAG_GL1);
 8007892:	200f      	movs	r0, #15
//! DMA channel interrupt is triggered when all ADC channels have been converted
//! \note shouldn't be called directly from application
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_AIN_CHANNEL_MASK
void DMA1_Channel1_IRQHandler(void)
{
 8007894:	b089      	sub	sp, #36	; 0x24
  int i;
  u16 *src_ptr, *dst_ptr;

  // clear the pending flag(s)
  DMA_ClearFlag(DMA1_FLAG_TC1 | DMA1_FLAG_TE1 | DMA1_FLAG_HT1 | DMA1_FLAG_GL1);
 8007896:	f001 fbe7 	bl	8009068 <DMA_ClearFlag>
    oversampling_ctr = 0;
#endif

  // whenever we reached the last sample:
  // copy conversion values to ain_pin_values if difference > deadband
  if( oversampling_ctr == 0 ) {
 800789a:	4b2f      	ldr	r3, [pc, #188]	; (8007958 <DMA1_Channel1_IRQHandler+0xc8>)
 800789c:	7818      	ldrb	r0, [r3, #0]
 800789e:	2800      	cmp	r0, #0
 80078a0:	d14d      	bne.n	800793e <DMA1_Channel1_IRQHandler+0xae>
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80078a2:	4b2e      	ldr	r3, [pc, #184]	; (800795c <DMA1_Channel1_IRQHandler+0xcc>)
 80078a4:	4a2e      	ldr	r2, [pc, #184]	; (8007960 <DMA1_Channel1_IRQHandler+0xd0>)
 80078a6:	781b      	ldrb	r3, [r3, #0]
 80078a8:	7812      	ldrb	r2, [r2, #0]

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80078aa:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 8007964 <DMA1_Channel1_IRQHandler+0xd4>
  if( oversampling_ctr == 0 ) {
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80078ae:	435a      	muls	r2, r3

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80078b0:	f89c c000 	ldrb.w	ip, [ip]
 80078b4:	4c2c      	ldr	r4, [pc, #176]	; (8007968 <DMA1_Channel1_IRQHandler+0xd8>)
  if( oversampling_ctr == 0 ) {
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80078b6:	b2d2      	uxtb	r2, r2

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80078b8:	f8cd c01c 	str.w	ip, [sp, #28]
 80078bc:	9405      	str	r4, [sp, #20]
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    src_ptr = (u16 *)adc_conversion_values_sum;
#else
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 80078be:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 800796c <DMA1_Channel1_IRQHandler+0xdc>

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 80078c2:	4c2b      	ldr	r4, [pc, #172]	; (8007970 <DMA1_Channel1_IRQHandler+0xe0>)
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
    u8 bit_offset = pin_offset & 0x1f;
 80078c4:	f002 031f 	and.w	r3, r2, #31
    u8 word_offset = pin_offset >> 5;
 80078c8:	0951      	lsrs	r1, r2, #5
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    src_ptr = (u16 *)adc_conversion_values_sum;
#else
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 80078ca:	0052      	lsls	r2, r2, #1
 80078cc:	4494      	add	ip, r2
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
#endif
	*dst_ptr = *src_ptr;
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 80078ce:	4d29      	ldr	r5, [pc, #164]	; (8007974 <DMA1_Channel1_IRQHandler+0xe4>)
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 80078d0:	18a2      	adds	r2, r4, r2
#endif

    for(i=0; i<num_channels; ++i) {
 80078d2:	e031      	b.n	8007938 <DMA1_Channel1_IRQHandler+0xa8>
#if MIOS32_AIN_DEADBAND_IDLE
      u16 deadband = *idle_ctr_ptr ? (MIOS32_AIN_DEADBAND) : (MIOS32_AIN_DEADBAND_IDLE);
 80078d4:	f832 4b02 	ldrh.w	r4, [r2], #2
 80078d8:	2c00      	cmp	r4, #0
 80078da:	bf0c      	ite	eq
 80078dc:	267f      	moveq	r6, #127	; 0x7f
 80078de:	261f      	movne	r6, #31
 80078e0:	9606      	str	r6, [sp, #24]

      // takeover new value if difference to old value is outside the deadband
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
 80078e2:	9e05      	ldr	r6, [sp, #20]
 80078e4:	f836 7f02 	ldrh.w	r7, [r6, #2]!
 80078e8:	9701      	str	r7, [sp, #4]
 80078ea:	9605      	str	r6, [sp, #20]
 80078ec:	f83c 7b02 	ldrh.w	r7, [ip], #2
 80078f0:	9e01      	ldr	r6, [sp, #4]
 80078f2:	1bf7      	subs	r7, r6, r7
 80078f4:	ea87 76e7 	eor.w	r6, r7, r7, asr #31
 80078f8:	eba6 76e7 	sub.w	r6, r6, r7, asr #31
 80078fc:	9f06      	ldr	r7, [sp, #24]
 80078fe:	42be      	cmp	r6, r7
 8007900:	dd0e      	ble.n	8007920 <DMA1_Channel1_IRQHandler+0x90>
#endif
	*dst_ptr = *src_ptr;
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 8007902:	2701      	movs	r7, #1
 8007904:	fa17 f603 	lsls.w	r6, r7, r3
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
#endif
	*dst_ptr = *src_ptr;
 8007908:	9c01      	ldr	r4, [sp, #4]
 800790a:	f82c 4c02 	strh.w	r4, [ip, #-2]
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 800790e:	f855 4021 	ldr.w	r4, [r5, r1, lsl #2]
 8007912:	ea46 0404 	orr.w	r4, r6, r4
 8007916:	f845 4021 	str.w	r4, [r5, r1, lsl #2]
#if MIOS32_AIN_DEADBAND_IDLE
	*idle_ctr_ptr = MIOS32_AIN_IDLE_CTR;
 800791a:	f640 34b8 	movw	r4, #3000	; 0xbb8
 800791e:	e001      	b.n	8007924 <DMA1_Channel1_IRQHandler+0x94>
#endif
      } else {
#if MIOS32_AIN_DEADBAND_IDLE
	if( *idle_ctr_ptr )
 8007920:	b114      	cbz	r4, 8007928 <DMA1_Channel1_IRQHandler+0x98>
	  *idle_ctr_ptr -= 1;
 8007922:	3c01      	subs	r4, #1
 8007924:	f822 4c02 	strh.w	r4, [r2, #-2]
#if MIOS32_AIN_DEADBAND_IDLE
      ++idle_ctr_ptr;
#endif

      // switch to next bit/word offset for "changed" flags
      if( ++bit_offset >= 32 ) {
 8007928:	3301      	adds	r3, #1
 800792a:	b2db      	uxtb	r3, r3
 800792c:	2b20      	cmp	r3, #32
 800792e:	d102      	bne.n	8007936 <DMA1_Channel1_IRQHandler+0xa6>
	bit_offset = 0;
	++word_offset;
 8007930:	3101      	adds	r1, #1
 8007932:	b2c9      	uxtb	r1, r1
      ++idle_ctr_ptr;
#endif

      // switch to next bit/word offset for "changed" flags
      if( ++bit_offset >= 32 ) {
	bit_offset = 0;
 8007934:	2300      	movs	r3, #0

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 8007936:	3001      	adds	r0, #1
 8007938:	9e07      	ldr	r6, [sp, #28]
 800793a:	42b0      	cmp	r0, r6
 800793c:	dbca      	blt.n	80078d4 <DMA1_Channel1_IRQHandler+0x44>
    // starting conversion of new selected channels
  }
#endif

  // request next conversion as long as oversampling/mux counter haven't reached the end
  if( mux_ctr || oversampling_ctr )
 800793e:	4b07      	ldr	r3, [pc, #28]	; (800795c <DMA1_Channel1_IRQHandler+0xcc>)
 8007940:	781b      	ldrb	r3, [r3, #0]
 8007942:	b913      	cbnz	r3, 800794a <DMA1_Channel1_IRQHandler+0xba>
 8007944:	4b04      	ldr	r3, [pc, #16]	; (8007958 <DMA1_Channel1_IRQHandler+0xc8>)
 8007946:	781b      	ldrb	r3, [r3, #0]
 8007948:	b11b      	cbz	r3, 8007952 <DMA1_Channel1_IRQHandler+0xc2>
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 800794a:	480b      	ldr	r0, [pc, #44]	; (8007978 <DMA1_Channel1_IRQHandler+0xe8>)
 800794c:	2101      	movs	r1, #1
 800794e:	f001 f958 	bl	8008c02 <ADC_SoftwareStartConvCmd>
}
 8007952:	b009      	add	sp, #36	; 0x24
 8007954:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007956:	bf00      	nop
 8007958:	20000848 	.word	0x20000848
 800795c:	2000086c 	.word	0x2000086c
 8007960:	20000898 	.word	0x20000898
 8007964:	20000890 	.word	0x20000890
 8007968:	2000084a 	.word	0x2000084a
 800796c:	20000828 	.word	0x20000828
 8007970:	20000870 	.word	0x20000870
 8007974:	2000089c 	.word	0x2000089c
 8007978:	40012400 	.word	0x40012400

0800797c <MIOS32_USB_CB_SetDeviceAddress>:
}

// update the device state to addressed
static void MIOS32_USB_CB_SetDeviceAddress (void)
{
  bDeviceState = ADDRESSED;
 800797c:	4b01      	ldr	r3, [pc, #4]	; (8007984 <MIOS32_USB_CB_SetDeviceAddress+0x8>)
 800797e:	2204      	movs	r2, #4
 8007980:	601a      	str	r2, [r3, #0]
}
 8007982:	4770      	bx	lr
 8007984:	200008a0 	.word	0x200008a0

08007988 <MIOS32_USB_CB_Status_In>:
static void MIOS32_USB_CB_Status_In(void)
{
#ifdef MIOS32_USE_USB_COM
  MIOS32_USB_COM_CB_StatusIn();
#endif
}
 8007988:	4770      	bx	lr

0800798a <MIOS32_USB_CB_Status_Out>:

// status OUT routine
static void MIOS32_USB_CB_Status_Out(void)
{
}
 800798a:	4770      	bx	lr

0800798c <MIOS32_USB_CB_Data_Setup>:
  RESULT res;
  if( (res=MIOS32_USB_COM_CB_Data_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif
  return USB_UNSUPPORT;
}
 800798c:	2002      	movs	r0, #2
 800798e:	4770      	bx	lr

08007990 <MIOS32_USB_CB_NoData_Setup>:
  if( (res=MIOS32_USB_COM_CB_NoData_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif

  return USB_UNSUPPORT;
}
 8007990:	2002      	movs	r0, #2
 8007992:	4770      	bx	lr

08007994 <MIOS32_USB_CB_Get_Interface_Setting>:
}

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
 8007994:	b921      	cbnz	r1, 80079a0 <MIOS32_USB_CB_Get_Interface_Setting+0xc>
    return USB_UNSUPPORT;
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
 8007996:	2801      	cmp	r0, #1
 8007998:	bf8c      	ite	hi
 800799a:	2002      	movhi	r0, #2
 800799c:	2000      	movls	r0, #0
 800799e:	e000      	b.n	80079a2 <MIOS32_USB_CB_Get_Interface_Setting+0xe>

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
    return USB_UNSUPPORT;
 80079a0:	2002      	movs	r0, #2
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
  }

  return USB_SUCCESS;
}
 80079a2:	4770      	bx	lr

080079a4 <MIOS32_USB_CB_SetConfiguration>:
  bDeviceState = ATTACHED;
}

// update the device state to configured.
static void MIOS32_USB_CB_SetConfiguration(void)
{
 80079a4:	b508      	push	{r3, lr}
  if (pInformation->Current_Configuration != 0) {
 80079a6:	4b05      	ldr	r3, [pc, #20]	; (80079bc <MIOS32_USB_CB_SetConfiguration+0x18>)
 80079a8:	681b      	ldr	r3, [r3, #0]
 80079aa:	7a9b      	ldrb	r3, [r3, #10]
 80079ac:	b12b      	cbz	r3, 80079ba <MIOS32_USB_CB_SetConfiguration+0x16>
#ifndef MIOS32_DONT_USE_USB_MIDI
    // propagate connection state to USB MIDI driver
    MIOS32_USB_MIDI_ChangeConnectionState(1); // connected
 80079ae:	2001      	movs	r0, #1
 80079b0:	f000 fa92 	bl	8007ed8 <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
    // propagate connection state to USB COM driver
    MIOS32_USB_COM_ChangeConnectionState(1); // connected
#endif

    bDeviceState = CONFIGURED;
 80079b4:	4b02      	ldr	r3, [pc, #8]	; (80079c0 <MIOS32_USB_CB_SetConfiguration+0x1c>)
 80079b6:	2205      	movs	r2, #5
 80079b8:	601a      	str	r2, [r3, #0]
  }
}
 80079ba:	bd08      	pop	{r3, pc}
 80079bc:	2000379c 	.word	0x2000379c
 80079c0:	200008a0 	.word	0x200008a0

080079c4 <MIOS32_USB_CB_GetStringDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 80079c4:	b570      	push	{r4, r5, r6, lr}
 80079c6:	b0c4      	sub	sp, #272	; 0x110
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 80079c8:	493f      	ldr	r1, [pc, #252]	; (8007ac8 <MIOS32_USB_CB_GetStringDescriptor+0x104>)
 80079ca:	220c      	movs	r2, #12
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 80079cc:	4604      	mov	r4, r0
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 80079ce:	a83d      	add	r0, sp, #244	; 0xf4
 80079d0:	f002 fd86 	bl	800a4e0 <memcpy>
  const u8 product_str[] = MIOS32_USB_PRODUCT_STR;
 80079d4:	a842      	add	r0, sp, #264	; 0x108
 80079d6:	493d      	ldr	r1, [pc, #244]	; (8007acc <MIOS32_USB_CB_GetStringDescriptor+0x108>)
 80079d8:	2207      	movs	r2, #7
 80079da:	f002 fd81 	bl	800a4e0 <memcpy>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 80079de:	4b3c      	ldr	r3, [pc, #240]	; (8007ad0 <MIOS32_USB_CB_GetStringDescriptor+0x10c>)
 80079e0:	681b      	ldr	r3, [r3, #0]
 80079e2:	78db      	ldrb	r3, [r3, #3]
 80079e4:	2b03      	cmp	r3, #3
 80079e6:	d86c      	bhi.n	8007ac2 <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 80079e8:	e8df f003 	tbb	[pc, r3]
 80079ec:	40020a12 	.word	0x40020a12
 80079f0:	a941      	add	r1, sp, #260	; 0x104
 80079f2:	3103      	adds	r1, #3
 80079f4:	f10d 0206 	add.w	r2, sp, #6
 80079f8:	2302      	movs	r3, #2

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 80079fa:	f04f 0c00 	mov.w	ip, #0
 80079fe:	e027      	b.n	8007a50 <MIOS32_USB_CB_GetStringDescriptor+0x8c>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 8007a00:	f10d 01f3 	add.w	r1, sp, #243	; 0xf3
 8007a04:	f10d 0206 	add.w	r2, sp, #6
 8007a08:	2302      	movs	r3, #2

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 8007a0a:	f04f 0c00 	mov.w	ip, #0
 8007a0e:	e00b      	b.n	8007a28 <MIOS32_USB_CB_GetStringDescriptor+0x64>
  int i;

  switch( pInformation->USBwValue0 ) {
    case 0: // Language
      // buffer[0] and [1] initialized below
      buffer[2] = 0x09;        // CharSet
 8007a10:	aa01      	add	r2, sp, #4
 8007a12:	2309      	movs	r3, #9
 8007a14:	7093      	strb	r3, [r2, #2]
      buffer[3] = 0x04;        // U.S.
 8007a16:	2304      	movs	r3, #4
 8007a18:	70d3      	strb	r3, [r2, #3]
      len = 4;
      break;
 8007a1a:	e046      	b.n	8007aaa <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 8007a1c:	3302      	adds	r3, #2
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
 8007a1e:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 8007a22:	f802 cc01 	strb.w	ip, [r2, #-1]
 8007a26:	b29b      	uxth	r3, r3
      len = 4;
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
 8007a28:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007a2c:	3202      	adds	r2, #2
 8007a2e:	1e05      	subs	r5, r0, #0
 8007a30:	bf18      	it	ne
 8007a32:	2501      	movne	r5, #1
 8007a34:	2bc7      	cmp	r3, #199	; 0xc7
 8007a36:	bf8c      	ite	hi
 8007a38:	2500      	movhi	r5, #0
 8007a3a:	f005 0501 	andls.w	r5, r5, #1
 8007a3e:	2d00      	cmp	r5, #0
 8007a40:	d1ec      	bne.n	8007a1c <MIOS32_USB_CB_GetStringDescriptor+0x58>
 8007a42:	e032      	b.n	8007aaa <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 8007a44:	3302      	adds	r3, #2
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
 8007a46:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 8007a4a:	f802 cc01 	strb.w	ip, [r2, #-1]
 8007a4e:	b29b      	uxth	r3, r3
      }
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
 8007a50:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007a54:	3202      	adds	r2, #2
 8007a56:	1e05      	subs	r5, r0, #0
 8007a58:	bf18      	it	ne
 8007a5a:	2501      	movne	r5, #1
 8007a5c:	2bc7      	cmp	r3, #199	; 0xc7
 8007a5e:	bf8c      	ite	hi
 8007a60:	2500      	movhi	r5, #0
 8007a62:	f005 0501 	andls.w	r5, r5, #1
 8007a66:	2d00      	cmp	r5, #0
 8007a68:	d1ec      	bne.n	8007a44 <MIOS32_USB_CB_GetStringDescriptor+0x80>
 8007a6a:	e01e      	b.n	8007aaa <MIOS32_USB_CB_GetStringDescriptor+0xe6>
      }
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
 8007a6c:	ad33      	add	r5, sp, #204	; 0xcc
 8007a6e:	4628      	mov	r0, r5
 8007a70:	f7fe fd0a 	bl	8006488 <MIOS32_SYS_SerialNumberGet>
 8007a74:	2800      	cmp	r0, #0
 8007a76:	db24      	blt.n	8007ac2 <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 8007a78:	3d01      	subs	r5, #1
 8007a7a:	f10d 0206 	add.w	r2, sp, #6
 8007a7e:	2302      	movs	r3, #2
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
 8007a80:	2000      	movs	r0, #0
 8007a82:	e005      	b.n	8007a90 <MIOS32_USB_CB_GetStringDescriptor+0xcc>
 8007a84:	3302      	adds	r3, #2

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
 8007a86:	f802 1c02 	strb.w	r1, [r2, #-2]
	    buffer[len++] = 0;
 8007a8a:	f802 0c01 	strb.w	r0, [r2, #-1]
 8007a8e:	b29b      	uxth	r3, r3
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
 8007a90:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007a94:	3202      	adds	r2, #2
 8007a96:	1e0e      	subs	r6, r1, #0
 8007a98:	bf18      	it	ne
 8007a9a:	2601      	movne	r6, #1
 8007a9c:	2bc7      	cmp	r3, #199	; 0xc7
 8007a9e:	bf8c      	ite	hi
 8007aa0:	2600      	movhi	r6, #0
 8007aa2:	f006 0601 	andls.w	r6, r6, #1
 8007aa6:	2e00      	cmp	r6, #0
 8007aa8:	d1ec      	bne.n	8007a84 <MIOS32_USB_CB_GetStringDescriptor+0xc0>
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 8007aaa:	aa01      	add	r2, sp, #4
  buffer[1] = DSCR_STRING; // Descriptor Type
 8007aac:	2103      	movs	r1, #3
 8007aae:	7051      	strb	r1, [r2, #1]
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 8007ab0:	7013      	strb	r3, [r2, #0]
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
 8007ab2:	4620      	mov	r0, r4
 8007ab4:	a940      	add	r1, sp, #256	; 0x100
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
 8007ab6:	9240      	str	r2, [sp, #256]	; 0x100
 8007ab8:	f8ad 3104 	strh.w	r3, [sp, #260]	; 0x104
  return Standard_GetDescriptorData(Length, &desc);
 8007abc:	f001 ff6e 	bl	800999c <Standard_GetDescriptorData>
 8007ac0:	e000      	b.n	8007ac4 <MIOS32_USB_CB_GetStringDescriptor+0x100>
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
	  }
	} else
	  return NULL;
 8007ac2:	2000      	movs	r0, #0

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
}
 8007ac4:	b044      	add	sp, #272	; 0x110
 8007ac6:	bd70      	pop	{r4, r5, r6, pc}
 8007ac8:	0800b124 	.word	0x0800b124
 8007acc:	0800af5b 	.word	0x0800af5b
 8007ad0:	2000379c 	.word	0x2000379c

08007ad4 <MIOS32_USB_CB_GetConfigDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 8007ad4:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 8007ad6:	4905      	ldr	r1, [pc, #20]	; (8007aec <MIOS32_USB_CB_GetConfigDescriptor+0x18>)
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 8007ad8:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 8007ada:	466b      	mov	r3, sp
 8007adc:	c903      	ldmia	r1!, {r0, r1}
 8007ade:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 8007ae2:	4610      	mov	r0, r2
 8007ae4:	4669      	mov	r1, sp
 8007ae6:	f001 ff59 	bl	800999c <Standard_GetDescriptorData>
}
 8007aea:	bd0e      	pop	{r1, r2, r3, pc}
 8007aec:	0800b138 	.word	0x0800b138

08007af0 <MIOS32_USB_CB_GetDeviceDescriptor>:
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 8007af0:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 8007af2:	4905      	ldr	r1, [pc, #20]	; (8007b08 <MIOS32_USB_CB_GetDeviceDescriptor+0x18>)
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 8007af4:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 8007af6:	466b      	mov	r3, sp
 8007af8:	c903      	ldmia	r1!, {r0, r1}
 8007afa:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 8007afe:	4610      	mov	r0, r2
 8007b00:	4669      	mov	r1, sp
 8007b02:	f001 ff4b 	bl	800999c <Standard_GetDescriptorData>
}
 8007b06:	bd0e      	pop	{r1, r2, r3, pc}
 8007b08:	0800b130 	.word	0x0800b130

08007b0c <MIOS32_USB_CB_Reset>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
 8007b0c:	b538      	push	{r3, r4, r5, lr}
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 8007b0e:	4b27      	ldr	r3, [pc, #156]	; (8007bac <MIOS32_USB_CB_Reset+0xa0>)
 8007b10:	2400      	movs	r4, #0
 8007b12:	681b      	ldr	r3, [r3, #0]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007b14:	2580      	movs	r5, #128	; 0x80

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 8007b16:	729c      	strb	r4, [r3, #10]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007b18:	725d      	strb	r5, [r3, #9]

  // Set MIOS32 Device with the default Interface
  pInformation->Current_Interface = 0;
 8007b1a:	72dc      	strb	r4, [r3, #11]

#ifdef STM32F10X_CL   
  // EP0 is already configured in DFU_Init() by USB_SIL_Init() function
#else 
  SetBTABLE(MIOS32_USB_BTABLE_ADDRESS);
 8007b1c:	4620      	mov	r0, r4
 8007b1e:	f002 faab 	bl	800a078 <SetBTABLE>

  // Initialize Endpoint 0
  SetEPType(ENDP0, EP_CONTROL);
 8007b22:	4620      	mov	r0, r4
 8007b24:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007b28:	f002 fab0 	bl	800a08c <SetEPType>
  SetEPTxStatus(ENDP0, EP_TX_STALL);
 8007b2c:	4620      	mov	r0, r4
 8007b2e:	2110      	movs	r1, #16
 8007b30:	f002 fac4 	bl	800a0bc <SetEPTxStatus>
  SetEPRxAddr(ENDP0, MIOS32_USB_ENDP0_RXADDR);
 8007b34:	4620      	mov	r0, r4
 8007b36:	2140      	movs	r1, #64	; 0x40
 8007b38:	f002 fb48 	bl	800a1cc <SetEPRxAddr>
  SetEPTxAddr(ENDP0, MIOS32_USB_ENDP0_TXADDR);
 8007b3c:	4629      	mov	r1, r5
 8007b3e:	4620      	mov	r0, r4
 8007b40:	f002 fb34 	bl	800a1ac <SetEPTxAddr>
  Clear_Status_Out(ENDP0);
 8007b44:	4620      	mov	r0, r4
 8007b46:	f002 faf9 	bl	800a13c <Clear_Status_Out>
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 8007b4a:	4b19      	ldr	r3, [pc, #100]	; (8007bb0 <MIOS32_USB_CB_Reset+0xa4>)
 8007b4c:	4620      	mov	r0, r4
 8007b4e:	681b      	ldr	r3, [r3, #0]
 8007b50:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8007b54:	f002 fb74 	bl	800a240 <SetEPRxCount>
  SetEPRxValid(ENDP0);
 8007b58:	4620      	mov	r0, r4
 8007b5a:	f002 fadd 	bl	800a118 <SetEPRxValid>
  
  // Init EP1 OUT
  OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
# else
  // Initialize Endpoint 1
  SetEPType(ENDP1, EP_BULK);
 8007b5e:	2001      	movs	r0, #1
 8007b60:	4621      	mov	r1, r4
 8007b62:	f002 fa93 	bl	800a08c <SetEPType>

  SetEPTxAddr(ENDP1, MIOS32_USB_ENDP1_TXADDR);
 8007b66:	2001      	movs	r0, #1
 8007b68:	21c0      	movs	r1, #192	; 0xc0
 8007b6a:	f002 fb1f 	bl	800a1ac <SetEPTxAddr>
  SetEPTxCount(ENDP1, MIOS32_USB_MIDI_DATA_OUT_SIZE);
 8007b6e:	2001      	movs	r0, #1
 8007b70:	2140      	movs	r1, #64	; 0x40
 8007b72:	f002 fb57 	bl	800a224 <SetEPTxCount>
  SetEPTxStatus(ENDP1, EP_TX_NAK);
 8007b76:	2001      	movs	r0, #1
 8007b78:	2120      	movs	r1, #32
 8007b7a:	f002 fa9f 	bl	800a0bc <SetEPTxStatus>

  SetEPRxAddr(ENDP1, MIOS32_USB_ENDP1_RXADDR);
 8007b7e:	2001      	movs	r0, #1
 8007b80:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007b84:	f002 fb22 	bl	800a1cc <SetEPRxAddr>
  SetEPRxCount(ENDP1, MIOS32_USB_MIDI_DATA_IN_SIZE);
 8007b88:	2140      	movs	r1, #64	; 0x40
 8007b8a:	2001      	movs	r0, #1
 8007b8c:	f002 fb58 	bl	800a240 <SetEPRxCount>
  SetEPRxValid(ENDP1);
 8007b90:	2001      	movs	r0, #1
 8007b92:	f002 fac1 	bl	800a118 <SetEPRxValid>
# endif
#endif

  // Set this device to response on default address
#ifndef STM32F10X_CL   
  SetDeviceAddress(0);
 8007b96:	4620      	mov	r0, r4
 8007b98:	f002 f932 	bl	8009e00 <SetDeviceAddress>
#endif

#ifndef MIOS32_DONT_USE_USB_MIDI
  // propagate connection state to USB MIDI driver
  MIOS32_USB_MIDI_ChangeConnectionState(0); // not connected
 8007b9c:	4620      	mov	r0, r4
 8007b9e:	f000 f99b 	bl	8007ed8 <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
  // propagate connection state to USB COM driver
  MIOS32_USB_COM_ChangeConnectionState(0); // not connected
#endif

  bDeviceState = ATTACHED;
 8007ba2:	4b04      	ldr	r3, [pc, #16]	; (8007bb4 <MIOS32_USB_CB_Reset+0xa8>)
 8007ba4:	2201      	movs	r2, #1
 8007ba6:	601a      	str	r2, [r3, #0]
}
 8007ba8:	bd38      	pop	{r3, r4, r5, pc}
 8007baa:	bf00      	nop
 8007bac:	2000379c 	.word	0x2000379c
 8007bb0:	20003794 	.word	0x20003794
 8007bb4:	200008a0 	.word	0x200008a0

08007bb8 <USB_LP_CAN1_RX0_IRQHandler>:
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  u16 wIstr = _GetISTR();
 8007bb8:	4b0d      	ldr	r3, [pc, #52]	; (8007bf0 <USB_LP_CAN1_RX0_IRQHandler+0x38>)
  }
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
 8007bba:	b510      	push	{r4, lr}
  u16 wIstr = _GetISTR();
 8007bbc:	681c      	ldr	r4, [r3, #0]
 8007bbe:	b2a4      	uxth	r4, r4

  if( wIstr & ISTR_RESET ) {
 8007bc0:	f414 6f80 	tst.w	r4, #1024	; 0x400
 8007bc4:	d006      	beq.n	8007bd4 <USB_LP_CAN1_RX0_IRQHandler+0x1c>
    _SetISTR((u16)CLR_RESET);
 8007bc6:	f64f 32ff 	movw	r2, #64511	; 0xfbff
 8007bca:	601a      	str	r2, [r3, #0]
    pProperty->Reset();
 8007bcc:	4b09      	ldr	r3, [pc, #36]	; (8007bf4 <USB_LP_CAN1_RX0_IRQHandler+0x3c>)
 8007bce:	681b      	ldr	r3, [r3, #0]
 8007bd0:	685b      	ldr	r3, [r3, #4]
 8007bd2:	4798      	blx	r3
  }

  if( wIstr & ISTR_SOF ) {
 8007bd4:	f414 7f00 	tst.w	r4, #512	; 0x200
    _SetISTR((u16)CLR_SOF);
 8007bd8:	bf1e      	ittt	ne
 8007bda:	4b05      	ldrne	r3, [pc, #20]	; (8007bf0 <USB_LP_CAN1_RX0_IRQHandler+0x38>)
 8007bdc:	f64f 52ff 	movwne	r2, #65023	; 0xfdff
 8007be0:	601a      	strne	r2, [r3, #0]
  }

  if( wIstr & ISTR_CTR ) {
 8007be2:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8007be6:	d001      	beq.n	8007bec <USB_LP_CAN1_RX0_IRQHandler+0x34>
    // servicing of the endpoint correct transfer interrupt
    // clear of the CTR flag into the sub
    CTR_LP();
 8007be8:	f002 f964 	bl	8009eb4 <CTR_LP>
  }
}
 8007bec:	bd10      	pop	{r4, pc}
 8007bee:	bf00      	nop
 8007bf0:	40005c44 	.word	0x40005c44
 8007bf4:	20003794 	.word	0x20003794

08007bf8 <MIOS32_USB_IsInitialized>:
//! This function is used by the bootloader to avoid a reconnection, it isn't
//! relevant for typical applications!
//! \return 1 if USB already initialized, 0 if not initialized
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_IsInitialized(void)
{
 8007bf8:	b508      	push	{r3, lr}
  // we assume that initialisation has been done when B-Session valid flag is set
  __IO USB_OTG_GREGS *GREGS = (USB_OTG_GREGS *)(USB_OTG_FS_BASE_ADDR + USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  return (GREGS->GOTGCTL & (1 << 19));
#else
  // we assume that initialisation has been done when endpoint 0 contains a value
  return GetEPType(ENDP0) ? 1 : 0;
 8007bfa:	2000      	movs	r0, #0
 8007bfc:	f002 fa55 	bl	800a0aa <GetEPType>
 8007c00:	3800      	subs	r0, #0
 8007c02:	bf18      	it	ne
 8007c04:	2001      	movne	r0, #1
#endif
}
 8007c06:	bd08      	pop	{r3, pc}

08007c08 <MIOS32_USB_Init>:
//!   </UL>
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_Init(u32 mode)
{
 8007c08:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007c0a:	4604      	mov	r4, r0
  u32 delay;

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8007c0c:	a801      	add	r0, sp, #4
 8007c0e:	f000 ff4b 	bl	8008aa8 <GPIO_StructInit>

  // currently only mode 0..2 supported
  if( mode >= 3 )
 8007c12:	2c02      	cmp	r4, #2
    return -1; // unsupported mode
 8007c14:	bf88      	it	hi
 8007c16:	f04f 30ff 	movhi.w	r0, #4294967295

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  // currently only mode 0..2 supported
  if( mode >= 3 )
 8007c1a:	d877      	bhi.n	8007d0c <MIOS32_USB_Init+0x104>
    return -1; // unsupported mode

  // clear all USB interrupt requests
#ifdef STM32F10X_CL
#else
  MIOS32_IRQ_Disable();
 8007c1c:	f7fe fd40 	bl	80066a0 <MIOS32_IRQ_Disable>
  _SetCNTR(0); // Interrupt Mask
 8007c20:	4b3b      	ldr	r3, [pc, #236]	; (8007d10 <MIOS32_USB_Init+0x108>)
 8007c22:	2200      	movs	r2, #0
 8007c24:	601a      	str	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 8007c26:	f7fe fd51 	bl	80066cc <MIOS32_IRQ_Enable>
#endif

  // if mode != 2: install MIOS32 hooks
  // a local driver can install it's own hooks and call MIOS32_USB_Init(2) to force re-enumeration
  if( mode != 2 ) {
 8007c2a:	2c02      	cmp	r4, #2
 8007c2c:	d013      	beq.n	8007c56 <MIOS32_USB_Init+0x4e>
    pInformation = &My_Device_Info; // Note: usually no need to duplicate this for external drivers
 8007c2e:	4a39      	ldr	r2, [pc, #228]	; (8007d14 <MIOS32_USB_Init+0x10c>)
 8007c30:	4b39      	ldr	r3, [pc, #228]	; (8007d18 <MIOS32_USB_Init+0x110>)
 8007c32:	601a      	str	r2, [r3, #0]

    // following hooks/pointers should be replaced by external drivers
    memcpy(&Device_Table, (DEVICE *)&My_Device_Table, sizeof(Device_Table));
 8007c34:	4b39      	ldr	r3, [pc, #228]	; (8007d1c <MIOS32_USB_Init+0x114>)
 8007c36:	2205      	movs	r2, #5
 8007c38:	701a      	strb	r2, [r3, #0]
 8007c3a:	2201      	movs	r2, #1
 8007c3c:	705a      	strb	r2, [r3, #1]
    pProperty = (DEVICE_PROP *)&My_Device_Property;
 8007c3e:	4a38      	ldr	r2, [pc, #224]	; (8007d20 <MIOS32_USB_Init+0x118>)
 8007c40:	4b38      	ldr	r3, [pc, #224]	; (8007d24 <MIOS32_USB_Init+0x11c>)
 8007c42:	601a      	str	r2, [r3, #0]
    pUser_Standard_Requests = (USER_STANDARD_REQUESTS *)&My_User_Standard_Requests;
 8007c44:	4a38      	ldr	r2, [pc, #224]	; (8007d28 <MIOS32_USB_Init+0x120>)
 8007c46:	4b39      	ldr	r3, [pc, #228]	; (8007d2c <MIOS32_USB_Init+0x124>)
 8007c48:	601a      	str	r2, [r3, #0]

#ifndef MIOS32_DONT_USE_USB_MIDI
    pEpInt_IN[0]  = MIOS32_USB_MIDI_EP1_IN_Callback;  // IN  EP1
 8007c4a:	4a39      	ldr	r2, [pc, #228]	; (8007d30 <MIOS32_USB_Init+0x128>)
 8007c4c:	4b39      	ldr	r3, [pc, #228]	; (8007d34 <MIOS32_USB_Init+0x12c>)
 8007c4e:	601a      	str	r2, [r3, #0]
    pEpInt_OUT[0] = MIOS32_USB_MIDI_EP1_OUT_Callback; // OUT EP1
 8007c50:	4a39      	ldr	r2, [pc, #228]	; (8007d38 <MIOS32_USB_Init+0x130>)
 8007c52:	4b3a      	ldr	r3, [pc, #232]	; (8007d3c <MIOS32_USB_Init+0x134>)
 8007c54:	601a      	str	r2, [r3, #0]
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 8007c56:	4d30      	ldr	r5, [pc, #192]	; (8007d18 <MIOS32_USB_Init+0x110>)
#endif
  }

  // change connection state to disconnected
#ifndef MIOS32_DONT_USE_USB_MIDI
  MIOS32_USB_MIDI_ChangeConnectionState(0);
 8007c58:	2000      	movs	r0, #0
 8007c5a:	f000 f93d 	bl	8007ed8 <MIOS32_USB_MIDI_ChangeConnectionState>
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 8007c5e:	682b      	ldr	r3, [r5, #0]
 8007c60:	2202      	movs	r2, #2
 8007c62:	721a      	strb	r2, [r3, #8]
  pInformation->Current_Configuration = 0;
 8007c64:	2200      	movs	r2, #0
 8007c66:	729a      	strb	r2, [r3, #10]

  // if mode == 0: don't initialize USB if not required (important for BSL)
  if( mode == 0 && MIOS32_USB_IsInitialized() ) {
 8007c68:	b99c      	cbnz	r4, 8007c92 <MIOS32_USB_Init+0x8a>
 8007c6a:	f7ff ffc5 	bl	8007bf8 <MIOS32_USB_IsInitialized>
 8007c6e:	b180      	cbz	r0, 8007c92 <MIOS32_USB_Init+0x8a>
    // Init EP1 OUT again
    OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
#else
#ifndef MIOS32_DONT_USE_USB_MIDI
    // release ENDP1 Rx/Tx
    SetEPTxStatus(ENDP1, EP_TX_NAK);
 8007c70:	2001      	movs	r0, #1
 8007c72:	2120      	movs	r1, #32
 8007c74:	f002 fa22 	bl	800a0bc <SetEPTxStatus>
    SetEPRxValid(ENDP1);
 8007c78:	2001      	movs	r0, #1
 8007c7a:	f002 fa4d 	bl	800a118 <SetEPRxValid>
#endif
#endif

    pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007c7e:	682b      	ldr	r3, [r5, #0]
 8007c80:	2280      	movs	r2, #128	; 0x80
 8007c82:	725a      	strb	r2, [r3, #9]
    pInformation->Current_Configuration = 1;
 8007c84:	2201      	movs	r2, #1
 8007c86:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 8007c88:	4b28      	ldr	r3, [pc, #160]	; (8007d2c <MIOS32_USB_Init+0x124>)
 8007c8a:	681b      	ldr	r3, [r3, #0]
 8007c8c:	685b      	ldr	r3, [r3, #4]
 8007c8e:	4798      	blx	r3
 8007c90:	e02d      	b.n	8007cee <MIOS32_USB_Init+0xe6>
    
    // connect device
    USB_DevConnect();
#else
    // force USB reset and power-down (this will also release the USB pins for direct GPIO control)
    _SetCNTR(CNTR_FRES | CNTR_PDWN);
 8007c92:	4a1f      	ldr	r2, [pc, #124]	; (8007d10 <MIOS32_USB_Init+0x108>)
 8007c94:	2303      	movs	r3, #3
 8007c96:	6013      	str	r3, [r2, #0]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8007c98:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8007c9c:	f8ad 2004 	strh.w	r2, [sp, #4]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007ca0:	a901      	add	r1, sp, #4
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007ca2:	2210      	movs	r2, #16
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007ca4:	4826      	ldr	r0, [pc, #152]	; (8007d40 <MIOS32_USB_Init+0x138>)
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007ca6:	f88d 2007 	strb.w	r2, [sp, #7]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007caa:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007cae:	f000 fea2 	bl	80089f6 <GPIO_Init>
 8007cb2:	4b24      	ldr	r3, [pc, #144]	; (8007d44 <MIOS32_USB_Init+0x13c>)

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 8007cb4:	4922      	ldr	r1, [pc, #136]	; (8007d40 <MIOS32_USB_Init+0x138>)
 8007cb6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 8007cba:	f113 33ff 	adds.w	r3, r3, #4294967295
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 8007cbe:	614a      	str	r2, [r1, #20]
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 8007cc0:	d1fb      	bne.n	8007cba <MIOS32_USB_Init+0xb2>
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 8007cc2:	4a13      	ldr	r2, [pc, #76]	; (8007d10 <MIOS32_USB_Init+0x108>)
 8007cc4:	2102      	movs	r1, #2
 8007cc6:	6011      	str	r1, [r2, #0]

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 8007cc8:	4a1d      	ldr	r2, [pc, #116]	; (8007d40 <MIOS32_USB_Init+0x138>)
    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 8007cca:	200a      	movs	r0, #10

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 8007ccc:	f110 30ff 	adds.w	r0, r0, #4294967295
 8007cd0:	6153      	str	r3, [r2, #20]
 8007cd2:	d1fb      	bne.n	8007ccc <MIOS32_USB_Init+0xc4>

    // CNTR_FRES = 0
    _SetCNTR(0);
 8007cd4:	4b0e      	ldr	r3, [pc, #56]	; (8007d10 <MIOS32_USB_Init+0x108>)
 8007cd6:	6018      	str	r0, [r3, #0]

    // Clear pending interrupts
    _SetISTR(0);
 8007cd8:	3304      	adds	r3, #4
 8007cda:	6018      	str	r0, [r3, #0]

    // Configure USB clock
    // USBCLK = PLLCLK / 1.5
    RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
 8007cdc:	f001 fada 	bl	8009294 <RCC_USBCLKConfig>
    // Enable USB clock
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
 8007ce0:	2101      	movs	r1, #1
 8007ce2:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8007ce6:	f001 fb63 	bl	80093b0 <RCC_APB1PeriphClockCmd>
#endif /* STM32F10X_CL */

  }

  // don't set interrupt mask on custom driver installation
  if( mode != 2 ) {
 8007cea:	2c02      	cmp	r4, #2
 8007cec:	d006      	beq.n	8007cfc <MIOS32_USB_Init+0xf4>
#ifdef STM32F10X_CL
    OTGD_FS_EnableGlobalInt();
#else
    // clear pending interrupts (again)
    _SetISTR(0);
 8007cee:	4b16      	ldr	r3, [pc, #88]	; (8007d48 <MIOS32_USB_Init+0x140>)
 8007cf0:	2200      	movs	r2, #0
 8007cf2:	601a      	str	r2, [r3, #0]

    // set interrupts mask
    _SetCNTR(IMR_MSK); // Interrupt mask
 8007cf4:	f502 4204 	add.w	r2, r2, #33792	; 0x8400
 8007cf8:	3b04      	subs	r3, #4
 8007cfa:	601a      	str	r2, [r3, #0]
#endif
  }

  bDeviceState = UNCONNECTED;
 8007cfc:	4b13      	ldr	r3, [pc, #76]	; (8007d4c <MIOS32_USB_Init+0x144>)
 8007cfe:	2400      	movs	r4, #0
 8007d00:	601c      	str	r4, [r3, #0]
#ifdef STM32F10X_CL
  // Enable the USB interrupts
  MIOS32_IRQ_Install(OTG_FS_IRQn, MIOS32_IRQ_USB_PRIORITY);
#else
  // enable USB interrupts (unfortunately shared with CAN Rx0, as either CAN or USB can be used, but not at the same time)
  MIOS32_IRQ_Install(USB_LP_CAN1_RX0_IRQn, MIOS32_IRQ_USB_PRIORITY);
 8007d02:	2014      	movs	r0, #20
 8007d04:	2108      	movs	r1, #8
 8007d06:	f7fe fcf3 	bl	80066f0 <MIOS32_IRQ_Install>
#endif

  return 0; // no error
 8007d0a:	4620      	mov	r0, r4
}
 8007d0c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8007d0e:	bf00      	nop
 8007d10:	40005c40 	.word	0x40005c40
 8007d14:	200008a4 	.word	0x200008a4
 8007d18:	2000379c 	.word	0x2000379c
 8007d1c:	200037a0 	.word	0x200037a0
 8007d20:	0800b0f4 	.word	0x0800b0f4
 8007d24:	20003794 	.word	0x20003794
 8007d28:	0800b0bc 	.word	0x0800b0bc
 8007d2c:	20003798 	.word	0x20003798
 8007d30:	0800804d 	.word	0x0800804d
 8007d34:	2000000c 	.word	0x2000000c
 8007d38:	08008061 	.word	0x08008061
 8007d3c:	20000028 	.word	0x20000028
 8007d40:	40010800 	.word	0x40010800
 8007d44:	00030d40 	.word	0x00030d40
 8007d48:	40005c44 	.word	0x40005c44
 8007d4c:	200008a0 	.word	0x200008a0

08007d50 <MIOS32_USB_MIDI_RxBufferHandler>:

/////////////////////////////////////////////////////////////////////////////
// This handler receives new packages if the Tx buffer is not full
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_RxBufferHandler(void)
{
 8007d50:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  s16 count;

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 8007d52:	f7fe fca5 	bl	80066a0 <MIOS32_IRQ_Disable>

      OTGD_FS_EPStartXfer(ep);
    }
  }
#else
  if( rx_buffer_new_data && (count=GetEPRxCount(ENDP1)>>2) ) {
 8007d56:	4b23      	ldr	r3, [pc, #140]	; (8007de4 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 8007d58:	781b      	ldrb	r3, [r3, #0]
 8007d5a:	2b00      	cmp	r3, #0
 8007d5c:	d03f      	beq.n	8007dde <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007d5e:	2001      	movs	r0, #1
 8007d60:	f002 fa8e 	bl	800a280 <GetEPRxCount>
 8007d64:	f3c0 058f 	ubfx	r5, r0, #2, #16
 8007d68:	2d00      	cmp	r5, #0
 8007d6a:	d038      	beq.n	8007dde <MIOS32_USB_MIDI_RxBufferHandler+0x8e>

    // check if buffer is free
    if( count < (MIOS32_USB_MIDI_RX_BUFFER_SIZE-rx_buffer_size) ) {
 8007d6c:	4b1e      	ldr	r3, [pc, #120]	; (8007de8 <MIOS32_USB_MIDI_RxBufferHandler+0x98>)
 8007d6e:	b229      	sxth	r1, r5
 8007d70:	881a      	ldrh	r2, [r3, #0]
 8007d72:	b292      	uxth	r2, r2
 8007d74:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
 8007d78:	4291      	cmp	r1, r2
 8007d7a:	da30      	bge.n	8007dde <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007d7c:	4e1b      	ldr	r6, [pc, #108]	; (8007dec <MIOS32_USB_MIDI_RxBufferHandler+0x9c>)
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007d7e:	4c1c      	ldr	r4, [pc, #112]	; (8007df0 <MIOS32_USB_MIDI_RxBufferHandler+0xa0>)
 8007d80:	4a1c      	ldr	r2, [pc, #112]	; (8007df4 <MIOS32_USB_MIDI_RxBufferHandler+0xa4>)
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007d82:	f836 1c08 	ldrh.w	r1, [r6, #-8]
 8007d86:	f836 7c04 	ldrh.w	r7, [r6, #-4]

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8007d8a:	9201      	str	r2, [sp, #4]
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007d8c:	ea41 4707 	orr.w	r7, r1, r7, lsl #16

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8007d90:	f3c7 1003 	ubfx	r0, r7, #4, #4
 8007d94:	3010      	adds	r0, #16
 8007d96:	4639      	mov	r1, r7
 8007d98:	9300      	str	r3, [sp, #0]
 8007d9a:	f7fe f8ed 	bl	8005f78 <MIOS32_MIDI_SendPackageToRxCallback>
 8007d9e:	9a01      	ldr	r2, [sp, #4]
 8007da0:	9b00      	ldr	r3, [sp, #0]
 8007da2:	b980      	cbnz	r0, 8007dc6 <MIOS32_USB_MIDI_RxBufferHandler+0x76>
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007da4:	8821      	ldrh	r1, [r4, #0]
 8007da6:	b289      	uxth	r1, r1
 8007da8:	f842 7021 	str.w	r7, [r2, r1, lsl #2]

	  if( ++rx_buffer_head >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8007dac:	8821      	ldrh	r1, [r4, #0]
 8007dae:	3101      	adds	r1, #1
 8007db0:	b289      	uxth	r1, r1
 8007db2:	8021      	strh	r1, [r4, #0]
 8007db4:	8821      	ldrh	r1, [r4, #0]
 8007db6:	b289      	uxth	r1, r1
 8007db8:	293f      	cmp	r1, #63	; 0x3f
	    rx_buffer_head = 0;
 8007dba:	bf88      	it	hi
 8007dbc:	8020      	strhhi	r0, [r4, #0]
	  ++rx_buffer_size;
 8007dbe:	8819      	ldrh	r1, [r3, #0]
 8007dc0:	3101      	adds	r1, #1
 8007dc2:	b289      	uxth	r1, r1
 8007dc4:	8019      	strh	r1, [r3, #0]
	}
      } while( --count > 0 );
 8007dc6:	3d01      	subs	r5, #1
 8007dc8:	b2ad      	uxth	r5, r5
 8007dca:	b229      	sxth	r1, r5
 8007dcc:	3608      	adds	r6, #8
 8007dce:	2900      	cmp	r1, #0
 8007dd0:	dcd7      	bgt.n	8007d82 <MIOS32_USB_MIDI_RxBufferHandler+0x32>

      // notify, that data has been put into buffer
      rx_buffer_new_data = 0;
 8007dd2:	4b04      	ldr	r3, [pc, #16]	; (8007de4 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 8007dd4:	2200      	movs	r2, #0
 8007dd6:	701a      	strb	r2, [r3, #0]

      // release OUT pipe
      SetEPRxValid(ENDP1);
 8007dd8:	2001      	movs	r0, #1
 8007dda:	f002 f99d 	bl	800a118 <SetEPRxValid>
    }
  }
#endif
  MIOS32_IRQ_Enable();
 8007dde:	f7fe fc75 	bl	80066cc <MIOS32_IRQ_Enable>
}
 8007de2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007de4:	20000ac8 	.word	0x20000ac8
 8007de8:	200008c0 	.word	0x200008c0
 8007dec:	40006208 	.word	0x40006208
 8007df0:	20000aca 	.word	0x20000aca
 8007df4:	200009c8 	.word	0x200009c8

08007df8 <MIOS32_USB_MIDI_TxBufferHandler>:
/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
{
 8007df8:	b510      	push	{r4, lr}
  //   - last transfer finished
  //   - new packages are in the buffer
  //   - the device is configured

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 8007dfa:	f7fe fc51 	bl	80066a0 <MIOS32_IRQ_Disable>
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
	tx_buffer_tail = 0;
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
 8007dfe:	4b2c      	ldr	r3, [pc, #176]	; (8007eb0 <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
 8007e00:	781b      	ldrb	r3, [r3, #0]
 8007e02:	2b00      	cmp	r3, #0
 8007e04:	d150      	bne.n	8007ea8 <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 8007e06:	4b2b      	ldr	r3, [pc, #172]	; (8007eb4 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)
 8007e08:	881a      	ldrh	r2, [r3, #0]
 8007e0a:	b292      	uxth	r2, r2
 8007e0c:	2a00      	cmp	r2, #0
 8007e0e:	d04b      	beq.n	8007ea8 <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 8007e10:	4a29      	ldr	r2, [pc, #164]	; (8007eb8 <MIOS32_USB_MIDI_TxBufferHandler+0xc0>)
 8007e12:	7812      	ldrb	r2, [r2, #0]
 8007e14:	2a00      	cmp	r2, #0
 8007e16:	d047      	beq.n	8007ea8 <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8007e18:	881a      	ldrh	r2, [r3, #0]
 8007e1a:	b292      	uxth	r2, r2
 8007e1c:	2a10      	cmp	r2, #16
 8007e1e:	bf98      	it	ls
 8007e20:	881c      	ldrhls	r4, [r3, #0]

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007e22:	4b23      	ldr	r3, [pc, #140]	; (8007eb0 <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8007e24:	bf94      	ite	ls
 8007e26:	b2a4      	uxthls	r4, r4
 8007e28:	2410      	movhi	r4, #16

    // notify that new package is sent
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007e2a:	b2a4      	uxth	r4, r4
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007e2c:	2001      	movs	r0, #1

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007e2e:	00a1      	lsls	r1, r4, #2
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007e30:	7018      	strb	r0, [r3, #0]

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007e32:	b289      	uxth	r1, r1
 8007e34:	f002 f9f6 	bl	800a224 <SetEPTxCount>

    tx_buffer_size -= count;
 8007e38:	4b1e      	ldr	r3, [pc, #120]	; (8007eb4 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007e3a:	4920      	ldr	r1, [pc, #128]	; (8007ebc <MIOS32_USB_MIDI_TxBufferHandler+0xc4>)
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);

    tx_buffer_size -= count;
 8007e3c:	881a      	ldrh	r2, [r3, #0]
 8007e3e:	1b12      	subs	r2, r2, r4
 8007e40:	b292      	uxth	r2, r2
 8007e42:	801a      	strh	r2, [r3, #0]

/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
 8007e44:	3c01      	subs	r4, #1
 8007e46:	4b1e      	ldr	r3, [pc, #120]	; (8007ec0 <MIOS32_USB_MIDI_TxBufferHandler+0xc8>)
 8007e48:	b2a4      	uxth	r4, r4
 8007e4a:	18e3      	adds	r3, r4, r3
 8007e4c:	00d8      	lsls	r0, r3, #3
 8007e4e:	4a1d      	ldr	r2, [pc, #116]	; (8007ec4 <MIOS32_USB_MIDI_TxBufferHandler+0xcc>)

    tx_buffer_size -= count;

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007e50:	4b1d      	ldr	r3, [pc, #116]	; (8007ec8 <MIOS32_USB_MIDI_TxBufferHandler+0xd0>)
 8007e52:	f8b3 c000 	ldrh.w	ip, [r3]
 8007e56:	fa1f fc8c 	uxth.w	ip, ip
 8007e5a:	f831 c02c 	ldrh.w	ip, [r1, ip, lsl #2]
 8007e5e:	f842 cc08 	str.w	ip, [r2, #-8]
      *pma_addr++ = (tx_buffer[tx_buffer_tail]>>16) & 0xffff;
 8007e62:	f8b3 c000 	ldrh.w	ip, [r3]
 8007e66:	fa1f fc8c 	uxth.w	ip, ip
 8007e6a:	f851 c02c 	ldr.w	ip, [r1, ip, lsl #2]
 8007e6e:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8007e72:	f842 cc04 	str.w	ip, [r2, #-4]
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007e76:	f8b3 c000 	ldrh.w	ip, [r3]
 8007e7a:	f10c 0c01 	add.w	ip, ip, #1
 8007e7e:	fa1f fc8c 	uxth.w	ip, ip
 8007e82:	f8a3 c000 	strh.w	ip, [r3]
 8007e86:	f8b3 c000 	ldrh.w	ip, [r3]
 8007e8a:	fa1f fc8c 	uxth.w	ip, ip
 8007e8e:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
	tx_buffer_tail = 0;
 8007e92:	bf84      	itt	hi
 8007e94:	f04f 0c00 	movhi.w	ip, #0
 8007e98:	f8a3 c000 	strhhi.w	ip, [r3]
 8007e9c:	3208      	adds	r2, #8
    } while( --count );
 8007e9e:	4282      	cmp	r2, r0
 8007ea0:	d1d7      	bne.n	8007e52 <MIOS32_USB_MIDI_TxBufferHandler+0x5a>

    // send buffer
    SetEPTxValid(ENDP1);
 8007ea2:	2001      	movs	r0, #1
 8007ea4:	f002 f926 	bl	800a0f4 <SetEPTxValid>
  }
#endif
  MIOS32_IRQ_Enable();
 8007ea8:	f7fe fc10 	bl	80066cc <MIOS32_IRQ_Enable>
}
 8007eac:	bd10      	pop	{r4, pc}
 8007eae:	bf00      	nop
 8007eb0:	200009c4 	.word	0x200009c4
 8007eb4:	20000acc 	.word	0x20000acc
 8007eb8:	20000ad2 	.word	0x20000ad2
 8007ebc:	200008c4 	.word	0x200008c4
 8007ec0:	08000c32 	.word	0x08000c32
 8007ec4:	40006188 	.word	0x40006188
 8007ec8:	20000ace 	.word	0x20000ace

08007ecc <MIOS32_USB_MIDI_Init>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007ecc:	2800      	cmp	r0, #0
 8007ece:	bf14      	ite	ne
 8007ed0:	f04f 30ff 	movne.w	r0, #4294967295
 8007ed4:	2000      	moveq	r0, #0

  return 0; // no error
}
 8007ed6:	4770      	bx	lr

08007ed8 <MIOS32_USB_MIDI_ChangeConnectionState>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_ChangeConnectionState(u8 connected)
{
  // in all cases: re-initialize USB MIDI driver
  // clear buffer counters and busy/wait signals again (e.g., so that no invalid data will be sent out)
  rx_buffer_tail = rx_buffer_head = rx_buffer_size = 0;
 8007ed8:	4a10      	ldr	r2, [pc, #64]	; (8007f1c <MIOS32_USB_MIDI_ChangeConnectionState+0x44>)
 8007eda:	2300      	movs	r3, #0
 8007edc:	8013      	strh	r3, [r2, #0]
 8007ede:	8811      	ldrh	r1, [r2, #0]
 8007ee0:	4a0f      	ldr	r2, [pc, #60]	; (8007f20 <MIOS32_USB_MIDI_ChangeConnectionState+0x48>)
 8007ee2:	b289      	uxth	r1, r1
 8007ee4:	8011      	strh	r1, [r2, #0]
 8007ee6:	8811      	ldrh	r1, [r2, #0]
 8007ee8:	4a0e      	ldr	r2, [pc, #56]	; (8007f24 <MIOS32_USB_MIDI_ChangeConnectionState+0x4c>)
 8007eea:	b289      	uxth	r1, r1
 8007eec:	8011      	strh	r1, [r2, #0]
  rx_buffer_new_data = 0; // no data received yet
 8007eee:	4a0e      	ldr	r2, [pc, #56]	; (8007f28 <MIOS32_USB_MIDI_ChangeConnectionState+0x50>)
 8007ef0:	7013      	strb	r3, [r2, #0]
  tx_buffer_tail = tx_buffer_head = tx_buffer_size = 0;
 8007ef2:	4a0e      	ldr	r2, [pc, #56]	; (8007f2c <MIOS32_USB_MIDI_ChangeConnectionState+0x54>)
 8007ef4:	8013      	strh	r3, [r2, #0]
 8007ef6:	8811      	ldrh	r1, [r2, #0]
 8007ef8:	4a0d      	ldr	r2, [pc, #52]	; (8007f30 <MIOS32_USB_MIDI_ChangeConnectionState+0x58>)
 8007efa:	b289      	uxth	r1, r1
 8007efc:	8011      	strh	r1, [r2, #0]
 8007efe:	8811      	ldrh	r1, [r2, #0]
 8007f00:	4a0c      	ldr	r2, [pc, #48]	; (8007f34 <MIOS32_USB_MIDI_ChangeConnectionState+0x5c>)
 8007f02:	b289      	uxth	r1, r1
 8007f04:	8011      	strh	r1, [r2, #0]
 8007f06:	490c      	ldr	r1, [pc, #48]	; (8007f38 <MIOS32_USB_MIDI_ChangeConnectionState+0x60>)
 8007f08:	4a0c      	ldr	r2, [pc, #48]	; (8007f3c <MIOS32_USB_MIDI_ChangeConnectionState+0x64>)

  if( connected ) {
 8007f0a:	b110      	cbz	r0, 8007f12 <MIOS32_USB_MIDI_ChangeConnectionState+0x3a>
    transfer_possible = 1;
 8007f0c:	2001      	movs	r0, #1
 8007f0e:	7008      	strb	r0, [r1, #0]
 8007f10:	e001      	b.n	8007f16 <MIOS32_USB_MIDI_ChangeConnectionState+0x3e>
    tx_buffer_busy = 0; // buffer not busy anymore
  } else {
    // cable disconnected: disable transfers
    transfer_possible = 0;
 8007f12:	700b      	strb	r3, [r1, #0]
    tx_buffer_busy = 1; // buffer busy
 8007f14:	2301      	movs	r3, #1
 8007f16:	7013      	strb	r3, [r2, #0]
  }

  return 0; // no error
}
 8007f18:	2000      	movs	r0, #0
 8007f1a:	4770      	bx	lr
 8007f1c:	200008c0 	.word	0x200008c0
 8007f20:	20000aca 	.word	0x20000aca
 8007f24:	200008c2 	.word	0x200008c2
 8007f28:	20000ac8 	.word	0x20000ac8
 8007f2c:	20000acc 	.word	0x20000acc
 8007f30:	20000ad4 	.word	0x20000ad4
 8007f34:	20000ace 	.word	0x20000ace
 8007f38:	20000ad2 	.word	0x20000ad2
 8007f3c:	200009c4 	.word	0x200009c4

08007f40 <MIOS32_USB_MIDI_PackageSend_NonBlocking>:
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007f40:	b538      	push	{r3, r4, r5, lr}
  // device available?
  if( !transfer_possible )
 8007f42:	4d17      	ldr	r5, [pc, #92]	; (8007fa0 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x60>)
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007f44:	4604      	mov	r4, r0
  // device available?
  if( !transfer_possible )
 8007f46:	782b      	ldrb	r3, [r5, #0]
    return -1;
 8007f48:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
  // device available?
  if( !transfer_possible )
 8007f4c:	b33b      	cbz	r3, 8007f9e <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    return -1;

  // buffer full?
  if( tx_buffer_size >= (MIOS32_USB_MIDI_TX_BUFFER_SIZE-1) ) {
 8007f4e:	4b15      	ldr	r3, [pc, #84]	; (8007fa4 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007f50:	881b      	ldrh	r3, [r3, #0]
 8007f52:	b29b      	uxth	r3, r3
 8007f54:	2b3e      	cmp	r3, #62	; 0x3e
 8007f56:	d909      	bls.n	8007f6c <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x2c>
    // call USB handler, so that we are able to get the buffer free again on next execution
    // (this call simplifies polling loops!)
    MIOS32_USB_MIDI_TxBufferHandler();
 8007f58:	f7ff ff4e 	bl	8007df8 <MIOS32_USB_MIDI_TxBufferHandler>

    // device still available?
    // (ensures that polling loop terminates if cable has been disconnected)
    if( !transfer_possible )
 8007f5c:	782b      	ldrb	r3, [r5, #0]
 8007f5e:	2b00      	cmp	r3, #0
      return -1;
 8007f60:	bf14      	ite	ne
 8007f62:	f06f 0001 	mvnne.w	r0, #1
 8007f66:	f04f 30ff 	moveq.w	r0, #4294967295
 8007f6a:	e018      	b.n	8007f9e <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    // notify that buffer was full (request retry)
    return -2;
  }

  // put package into buffer - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007f6c:	f7fe fb98 	bl	80066a0 <MIOS32_IRQ_Disable>
  tx_buffer[tx_buffer_head++] = package.ALL;
 8007f70:	4b0d      	ldr	r3, [pc, #52]	; (8007fa8 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x68>)
 8007f72:	490e      	ldr	r1, [pc, #56]	; (8007fac <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x6c>)
 8007f74:	881a      	ldrh	r2, [r3, #0]
 8007f76:	b292      	uxth	r2, r2
 8007f78:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
 8007f7c:	3201      	adds	r2, #1
 8007f7e:	b292      	uxth	r2, r2
 8007f80:	801a      	strh	r2, [r3, #0]
  if( tx_buffer_head >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007f82:	881a      	ldrh	r2, [r3, #0]
 8007f84:	b292      	uxth	r2, r2
 8007f86:	2a3f      	cmp	r2, #63	; 0x3f
 8007f88:	d901      	bls.n	8007f8e <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x4e>
    tx_buffer_head = 0;
 8007f8a:	2200      	movs	r2, #0
 8007f8c:	801a      	strh	r2, [r3, #0]
  ++tx_buffer_size;
 8007f8e:	4b05      	ldr	r3, [pc, #20]	; (8007fa4 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007f90:	881a      	ldrh	r2, [r3, #0]
 8007f92:	3201      	adds	r2, #1
 8007f94:	b292      	uxth	r2, r2
 8007f96:	801a      	strh	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 8007f98:	f7fe fb98 	bl	80066cc <MIOS32_IRQ_Enable>

  return 0;
 8007f9c:	2000      	movs	r0, #0
}
 8007f9e:	bd38      	pop	{r3, r4, r5, pc}
 8007fa0:	20000ad2 	.word	0x20000ad2
 8007fa4:	20000acc 	.word	0x20000acc
 8007fa8:	20000ad4 	.word	0x20000ad4
 8007fac:	200008c4 	.word	0x200008c4

08007fb0 <MIOS32_USB_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: USB not connected
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend(mios32_midi_package_t package)
{
 8007fb0:	b570      	push	{r4, r5, r6, lr}
 8007fb2:	4606      	mov	r6, r0
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
    if( timeout_ctr >= 10000 )
 8007fb4:	4c0a      	ldr	r4, [pc, #40]	; (8007fe0 <MIOS32_USB_MIDI_PackageSend+0x30>)
 8007fb6:	f242 750f 	movw	r5, #9999	; 0x270f
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8007fba:	e004      	b.n	8007fc6 <MIOS32_USB_MIDI_PackageSend+0x16>
    if( timeout_ctr >= 10000 )
 8007fbc:	8823      	ldrh	r3, [r4, #0]
 8007fbe:	42ab      	cmp	r3, r5
 8007fc0:	d80c      	bhi.n	8007fdc <MIOS32_USB_MIDI_PackageSend+0x2c>
      break;
    ++timeout_ctr;
 8007fc2:	3301      	adds	r3, #1
 8007fc4:	8023      	strh	r3, [r4, #0]
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8007fc6:	4630      	mov	r0, r6
 8007fc8:	f7ff ffba 	bl	8007f40 <MIOS32_USB_MIDI_PackageSend_NonBlocking>
 8007fcc:	f110 0f02 	cmn.w	r0, #2
 8007fd0:	d0f4      	beq.n	8007fbc <MIOS32_USB_MIDI_PackageSend+0xc>
    if( timeout_ctr >= 10000 )
      break;
    ++timeout_ctr;
  }

  if( error >= 0 ) // no error: reset timeout counter
 8007fd2:	2800      	cmp	r0, #0
 8007fd4:	db02      	blt.n	8007fdc <MIOS32_USB_MIDI_PackageSend+0x2c>
    timeout_ctr = 0;
 8007fd6:	4b02      	ldr	r3, [pc, #8]	; (8007fe0 <MIOS32_USB_MIDI_PackageSend+0x30>)
 8007fd8:	2200      	movs	r2, #0
 8007fda:	801a      	strh	r2, [r3, #0]

  return error;
}
 8007fdc:	bd70      	pop	{r4, r5, r6, pc}
 8007fde:	bf00      	nop
 8007fe0:	20000ad0 	.word	0x20000ad0

08007fe4 <MIOS32_USB_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8007fe4:	4b12      	ldr	r3, [pc, #72]	; (8008030 <MIOS32_USB_MIDI_PackageReceive+0x4c>)
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 8007fe6:	b510      	push	{r4, lr}
  // package received?
  if( !rx_buffer_size )
 8007fe8:	881b      	ldrh	r3, [r3, #0]
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 8007fea:	4604      	mov	r4, r0
  // package received?
  if( !rx_buffer_size )
 8007fec:	b29b      	uxth	r3, r3
    return -1;
 8007fee:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8007ff2:	b1db      	cbz	r3, 800802c <MIOS32_USB_MIDI_PackageReceive+0x48>
    return -1;

  // get package - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007ff4:	f7fe fb54 	bl	80066a0 <MIOS32_IRQ_Disable>
  package->ALL = rx_buffer[rx_buffer_tail];
 8007ff8:	4b0e      	ldr	r3, [pc, #56]	; (8008034 <MIOS32_USB_MIDI_PackageReceive+0x50>)
 8007ffa:	4a0f      	ldr	r2, [pc, #60]	; (8008038 <MIOS32_USB_MIDI_PackageReceive+0x54>)
 8007ffc:	8819      	ldrh	r1, [r3, #0]
 8007ffe:	b289      	uxth	r1, r1
 8008000:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8008004:	6022      	str	r2, [r4, #0]
  if( ++rx_buffer_tail >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8008006:	881a      	ldrh	r2, [r3, #0]
 8008008:	3201      	adds	r2, #1
 800800a:	b292      	uxth	r2, r2
 800800c:	801a      	strh	r2, [r3, #0]
 800800e:	881a      	ldrh	r2, [r3, #0]
 8008010:	b292      	uxth	r2, r2
 8008012:	2a3f      	cmp	r2, #63	; 0x3f
 8008014:	d901      	bls.n	800801a <MIOS32_USB_MIDI_PackageReceive+0x36>
    rx_buffer_tail = 0;
 8008016:	2200      	movs	r2, #0
 8008018:	801a      	strh	r2, [r3, #0]
  --rx_buffer_size;
 800801a:	4c05      	ldr	r4, [pc, #20]	; (8008030 <MIOS32_USB_MIDI_PackageReceive+0x4c>)
 800801c:	8823      	ldrh	r3, [r4, #0]
 800801e:	3b01      	subs	r3, #1
 8008020:	b29b      	uxth	r3, r3
 8008022:	8023      	strh	r3, [r4, #0]
  MIOS32_IRQ_Enable();
 8008024:	f7fe fb52 	bl	80066cc <MIOS32_IRQ_Enable>

  return rx_buffer_size;
 8008028:	8820      	ldrh	r0, [r4, #0]
 800802a:	b280      	uxth	r0, r0
}
 800802c:	bd10      	pop	{r4, pc}
 800802e:	bf00      	nop
 8008030:	200008c0 	.word	0x200008c0
 8008034:	200008c2 	.word	0x200008c2
 8008038:	200009c8 	.word	0x200009c8

0800803c <MIOS32_USB_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Periodic_mS(void)
{
 800803c:	b508      	push	{r3, lr}
  // check for received packages
  MIOS32_USB_MIDI_RxBufferHandler();
 800803e:	f7ff fe87 	bl	8007d50 <MIOS32_USB_MIDI_RxBufferHandler>

  // check for packages which should be transmitted
  MIOS32_USB_MIDI_TxBufferHandler();
 8008042:	f7ff fed9 	bl	8007df8 <MIOS32_USB_MIDI_TxBufferHandler>

  return 0;
}
 8008046:	2000      	movs	r0, #0
 8008048:	bd08      	pop	{r3, pc}
	...

0800804c <MIOS32_USB_MIDI_EP1_IN_Callback>:
//! Called by STM32 USB driver to check for IN streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_IN_Callback(u8 bEP, u8 bEPStatus)
{
 800804c:	b508      	push	{r3, lr}
  // package has been sent
  tx_buffer_busy = 0;
 800804e:	4b03      	ldr	r3, [pc, #12]	; (800805c <MIOS32_USB_MIDI_EP1_IN_Callback+0x10>)
 8008050:	2200      	movs	r2, #0
 8008052:	701a      	strb	r2, [r3, #0]
  
  // check for next package
  MIOS32_USB_MIDI_TxBufferHandler();
 8008054:	f7ff fed0 	bl	8007df8 <MIOS32_USB_MIDI_TxBufferHandler>
}
 8008058:	bd08      	pop	{r3, pc}
 800805a:	bf00      	nop
 800805c:	200009c4 	.word	0x200009c4

08008060 <MIOS32_USB_MIDI_EP1_OUT_Callback>:
//! Called by STM32 USB driver to check for OUT streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_OUT_Callback(u8 bEP, u8 bEPStatus)
{
 8008060:	b508      	push	{r3, lr}
  // put package into buffer
  rx_buffer_new_data = 1;
 8008062:	4b03      	ldr	r3, [pc, #12]	; (8008070 <MIOS32_USB_MIDI_EP1_OUT_Callback+0x10>)
 8008064:	2201      	movs	r2, #1
 8008066:	701a      	strb	r2, [r3, #0]
  MIOS32_USB_MIDI_RxBufferHandler();
 8008068:	f7ff fe72 	bl	8007d50 <MIOS32_USB_MIDI_RxBufferHandler>
}
 800806c:	bd08      	pop	{r3, pc}
 800806e:	bf00      	nop
 8008070:	20000ac8 	.word	0x20000ac8

08008074 <MIOS32_UART_BaudrateSet>:
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 8008074:	b530      	push	{r4, r5, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008076:	2801      	cmp	r0, #1
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 8008078:	4604      	mov	r4, r0
 800807a:	b085      	sub	sp, #20
 800807c:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1;
 800807e:	bf88      	it	hi
 8008080:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008084:	d81a      	bhi.n	80080bc <MIOS32_UART_BaudrateSet+0x48>
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8008086:	f04f 0300 	mov.w	r3, #0
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 800808a:	a904      	add	r1, sp, #16
  if( uart >= MIOS32_UART_NUM )
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800808c:	f8ad 3004 	strh.w	r3, [sp, #4]
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8008090:	f8ad 3006 	strh.w	r3, [sp, #6]
  USART_InitStructure.USART_Parity = USART_Parity_No;
 8008094:	f8ad 3008 	strh.w	r3, [sp, #8]
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8008098:	f8ad 300c 	strh.w	r3, [sp, #12]
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 800809c:	f841 5d10 	str.w	r5, [r1, #-16]!
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80080a0:	f04f 030c 	mov.w	r3, #12

  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
 80080a4:	bf14      	ite	ne
 80080a6:	4806      	ldrne	r0, [pc, #24]	; (80080c0 <MIOS32_UART_BaudrateSet+0x4c>)
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 80080a8:	4806      	ldreq	r0, [pc, #24]	; (80080c4 <MIOS32_UART_BaudrateSet+0x50>)
 80080aa:	4669      	mov	r1, sp
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80080ac:	f8ad 300a 	strh.w	r3, [sp, #10]
  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 80080b0:	f000 fe54 	bl	8008d5c <USART_Init>
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 80080b4:	4b04      	ldr	r3, [pc, #16]	; (80080c8 <MIOS32_UART_BaudrateSet+0x54>)

  return 0;
 80080b6:	2000      	movs	r0, #0
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 80080b8:	f843 5024 	str.w	r5, [r3, r4, lsl #2]

  return 0;
#endif
}
 80080bc:	b005      	add	sp, #20
 80080be:	bd30      	pop	{r4, r5, pc}
 80080c0:	40013800 	.word	0x40013800
 80080c4:	40004800 	.word	0x40004800
 80080c8:	20000bec 	.word	0x20000bec

080080cc <MIOS32_UART_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_Init(u32 mode)
{
 80080cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80080ce:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80080d0:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_UART_Init(u32 mode)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
 80080d4:	2c00      	cmp	r4, #0
 80080d6:	f040 8086 	bne.w	80081e6 <MIOS32_UART_Init+0x11a>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 80080da:	ad01      	add	r5, sp, #4
#else

  // map UART pins
  MIOS32_UART0_REMAP_FUNC;
#if MIOS32_UART_NUM >= 2
  MIOS32_UART1_REMAP_FUNC;
 80080dc:	2101      	movs	r1, #1
 80080de:	4842      	ldr	r0, [pc, #264]	; (80081e8 <MIOS32_UART_Init+0x11c>)
 80080e0:	f000 fcea 	bl	8008ab8 <GPIO_PinRemapConfig>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 80080e4:	4628      	mov	r0, r5
 80080e6:	f000 fcdf 	bl	8008aa8 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80080ea:	2302      	movs	r3, #2
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 80080ec:	4629      	mov	r1, r5
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80080ee:	f88d 3006 	strb.w	r3, [sp, #6]

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 80080f2:	261c      	movs	r6, #28
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 80080f4:	f44f 7300 	mov.w	r3, #512	; 0x200
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 80080f8:	483c      	ldr	r0, [pc, #240]	; (80081ec <MIOS32_UART_Init+0x120>)
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 80080fa:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 80080fe:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8008102:	f000 fc78 	bl	80089f6 <GPIO_Init>

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 8008106:	f44f 6380 	mov.w	r3, #1024	; 0x400
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 800810a:	4629      	mov	r1, r5
 800810c:	4838      	ldr	r0, [pc, #224]	; (80081f0 <MIOS32_UART_Init+0x124>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 800810e:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8008112:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 8008116:	f000 fc6e 	bl	80089f6 <GPIO_Init>
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800811a:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 800811c:	4629      	mov	r1, r5
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800811e:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8008122:	4832      	ldr	r0, [pc, #200]	; (80081ec <MIOS32_UART_Init+0x120>)
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
 8008124:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8008128:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 800812c:	f000 fc63 	bl	80089f6 <GPIO_Init>
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 8008130:	f44f 6300 	mov.w	r3, #2048	; 0x800
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 8008134:	4629      	mov	r1, r5
 8008136:	482e      	ldr	r0, [pc, #184]	; (80081f0 <MIOS32_UART_Init+0x124>)
  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 8008138:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 800813c:	f000 fc5b 	bl	80089f6 <GPIO_Init>
  GPIO_Init(MIOS32_UART2_RX_PORT, &GPIO_InitStructure);
#endif

  // enable all USART clocks
  // TODO: more generic approach for different UART selections
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 8008140:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8008144:	2101      	movs	r1, #1
 8008146:	f001 f925 	bl	8009394 <RCC_APB2PeriphClockCmd>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 | RCC_APB1Periph_USART3, ENABLE);
 800814a:	f44f 20c0 	mov.w	r0, #393216	; 0x60000
 800814e:	2101      	movs	r1, #1
 8008150:	f001 f92e 	bl	80093b0 <RCC_APB1PeriphClockCmd>

  // USART configuration
  MIOS32_UART_BaudrateSet(0, MIOS32_UART0_BAUDRATE);
 8008154:	f647 2112 	movw	r1, #31250	; 0x7a12
 8008158:	4620      	mov	r0, r4
 800815a:	f7ff ff8b 	bl	8008074 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=2
  MIOS32_UART_BaudrateSet(1, MIOS32_UART1_BAUDRATE);
 800815e:	f647 2112 	movw	r1, #31250	; 0x7a12
 8008162:	2001      	movs	r0, #1
 8008164:	f7ff ff86 	bl	8008074 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=3
  MIOS32_UART_BaudrateSet(2, MIOS32_UART2_BAUDRATE);
#endif

  // configure and enable UART interrupts
  MIOS32_IRQ_Install(MIOS32_UART0_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 8008168:	2104      	movs	r1, #4
 800816a:	2025      	movs	r0, #37	; 0x25
 800816c:	f7fe fac0 	bl	80066f0 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART0, USART_IT_RXNE, ENABLE);
 8008170:	2201      	movs	r2, #1
 8008172:	4820      	ldr	r0, [pc, #128]	; (80081f4 <MIOS32_UART_Init+0x128>)
 8008174:	f240 5125 	movw	r1, #1317	; 0x525
 8008178:	f000 fe59 	bl	8008e2e <USART_ITConfig>

#if MIOS32_UART_NUM >= 2
  MIOS32_IRQ_Install(MIOS32_UART1_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 800817c:	2104      	movs	r1, #4
 800817e:	2027      	movs	r0, #39	; 0x27
 8008180:	f7fe fab6 	bl	80066f0 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART1, USART_IT_RXNE, ENABLE);
 8008184:	481c      	ldr	r0, [pc, #112]	; (80081f8 <MIOS32_UART_Init+0x12c>)
 8008186:	f240 5125 	movw	r1, #1317	; 0x525
 800818a:	2201      	movs	r2, #1
 800818c:	f000 fe4f 	bl	8008e2e <USART_ITConfig>
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 8008190:	481a      	ldr	r0, [pc, #104]	; (80081fc <MIOS32_UART_Init+0x130>)
 8008192:	491b      	ldr	r1, [pc, #108]	; (8008200 <MIOS32_UART_Init+0x134>)
 8008194:	7004      	strb	r4, [r0, #0]
 8008196:	7803      	ldrb	r3, [r0, #0]
 8008198:	f8df e068 	ldr.w	lr, [pc, #104]	; 8008204 <MIOS32_UART_Init+0x138>
 800819c:	700b      	strb	r3, [r1, #0]
 800819e:	780b      	ldrb	r3, [r1, #0]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80081a0:	4a19      	ldr	r2, [pc, #100]	; (8008208 <MIOS32_UART_Init+0x13c>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80081a2:	f88e 3000 	strb.w	r3, [lr]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80081a6:	7014      	strb	r4, [r2, #0]
 80081a8:	f892 c000 	ldrb.w	ip, [r2]
 80081ac:	4b17      	ldr	r3, [pc, #92]	; (800820c <MIOS32_UART_Init+0x140>)
 80081ae:	f883 c000 	strb.w	ip, [r3]
 80081b2:	781d      	ldrb	r5, [r3, #0]
 80081b4:	f8df c058 	ldr.w	ip, [pc, #88]	; 8008210 <MIOS32_UART_Init+0x144>
 80081b8:	f88c 5000 	strb.w	r5, [ip]
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80081bc:	7044      	strb	r4, [r0, #1]
 80081be:	7840      	ldrb	r0, [r0, #1]
 80081c0:	7048      	strb	r0, [r1, #1]
 80081c2:	7849      	ldrb	r1, [r1, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 80081c4:	480b      	ldr	r0, [pc, #44]	; (80081f4 <MIOS32_UART_Init+0x128>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80081c6:	f88e 1001 	strb.w	r1, [lr, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80081ca:	7054      	strb	r4, [r2, #1]
 80081cc:	7852      	ldrb	r2, [r2, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 80081ce:	2101      	movs	r1, #1

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80081d0:	705a      	strb	r2, [r3, #1]
 80081d2:	785b      	ldrb	r3, [r3, #1]
 80081d4:	f88c 3001 	strb.w	r3, [ip, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 80081d8:	f000 fe1c 	bl	8008e14 <USART_Cmd>
#if MIOS32_UART_NUM >= 2
  USART_Cmd(MIOS32_UART1, ENABLE);
 80081dc:	4806      	ldr	r0, [pc, #24]	; (80081f8 <MIOS32_UART_Init+0x12c>)
 80081de:	2101      	movs	r1, #1
 80081e0:	f000 fe18 	bl	8008e14 <USART_Cmd>
#endif
#if MIOS32_UART_NUM >= 3
  USART_Cmd(MIOS32_UART2, ENABLE);
#endif

  return 0; // no error
 80081e4:	4620      	mov	r0, r4
#endif
}
 80081e6:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 80081e8:	00140010 	.word	0x00140010
 80081ec:	40010800 	.word	0x40010800
 80081f0:	40011000 	.word	0x40011000
 80081f4:	40013800 	.word	0x40013800
 80081f8:	40004800 	.word	0x40004800
 80081fc:	20000adc 	.word	0x20000adc
 8008200:	20000be4 	.word	0x20000be4
 8008204:	20000ae0 	.word	0x20000ae0
 8008208:	20000be8 	.word	0x20000be8
 800820c:	20000bf4 	.word	0x20000bf4
 8008210:	20000ad8 	.word	0x20000ad8

08008214 <MIOS32_UART_RxBufferGet>:
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008214:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: number of received bytes
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
 8008216:	b538      	push	{r3, r4, r5, lr}
 8008218:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 800821a:	bf88      	it	hi
 800821c:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008220:	d81d      	bhi.n	800825e <MIOS32_UART_RxBufferGet+0x4a>
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 8008222:	4b0f      	ldr	r3, [pc, #60]	; (8008260 <MIOS32_UART_RxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 8008224:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 8008228:	5d1b      	ldrb	r3, [r3, r4]
 800822a:	b1c3      	cbz	r3, 800825e <MIOS32_UART_RxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 800822c:	f7fe fa38 	bl	80066a0 <MIOS32_IRQ_Disable>
  u8 b = rx_buffer[uart][rx_buffer_tail[uart]];
 8008230:	4b0c      	ldr	r3, [pc, #48]	; (8008264 <MIOS32_UART_RxBufferGet+0x50>)
 8008232:	490d      	ldr	r1, [pc, #52]	; (8008268 <MIOS32_UART_RxBufferGet+0x54>)
 8008234:	5d1a      	ldrb	r2, [r3, r4]
 8008236:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 800823a:	5c8d      	ldrb	r5, [r1, r2]
  if( ++rx_buffer_tail[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 800823c:	5d1a      	ldrb	r2, [r3, r4]
 800823e:	3201      	adds	r2, #1
 8008240:	b2d2      	uxtb	r2, r2
 8008242:	551a      	strb	r2, [r3, r4]
 8008244:	5d1a      	ldrb	r2, [r3, r4]
 8008246:	2a3f      	cmp	r2, #63	; 0x3f
 8008248:	d901      	bls.n	800824e <MIOS32_UART_RxBufferGet+0x3a>
    rx_buffer_tail[uart] = 0;
 800824a:	2200      	movs	r2, #0
 800824c:	551a      	strb	r2, [r3, r4]
  --rx_buffer_size[uart];
 800824e:	4b04      	ldr	r3, [pc, #16]	; (8008260 <MIOS32_UART_RxBufferGet+0x4c>)
 8008250:	5d1a      	ldrb	r2, [r3, r4]
 8008252:	3a01      	subs	r2, #1
 8008254:	b2d2      	uxtb	r2, r2
 8008256:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 8008258:	f7fe fa38 	bl	80066cc <MIOS32_IRQ_Enable>

  return b; // return received byte
 800825c:	4628      	mov	r0, r5
#endif
}
 800825e:	bd38      	pop	{r3, r4, r5, pc}
 8008260:	20000adc 	.word	0x20000adc
 8008264:	20000ae0 	.word	0x20000ae0
 8008268:	20000b64 	.word	0x20000b64

0800826c <MIOS32_UART_RxBufferPut>:
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 800826c:	2801      	cmp	r0, #1
//! \return -1 if UART not available
//! \return -2 if buffer full (retry)
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
 800826e:	b538      	push	{r3, r4, r5, lr}
 8008270:	4604      	mov	r4, r0
 8008272:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8008274:	bf88      	it	hi
 8008276:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 800827a:	d81f      	bhi.n	80082bc <MIOS32_UART_RxBufferPut+0x50>
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 800827c:	4b10      	ldr	r3, [pc, #64]	; (80082c0 <MIOS32_UART_RxBufferPut+0x54>)
 800827e:	5d1b      	ldrb	r3, [r3, r4]
 8008280:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full (retry)
 8008282:	bf88      	it	hi
 8008284:	f06f 0001 	mvnhi.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8008288:	d818      	bhi.n	80082bc <MIOS32_UART_RxBufferPut+0x50>
    return -2; // buffer full (retry)

  // copy received byte into receive buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 800828a:	f7fe fa09 	bl	80066a0 <MIOS32_IRQ_Disable>
  rx_buffer[uart][rx_buffer_head[uart]] = b;
 800828e:	4b0d      	ldr	r3, [pc, #52]	; (80082c4 <MIOS32_UART_RxBufferPut+0x58>)
 8008290:	490d      	ldr	r1, [pc, #52]	; (80082c8 <MIOS32_UART_RxBufferPut+0x5c>)
 8008292:	5d1a      	ldrb	r2, [r3, r4]
 8008294:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 8008298:	548d      	strb	r5, [r1, r2]
  if( ++rx_buffer_head[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 800829a:	5d1a      	ldrb	r2, [r3, r4]
 800829c:	3201      	adds	r2, #1
 800829e:	b2d2      	uxtb	r2, r2
 80082a0:	551a      	strb	r2, [r3, r4]
 80082a2:	5d1a      	ldrb	r2, [r3, r4]
 80082a4:	2a3f      	cmp	r2, #63	; 0x3f
 80082a6:	d901      	bls.n	80082ac <MIOS32_UART_RxBufferPut+0x40>
    rx_buffer_head[uart] = 0;
 80082a8:	2200      	movs	r2, #0
 80082aa:	551a      	strb	r2, [r3, r4]
  ++rx_buffer_size[uart];
 80082ac:	4b04      	ldr	r3, [pc, #16]	; (80082c0 <MIOS32_UART_RxBufferPut+0x54>)
 80082ae:	5d1a      	ldrb	r2, [r3, r4]
 80082b0:	3201      	adds	r2, #1
 80082b2:	b2d2      	uxtb	r2, r2
 80082b4:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 80082b6:	f7fe fa09 	bl	80066cc <MIOS32_IRQ_Enable>

  return 0; // no error
 80082ba:	2000      	movs	r0, #0
#endif
}
 80082bc:	bd38      	pop	{r3, r4, r5, pc}
 80082be:	bf00      	nop
 80082c0:	20000adc 	.word	0x20000adc
 80082c4:	20000be4 	.word	0x20000be4
 80082c8:	20000b64 	.word	0x20000b64

080082cc <MIOS32_UART_TxBufferGet>:
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80082cc:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: transmitted byte
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
 80082ce:	b538      	push	{r3, r4, r5, lr}
 80082d0:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 80082d2:	bf88      	it	hi
 80082d4:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80082d8:	d81d      	bhi.n	8008316 <MIOS32_UART_TxBufferGet+0x4a>
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 80082da:	4b0f      	ldr	r3, [pc, #60]	; (8008318 <MIOS32_UART_TxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 80082dc:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 80082e0:	5d1b      	ldrb	r3, [r3, r4]
 80082e2:	b1c3      	cbz	r3, 8008316 <MIOS32_UART_TxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 80082e4:	f7fe f9dc 	bl	80066a0 <MIOS32_IRQ_Disable>
  u8 b = tx_buffer[uart][tx_buffer_tail[uart]];
 80082e8:	4b0c      	ldr	r3, [pc, #48]	; (800831c <MIOS32_UART_TxBufferGet+0x50>)
 80082ea:	490d      	ldr	r1, [pc, #52]	; (8008320 <MIOS32_UART_TxBufferGet+0x54>)
 80082ec:	5d1a      	ldrb	r2, [r3, r4]
 80082ee:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 80082f2:	5c8d      	ldrb	r5, [r1, r2]
  if( ++tx_buffer_tail[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 80082f4:	5d1a      	ldrb	r2, [r3, r4]
 80082f6:	3201      	adds	r2, #1
 80082f8:	b2d2      	uxtb	r2, r2
 80082fa:	551a      	strb	r2, [r3, r4]
 80082fc:	5d1a      	ldrb	r2, [r3, r4]
 80082fe:	2a3f      	cmp	r2, #63	; 0x3f
 8008300:	d901      	bls.n	8008306 <MIOS32_UART_TxBufferGet+0x3a>
    tx_buffer_tail[uart] = 0;
 8008302:	2200      	movs	r2, #0
 8008304:	551a      	strb	r2, [r3, r4]
  --tx_buffer_size[uart];
 8008306:	4b04      	ldr	r3, [pc, #16]	; (8008318 <MIOS32_UART_TxBufferGet+0x4c>)
 8008308:	5d1a      	ldrb	r2, [r3, r4]
 800830a:	3a01      	subs	r2, #1
 800830c:	b2d2      	uxtb	r2, r2
 800830e:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 8008310:	f7fe f9dc 	bl	80066cc <MIOS32_IRQ_Enable>

  return b; // return transmitted byte
 8008314:	4628      	mov	r0, r5
#endif
}
 8008316:	bd38      	pop	{r3, r4, r5, pc}
 8008318:	20000be8 	.word	0x20000be8
 800831c:	20000ad8 	.word	0x20000ad8
 8008320:	20000ae4 	.word	0x20000ae4

08008324 <MIOS32_UART_TxBufferPutMore_NonBlocking>:
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 8008324:	b5f0      	push	{r4, r5, r6, r7, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008326:	2801      	cmp	r0, #1
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 8008328:	4604      	mov	r4, r0
 800832a:	b087      	sub	sp, #28
 800832c:	460d      	mov	r5, r1
 800832e:	4617      	mov	r7, r2
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8008330:	bf88      	it	hi
 8008332:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008336:	d852      	bhi.n	80083de <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 8008338:	4e2a      	ldr	r6, [pc, #168]	; (80083e4 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc0>)
 800833a:	5d33      	ldrb	r3, [r6, r4]
 800833c:	18d3      	adds	r3, r2, r3
 800833e:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full or cannot get all requested bytes (retry)
 8008340:	bfc8      	it	gt
 8008342:	f06f 0001 	mvngt.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 8008346:	dc4a      	bgt.n	80083de <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -2; // buffer full or cannot get all requested bytes (retry)

  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 8008348:	f7fe f9aa 	bl	80066a0 <MIOS32_IRQ_Disable>

  u16 i;
  for(i=0; i<len; ++i) {
 800834c:	2200      	movs	r2, #0
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 800834e:	4b26      	ldr	r3, [pc, #152]	; (80083e8 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc4>)

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008350:	4826      	ldr	r0, [pc, #152]	; (80083ec <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc8>)
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008352:	4927      	ldr	r1, [pc, #156]	; (80083f0 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xcc>)
 8008354:	9701      	str	r7, [sp, #4]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 8008356:	e03c      	b.n	80083d2 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xae>
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 8008358:	f813 c004 	ldrb.w	ip, [r3, r4]
 800835c:	f815 7b01 	ldrb.w	r7, [r5], #1
 8008360:	f8df e090 	ldr.w	lr, [pc, #144]	; 80083f4 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xd0>
 8008364:	eb0c 1c84 	add.w	ip, ip, r4, lsl #6
 8008368:	f80e 700c 	strb.w	r7, [lr, ip]

    if( ++tx_buffer_head[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 800836c:	f813 c004 	ldrb.w	ip, [r3, r4]
 8008370:	f10c 0c01 	add.w	ip, ip, #1
 8008374:	fa5f fc8c 	uxtb.w	ip, ip
 8008378:	f803 c004 	strb.w	ip, [r3, r4]
 800837c:	f813 c004 	ldrb.w	ip, [r3, r4]
 8008380:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
      tx_buffer_head[uart] = 0;
 8008384:	bf84      	itt	hi
 8008386:	f04f 0c00 	movhi.w	ip, #0
 800838a:	f803 c004 	strbhi.w	ip, [r3, r4]

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
 800838e:	f816 c004 	ldrb.w	ip, [r6, r4]
 8008392:	f10c 0c01 	add.w	ip, ip, #1
 8008396:	fa5f fc8c 	uxtb.w	ip, ip
 800839a:	f806 c004 	strb.w	ip, [r6, r4]
 800839e:	f816 c004 	ldrb.w	ip, [r6, r4]
 80083a2:	f1bc 0f01 	cmp.w	ip, #1
 80083a6:	d112      	bne.n	80083ce <MIOS32_UART_TxBufferPutMore_NonBlocking+0xaa>
      switch( uart ) {
 80083a8:	2c01      	cmp	r4, #1
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083aa:	bf15      	itete	ne
 80083ac:	f8b1 c00c 	ldrhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083b0:	f8b0 c00c 	ldrheq.w	ip, [r0, #12]
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083b4:	fa1f fc8c 	uxthne.w	ip, ip
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083b8:	fa1f fc8c 	uxtheq.w	ip, ip
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083bc:	bf15      	itete	ne
 80083be:	f04c 0c80 	orrne.w	ip, ip, #128	; 0x80
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083c2:	f04c 0c80 	orreq.w	ip, ip, #128	; 0x80
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083c6:	f8a1 c00c 	strhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083ca:	f8a0 c00c 	strheq.w	ip, [r0, #12]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 80083ce:	3201      	adds	r2, #1
 80083d0:	b292      	uxth	r2, r2
 80083d2:	9f01      	ldr	r7, [sp, #4]
 80083d4:	42ba      	cmp	r2, r7
 80083d6:	d3bf      	bcc.n	8008358 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x34>
        default: MIOS32_IRQ_Enable(); return -3; // uart not supported by routine (yet)
      }
    }
  }

  MIOS32_IRQ_Enable();
 80083d8:	f7fe f978 	bl	80066cc <MIOS32_IRQ_Enable>

  return 0; // no error
 80083dc:	2000      	movs	r0, #0
#endif
}
 80083de:	b007      	add	sp, #28
 80083e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80083e2:	bf00      	nop
 80083e4:	20000be8 	.word	0x20000be8
 80083e8:	20000bf4 	.word	0x20000bf4
 80083ec:	40004800 	.word	0x40004800
 80083f0:	40013800 	.word	0x40013800
 80083f4:	20000ae4 	.word	0x20000ae4

080083f8 <MIOS32_UART_TxBufferPutMore>:
//! \return -1 if UART not available
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore(u8 uart, u8 *buffer, u16 len)
{
 80083f8:	b570      	push	{r4, r5, r6, lr}
 80083fa:	4605      	mov	r5, r0
 80083fc:	460c      	mov	r4, r1
 80083fe:	4616      	mov	r6, r2
  s32 error;

  while( (error=MIOS32_UART_TxBufferPutMore_NonBlocking(uart, buffer, len)) == -2 );
 8008400:	4628      	mov	r0, r5
 8008402:	4621      	mov	r1, r4
 8008404:	4632      	mov	r2, r6
 8008406:	f7ff ff8d 	bl	8008324 <MIOS32_UART_TxBufferPutMore_NonBlocking>
 800840a:	f110 0f02 	cmn.w	r0, #2
 800840e:	d0f7      	beq.n	8008400 <MIOS32_UART_TxBufferPutMore+0x8>

  return error;
}
 8008410:	bd70      	pop	{r4, r5, r6, pc}
	...

08008414 <USART1_IRQHandler>:
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8008414:	4b14      	ldr	r3, [pc, #80]	; (8008468 <USART1_IRQHandler+0x54>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
 8008416:	b510      	push	{r4, lr}
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8008418:	881a      	ldrh	r2, [r3, #0]
 800841a:	f012 0f20 	tst.w	r2, #32
 800841e:	d009      	beq.n	8008434 <USART1_IRQHandler+0x20>
    u8 b = MIOS32_UART0->DR;
 8008420:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 8008422:	2020      	movs	r0, #32
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART0->DR;
 8008424:	b2e4      	uxtb	r4, r4

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 8008426:	4621      	mov	r1, r4
 8008428:	f7fd fd9c 	bl	8005f64 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(0, b) < 0 ) {
 800842c:	b910      	cbnz	r0, 8008434 <USART1_IRQHandler+0x20>
 800842e:	4621      	mov	r1, r4
 8008430:	f7ff ff1c 	bl	800826c <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
 8008434:	4c0c      	ldr	r4, [pc, #48]	; (8008468 <USART1_IRQHandler+0x54>)
 8008436:	8823      	ldrh	r3, [r4, #0]
 8008438:	f013 0f80 	tst.w	r3, #128	; 0x80
 800843c:	d013      	beq.n	8008466 <USART1_IRQHandler+0x52>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 800843e:	4b0b      	ldr	r3, [pc, #44]	; (800846c <USART1_IRQHandler+0x58>)
 8008440:	781b      	ldrb	r3, [r3, #0]
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
 8008442:	b153      	cbz	r3, 800845a <USART1_IRQHandler+0x46>
      s32 b = MIOS32_UART_TxBufferGet(0);
 8008444:	2000      	movs	r0, #0
 8008446:	f7ff ff41 	bl	80082cc <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 800844a:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
      } else {
	MIOS32_UART0->DR = b;
 800844c:	bfa4      	itt	ge
 800844e:	b280      	uxthge	r0, r0
 8008450:	80a0      	strhge	r0, [r4, #4]
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(0);
      if( b < 0 ) {
 8008452:	da08      	bge.n	8008466 <USART1_IRQHandler+0x52>
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
 8008454:	23ff      	movs	r3, #255	; 0xff
 8008456:	80a3      	strh	r3, [r4, #4]
 8008458:	e005      	b.n	8008466 <USART1_IRQHandler+0x52>
      } else {
	MIOS32_UART0->DR = b;
      }
    } else {
      MIOS32_UART0->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 800845a:	89a3      	ldrh	r3, [r4, #12]
 800845c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008460:	041b      	lsls	r3, r3, #16
 8008462:	0c1b      	lsrs	r3, r3, #16
 8008464:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 8008466:	bd10      	pop	{r4, pc}
 8008468:	40013800 	.word	0x40013800
 800846c:	20000be8 	.word	0x20000be8

08008470 <USART3_IRQHandler>:
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 8008470:	4b15      	ldr	r3, [pc, #84]	; (80084c8 <USART3_IRQHandler+0x58>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
 8008472:	b510      	push	{r4, lr}
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 8008474:	881a      	ldrh	r2, [r3, #0]
 8008476:	f012 0f20 	tst.w	r2, #32
 800847a:	d00a      	beq.n	8008492 <USART3_IRQHandler+0x22>
    u8 b = MIOS32_UART1->DR;
 800847c:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 800847e:	2021      	movs	r0, #33	; 0x21
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART1->DR;
 8008480:	b2e4      	uxtb	r4, r4

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 8008482:	4621      	mov	r1, r4
 8008484:	f7fd fd6e 	bl	8005f64 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(1, b) < 0 ) {
 8008488:	b918      	cbnz	r0, 8008492 <USART3_IRQHandler+0x22>
 800848a:	3001      	adds	r0, #1
 800848c:	4621      	mov	r1, r4
 800848e:	f7ff feed 	bl	800826c <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
 8008492:	4c0d      	ldr	r4, [pc, #52]	; (80084c8 <USART3_IRQHandler+0x58>)
 8008494:	8823      	ldrh	r3, [r4, #0]
 8008496:	f013 0f80 	tst.w	r3, #128	; 0x80
 800849a:	d013      	beq.n	80084c4 <USART3_IRQHandler+0x54>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 800849c:	4b0b      	ldr	r3, [pc, #44]	; (80084cc <USART3_IRQHandler+0x5c>)
 800849e:	785b      	ldrb	r3, [r3, #1]
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
 80084a0:	b153      	cbz	r3, 80084b8 <USART3_IRQHandler+0x48>
      s32 b = MIOS32_UART_TxBufferGet(1);
 80084a2:	2001      	movs	r0, #1
 80084a4:	f7ff ff12 	bl	80082cc <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 80084a8:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
      } else {
	MIOS32_UART1->DR = b;
 80084aa:	bfa4      	itt	ge
 80084ac:	b280      	uxthge	r0, r0
 80084ae:	80a0      	strhge	r0, [r4, #4]
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(1);
      if( b < 0 ) {
 80084b0:	da08      	bge.n	80084c4 <USART3_IRQHandler+0x54>
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
 80084b2:	23ff      	movs	r3, #255	; 0xff
 80084b4:	80a3      	strh	r3, [r4, #4]
 80084b6:	e005      	b.n	80084c4 <USART3_IRQHandler+0x54>
      } else {
	MIOS32_UART1->DR = b;
      }
    } else {
      MIOS32_UART1->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 80084b8:	89a3      	ldrh	r3, [r4, #12]
 80084ba:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80084be:	041b      	lsls	r3, r3, #16
 80084c0:	0c1b      	lsrs	r3, r3, #16
 80084c2:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 80084c4:	bd10      	pop	{r4, pc}
 80084c6:	bf00      	nop
 80084c8:	40004800 	.word	0x40004800
 80084cc:	20000be8 	.word	0x20000be8

080084d0 <USART2_IRQHandler>:
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 80084d0:	4b0e      	ldr	r3, [pc, #56]	; (800850c <USART2_IRQHandler+0x3c>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
 80084d2:	b510      	push	{r4, lr}
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 80084d4:	881a      	ldrh	r2, [r3, #0]
 80084d6:	f012 0f20 	tst.w	r2, #32
 80084da:	d00a      	beq.n	80084f2 <USART2_IRQHandler+0x22>
    u8 b = MIOS32_UART2->DR;
 80084dc:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 80084de:	2022      	movs	r0, #34	; 0x22
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART2->DR;
 80084e0:	b2e4      	uxtb	r4, r4

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 80084e2:	4621      	mov	r1, r4
 80084e4:	f7fd fd3e 	bl	8005f64 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(2, b) < 0 ) {
 80084e8:	b918      	cbnz	r0, 80084f2 <USART2_IRQHandler+0x22>
 80084ea:	3002      	adds	r0, #2
 80084ec:	4621      	mov	r1, r4
 80084ee:	f7ff febd 	bl	800826c <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART2->SR & (1 << 7) ) { // check if TXE flag is set
 80084f2:	4a06      	ldr	r2, [pc, #24]	; (800850c <USART2_IRQHandler+0x3c>)
 80084f4:	8813      	ldrh	r3, [r2, #0]
 80084f6:	f013 0f80 	tst.w	r3, #128	; 0x80
 80084fa:	d005      	beq.n	8008508 <USART2_IRQHandler+0x38>
	MIOS32_UART2->DR = 0xff;
      } else {
	MIOS32_UART2->DR = b;
      }
    } else {
      MIOS32_UART2->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 80084fc:	8993      	ldrh	r3, [r2, #12]
 80084fe:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008502:	041b      	lsls	r3, r3, #16
 8008504:	0c1b      	lsrs	r3, r3, #16
 8008506:	8193      	strh	r3, [r2, #12]
    }
  }
}
 8008508:	bd10      	pop	{r4, pc}
 800850a:	bf00      	nop
 800850c:	40004400 	.word	0x40004400

08008510 <I2C2_EV_IRQHandler>:
/////////////////////////////////////////////////////////////////////////////
// interrupt vectors
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
 8008510:	b570      	push	{r4, r5, r6, lr}
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8008512:	4c68      	ldr	r4, [pc, #416]	; (80086b4 <I2C2_EV_IRQHandler+0x1a4>)
 8008514:	6820      	ldr	r0, [r4, #0]
 8008516:	f000 fce4 	bl	8008ee2 <I2C_GetLastEvent>
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 800851a:	4b67      	ldr	r3, [pc, #412]	; (80086b8 <I2C2_EV_IRQHandler+0x1a8>)
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 800851c:	4605      	mov	r5, r0
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 800851e:	ea00 0303 	and.w	r3, r0, r3
 8008522:	2b00      	cmp	r3, #0
 8008524:	d033      	beq.n	800858e <I2C2_EV_IRQHandler+0x7e>
 8008526:	68e3      	ldr	r3, [r4, #12]
 8008528:	2b00      	cmp	r3, #0
 800852a:	d030      	beq.n	800858e <I2C2_EV_IRQHandler+0x7e>
    // get received data
    b = I2C_ReceiveData(iicx->base);
 800852c:	6820      	ldr	r0, [r4, #0]
 800852e:	f000 fccd 	bl	8008ecc <I2C_ReceiveData>

    // failsave: still place in buffer?
    if( iicx->buffer_ix < iicx->buffer_len )
 8008532:	8a62      	ldrh	r2, [r4, #18]
 8008534:	8a23      	ldrh	r3, [r4, #16]
 8008536:	b292      	uxth	r2, r2
 8008538:	b29b      	uxth	r3, r3
 800853a:	429a      	cmp	r2, r3
 800853c:	d206      	bcs.n	800854c <I2C2_EV_IRQHandler+0x3c>
      iicx->rx_buffer_ptr[iicx->buffer_ix++] = b;
 800853e:	8a63      	ldrh	r3, [r4, #18]
 8008540:	68e2      	ldr	r2, [r4, #12]
 8008542:	b29b      	uxth	r3, r3
 8008544:	54d0      	strb	r0, [r2, r3]
 8008546:	3301      	adds	r3, #1
 8008548:	b29b      	uxth	r3, r3
 800854a:	8263      	strh	r3, [r4, #18]

    // last byte received, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 800854c:	4b59      	ldr	r3, [pc, #356]	; (80086b4 <I2C2_EV_IRQHandler+0x1a4>)
 800854e:	695a      	ldr	r2, [r3, #20]
 8008550:	f012 0f02 	tst.w	r2, #2
 8008554:	d13e      	bne.n	80085d4 <I2C2_EV_IRQHandler+0xc4>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    }
 
    // request NAK and stop condition before receiving last data
    if( (iicx->buffer_ix >= iicx->buffer_len-1) || (iicx->transfer_state.ABORT_IF_FIRST_BYTE_0 && iicx->buffer_ix == 1 && b == 0x00) ) {
 8008556:	8a59      	ldrh	r1, [r3, #18]
 8008558:	8a1a      	ldrh	r2, [r3, #16]
 800855a:	b289      	uxth	r1, r1
 800855c:	b292      	uxth	r2, r2
 800855e:	3a01      	subs	r2, #1
 8008560:	4291      	cmp	r1, r2
 8008562:	da0c      	bge.n	800857e <I2C2_EV_IRQHandler+0x6e>
 8008564:	695a      	ldr	r2, [r3, #20]
 8008566:	f012 0f04 	tst.w	r2, #4
 800856a:	f000 80a1 	beq.w	80086b0 <I2C2_EV_IRQHandler+0x1a0>
 800856e:	8a5b      	ldrh	r3, [r3, #18]
 8008570:	b29b      	uxth	r3, r3
 8008572:	2b01      	cmp	r3, #1
 8008574:	f040 809c 	bne.w	80086b0 <I2C2_EV_IRQHandler+0x1a0>
 8008578:	2800      	cmp	r0, #0
 800857a:	f040 8099 	bne.w	80086b0 <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 800857e:	4c4d      	ldr	r4, [pc, #308]	; (80086b4 <I2C2_EV_IRQHandler+0x1a4>)
 8008580:	2100      	movs	r1, #0
 8008582:	6820      	ldr	r0, [r4, #0]
 8008584:	f000 fc88 	bl	8008e98 <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 8008588:	6820      	ldr	r0, [r4, #0]
 800858a:	2101      	movs	r1, #1
 800858c:	e011      	b.n	80085b2 <I2C2_EV_IRQHandler+0xa2>
  }

  // ADDR set, TRA flag not set (indicates transmitter/receiver mode).
  // ADDR will be cleared by a read of SR1 followed by a read of SR2 (done by I2C_GetLastEvent)
  // If transmitter mode is selected (TRA set), we go on, TXE will be catched to send the first byte
  if( (event & I2C_FLAG_ADDR) && !(event & I2C_FLAG_TRA) ){
 800858e:	4b4b      	ldr	r3, [pc, #300]	; (80086bc <I2C2_EV_IRQHandler+0x1ac>)
 8008590:	ea05 0303 	and.w	r3, r5, r3
 8008594:	b1a3      	cbz	r3, 80085c0 <I2C2_EV_IRQHandler+0xb0>
 8008596:	f415 2180 	ands.w	r1, r5, #262144	; 0x40000
 800859a:	d111      	bne.n	80085c0 <I2C2_EV_IRQHandler+0xb0>
    // address sent (receiver mode), receiving first byte - check if we already have to request NAK/Stop
    if( iicx->buffer_len == 1 ) {
 800859c:	4c45      	ldr	r4, [pc, #276]	; (80086b4 <I2C2_EV_IRQHandler+0x1a4>)
 800859e:	8a25      	ldrh	r5, [r4, #16]
 80085a0:	b2ad      	uxth	r5, r5
 80085a2:	2d01      	cmp	r5, #1
 80085a4:	f040 8084 	bne.w	80086b0 <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80085a8:	6820      	ldr	r0, [r4, #0]
 80085aa:	f000 fc75 	bl	8008e98 <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80085ae:	6820      	ldr	r0, [r4, #0]
 80085b0:	4629      	mov	r1, r5
 80085b2:	f000 fc64 	bl	8008e7e <I2C_GenerateSTOP>
      iicx->transfer_state.STOP_REQUESTED = 1;
 80085b6:	6963      	ldr	r3, [r4, #20]
 80085b8:	f043 0302 	orr.w	r3, r3, #2
 80085bc:	6163      	str	r3, [r4, #20]
 80085be:	e077      	b.n	80086b0 <I2C2_EV_IRQHandler+0x1a0>

  // TxE set, will be cleared by writing DR, or after START or STOP was generated
  // This handling also applies for BTF, as TXE will alway be set if BTF is.
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  if( event & I2C_FLAG_TXE ){
 80085c0:	4a3f      	ldr	r2, [pc, #252]	; (80086c0 <I2C2_EV_IRQHandler+0x1b0>)
 80085c2:	ea05 0202 	and.w	r2, r5, r2
 80085c6:	2a00      	cmp	r2, #0
 80085c8:	d03e      	beq.n	8008648 <I2C2_EV_IRQHandler+0x138>

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 80085ca:	4b3a      	ldr	r3, [pc, #232]	; (80086b4 <I2C2_EV_IRQHandler+0x1a4>)
 80085cc:	695a      	ldr	r2, [r3, #20]
 80085ce:	f012 0f02 	tst.w	r2, #2
 80085d2:	d007      	beq.n	80085e4 <I2C2_EV_IRQHandler+0xd4>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 80085d4:	695a      	ldr	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80085d6:	6818      	ldr	r0, [r3, #0]
  if( event & I2C_FLAG_TXE ){

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 80085d8:	f36f 0200 	bfc	r2, #0, #1
 80085dc:	615a      	str	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80085de:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 80085e2:	e02f      	b.n	8008644 <I2C2_EV_IRQHandler+0x134>
      return;
    }

    if( iicx->buffer_ix < iicx->buffer_len ) {
 80085e4:	8a59      	ldrh	r1, [r3, #18]
 80085e6:	8a1a      	ldrh	r2, [r3, #16]
 80085e8:	b289      	uxth	r1, r1
 80085ea:	b292      	uxth	r2, r2
 80085ec:	4291      	cmp	r1, r2
 80085ee:	d20b      	bcs.n	8008608 <I2C2_EV_IRQHandler+0xf8>
      // checking tx_buffer_ptr for NULL is a failsafe measure.
      I2C_SendData(iicx->base, (iicx->tx_buffer_ptr == NULL) ? 0 : iicx->tx_buffer_ptr[iicx->buffer_ix++]);
 80085f0:	6899      	ldr	r1, [r3, #8]
 80085f2:	6818      	ldr	r0, [r3, #0]
 80085f4:	b129      	cbz	r1, 8008602 <I2C2_EV_IRQHandler+0xf2>
 80085f6:	8a5a      	ldrh	r2, [r3, #18]
 80085f8:	b292      	uxth	r2, r2
 80085fa:	5c89      	ldrb	r1, [r1, r2]
 80085fc:	3201      	adds	r2, #1
 80085fe:	b292      	uxth	r2, r2
 8008600:	825a      	strh	r2, [r3, #18]
 8008602:	f000 fc61 	bl	8008ec8 <I2C_SendData>
 8008606:	e053      	b.n	80086b0 <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 

    // peripheral is transfering last byte, request stop condition /
    // on write-without-stop transfer-type, request start condition instead
    if( !iicx->transfer_state.WRITE_WITHOUT_STOP )
 8008608:	695a      	ldr	r2, [r3, #20]
 800860a:	f012 0f08 	tst.w	r2, #8
 800860e:	d104      	bne.n	800861a <I2C2_EV_IRQHandler+0x10a>
      I2C_GenerateSTOP(iicx->base, ENABLE);
 8008610:	6818      	ldr	r0, [r3, #0]
 8008612:	2101      	movs	r1, #1
 8008614:	f000 fc33 	bl	8008e7e <I2C_GenerateSTOP>
 8008618:	e003      	b.n	8008622 <I2C2_EV_IRQHandler+0x112>
    else
      I2C_GenerateSTART(iicx->base, ENABLE);
 800861a:	6818      	ldr	r0, [r3, #0]
 800861c:	2101      	movs	r1, #1
 800861e:	f000 fc21 	bl	8008e64 <I2C_GenerateSTART>
    iicx->transfer_state.STOP_REQUESTED = 1;
 8008622:	4b24      	ldr	r3, [pc, #144]	; (80086b4 <I2C2_EV_IRQHandler+0x1a4>)
 8008624:	695a      	ldr	r2, [r3, #20]
 8008626:	f042 0202 	orr.w	r2, r2, #2
 800862a:	615a      	str	r2, [r3, #20]

    if( iicx->buffer_len == 0 ) {
 800862c:	8a1a      	ldrh	r2, [r3, #16]
 800862e:	b292      	uxth	r2, r2
 8008630:	b92a      	cbnz	r2, 800863e <I2C2_EV_IRQHandler+0x12e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008632:	6959      	ldr	r1, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008634:	6818      	ldr	r0, [r3, #0]
      I2C_GenerateSTART(iicx->base, ENABLE);
    iicx->transfer_state.STOP_REQUESTED = 1;

    if( iicx->buffer_len == 0 ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008636:	f362 0100 	bfi	r1, r2, #0, #1
 800863a:	6159      	str	r1, [r3, #20]
 800863c:	e012      	b.n	8008664 <I2C2_EV_IRQHandler+0x154>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
    } else {
      // Disable the I2C_IT_BUF interrupt after sending the last buffer data 
      // (last EV8) to not allow a new interrupt just with TxE - only BTF will generate it
      // if this is not done, BUSY will be cleared before the transfer is finished
      I2C_ITConfig(iicx->base, I2C_IT_BUF, DISABLE);
 800863e:	6818      	ldr	r0, [r3, #0]
 8008640:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008644:	2200      	movs	r2, #0
 8008646:	e00f      	b.n	8008668 <I2C2_EV_IRQHandler+0x158>
    }
  return;
  }

  // SB set, cleared by reading SR1 (done by I2C_GetLastEvent) followed by writing DR register
  if( event & I2C_FLAG_SB ){
 8008648:	4e1e      	ldr	r6, [pc, #120]	; (80086c4 <I2C2_EV_IRQHandler+0x1b4>)
 800864a:	4c1a      	ldr	r4, [pc, #104]	; (80086b4 <I2C2_EV_IRQHandler+0x1a4>)
 800864c:	ea05 0606 	and.w	r6, r5, r6
 8008650:	b1a6      	cbz	r6, 800867c <I2C2_EV_IRQHandler+0x16c>
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8008652:	6963      	ldr	r3, [r4, #20]
 8008654:	f013 0f02 	tst.w	r3, #2
 8008658:	d009      	beq.n	800866e <I2C2_EV_IRQHandler+0x15e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800865a:	6963      	ldr	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 800865c:	6820      	ldr	r0, [r4, #0]
  if( event & I2C_FLAG_SB ){
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800865e:	f362 0300 	bfi	r3, r2, #0, #1
 8008662:	6163      	str	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008664:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8008668:	f000 fc23 	bl	8008eb2 <I2C_ITConfig>
 800866c:	e020      	b.n	80086b0 <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
      (iicx->iic_address & 1)
 800866e:	7921      	ldrb	r1, [r4, #4]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
 8008670:	6820      	ldr	r0, [r4, #0]
 8008672:	f001 0201 	and.w	r2, r1, #1
 8008676:	f000 fc2c 	bl	8008ed2 <I2C_Send7bitAddress>
 800867a:	e019      	b.n	80086b0 <I2C2_EV_IRQHandler+0x1a0>
  }

  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 800867c:	4632      	mov	r2, r6
 800867e:	6820      	ldr	r0, [r4, #0]
 8008680:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8008684:	f000 fc15 	bl	8008eb2 <I2C_ITConfig>
  // notify error
  MIOS32_IIC_unexpected_event = event;
 8008688:	4b0f      	ldr	r3, [pc, #60]	; (80086c8 <I2C2_EV_IRQHandler+0x1b8>)
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 800868a:	4631      	mov	r1, r6
  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
 800868c:	601d      	str	r5, [r3, #0]
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
 800868e:	f06f 0307 	mvn.w	r3, #7
 8008692:	61a3      	str	r3, [r4, #24]
  iicx->transfer_state.BUSY = 0;
 8008694:	6963      	ldr	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 8008696:	6820      	ldr	r0, [r4, #0]
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
 8008698:	f366 0300 	bfi	r3, r6, #0, #1
 800869c:	6163      	str	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 800869e:	f000 fbfb 	bl	8008e98 <I2C_AcknowledgeConfig>
  b = I2C_ReceiveData(iicx->base);
 80086a2:	6820      	ldr	r0, [r4, #0]
 80086a4:	f000 fc12 	bl	8008ecc <I2C_ReceiveData>
  I2C_GenerateSTOP(iicx->base, ENABLE);
 80086a8:	6820      	ldr	r0, [r4, #0]
 80086aa:	2101      	movs	r1, #1
 80086ac:	f000 fbe7 	bl	8008e7e <I2C_GenerateSTOP>
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
  EV_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 80086b0:	bd70      	pop	{r4, r5, r6, pc}
 80086b2:	bf00      	nop
 80086b4:	20000bf8 	.word	0x20000bf8
 80086b8:	10000040 	.word	0x10000040
 80086bc:	10000002 	.word	0x10000002
 80086c0:	10000080 	.word	0x10000080
 80086c4:	10000001 	.word	0x10000001
 80086c8:	200037a4 	.word	0x200037a4

080086cc <I2C2_ER_IRQHandler>:

void I2C2_ER_IRQHandler(void)
{
 80086cc:	b538      	push	{r3, r4, r5, lr}
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 80086ce:	4d1c      	ldr	r5, [pc, #112]	; (8008740 <I2C2_ER_IRQHandler+0x74>)
 80086d0:	6828      	ldr	r0, [r5, #0]
 80086d2:	f000 fc06 	bl	8008ee2 <I2C_GetLastEvent>
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 80086d6:	4b1b      	ldr	r3, [pc, #108]	; (8008744 <I2C2_ER_IRQHandler+0x78>)
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 80086d8:	4604      	mov	r4, r0
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 80086da:	ea00 0303 	and.w	r3, r0, r3
 80086de:	b133      	cbz	r3, 80086ee <I2C2_ER_IRQHandler+0x22>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_BERR);
 80086e0:	6828      	ldr	r0, [r5, #0]
 80086e2:	4919      	ldr	r1, [pc, #100]	; (8008748 <I2C2_ER_IRQHandler+0x7c>)
 80086e4:	f000 fc05 	bl	8008ef2 <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_BUS;
 80086e8:	f06f 0305 	mvn.w	r3, #5
 80086ec:	61ab      	str	r3, [r5, #24]
  }

  // arbitration lost
  if( event & I2C_FLAG_ARLO ) {
 80086ee:	4b17      	ldr	r3, [pc, #92]	; (800874c <I2C2_ER_IRQHandler+0x80>)
 80086f0:	ea04 0303 	and.w	r3, r4, r3
 80086f4:	b13b      	cbz	r3, 8008706 <I2C2_ER_IRQHandler+0x3a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_ARLO);
 80086f6:	4d12      	ldr	r5, [pc, #72]	; (8008740 <I2C2_ER_IRQHandler+0x74>)
 80086f8:	4915      	ldr	r1, [pc, #84]	; (8008750 <I2C2_ER_IRQHandler+0x84>)
 80086fa:	6828      	ldr	r0, [r5, #0]
 80086fc:	f000 fbf9 	bl	8008ef2 <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_ARBITRATION_LOST;
 8008700:	f06f 0304 	mvn.w	r3, #4
 8008704:	61ab      	str	r3, [r5, #24]
  }

  // no acknowledge received from slave (e.g. slave not connected)
  if( event & I2C_FLAG_AF ) {
 8008706:	4b13      	ldr	r3, [pc, #76]	; (8008754 <I2C2_ER_IRQHandler+0x88>)
 8008708:	ea04 0303 	and.w	r3, r4, r3
 800870c:	b15b      	cbz	r3, 8008726 <I2C2_ER_IRQHandler+0x5a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_AF);
 800870e:	4c0c      	ldr	r4, [pc, #48]	; (8008740 <I2C2_ER_IRQHandler+0x74>)
 8008710:	4911      	ldr	r1, [pc, #68]	; (8008758 <I2C2_ER_IRQHandler+0x8c>)
 8008712:	6820      	ldr	r0, [r4, #0]
 8008714:	f000 fbed 	bl	8008ef2 <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_SLAVE_NOT_CONNECTED;
 8008718:	f06f 0306 	mvn.w	r3, #6
 800871c:	61a3      	str	r3, [r4, #24]
    // send stop condition to release bus
    I2C_GenerateSTOP(iicx->base, ENABLE);
 800871e:	6820      	ldr	r0, [r4, #0]
 8008720:	2101      	movs	r1, #1
 8008722:	f000 fbac 	bl	8008e7e <I2C_GenerateSTOP>
  }

  // disable interrupts
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008726:	4c06      	ldr	r4, [pc, #24]	; (8008740 <I2C2_ER_IRQHandler+0x74>)
 8008728:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 800872c:	6820      	ldr	r0, [r4, #0]
 800872e:	2200      	movs	r2, #0
 8008730:	f000 fbbf 	bl	8008eb2 <I2C_ITConfig>

  // notify that transfer has finished (due to the error)
  iicx->transfer_state.BUSY = 0;
 8008734:	6963      	ldr	r3, [r4, #20]
 8008736:	f36f 0300 	bfc	r3, #0, #1
 800873a:	6163      	str	r3, [r4, #20]
}

void I2C2_ER_IRQHandler(void)
{
  ER_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 800873c:	bd38      	pop	{r3, r4, r5, pc}
 800873e:	bf00      	nop
 8008740:	20000bf8 	.word	0x20000bf8
 8008744:	10000100 	.word	0x10000100
 8008748:	01000100 	.word	0x01000100
 800874c:	10000200 	.word	0x10000200
 8008750:	01000200 	.word	0x01000200
 8008754:	10000400 	.word	0x10000400
 8008758:	01000400 	.word	0x01000400

0800875c <printchar>:

#include <stdarg.h>
#include <mios32.h>

static void printchar(char **str, int c)
{
 800875c:	b508      	push	{r3, lr}
  //	extern int putchar(int c);
	
	if (str) {
 800875e:	b128      	cbz	r0, 800876c <printchar+0x10>
		**str = c;
 8008760:	6803      	ldr	r3, [r0, #0]
 8008762:	7019      	strb	r1, [r3, #0]
		++(*str);
 8008764:	6803      	ldr	r3, [r0, #0]
 8008766:	3301      	adds	r3, #1
 8008768:	6003      	str	r3, [r0, #0]
 800876a:	e003      	b.n	8008774 <printchar+0x18>
	}
#ifndef MIOS32_DONT_USE_COM
	else MIOS32_COM_SendChar(1, c); // (void)putchar(c);
 800876c:	b2c9      	uxtb	r1, r1
 800876e:	2001      	movs	r0, #1
 8008770:	f7fd fc5e 	bl	8006030 <MIOS32_COM_SendChar>
#endif
}
 8008774:	bd08      	pop	{r3, pc}

08008776 <prints>:

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 8008776:	2a00      	cmp	r2, #0

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8008778:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800877a:	468c      	mov	ip, r1
 800877c:	4604      	mov	r4, r0
 800877e:	4615      	mov	r5, r2
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 8008780:	dd10      	ble.n	80087a4 <prints+0x2e>
 8008782:	2200      	movs	r2, #0
 8008784:	e000      	b.n	8008788 <prints+0x12>
		register int len = 0;
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
 8008786:	3201      	adds	r2, #1
 8008788:	f81c 1002 	ldrb.w	r1, [ip, r2]
 800878c:	2900      	cmp	r1, #0
 800878e:	d1fa      	bne.n	8008786 <prints+0x10>
		if (len >= width) width = 0;
 8008790:	42aa      	cmp	r2, r5
 8008792:	bfac      	ite	ge
 8008794:	460d      	movge	r5, r1
		else width -= len;
 8008796:	1aad      	sublt	r5, r5, r2
		if (pad & PAD_ZERO) padchar = '0';
 8008798:	f013 0f02 	tst.w	r3, #2
 800879c:	bf0c      	ite	eq
 800879e:	2720      	moveq	r7, #32
 80087a0:	2730      	movne	r7, #48	; 0x30
 80087a2:	e000      	b.n	80087a6 <prints+0x30>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 80087a4:	2720      	movs	r7, #32
		for (ptr = string; *ptr; ++ptr) ++len;
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
 80087a6:	f013 0601 	ands.w	r6, r3, #1
 80087aa:	d10d      	bne.n	80087c8 <prints+0x52>
 80087ac:	e009      	b.n	80087c2 <prints+0x4c>
		for ( ; width > 0; --width) {
			printchar (out, padchar);
 80087ae:	4620      	mov	r0, r4
 80087b0:	4639      	mov	r1, r7
 80087b2:	f8cd c004 	str.w	ip, [sp, #4]
 80087b6:	f7ff ffd1 	bl	800875c <printchar>
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80087ba:	f8dd c004 	ldr.w	ip, [sp, #4]
			printchar (out, padchar);
			++pc;
 80087be:	3601      	adds	r6, #1
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80087c0:	3d01      	subs	r5, #1
 80087c2:	2d00      	cmp	r5, #0
 80087c4:	dcf3      	bgt.n	80087ae <prints+0x38>
 80087c6:	e000      	b.n	80087ca <prints+0x54>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 80087c8:	2600      	movs	r6, #0
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80087ca:	4663      	mov	r3, ip
 80087cc:	e005      	b.n	80087da <prints+0x64>
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
 80087ce:	4620      	mov	r0, r4
 80087d0:	9301      	str	r3, [sp, #4]
 80087d2:	f7ff ffc3 	bl	800875c <printchar>
		++pc;
 80087d6:	9b01      	ldr	r3, [sp, #4]
 80087d8:	3601      	adds	r6, #1
		for ( ; width > 0; --width) {
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
 80087da:	f813 1b01 	ldrb.w	r1, [r3], #1
 80087de:	2900      	cmp	r1, #0
 80087e0:	d1f5      	bne.n	80087ce <prints+0x58>
 80087e2:	e005      	b.n	80087f0 <prints+0x7a>
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
		printchar (out, padchar);
 80087e4:	4620      	mov	r0, r4
 80087e6:	4639      	mov	r1, r7
 80087e8:	f7ff ffb8 	bl	800875c <printchar>
		++pc;
 80087ec:	3601      	adds	r6, #1
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
 80087ee:	3d01      	subs	r5, #1
 80087f0:	2d00      	cmp	r5, #0
 80087f2:	dcf7      	bgt.n	80087e4 <prints+0x6e>
		printchar (out, padchar);
		++pc;
	}

	return pc;
}
 80087f4:	4630      	mov	r0, r6
 80087f6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080087f8 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 80087f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80087fa:	b087      	sub	sp, #28
 80087fc:	4604      	mov	r4, r0
 80087fe:	461d      	mov	r5, r3
 8008800:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008802:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
	register unsigned int u = i;
 8008804:	4608      	mov	r0, r1

	if (i == 0) {
 8008806:	b951      	cbnz	r1, 800881e <printi+0x26>
		print_buf[0] = '0';
 8008808:	2230      	movs	r2, #48	; 0x30
 800880a:	f88d 200c 	strb.w	r2, [sp, #12]
		print_buf[1] = '\0';
 800880e:	f88d 100d 	strb.w	r1, [sp, #13]
		return prints (out, print_buf, width, pad);
 8008812:	4620      	mov	r0, r4
 8008814:	a903      	add	r1, sp, #12
 8008816:	4632      	mov	r2, r6
 8008818:	f7ff ffad 	bl	8008776 <prints>
 800881c:	e043      	b.n	80088a6 <printi+0xae>
	}

	if (sg && b == 10 && i < 0) {
 800881e:	2a0a      	cmp	r2, #10
 8008820:	bf14      	ite	ne
 8008822:	2100      	movne	r1, #0
 8008824:	2101      	moveq	r1, #1
 8008826:	2d00      	cmp	r5, #0
 8008828:	bf0c      	ite	eq
 800882a:	2500      	moveq	r5, #0
 800882c:	f001 0501 	andne.w	r5, r1, #1
 8008830:	b12d      	cbz	r5, 800883e <printi+0x46>
 8008832:	2800      	cmp	r0, #0
 8008834:	da02      	bge.n	800883c <printi+0x44>
		neg = 1;
		u = -i;
 8008836:	4240      	negs	r0, r0
		print_buf[1] = '\0';
		return prints (out, print_buf, width, pad);
	}

	if (sg && b == 10 && i < 0) {
		neg = 1;
 8008838:	2501      	movs	r5, #1
 800883a:	e000      	b.n	800883e <printi+0x46>

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 800883c:	2500      	movs	r5, #0
	*s = '\0';

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 800883e:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
		neg = 1;
		u = -i;
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';
 8008842:	a906      	add	r1, sp, #24
 8008844:	f04f 0c00 	mov.w	ip, #0
 8008848:	f801 cd01 	strb.w	ip, [r1, #-1]!

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 800884c:	f1ae 0e3a 	sub.w	lr, lr, #58	; 0x3a
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 8008850:	e00d      	b.n	800886e <printi+0x76>
		t = u % b;
 8008852:	fbb0 fcf2 	udiv	ip, r0, r2
 8008856:	fb02 0c1c 	mls	ip, r2, ip, r0
		if( t >= 10 )
 800885a:	f1bc 0f09 	cmp.w	ip, #9
			t += letbase - '0' - 10;
 800885e:	bfc8      	it	gt
 8008860:	44f4      	addgt	ip, lr
		*--s = t + '0';
 8008862:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8008866:	f801 cd01 	strb.w	ip, [r1, #-1]!
		u /= b;
 800886a:	fbb0 f0f2 	udiv	r0, r0, r2
 800886e:	460f      	mov	r7, r1
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 8008870:	2800      	cmp	r0, #0
 8008872:	d1ee      	bne.n	8008852 <printi+0x5a>
			t += letbase - '0' - 10;
		*--s = t + '0';
		u /= b;
	}

	if (neg) {
 8008874:	b18d      	cbz	r5, 800889a <printi+0xa2>
		if( width && (pad & PAD_ZERO) ) {
 8008876:	b15e      	cbz	r6, 8008890 <printi+0x98>
 8008878:	f013 0f02 	tst.w	r3, #2
 800887c:	d008      	beq.n	8008890 <printi+0x98>
			printchar (out, '-');
 800887e:	4620      	mov	r0, r4
 8008880:	212d      	movs	r1, #45	; 0x2d
 8008882:	9301      	str	r3, [sp, #4]
			++pc;
			--width;
 8008884:	3e01      	subs	r6, #1
		u /= b;
	}

	if (neg) {
		if( width && (pad & PAD_ZERO) ) {
			printchar (out, '-');
 8008886:	f7ff ff69 	bl	800875c <printchar>
			++pc;
 800888a:	2501      	movs	r5, #1
			--width;
 800888c:	9b01      	ldr	r3, [sp, #4]
 800888e:	e004      	b.n	800889a <printi+0xa2>
		}
		else {
			*--s = '-';
 8008890:	222d      	movs	r2, #45	; 0x2d
 8008892:	1e4f      	subs	r7, r1, #1
 8008894:	f801 2c01 	strb.w	r2, [r1, #-1]

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 8008898:	2500      	movs	r5, #0
		else {
			*--s = '-';
		}
	}

	return pc + prints (out, s, width, pad);
 800889a:	4620      	mov	r0, r4
 800889c:	4639      	mov	r1, r7
 800889e:	4632      	mov	r2, r6
 80088a0:	f7ff ff69 	bl	8008776 <prints>
 80088a4:	1940      	adds	r0, r0, r5
}
 80088a6:	b007      	add	sp, #28
 80088a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080088ac <print>:

static int print( char **out, const char *format, va_list args )
{
 80088ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80088ae:	b089      	sub	sp, #36	; 0x24
 80088b0:	4606      	mov	r6, r0
 80088b2:	460d      	mov	r5, r1
 80088b4:	9205      	str	r2, [sp, #20]
	register int width, pad;
	register int pc = 0;
 80088b6:	2400      	movs	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
 80088b8:	e07a      	b.n	80089b0 <print+0x104>
		if (*format == '%') {
 80088ba:	2b25      	cmp	r3, #37	; 0x25
 80088bc:	d172      	bne.n	80089a4 <print+0xf8>
			++format;
			width = pad = 0;
			if (*format == '\0') break;
 80088be:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80088c2:	2b00      	cmp	r3, #0
 80088c4:	d077      	beq.n	80089b6 <print+0x10a>
			if (*format == '%') goto out;
 80088c6:	2b25      	cmp	r3, #37	; 0x25
 80088c8:	d06c      	beq.n	80089a4 <print+0xf8>
			if (*format == '-') {
 80088ca:	2b2d      	cmp	r3, #45	; 0x2d
 80088cc:	d102      	bne.n	80088d4 <print+0x28>
				++format;
 80088ce:	3501      	adds	r5, #1
				pad = PAD_RIGHT;
 80088d0:	2301      	movs	r3, #1
 80088d2:	e003      	b.n	80088dc <print+0x30>
	char scr[2];

	for (; *format != 0; ++format) {
		if (*format == '%') {
			++format;
			width = pad = 0;
 80088d4:	2300      	movs	r3, #0
 80088d6:	e001      	b.n	80088dc <print+0x30>
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
 80088d8:	f043 0302 	orr.w	r3, r3, #2
 80088dc:	462f      	mov	r7, r5
			if (*format == '%') goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
 80088de:	f815 2b01 	ldrb.w	r2, [r5], #1
 80088e2:	2a30      	cmp	r2, #48	; 0x30
 80088e4:	d0f8      	beq.n	80088d8 <print+0x2c>
 80088e6:	2200      	movs	r2, #0
 80088e8:	e002      	b.n	80088f0 <print+0x44>
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
				width *= 10;
				width += *format - '0';
 80088ea:	200a      	movs	r0, #10
 80088ec:	fb00 c202 	mla	r2, r0, r2, ip
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 80088f0:	7839      	ldrb	r1, [r7, #0]
				width *= 10;
				width += *format - '0';
 80088f2:	463d      	mov	r5, r7
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 80088f4:	f1a1 0c30 	sub.w	ip, r1, #48	; 0x30
 80088f8:	fa5f f08c 	uxtb.w	r0, ip
 80088fc:	3701      	adds	r7, #1
 80088fe:	2809      	cmp	r0, #9
 8008900:	d9f3      	bls.n	80088ea <print+0x3e>
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
 8008902:	2973      	cmp	r1, #115	; 0x73
 8008904:	d109      	bne.n	800891a <print+0x6e>
				register char *s = (char *)va_arg( args, int );
 8008906:	9905      	ldr	r1, [sp, #20]
 8008908:	1d08      	adds	r0, r1, #4
 800890a:	9005      	str	r0, [sp, #20]
 800890c:	6809      	ldr	r1, [r1, #0]
				pc += prints (out, s?s:"(null)", width, pad);
 800890e:	482d      	ldr	r0, [pc, #180]	; (80089c4 <print+0x118>)
 8008910:	2900      	cmp	r1, #0
 8008912:	bf08      	it	eq
 8008914:	4601      	moveq	r1, r0
 8008916:	4630      	mov	r0, r6
 8008918:	e041      	b.n	800899e <print+0xf2>
				continue;
			}
			if( *format == 'd' ) {
 800891a:	2964      	cmp	r1, #100	; 0x64
 800891c:	d10e      	bne.n	800893c <print+0x90>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 800891e:	9905      	ldr	r1, [sp, #20]
 8008920:	9301      	str	r3, [sp, #4]
 8008922:	2361      	movs	r3, #97	; 0x61
 8008924:	9200      	str	r2, [sp, #0]
 8008926:	9302      	str	r3, [sp, #8]
 8008928:	1d08      	adds	r0, r1, #4
 800892a:	6809      	ldr	r1, [r1, #0]
 800892c:	9005      	str	r0, [sp, #20]
 800892e:	220a      	movs	r2, #10
 8008930:	4630      	mov	r0, r6
 8008932:	2301      	movs	r3, #1
 8008934:	f7ff ff60 	bl	80087f8 <printi>
 8008938:	1824      	adds	r4, r4, r0
				continue;
 800893a:	e038      	b.n	80089ae <print+0x102>
			}
			if( *format == 'x' ) {
 800893c:	2978      	cmp	r1, #120	; 0x78
 800893e:	d106      	bne.n	800894e <print+0xa2>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 8008940:	9905      	ldr	r1, [sp, #20]
 8008942:	9301      	str	r3, [sp, #4]
 8008944:	1d08      	adds	r0, r1, #4
 8008946:	9005      	str	r0, [sp, #20]
 8008948:	9200      	str	r2, [sp, #0]
 800894a:	2361      	movs	r3, #97	; 0x61
 800894c:	e007      	b.n	800895e <print+0xb2>
				continue;
			}
			if( *format == 'X' ) {
 800894e:	2958      	cmp	r1, #88	; 0x58
 8008950:	d10a      	bne.n	8008968 <print+0xbc>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 8008952:	9905      	ldr	r1, [sp, #20]
 8008954:	9301      	str	r3, [sp, #4]
 8008956:	1d08      	adds	r0, r1, #4
 8008958:	9005      	str	r0, [sp, #20]
 800895a:	9200      	str	r2, [sp, #0]
 800895c:	2341      	movs	r3, #65	; 0x41
 800895e:	9302      	str	r3, [sp, #8]
 8008960:	4630      	mov	r0, r6
 8008962:	6809      	ldr	r1, [r1, #0]
 8008964:	2210      	movs	r2, #16
 8008966:	e00b      	b.n	8008980 <print+0xd4>
				continue;
			}
			if( *format == 'u' ) {
 8008968:	2975      	cmp	r1, #117	; 0x75
 800896a:	d10b      	bne.n	8008984 <print+0xd8>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 800896c:	9905      	ldr	r1, [sp, #20]
 800896e:	9301      	str	r3, [sp, #4]
 8008970:	2361      	movs	r3, #97	; 0x61
 8008972:	9200      	str	r2, [sp, #0]
 8008974:	9302      	str	r3, [sp, #8]
 8008976:	1d08      	adds	r0, r1, #4
 8008978:	6809      	ldr	r1, [r1, #0]
 800897a:	9005      	str	r0, [sp, #20]
 800897c:	220a      	movs	r2, #10
 800897e:	4630      	mov	r0, r6
 8008980:	2300      	movs	r3, #0
 8008982:	e7d7      	b.n	8008934 <print+0x88>
				continue;
			}
			if( *format == 'c' ) {
 8008984:	2963      	cmp	r1, #99	; 0x63
 8008986:	d112      	bne.n	80089ae <print+0x102>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
 8008988:	9905      	ldr	r1, [sp, #20]
 800898a:	1d08      	adds	r0, r1, #4
 800898c:	6809      	ldr	r1, [r1, #0]
 800898e:	9005      	str	r0, [sp, #20]
 8008990:	f88d 101c 	strb.w	r1, [sp, #28]
				scr[1] = '\0';
 8008994:	2100      	movs	r1, #0
 8008996:	f88d 101d 	strb.w	r1, [sp, #29]
				pc += prints (out, scr, width, pad);
 800899a:	4630      	mov	r0, r6
 800899c:	a907      	add	r1, sp, #28
 800899e:	f7ff feea 	bl	8008776 <prints>
 80089a2:	e7c9      	b.n	8008938 <print+0x8c>
				continue;
			}
		}
		else {
		out:
			printchar (out, *format);
 80089a4:	7829      	ldrb	r1, [r5, #0]
 80089a6:	4630      	mov	r0, r6
 80089a8:	f7ff fed8 	bl	800875c <printchar>
			++pc;
 80089ac:	3401      	adds	r4, #1
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
 80089ae:	3501      	adds	r5, #1
 80089b0:	782b      	ldrb	r3, [r5, #0]
 80089b2:	2b00      	cmp	r3, #0
 80089b4:	d181      	bne.n	80088ba <print+0xe>
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
 80089b6:	b116      	cbz	r6, 80089be <print+0x112>
 80089b8:	6833      	ldr	r3, [r6, #0]
 80089ba:	2200      	movs	r2, #0
 80089bc:	701a      	strb	r2, [r3, #0]
	va_end( args );
	return pc;
}
 80089be:	4620      	mov	r0, r4
 80089c0:	b009      	add	sp, #36	; 0x24
 80089c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80089c4:	0800b1a8 	.word	0x0800b1a8

080089c8 <sprintf>:
{
  return print( 0, format, args );
}

int sprintf(char *out, const char *format, ...)
{
 80089c8:	b40e      	push	{r1, r2, r3}
 80089ca:	b50f      	push	{r0, r1, r2, r3, lr}
 80089cc:	aa05      	add	r2, sp, #20
 80089ce:	f852 1b04 	ldr.w	r1, [r2], #4
 80089d2:	9001      	str	r0, [sp, #4]
        va_list args;
        
        va_start( args, format );
        return print( &out, format, args );
 80089d4:	a801      	add	r0, sp, #4

int sprintf(char *out, const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
 80089d6:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 80089d8:	f7ff ff68 	bl	80088ac <print>
}
 80089dc:	b004      	add	sp, #16
 80089de:	f85d eb04 	ldr.w	lr, [sp], #4
 80089e2:	b003      	add	sp, #12
 80089e4:	4770      	bx	lr

080089e6 <vsprintf>:

// TK: added for alternative parameter passing
int vsprintf(char *out, const char *format, va_list args)
{
 80089e6:	b507      	push	{r0, r1, r2, lr}
 80089e8:	4603      	mov	r3, r0
  char *_out;
  _out = out;
 80089ea:	a802      	add	r0, sp, #8
 80089ec:	f840 3d04 	str.w	r3, [r0, #-4]!
  return print( &_out, format, args );
 80089f0:	f7ff ff5c 	bl	80088ac <print>
}
 80089f4:	bd0e      	pop	{r1, r2, r3, pc}

080089f6 <GPIO_Init>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 80089f6:	78cb      	ldrb	r3, [r1, #3]
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80089f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 80089fa:	f013 0f10 	tst.w	r3, #16
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 80089fe:	f003 020f 	and.w	r2, r3, #15
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8008a02:	880f      	ldrh	r7, [r1, #0]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8008a04:	bf1c      	itt	ne
 8008a06:	788b      	ldrbne	r3, [r1, #2]
 8008a08:	431a      	orrne	r2, r3
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8008a0a:	f017 0fff 	tst.w	r7, #255	; 0xff
 8008a0e:	d022      	beq.n	8008a56 <GPIO_Init+0x60>
  {
    tmpreg = GPIOx->CRL;
 8008a10:	f8d0 c000 	ldr.w	ip, [r0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008a14:	2300      	movs	r3, #0
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008a16:	9701      	str	r7, [sp, #4]
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
 8008a18:	2401      	movs	r4, #1
 8008a1a:	fa14 f503 	lsls.w	r5, r4, r3
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8008a1e:	9e01      	ldr	r6, [sp, #4]
 8008a20:	ea05 0406 	and.w	r4, r5, r6
      if (currentpin == pos)
 8008a24:	42ac      	cmp	r4, r5
 8008a26:	d111      	bne.n	8008a4c <GPIO_Init+0x56>
      {
        pos = pinpos << 2;
 8008a28:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008a2a:	270f      	movs	r7, #15
 8008a2c:	fa17 f506 	lsls.w	r5, r7, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008a30:	fa12 f606 	lsls.w	r6, r2, r6
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8008a34:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a38:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008a3a:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a3e:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8008a40:	bf08      	it	eq
 8008a42:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a44:	d002      	beq.n	8008a4c <GPIO_Init+0x56>
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8008a46:	2d48      	cmp	r5, #72	; 0x48
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8008a48:	bf08      	it	eq
 8008a4a:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008a4c:	3301      	adds	r3, #1
 8008a4e:	2b08      	cmp	r3, #8
 8008a50:	d1e2      	bne.n	8008a18 <GPIO_Init+0x22>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8008a52:	f8c0 c000 	str.w	ip, [r0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8008a56:	880f      	ldrh	r7, [r1, #0]
 8008a58:	2fff      	cmp	r7, #255	; 0xff
 8008a5a:	d924      	bls.n	8008aa6 <GPIO_Init+0xb0>
  {
    tmpreg = GPIOx->CRH;
 8008a5c:	f8d0 c004 	ldr.w	ip, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008a60:	2300      	movs	r3, #0
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008a62:	9201      	str	r2, [sp, #4]
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8008a64:	2201      	movs	r2, #1
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
 8008a66:	f103 0508 	add.w	r5, r3, #8
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8008a6a:	fa12 f505 	lsls.w	r5, r2, r5
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8008a6e:	ea05 0407 	and.w	r4, r5, r7
      if (currentpin == pos)
 8008a72:	42ac      	cmp	r4, r5
 8008a74:	d112      	bne.n	8008a9c <GPIO_Init+0xa6>
      {
        pos = pinpos << 2;
 8008a76:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008a78:	320e      	adds	r2, #14
 8008a7a:	fa12 f506 	lsls.w	r5, r2, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008a7e:	9a01      	ldr	r2, [sp, #4]
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8008a80:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008a84:	fa12 f606 	lsls.w	r6, r2, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a88:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008a8a:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a8e:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8008a90:	bf08      	it	eq
 8008a92:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a94:	d002      	beq.n	8008a9c <GPIO_Init+0xa6>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8008a96:	2d48      	cmp	r5, #72	; 0x48
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8008a98:	bf08      	it	eq
 8008a9a:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008a9c:	3301      	adds	r3, #1
 8008a9e:	2b08      	cmp	r3, #8
 8008aa0:	d1e0      	bne.n	8008a64 <GPIO_Init+0x6e>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8008aa2:	f8c0 c004 	str.w	ip, [r0, #4]
  }
}
 8008aa6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08008aa8 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8008aa8:	f04f 33ff 	mov.w	r3, #4294967295
 8008aac:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8008aae:	2302      	movs	r3, #2
 8008ab0:	7083      	strb	r3, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8008ab2:	18db      	adds	r3, r3, r3
 8008ab4:	70c3      	strb	r3, [r0, #3]
}
 8008ab6:	4770      	bx	lr

08008ab8 <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8008ab8:	2800      	cmp	r0, #0
  {
    tmpreg = AFIO->MAPR2;
 8008aba:	bfb4      	ite	lt
 8008abc:	4b1a      	ldrlt	r3, [pc, #104]	; (8008b28 <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    tmpreg = AFIO->MAPR;
 8008abe:	4b1a      	ldrge	r3, [pc, #104]	; (8008b28 <GPIO_PinRemapConfig+0x70>)
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008ac0:	f400 1c40 	and.w	ip, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 8008ac4:	bfb4      	ite	lt
 8008ac6:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 8008ac8:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008aca:	f5bc 1f40 	cmp.w	ip, #3145728	; 0x300000
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 8008ace:	b510      	push	{r4, lr}
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 8008ad0:	b282      	uxth	r2, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008ad2:	d10a      	bne.n	8008aea <GPIO_PinRemapConfig+0x32>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8008ad4:	f8df c050 	ldr.w	ip, [pc, #80]	; 8008b28 <GPIO_PinRemapConfig+0x70>
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8008ad8:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8008adc:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8008ae0:	f024 6470 	bic.w	r4, r4, #251658240	; 0xf000000
 8008ae4:	f8cc 4004 	str.w	r4, [ip, #4]
 8008ae8:	e012      	b.n	8008b10 <GPIO_PinRemapConfig+0x58>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8008aea:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008aee:	bf02      	ittt	eq
 8008af0:	ea4f 5c50 	moveq.w	ip, r0, lsr #21
 8008af4:	ea4f 1c0c 	moveq.w	ip, ip, lsl #4
 8008af8:	fa02 fc0c 	lsleq.w	ip, r2, ip
  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8008afc:	d004      	beq.n	8008b08 <GPIO_PinRemapConfig+0x50>
  else
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 8008afe:	f3c0 4c03 	ubfx	ip, r0, #16, #4
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 8008b02:	2403      	movs	r4, #3
 8008b04:	fa04 fc0c 	lsl.w	ip, r4, ip
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008b08:	ea23 030c 	bic.w	r3, r3, ip
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8008b0c:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  }

  if (NewState != DISABLE)
 8008b10:	b119      	cbz	r1, 8008b1a <GPIO_PinRemapConfig+0x62>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008b12:	0d41      	lsrs	r1, r0, #21
 8008b14:	0109      	lsls	r1, r1, #4
 8008b16:	408a      	lsls	r2, r1
 8008b18:	4313      	orrs	r3, r2
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8008b1a:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 8008b1c:	bfb5      	itete	lt
 8008b1e:	4a02      	ldrlt	r2, [pc, #8]	; (8008b28 <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008b20:	4a01      	ldrge	r2, [pc, #4]	; (8008b28 <GPIO_PinRemapConfig+0x70>)
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    AFIO->MAPR2 = tmpreg;
 8008b22:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008b24:	6053      	strge	r3, [r2, #4]
  }  
}
 8008b26:	bd10      	pop	{r4, pc}
 8008b28:	40010000 	.word	0x40010000

08008b2c <FLASH_SetLatency>:
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 8008b2c:	4b03      	ldr	r3, [pc, #12]	; (8008b3c <FLASH_SetLatency+0x10>)
 8008b2e:	681a      	ldr	r2, [r3, #0]
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8008b30:	f002 0238 	and.w	r2, r2, #56	; 0x38
  tmpreg |= FLASH_Latency;
 8008b34:	4310      	orrs	r0, r2
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8008b36:	6018      	str	r0, [r3, #0]
}
 8008b38:	4770      	bx	lr
 8008b3a:	bf00      	nop
 8008b3c:	40022000 	.word	0x40022000

08008b40 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 8008b40:	4b04      	ldr	r3, [pc, #16]	; (8008b54 <FLASH_PrefetchBufferCmd+0x14>)
 8008b42:	681a      	ldr	r2, [r3, #0]
 8008b44:	f022 0210 	bic.w	r2, r2, #16
 8008b48:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 8008b4a:	681a      	ldr	r2, [r3, #0]
 8008b4c:	4310      	orrs	r0, r2
 8008b4e:	6018      	str	r0, [r3, #0]
}
 8008b50:	4770      	bx	lr
 8008b52:	bf00      	nop
 8008b54:	40022000 	.word	0x40022000

08008b58 <ADC_Init>:
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8008b58:	6843      	ldr	r3, [r0, #4]
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
 8008b5a:	680a      	ldr	r2, [r1, #0]

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
 8008b5c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8008b60:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
 8008b64:	4313      	orrs	r3, r2
 8008b66:	790a      	ldrb	r2, [r1, #4]
 8008b68:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8008b6c:	6043      	str	r3, [r0, #4]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008b6e:	688a      	ldr	r2, [r1, #8]
 8008b70:	68cb      	ldr	r3, [r1, #12]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8008b72:	f8d0 c008 	ldr.w	ip, [r0, #8]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008b76:	431a      	orrs	r2, r3

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  /* Clear CONT, ALIGN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_Mask;
 8008b78:	4b09      	ldr	r3, [pc, #36]	; (8008ba0 <ADC_Init+0x48>)
 8008b7a:	ea0c 0303 	and.w	r3, ip, r3
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008b7e:	ea42 0303 	orr.w	r3, r2, r3
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8008b82:	794a      	ldrb	r2, [r1, #5]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008b84:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8008b88:	6083      	str	r3, [r0, #8]
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 8008b8a:	7c0b      	ldrb	r3, [r1, #16]
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8008b8c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 8008b8e:	3b01      	subs	r3, #1

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
 8008b90:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
 8008b94:	b2db      	uxtb	r3, r3
 8008b96:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8008b9a:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8008b9c:	4770      	bx	lr
 8008b9e:	bf00      	nop
 8008ba0:	fff1f7fd 	.word	0xfff1f7fd

08008ba4 <ADC_StructInit>:
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
 8008ba4:	2300      	movs	r3, #0
 8008ba6:	6003      	str	r3, [r0, #0]
  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8008ba8:	7103      	strb	r3, [r0, #4]
  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8008baa:	7143      	strb	r3, [r0, #5]
  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 8008bac:	6083      	str	r3, [r0, #8]
  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8008bae:	60c3      	str	r3, [r0, #12]
  /* Initialize the ADC_NbrOfChannel member */
  ADC_InitStruct->ADC_NbrOfChannel = 1;
 8008bb0:	3301      	adds	r3, #1
 8008bb2:	7403      	strb	r3, [r0, #16]
}
 8008bb4:	4770      	bx	lr

08008bb6 <ADC_Cmd>:
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008bb6:	b119      	cbz	r1, 8008bc0 <ADC_Cmd+0xa>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
 8008bb8:	6883      	ldr	r3, [r0, #8]
 8008bba:	f043 0301 	orr.w	r3, r3, #1
 8008bbe:	e002      	b.n	8008bc6 <ADC_Cmd+0x10>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
 8008bc0:	6883      	ldr	r3, [r0, #8]
 8008bc2:	f023 0301 	bic.w	r3, r3, #1
 8008bc6:	6083      	str	r3, [r0, #8]
  }
}
 8008bc8:	4770      	bx	lr

08008bca <ADC_DMACmd>:
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008bca:	b119      	cbz	r1, 8008bd4 <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
 8008bcc:	6883      	ldr	r3, [r0, #8]
 8008bce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008bd2:	e002      	b.n	8008bda <ADC_DMACmd+0x10>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
 8008bd4:	6883      	ldr	r3, [r0, #8]
 8008bd6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008bda:	6083      	str	r3, [r0, #8]
  }
}
 8008bdc:	4770      	bx	lr

08008bde <ADC_ResetCalibration>:
void ADC_ResetCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
 8008bde:	6883      	ldr	r3, [r0, #8]
 8008be0:	f043 0308 	orr.w	r3, r3, #8
 8008be4:	6083      	str	r3, [r0, #8]
}
 8008be6:	4770      	bx	lr

08008be8 <ADC_GetResetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
 8008be8:	6880      	ldr	r0, [r0, #8]
 8008bea:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    /* RSTCAL bit is reset */
    bitstatus = RESET;
  }
  /* Return the RSTCAL bit status */
  return  bitstatus;
}
 8008bee:	4770      	bx	lr

08008bf0 <ADC_StartCalibration>:
void ADC_StartCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
 8008bf0:	6883      	ldr	r3, [r0, #8]
 8008bf2:	f043 0304 	orr.w	r3, r3, #4
 8008bf6:	6083      	str	r3, [r0, #8]
}
 8008bf8:	4770      	bx	lr

08008bfa <ADC_GetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
 8008bfa:	6880      	ldr	r0, [r0, #8]
 8008bfc:	f3c0 0080 	ubfx	r0, r0, #2, #1
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
 8008c00:	4770      	bx	lr

08008c02 <ADC_SoftwareStartConvCmd>:
void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008c02:	b119      	cbz	r1, 8008c0c <ADC_SoftwareStartConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
 8008c04:	6883      	ldr	r3, [r0, #8]
 8008c06:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 8008c0a:	e002      	b.n	8008c12 <ADC_SoftwareStartConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
 8008c0c:	6883      	ldr	r3, [r0, #8]
 8008c0e:	f423 03a0 	bic.w	r3, r3, #5242880	; 0x500000
 8008c12:	6083      	str	r3, [r0, #8]
  }
}
 8008c14:	4770      	bx	lr

08008c16 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8008c16:	2909      	cmp	r1, #9
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8008c18:	b530      	push	{r4, r5, lr}
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8008c1a:	d912      	bls.n	8008c42 <ADC_RegularChannelConfig+0x2c>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
 8008c1c:	f04f 0c03 	mov.w	ip, #3
 8008c20:	fb0c fc01 	mul.w	ip, ip, r1
 8008c24:	2407      	movs	r4, #7
 8008c26:	f1ac 0c1e 	sub.w	ip, ip, #30
 8008c2a:	fa04 f40c 	lsl.w	r4, r4, ip
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8008c2e:	fa03 f30c 	lsl.w	r3, r3, ip
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8008c32:	68c5      	ldr	r5, [r0, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 8008c34:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 8008c38:	ea44 0c03 	orr.w	ip, r4, r3
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8008c3c:	f8c0 c00c 	str.w	ip, [r0, #12]
 8008c40:	e00e      	b.n	8008c60 <ADC_RegularChannelConfig+0x4a>
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 8008c42:	f04f 0c03 	mov.w	ip, #3
 8008c46:	fb0c fc01 	mul.w	ip, ip, r1
 8008c4a:	2407      	movs	r4, #7
 8008c4c:	fa04 f40c 	lsl.w	r4, r4, ip
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8008c50:	fa03 fc0c 	lsl.w	ip, r3, ip
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8008c54:	6905      	ldr	r5, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 8008c56:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 8008c5a:	ea44 030c 	orr.w	r3, r4, ip
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8008c5e:	6103      	str	r3, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8008c60:	2a06      	cmp	r2, #6
 8008c62:	d80d      	bhi.n	8008c80 <ADC_RegularChannelConfig+0x6a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
 8008c64:	2305      	movs	r3, #5
 8008c66:	3a01      	subs	r2, #1
 8008c68:	435a      	muls	r2, r3
 8008c6a:	331a      	adds	r3, #26
 8008c6c:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8008c6e:	4091      	lsls	r1, r2
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8008c70:	f8d0 c034 	ldr.w	ip, [r0, #52]	; 0x34
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008c74:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008c78:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8008c7c:	6342      	str	r2, [r0, #52]	; 0x34
 8008c7e:	e01c      	b.n	8008cba <ADC_RegularChannelConfig+0xa4>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 8008c80:	2a0c      	cmp	r2, #12
 8008c82:	d80d      	bhi.n	8008ca0 <ADC_RegularChannelConfig+0x8a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
 8008c84:	2305      	movs	r3, #5
 8008c86:	435a      	muls	r2, r3
 8008c88:	331a      	adds	r3, #26
 8008c8a:	3a23      	subs	r2, #35	; 0x23
 8008c8c:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8008c8e:	4091      	lsls	r1, r2
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8008c90:	f8d0 c030 	ldr.w	ip, [r0, #48]	; 0x30
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008c94:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008c98:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8008c9c:	6302      	str	r2, [r0, #48]	; 0x30
 8008c9e:	e00c      	b.n	8008cba <ADC_RegularChannelConfig+0xa4>
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
 8008ca0:	2305      	movs	r3, #5
 8008ca2:	435a      	muls	r2, r3
 8008ca4:	331a      	adds	r3, #26
 8008ca6:	3a41      	subs	r2, #65	; 0x41
 8008ca8:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8008caa:	4091      	lsls	r1, r2
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8008cac:	f8d0 c02c 	ldr.w	ip, [r0, #44]	; 0x2c
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008cb0:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008cb4:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8008cb8:	62c2      	str	r2, [r0, #44]	; 0x2c
  }
}
 8008cba:	bd30      	pop	{r4, r5, pc}

08008cbc <ADC_ExternalTrigConvCmd>:
void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008cbc:	b119      	cbz	r1, 8008cc6 <ADC_ExternalTrigConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event */
    ADCx->CR2 |= CR2_EXTTRIG_Set;
 8008cbe:	6883      	ldr	r3, [r0, #8]
 8008cc0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008cc4:	e002      	b.n	8008ccc <ADC_ExternalTrigConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event */
    ADCx->CR2 &= CR2_EXTTRIG_Reset;
 8008cc6:	6883      	ldr	r3, [r0, #8]
 8008cc8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8008ccc:	6083      	str	r3, [r0, #8]
  }
}
 8008cce:	4770      	bx	lr

08008cd0 <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008cd0:	f8b1 c002 	ldrh.w	ip, [r1, #2]
 8008cd4:	880b      	ldrh	r3, [r1, #0]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8008cd6:	8802      	ldrh	r2, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008cd8:	ea4c 0303 	orr.w	r3, ip, r3
 8008cdc:	f8b1 c004 	ldrh.w	ip, [r1, #4]

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008ce0:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008ce4:	ea43 030c 	orr.w	r3, r3, ip
 8008ce8:	f8b1 c006 	ldrh.w	ip, [r1, #6]
 8008cec:	ea43 030c 	orr.w	r3, r3, ip
 8008cf0:	f8b1 c008 	ldrh.w	ip, [r1, #8]
 8008cf4:	ea43 030c 	orr.w	r3, r3, ip
 8008cf8:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 8008cfc:	ea43 030c 	orr.w	r3, r3, ip
 8008d00:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
 8008d04:	ea43 030c 	orr.w	r3, r3, ip
 8008d08:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
 8008d0c:	ea43 030c 	orr.w	r3, r3, ip
 8008d10:	ea42 0303 	orr.w	r3, r2, r3
 8008d14:	b29b      	uxth	r3, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8008d16:	8003      	strh	r3, [r0, #0]
  
  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= SPI_Mode_Select;		
 8008d18:	8b83      	ldrh	r3, [r0, #28]
 8008d1a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8008d1e:	041b      	lsls	r3, r3, #16
 8008d20:	0c1b      	lsrs	r3, r3, #16
 8008d22:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8008d24:	8a0b      	ldrh	r3, [r1, #16]
 8008d26:	8203      	strh	r3, [r0, #16]
}
 8008d28:	4770      	bx	lr

08008d2a <SPI_Cmd>:
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008d2a:	b121      	cbz	r1, 8008d36 <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 8008d2c:	8803      	ldrh	r3, [r0, #0]
 8008d2e:	b29b      	uxth	r3, r3
 8008d30:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008d34:	e004      	b.n	8008d40 <SPI_Cmd+0x16>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= CR1_SPE_Reset;
 8008d36:	8803      	ldrh	r3, [r0, #0]
 8008d38:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8008d3c:	041b      	lsls	r3, r3, #16
 8008d3e:	0c1b      	lsrs	r3, r3, #16
 8008d40:	8003      	strh	r3, [r0, #0]
  }
}
 8008d42:	4770      	bx	lr

08008d44 <SPI_I2S_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
 8008d44:	b11a      	cbz	r2, 8008d4e <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8008d46:	8883      	ldrh	r3, [r0, #4]
 8008d48:	b29b      	uxth	r3, r3
 8008d4a:	4319      	orrs	r1, r3
 8008d4c:	e003      	b.n	8008d56 <SPI_I2S_DMACmd+0x12>
  }
  else
  {
    /* Disable the selected SPI/I2S DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8008d4e:	8883      	ldrh	r3, [r0, #4]
 8008d50:	b29b      	uxth	r3, r3
 8008d52:	ea23 0101 	bic.w	r1, r3, r1
 8008d56:	8081      	strh	r1, [r0, #4]
  }
}
 8008d58:	4770      	bx	lr
	...

08008d5c <USART_Init>:
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8008d5c:	8a03      	ldrh	r3, [r0, #16]
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8008d5e:	88ca      	ldrh	r2, [r1, #6]
  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 8008d60:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8008d64:	041b      	lsls	r3, r3, #16
 8008d66:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8008d68:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008d6a:	b530      	push	{r4, r5, lr}
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8008d6c:	8203      	strh	r3, [r0, #16]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008d6e:	460d      	mov	r5, r1
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8008d70:	8983      	ldrh	r3, [r0, #12]
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008d72:	8909      	ldrh	r1, [r1, #8]
 8008d74:	88aa      	ldrh	r2, [r5, #4]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008d76:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008d7a:	ea41 0202 	orr.w	r2, r1, r2
 8008d7e:	8969      	ldrh	r1, [r5, #10]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008d80:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008d84:	430a      	orrs	r2, r1
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008d86:	041b      	lsls	r3, r3, #16
 8008d88:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008d8a:	b292      	uxth	r2, r2
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8008d8c:	ea42 0303 	orr.w	r3, r2, r3
 8008d90:	8183      	strh	r3, [r0, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8008d92:	8a83      	ldrh	r3, [r0, #20]
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8008d94:	89aa      	ldrh	r2, [r5, #12]
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8008d96:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008d9a:	041b      	lsls	r3, r3, #16
 8008d9c:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8008d9e:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008da0:	b087      	sub	sp, #28
 8008da2:	4604      	mov	r4, r0
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8008da4:	8283      	strh	r3, [r0, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8008da6:	a801      	add	r0, sp, #4
 8008da8:	f000 fa92 	bl	80092d0 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 8008dac:	4b18      	ldr	r3, [pc, #96]	; (8008e10 <USART_Init+0xb4>)
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008dae:	89a2      	ldrh	r2, [r4, #12]
  USARTx->CR3 = (uint16_t)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
 8008db0:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008db2:	b212      	sxth	r2, r2
/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8008db4:	bf0c      	ite	eq
 8008db6:	9b04      	ldreq	r3, [sp, #16]
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8008db8:	9b03      	ldrne	r3, [sp, #12]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008dba:	2a00      	cmp	r2, #0
 8008dbc:	682a      	ldr	r2, [r5, #0]
 8008dbe:	da03      	bge.n	8008dc8 <USART_Init+0x6c>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8008dc0:	2119      	movs	r1, #25
 8008dc2:	4359      	muls	r1, r3
 8008dc4:	0052      	lsls	r2, r2, #1
 8008dc6:	e002      	b.n	8008dce <USART_Init+0x72>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8008dc8:	2119      	movs	r1, #25
 8008dca:	4359      	muls	r1, r3
 8008dcc:	0092      	lsls	r2, r2, #2
  }
  tmpreg = (integerdivider / 100) << 4;
 8008dce:	2364      	movs	r3, #100	; 0x64
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8008dd0:	fbb1 f1f2 	udiv	r1, r1, r2
  }
  tmpreg = (integerdivider / 100) << 4;
 8008dd4:	fbb1 f2f3 	udiv	r2, r1, r3
 8008dd8:	0112      	lsls	r2, r2, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8008dda:	0910      	lsrs	r0, r2, #4
 8008ddc:	fb03 1110 	mls	r1, r3, r0, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008de0:	89a0      	ldrh	r0, [r4, #12]
 8008de2:	b200      	sxth	r0, r0
 8008de4:	2800      	cmp	r0, #0
 8008de6:	da06      	bge.n	8008df6 <USART_Init+0x9a>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8008de8:	00c9      	lsls	r1, r1, #3
 8008dea:	3132      	adds	r1, #50	; 0x32
 8008dec:	fbb1 f3f3 	udiv	r3, r1, r3
 8008df0:	f003 0307 	and.w	r3, r3, #7
 8008df4:	e005      	b.n	8008e02 <USART_Init+0xa6>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8008df6:	0109      	lsls	r1, r1, #4
 8008df8:	3132      	adds	r1, #50	; 0x32
 8008dfa:	fbb1 f3f3 	udiv	r3, r1, r3
 8008dfe:	f003 030f 	and.w	r3, r3, #15
 8008e02:	ea43 0202 	orr.w	r2, r3, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 8008e06:	b292      	uxth	r2, r2
 8008e08:	8122      	strh	r2, [r4, #8]
}
 8008e0a:	b007      	add	sp, #28
 8008e0c:	bd30      	pop	{r4, r5, pc}
 8008e0e:	bf00      	nop
 8008e10:	40013800 	.word	0x40013800

08008e14 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008e14:	b121      	cbz	r1, 8008e20 <USART_Cmd+0xc>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8008e16:	8983      	ldrh	r3, [r0, #12]
 8008e18:	b29b      	uxth	r3, r3
 8008e1a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8008e1e:	e004      	b.n	8008e2a <USART_Cmd+0x16>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 8008e20:	8983      	ldrh	r3, [r0, #12]
 8008e22:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008e26:	041b      	lsls	r3, r3, #16
 8008e28:	0c1b      	lsrs	r3, r3, #16
 8008e2a:	8183      	strh	r3, [r0, #12]
  }
}
 8008e2c:	4770      	bx	lr

08008e2e <USART_ITConfig>:
  }   
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8008e2e:	f3c1 1342 	ubfx	r3, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8008e32:	f04f 0c01 	mov.w	ip, #1

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
 8008e36:	f001 011f 	and.w	r1, r1, #31
  itmask = (((uint32_t)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8008e3a:	4563      	cmp	r3, ip
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8008e3c:	fa0c f101 	lsl.w	r1, ip, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8008e40:	d101      	bne.n	8008e46 <USART_ITConfig+0x18>
  {
    usartxbase += 0x0C;
 8008e42:	300c      	adds	r0, #12
 8008e44:	e004      	b.n	8008e50 <USART_ITConfig+0x22>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8008e46:	2b02      	cmp	r3, #2
 8008e48:	d101      	bne.n	8008e4e <USART_ITConfig+0x20>
  {
    usartxbase += 0x10;
 8008e4a:	3010      	adds	r0, #16
 8008e4c:	e000      	b.n	8008e50 <USART_ITConfig+0x22>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8008e4e:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
 8008e50:	b11a      	cbz	r2, 8008e5a <USART_ITConfig+0x2c>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8008e52:	6803      	ldr	r3, [r0, #0]
 8008e54:	ea43 0101 	orr.w	r1, r3, r1
 8008e58:	e002      	b.n	8008e60 <USART_ITConfig+0x32>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8008e5a:	6803      	ldr	r3, [r0, #0]
 8008e5c:	ea23 0101 	bic.w	r1, r3, r1
 8008e60:	6001      	str	r1, [r0, #0]
  }
}
 8008e62:	4770      	bx	lr

08008e64 <I2C_GenerateSTART>:
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008e64:	b121      	cbz	r1, 8008e70 <I2C_GenerateSTART+0xc>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 8008e66:	8803      	ldrh	r3, [r0, #0]
 8008e68:	b29b      	uxth	r3, r3
 8008e6a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008e6e:	e004      	b.n	8008e7a <I2C_GenerateSTART+0x16>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
 8008e70:	8803      	ldrh	r3, [r0, #0]
 8008e72:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008e76:	041b      	lsls	r3, r3, #16
 8008e78:	0c1b      	lsrs	r3, r3, #16
 8008e7a:	8003      	strh	r3, [r0, #0]
  }
}
 8008e7c:	4770      	bx	lr

08008e7e <I2C_GenerateSTOP>:
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008e7e:	b121      	cbz	r1, 8008e8a <I2C_GenerateSTOP+0xc>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 8008e80:	8803      	ldrh	r3, [r0, #0]
 8008e82:	b29b      	uxth	r3, r3
 8008e84:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008e88:	e004      	b.n	8008e94 <I2C_GenerateSTOP+0x16>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
 8008e8a:	8803      	ldrh	r3, [r0, #0]
 8008e8c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8008e90:	041b      	lsls	r3, r3, #16
 8008e92:	0c1b      	lsrs	r3, r3, #16
 8008e94:	8003      	strh	r3, [r0, #0]
  }
}
 8008e96:	4770      	bx	lr

08008e98 <I2C_AcknowledgeConfig>:
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008e98:	b121      	cbz	r1, 8008ea4 <I2C_AcknowledgeConfig+0xc>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8008e9a:	8803      	ldrh	r3, [r0, #0]
 8008e9c:	b29b      	uxth	r3, r3
 8008e9e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008ea2:	e004      	b.n	8008eae <I2C_AcknowledgeConfig+0x16>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
 8008ea4:	8803      	ldrh	r3, [r0, #0]
 8008ea6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008eaa:	041b      	lsls	r3, r3, #16
 8008eac:	0c1b      	lsrs	r3, r3, #16
 8008eae:	8003      	strh	r3, [r0, #0]
  }
}
 8008eb0:	4770      	bx	lr

08008eb2 <I2C_ITConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8008eb2:	b11a      	cbz	r2, 8008ebc <I2C_ITConfig+0xa>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8008eb4:	8883      	ldrh	r3, [r0, #4]
 8008eb6:	b29b      	uxth	r3, r3
 8008eb8:	4319      	orrs	r1, r3
 8008eba:	e003      	b.n	8008ec4 <I2C_ITConfig+0x12>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8008ebc:	8883      	ldrh	r3, [r0, #4]
 8008ebe:	b29b      	uxth	r3, r3
 8008ec0:	ea23 0101 	bic.w	r1, r3, r1
 8008ec4:	8081      	strh	r1, [r0, #4]
  }
}
 8008ec6:	4770      	bx	lr

08008ec8 <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8008ec8:	8201      	strh	r1, [r0, #16]
}
 8008eca:	4770      	bx	lr

08008ecc <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8008ecc:	8a00      	ldrh	r0, [r0, #16]
 8008ece:	b2c0      	uxtb	r0, r0
}
 8008ed0:	4770      	bx	lr

08008ed2 <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 8008ed2:	b112      	cbz	r2, 8008eda <I2C_Send7bitAddress+0x8>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 8008ed4:	f041 0101 	orr.w	r1, r1, #1
 8008ed8:	e001      	b.n	8008ede <I2C_Send7bitAddress+0xc>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 8008eda:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 8008ede:	8201      	strh	r1, [r0, #16]
}
 8008ee0:	4770      	bx	lr

08008ee2 <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8008ee2:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 8008ee4:	8b00      	ldrh	r0, [r0, #24]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8008ee6:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 8008ee8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8008eec:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

  /* Return status */
  return lastevent;
}
 8008ef0:	4770      	bx	lr

08008ef2 <I2C_ClearITPendingBit>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_Mask;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8008ef2:	43c9      	mvns	r1, r1
 8008ef4:	b289      	uxth	r1, r1
 8008ef6:	8281      	strh	r1, [r0, #20]
}
 8008ef8:	4770      	bx	lr
	...

08008efc <DMA_DeInit>:
void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 8008efc:	6803      	ldr	r3, [r0, #0]
 8008efe:	f023 0301 	bic.w	r3, r3, #1
 8008f02:	6003      	str	r3, [r0, #0]
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8008f04:	2300      	movs	r3, #0
 8008f06:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8008f08:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8008f0a:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 8008f0c:	60c3      	str	r3, [r0, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8008f0e:	4b24      	ldr	r3, [pc, #144]	; (8008fa0 <DMA_DeInit+0xa4>)
 8008f10:	4298      	cmp	r0, r3
 8008f12:	d01e      	beq.n	8008f52 <DMA_DeInit+0x56>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8008f14:	4b23      	ldr	r3, [pc, #140]	; (8008fa4 <DMA_DeInit+0xa8>)
 8008f16:	4298      	cmp	r0, r3
 8008f18:	d023      	beq.n	8008f62 <DMA_DeInit+0x66>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8008f1a:	4b23      	ldr	r3, [pc, #140]	; (8008fa8 <DMA_DeInit+0xac>)
 8008f1c:	4298      	cmp	r0, r3
 8008f1e:	d028      	beq.n	8008f72 <DMA_DeInit+0x76>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8008f20:	4b22      	ldr	r3, [pc, #136]	; (8008fac <DMA_DeInit+0xb0>)
 8008f22:	4298      	cmp	r0, r3
 8008f24:	d02d      	beq.n	8008f82 <DMA_DeInit+0x86>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8008f26:	4b22      	ldr	r3, [pc, #136]	; (8008fb0 <DMA_DeInit+0xb4>)
 8008f28:	4298      	cmp	r0, r3
 8008f2a:	d032      	beq.n	8008f92 <DMA_DeInit+0x96>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8008f2c:	4b21      	ldr	r3, [pc, #132]	; (8008fb4 <DMA_DeInit+0xb8>)
 8008f2e:	4298      	cmp	r0, r3
 8008f30:	d104      	bne.n	8008f3c <DMA_DeInit+0x40>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 8008f32:	3b6c      	subs	r3, #108	; 0x6c
 8008f34:	685a      	ldr	r2, [r3, #4]
 8008f36:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8008f3a:	e02e      	b.n	8008f9a <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8008f3c:	4b1e      	ldr	r3, [pc, #120]	; (8008fb8 <DMA_DeInit+0xbc>)
 8008f3e:	4298      	cmp	r0, r3
 8008f40:	d104      	bne.n	8008f4c <DMA_DeInit+0x50>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8008f42:	3b80      	subs	r3, #128	; 0x80
 8008f44:	685a      	ldr	r2, [r3, #4]
 8008f46:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 8008f4a:	e026      	b.n	8008f9a <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8008f4c:	4b1b      	ldr	r3, [pc, #108]	; (8008fbc <DMA_DeInit+0xc0>)
 8008f4e:	4298      	cmp	r0, r3
 8008f50:	d104      	bne.n	8008f5c <DMA_DeInit+0x60>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8008f52:	3b08      	subs	r3, #8
 8008f54:	685a      	ldr	r2, [r3, #4]
 8008f56:	f042 020f 	orr.w	r2, r2, #15
 8008f5a:	e01e      	b.n	8008f9a <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8008f5c:	4b18      	ldr	r3, [pc, #96]	; (8008fc0 <DMA_DeInit+0xc4>)
 8008f5e:	4298      	cmp	r0, r3
 8008f60:	d104      	bne.n	8008f6c <DMA_DeInit+0x70>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 8008f62:	3b1c      	subs	r3, #28
 8008f64:	685a      	ldr	r2, [r3, #4]
 8008f66:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 8008f6a:	e016      	b.n	8008f9a <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 8008f6c:	4b15      	ldr	r3, [pc, #84]	; (8008fc4 <DMA_DeInit+0xc8>)
 8008f6e:	4298      	cmp	r0, r3
 8008f70:	d104      	bne.n	8008f7c <DMA_DeInit+0x80>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 8008f72:	3b30      	subs	r3, #48	; 0x30
 8008f74:	685a      	ldr	r2, [r3, #4]
 8008f76:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 8008f7a:	e00e      	b.n	8008f9a <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 8008f7c:	4b12      	ldr	r3, [pc, #72]	; (8008fc8 <DMA_DeInit+0xcc>)
 8008f7e:	4298      	cmp	r0, r3
 8008f80:	d104      	bne.n	8008f8c <DMA_DeInit+0x90>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8008f82:	3b44      	subs	r3, #68	; 0x44
 8008f84:	685a      	ldr	r2, [r3, #4]
 8008f86:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 8008f8a:	e006      	b.n	8008f9a <DMA_DeInit+0x9e>
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8008f8c:	4b0f      	ldr	r3, [pc, #60]	; (8008fcc <DMA_DeInit+0xd0>)
 8008f8e:	4298      	cmp	r0, r3
 8008f90:	d104      	bne.n	8008f9c <DMA_DeInit+0xa0>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 8008f92:	3b58      	subs	r3, #88	; 0x58
 8008f94:	685a      	ldr	r2, [r3, #4]
 8008f96:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 8008f9a:	605a      	str	r2, [r3, #4]
    }
  }
}
 8008f9c:	4770      	bx	lr
 8008f9e:	bf00      	nop
 8008fa0:	40020008 	.word	0x40020008
 8008fa4:	4002001c 	.word	0x4002001c
 8008fa8:	40020030 	.word	0x40020030
 8008fac:	40020044 	.word	0x40020044
 8008fb0:	40020058 	.word	0x40020058
 8008fb4:	4002006c 	.word	0x4002006c
 8008fb8:	40020080 	.word	0x40020080
 8008fbc:	40020408 	.word	0x40020408
 8008fc0:	4002041c 	.word	0x4002041c
 8008fc4:	40020430 	.word	0x40020430
 8008fc8:	40020444 	.word	0x40020444
 8008fcc:	40020458 	.word	0x40020458

08008fd0 <DMA_Init>:
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008fd0:	f8d1 c020 	ldr.w	ip, [r1, #32]
 8008fd4:	688b      	ldr	r3, [r1, #8]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 8008fd6:	6802      	ldr	r2, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008fd8:	ea4c 0303 	orr.w	r3, ip, r3
 8008fdc:	f8d1 c010 	ldr.w	ip, [r1, #16]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8008fe0:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008fe4:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8008fe8:	f8d1 c014 	ldr.w	ip, [r1, #20]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8008fec:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8008ff0:	ea43 030c 	orr.w	r3, r3, ip
 8008ff4:	f8d1 c018 	ldr.w	ip, [r1, #24]
 8008ff8:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8008ffc:	f8d1 c01c 	ldr.w	ip, [r1, #28]
 8009000:	ea43 030c 	orr.w	r3, r3, ip
 8009004:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
 8009008:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 800900c:	f8d1 c028 	ldr.w	ip, [r1, #40]	; 0x28
 8009010:	ea43 030c 	orr.w	r3, r3, ip
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8009014:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8009016:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8009018:	68cb      	ldr	r3, [r1, #12]
 800901a:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 800901c:	680b      	ldr	r3, [r1, #0]
 800901e:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8009020:	684b      	ldr	r3, [r1, #4]
 8009022:	60c3      	str	r3, [r0, #12]
}
 8009024:	4770      	bx	lr

08009026 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8009026:	2300      	movs	r3, #0
 8009028:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 800902a:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 800902c:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 800902e:	60c3      	str	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8009030:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8009032:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8009034:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8009036:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8009038:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 800903a:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 800903c:	6283      	str	r3, [r0, #40]	; 0x28
}
 800903e:	4770      	bx	lr

08009040 <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8009040:	b119      	cbz	r1, 800904a <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= CCR_ENABLE_Set;
 8009042:	6803      	ldr	r3, [r0, #0]
 8009044:	f043 0301 	orr.w	r3, r3, #1
 8009048:	e002      	b.n	8009050 <DMA_Cmd+0x10>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 800904a:	6803      	ldr	r3, [r0, #0]
 800904c:	f023 0301 	bic.w	r3, r3, #1
 8009050:	6003      	str	r3, [r0, #0]
  }
}
 8009052:	4770      	bx	lr

08009054 <DMA_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009054:	b112      	cbz	r2, 800905c <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8009056:	6803      	ldr	r3, [r0, #0]
 8009058:	4319      	orrs	r1, r3
 800905a:	e002      	b.n	8009062 <DMA_ITConfig+0xe>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 800905c:	6803      	ldr	r3, [r0, #0]
 800905e:	ea23 0101 	bic.w	r1, r3, r1
 8009062:	6001      	str	r1, [r0, #0]
  }
}
 8009064:	4770      	bx	lr
	...

08009068 <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
  /* Calculate the used DMA */

  if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8009068:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
  {
    /* Clear the selected DMA flags */
    DMA2->IFCR = DMA_FLAG;
 800906c:	bf14      	ite	ne
 800906e:	4b02      	ldrne	r3, [pc, #8]	; (8009078 <DMA_ClearFlag+0x10>)
  }
  else
  {
    /* Clear the selected DMA flags */
    DMA1->IFCR = DMA_FLAG;
 8009070:	4b02      	ldreq	r3, [pc, #8]	; (800907c <DMA_ClearFlag+0x14>)
 8009072:	6058      	str	r0, [r3, #4]
  }
}
 8009074:	4770      	bx	lr
 8009076:	bf00      	nop
 8009078:	40020400 	.word	0x40020400
 800907c:	40020000 	.word	0x40020000

08009080 <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8009080:	4a2d      	ldr	r2, [pc, #180]	; (8009138 <TIM_TimeBaseInit+0xb8>)
 8009082:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 800913c <TIM_TimeBaseInit+0xbc>
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8009086:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8009088:	4290      	cmp	r0, r2
 800908a:	bf14      	ite	ne
 800908c:	2200      	movne	r2, #0
 800908e:	2201      	moveq	r2, #1
 8009090:	4560      	cmp	r0, ip
 8009092:	bf08      	it	eq
 8009094:	f042 0201 	orreq.w	r2, r2, #1
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
  *   structure that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8009098:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 800909a:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 800909c:	b9ca      	cbnz	r2, 80090d2 <TIM_TimeBaseInit+0x52>
 800909e:	4c28      	ldr	r4, [pc, #160]	; (8009140 <TIM_TimeBaseInit+0xc0>)
 80090a0:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80090a4:	bf14      	ite	ne
 80090a6:	f04f 0c00 	movne.w	ip, #0
 80090aa:	f04f 0c01 	moveq.w	ip, #1
 80090ae:	42a0      	cmp	r0, r4
 80090b0:	bf14      	ite	ne
 80090b2:	4664      	movne	r4, ip
 80090b4:	f04c 0401 	orreq.w	r4, ip, #1
 80090b8:	b95c      	cbnz	r4, 80090d2 <TIM_TimeBaseInit+0x52>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 80090ba:	4c22      	ldr	r4, [pc, #136]	; (8009144 <TIM_TimeBaseInit+0xc4>)
 80090bc:	f8df c088 	ldr.w	ip, [pc, #136]	; 8009148 <TIM_TimeBaseInit+0xc8>
 80090c0:	42a0      	cmp	r0, r4
 80090c2:	bf14      	ite	ne
 80090c4:	2400      	movne	r4, #0
 80090c6:	2401      	moveq	r4, #1
 80090c8:	4560      	cmp	r0, ip
 80090ca:	bf08      	it	eq
 80090cc:	f044 0401 	orreq.w	r4, r4, #1
 80090d0:	b12c      	cbz	r4, 80090de <TIM_TimeBaseInit+0x5e>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80090d2:	f8b1 c002 	ldrh.w	ip, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 80090d6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80090da:	ea43 030c 	orr.w	r3, r3, ip
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 80090de:	4c1b      	ldr	r4, [pc, #108]	; (800914c <TIM_TimeBaseInit+0xcc>)
 80090e0:	f8df c06c 	ldr.w	ip, [pc, #108]	; 8009150 <TIM_TimeBaseInit+0xd0>
 80090e4:	1b04      	subs	r4, r0, r4
 80090e6:	bf18      	it	ne
 80090e8:	2401      	movne	r4, #1
 80090ea:	4560      	cmp	r0, ip
 80090ec:	bf0c      	ite	eq
 80090ee:	2400      	moveq	r4, #0
 80090f0:	f004 0401 	andne.w	r4, r4, #1
 80090f4:	b134      	cbz	r4, 8009104 <TIM_TimeBaseInit+0x84>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 80090f6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 80090fa:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 80090fe:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8009100:	ea43 030c 	orr.w	r3, r3, ip
  }

  TIMx->CR1 = tmpcr1;
 8009104:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8009106:	888b      	ldrh	r3, [r1, #4]
 8009108:	8583      	strh	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800910a:	880b      	ldrh	r3, [r1, #0]
 800910c:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 800910e:	b96a      	cbnz	r2, 800912c <TIM_TimeBaseInit+0xac>
 8009110:	4b10      	ldr	r3, [pc, #64]	; (8009154 <TIM_TimeBaseInit+0xd4>)
 8009112:	4a11      	ldr	r2, [pc, #68]	; (8009158 <TIM_TimeBaseInit+0xd8>)
 8009114:	4298      	cmp	r0, r3
 8009116:	bf14      	ite	ne
 8009118:	2300      	movne	r3, #0
 800911a:	2301      	moveq	r3, #1
 800911c:	4290      	cmp	r0, r2
 800911e:	bf08      	it	eq
 8009120:	f043 0301 	orreq.w	r3, r3, #1
 8009124:	b913      	cbnz	r3, 800912c <TIM_TimeBaseInit+0xac>
 8009126:	4b0d      	ldr	r3, [pc, #52]	; (800915c <TIM_TimeBaseInit+0xdc>)
 8009128:	4298      	cmp	r0, r3
 800912a:	d101      	bne.n	8009130 <TIM_TimeBaseInit+0xb0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 800912c:	7a0b      	ldrb	r3, [r1, #8]
 800912e:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 8009130:	2301      	movs	r3, #1
 8009132:	8283      	strh	r3, [r0, #20]
}
 8009134:	bd10      	pop	{r4, pc}
 8009136:	bf00      	nop
 8009138:	40012c00 	.word	0x40012c00
 800913c:	40013400 	.word	0x40013400
 8009140:	40000400 	.word	0x40000400
 8009144:	40000800 	.word	0x40000800
 8009148:	40000c00 	.word	0x40000c00
 800914c:	40001000 	.word	0x40001000
 8009150:	40001400 	.word	0x40001400
 8009154:	40014000 	.word	0x40014000
 8009158:	40014400 	.word	0x40014400
 800915c:	40014800 	.word	0x40014800

08009160 <TIM_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8009160:	b121      	cbz	r1, 800916c <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8009162:	8803      	ldrh	r3, [r0, #0]
 8009164:	b29b      	uxth	r3, r3
 8009166:	f043 0301 	orr.w	r3, r3, #1
 800916a:	e004      	b.n	8009176 <TIM_Cmd+0x16>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 800916c:	8803      	ldrh	r3, [r0, #0]
 800916e:	f023 0301 	bic.w	r3, r3, #1
 8009172:	041b      	lsls	r3, r3, #16
 8009174:	0c1b      	lsrs	r3, r3, #16
 8009176:	8003      	strh	r3, [r0, #0]
  }
}
 8009178:	4770      	bx	lr

0800917a <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 800917a:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 800917c:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 800917e:	4211      	tst	r1, r2
 8009180:	bf0c      	ite	eq
 8009182:	2000      	moveq	r0, #0
 8009184:	2001      	movne	r0, #1
 8009186:	4219      	tst	r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 8009188:	bf0c      	ite	eq
 800918a:	2000      	moveq	r0, #0
 800918c:	f000 0001 	andne.w	r0, r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8009190:	4770      	bx	lr

08009192 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8009192:	43c9      	mvns	r1, r1
 8009194:	b289      	uxth	r1, r1
 8009196:	8201      	strh	r1, [r0, #16]
}
 8009198:	4770      	bx	lr
	...

0800919c <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800919c:	4b0d      	ldr	r3, [pc, #52]	; (80091d4 <RCC_DeInit+0x38>)
 800919e:	681a      	ldr	r2, [r3, #0]
 80091a0:	f042 0201 	orr.w	r2, r2, #1
 80091a4:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 80091a6:	6859      	ldr	r1, [r3, #4]
 80091a8:	4a0b      	ldr	r2, [pc, #44]	; (80091d8 <RCC_DeInit+0x3c>)
 80091aa:	ea01 0202 	and.w	r2, r1, r2
 80091ae:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80091b0:	681a      	ldr	r2, [r3, #0]
 80091b2:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80091b6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80091ba:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80091bc:	681a      	ldr	r2, [r3, #0]
 80091be:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80091c2:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80091c4:	685a      	ldr	r2, [r3, #4]
 80091c6:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80091ca:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80091cc:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 80091d0:	609a      	str	r2, [r3, #8]
#endif /* STM32F10X_CL */

}
 80091d2:	4770      	bx	lr
 80091d4:	40021000 	.word	0x40021000
 80091d8:	f8ff0000 	.word	0xf8ff0000

080091dc <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80091dc:	4b0c      	ldr	r3, [pc, #48]	; (8009210 <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80091de:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80091e2:	681a      	ldr	r2, [r3, #0]
 80091e4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80091e8:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 80091ea:	681a      	ldr	r2, [r3, #0]
 80091ec:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80091f0:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80091f2:	d003      	beq.n	80091fc <RCC_HSEConfig+0x20>
 80091f4:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 80091f8:	d108      	bne.n	800920c <RCC_HSEConfig+0x30>
 80091fa:	e003      	b.n	8009204 <RCC_HSEConfig+0x28>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 80091fc:	681a      	ldr	r2, [r3, #0]
 80091fe:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009202:	e002      	b.n	800920a <RCC_HSEConfig+0x2e>
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 8009204:	681a      	ldr	r2, [r3, #0]
 8009206:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 800920a:	601a      	str	r2, [r3, #0]
      break;
      
    default:
      break;
  }
}
 800920c:	4770      	bx	lr
 800920e:	bf00      	nop
 8009210:	40021000 	.word	0x40021000

08009214 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8009214:	4b03      	ldr	r3, [pc, #12]	; (8009224 <RCC_PLLConfig+0x10>)
 8009216:	685a      	ldr	r2, [r3, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 8009218:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 800921c:	4310      	orrs	r0, r2
 800921e:	4308      	orrs	r0, r1
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8009220:	6058      	str	r0, [r3, #4]
}
 8009222:	4770      	bx	lr
 8009224:	40021000 	.word	0x40021000

08009228 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8009228:	4b01      	ldr	r3, [pc, #4]	; (8009230 <RCC_PLLCmd+0x8>)
 800922a:	6018      	str	r0, [r3, #0]
}
 800922c:	4770      	bx	lr
 800922e:	bf00      	nop
 8009230:	42420060 	.word	0x42420060

08009234 <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8009234:	4b03      	ldr	r3, [pc, #12]	; (8009244 <RCC_SYSCLKConfig+0x10>)
 8009236:	685a      	ldr	r2, [r3, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 8009238:	f022 0203 	bic.w	r2, r2, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 800923c:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800923e:	6058      	str	r0, [r3, #4]
}
 8009240:	4770      	bx	lr
 8009242:	bf00      	nop
 8009244:	40021000 	.word	0x40021000

08009248 <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8009248:	4b02      	ldr	r3, [pc, #8]	; (8009254 <RCC_GetSYSCLKSource+0xc>)
 800924a:	6858      	ldr	r0, [r3, #4]
 800924c:	f000 000c 	and.w	r0, r0, #12
}
 8009250:	4770      	bx	lr
 8009252:	bf00      	nop
 8009254:	40021000 	.word	0x40021000

08009258 <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8009258:	4b03      	ldr	r3, [pc, #12]	; (8009268 <RCC_HCLKConfig+0x10>)
 800925a:	685a      	ldr	r2, [r3, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 800925c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8009260:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8009262:	6058      	str	r0, [r3, #4]
}
 8009264:	4770      	bx	lr
 8009266:	bf00      	nop
 8009268:	40021000 	.word	0x40021000

0800926c <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 800926c:	4b03      	ldr	r3, [pc, #12]	; (800927c <RCC_PCLK1Config+0x10>)
 800926e:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 8009270:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8009274:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8009276:	6058      	str	r0, [r3, #4]
}
 8009278:	4770      	bx	lr
 800927a:	bf00      	nop
 800927c:	40021000 	.word	0x40021000

08009280 <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8009280:	4b03      	ldr	r3, [pc, #12]	; (8009290 <RCC_PCLK2Config+0x10>)
 8009282:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 8009284:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8009288:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800928c:	6058      	str	r0, [r3, #4]
}
 800928e:	4770      	bx	lr
 8009290:	40021000 	.word	0x40021000

08009294 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 8009294:	4b01      	ldr	r3, [pc, #4]	; (800929c <RCC_USBCLKConfig+0x8>)
 8009296:	6018      	str	r0, [r3, #0]
}
 8009298:	4770      	bx	lr
 800929a:	bf00      	nop
 800929c:	424200d8 	.word	0x424200d8

080092a0 <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 80092a0:	4b03      	ldr	r3, [pc, #12]	; (80092b0 <RCC_ADCCLKConfig+0x10>)
 80092a2:	685a      	ldr	r2, [r3, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 80092a4:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 80092a8:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80092aa:	6058      	str	r0, [r3, #4]
}
 80092ac:	4770      	bx	lr
 80092ae:	bf00      	nop
 80092b0:	40021000 	.word	0x40021000

080092b4 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 80092b4:	4b02      	ldr	r3, [pc, #8]	; (80092c0 <RCC_RTCCLKConfig+0xc>)
 80092b6:	6a1a      	ldr	r2, [r3, #32]
 80092b8:	4310      	orrs	r0, r2
 80092ba:	6218      	str	r0, [r3, #32]
}
 80092bc:	4770      	bx	lr
 80092be:	bf00      	nop
 80092c0:	40021000 	.word	0x40021000

080092c4 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80092c4:	4b01      	ldr	r3, [pc, #4]	; (80092cc <RCC_RTCCLKCmd+0x8>)
 80092c6:	6018      	str	r0, [r3, #0]
}
 80092c8:	4770      	bx	lr
 80092ca:	bf00      	nop
 80092cc:	4242043c 	.word	0x4242043c

080092d0 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 80092d0:	4b22      	ldr	r3, [pc, #136]	; (800935c <RCC_GetClocksFreq+0x8c>)
 80092d2:	685a      	ldr	r2, [r3, #4]
 80092d4:	f002 020c 	and.w	r2, r2, #12
  
  switch (tmp)
 80092d8:	2a04      	cmp	r2, #4
 80092da:	d002      	beq.n	80092e2 <RCC_GetClocksFreq+0x12>
 80092dc:	2a08      	cmp	r2, #8
 80092de:	d115      	bne.n	800930c <RCC_GetClocksFreq+0x3c>
 80092e0:	e001      	b.n	80092e6 <RCC_GetClocksFreq+0x16>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
 80092e2:	4b1f      	ldr	r3, [pc, #124]	; (8009360 <RCC_GetClocksFreq+0x90>)
 80092e4:	e013      	b.n	800930e <RCC_GetClocksFreq+0x3e>
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 80092e6:	685a      	ldr	r2, [r3, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 80092e8:	6859      	ldr	r1, [r3, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 80092ea:	f3c2 4283 	ubfx	r2, r2, #18, #4
 80092ee:	3202      	adds	r2, #2
      
      if (pllsource == 0x00)
 80092f0:	f411 3f80 	tst.w	r1, #65536	; 0x10000
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
 80092f4:	bf08      	it	eq
 80092f6:	4b1b      	ldreq	r3, [pc, #108]	; (8009364 <RCC_GetClocksFreq+0x94>)
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
      
      if (pllsource == 0x00)
 80092f8:	d005      	beq.n	8009306 <RCC_GetClocksFreq+0x36>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 80092fa:	685b      	ldr	r3, [r3, #4]
 80092fc:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 8009300:	bf14      	ite	ne
 8009302:	4b19      	ldrne	r3, [pc, #100]	; (8009368 <RCC_GetClocksFreq+0x98>)
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 8009304:	4b16      	ldreq	r3, [pc, #88]	; (8009360 <RCC_GetClocksFreq+0x90>)
 8009306:	435a      	muls	r2, r3
 8009308:	6002      	str	r2, [r0, #0]
 800930a:	e001      	b.n	8009310 <RCC_GetClocksFreq+0x40>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 800930c:	4b17      	ldr	r3, [pc, #92]	; (800936c <RCC_GetClocksFreq+0x9c>)
 800930e:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8009310:	4b12      	ldr	r3, [pc, #72]	; (800935c <RCC_GetClocksFreq+0x8c>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8009312:	4917      	ldr	r1, [pc, #92]	; (8009370 <RCC_GetClocksFreq+0xa0>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8009314:	685a      	ldr	r2, [r3, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8009316:	f8d0 c000 	ldr.w	ip, [r0]
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
  tmp = tmp >> 4;
 800931a:	f3c2 1203 	ubfx	r2, r2, #4, #4
  presc = APBAHBPrescTable[tmp];
 800931e:	5c8a      	ldrb	r2, [r1, r2]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8009320:	fa2c f202 	lsr.w	r2, ip, r2
 8009324:	6042      	str	r2, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8009326:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 8;
 800932a:	f3cc 2c02 	ubfx	ip, ip, #8, #3
  presc = APBAHBPrescTable[tmp];
 800932e:	f811 c00c 	ldrb.w	ip, [r1, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8009332:	fa22 fc0c 	lsr.w	ip, r2, ip
 8009336:	f8c0 c008 	str.w	ip, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 800933a:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 11;
 800933e:	f3cc 2cc2 	ubfx	ip, ip, #11, #3
  presc = APBAHBPrescTable[tmp];
 8009342:	f811 100c 	ldrb.w	r1, [r1, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8009346:	40ca      	lsrs	r2, r1
 8009348:	60c2      	str	r2, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 800934a:	685b      	ldr	r3, [r3, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
 800934c:	4909      	ldr	r1, [pc, #36]	; (8009374 <RCC_GetClocksFreq+0xa4>)
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
 800934e:	f3c3 3381 	ubfx	r3, r3, #14, #2
  presc = ADCPrescTable[tmp];
 8009352:	5ccb      	ldrb	r3, [r1, r3]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8009354:	fbb2 f2f3 	udiv	r2, r2, r3
 8009358:	6102      	str	r2, [r0, #16]
}
 800935a:	4770      	bx	lr
 800935c:	40021000 	.word	0x40021000
 8009360:	00b71b00 	.word	0x00b71b00
 8009364:	003d0900 	.word	0x003d0900
 8009368:	005b8d80 	.word	0x005b8d80
 800936c:	007a1200 	.word	0x007a1200
 8009370:	20000048 	.word	0x20000048
 8009374:	20000044 	.word	0x20000044

08009378 <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8009378:	b119      	cbz	r1, 8009382 <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800937a:	4b05      	ldr	r3, [pc, #20]	; (8009390 <RCC_AHBPeriphClockCmd+0x18>)
 800937c:	695a      	ldr	r2, [r3, #20]
 800937e:	4310      	orrs	r0, r2
 8009380:	e003      	b.n	800938a <RCC_AHBPeriphClockCmd+0x12>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8009382:	4b03      	ldr	r3, [pc, #12]	; (8009390 <RCC_AHBPeriphClockCmd+0x18>)
 8009384:	695a      	ldr	r2, [r3, #20]
 8009386:	ea22 0000 	bic.w	r0, r2, r0
 800938a:	6158      	str	r0, [r3, #20]
  }
}
 800938c:	4770      	bx	lr
 800938e:	bf00      	nop
 8009390:	40021000 	.word	0x40021000

08009394 <RCC_APB2PeriphClockCmd>:
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009394:	b119      	cbz	r1, 800939e <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8009396:	4b05      	ldr	r3, [pc, #20]	; (80093ac <RCC_APB2PeriphClockCmd+0x18>)
 8009398:	699a      	ldr	r2, [r3, #24]
 800939a:	4310      	orrs	r0, r2
 800939c:	e003      	b.n	80093a6 <RCC_APB2PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800939e:	4b03      	ldr	r3, [pc, #12]	; (80093ac <RCC_APB2PeriphClockCmd+0x18>)
 80093a0:	699a      	ldr	r2, [r3, #24]
 80093a2:	ea22 0000 	bic.w	r0, r2, r0
 80093a6:	6198      	str	r0, [r3, #24]
  }
}
 80093a8:	4770      	bx	lr
 80093aa:	bf00      	nop
 80093ac:	40021000 	.word	0x40021000

080093b0 <RCC_APB1PeriphClockCmd>:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80093b0:	b119      	cbz	r1, 80093ba <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80093b2:	4b05      	ldr	r3, [pc, #20]	; (80093c8 <RCC_APB1PeriphClockCmd+0x18>)
 80093b4:	69da      	ldr	r2, [r3, #28]
 80093b6:	4310      	orrs	r0, r2
 80093b8:	e003      	b.n	80093c2 <RCC_APB1PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80093ba:	4b03      	ldr	r3, [pc, #12]	; (80093c8 <RCC_APB1PeriphClockCmd+0x18>)
 80093bc:	69da      	ldr	r2, [r3, #28]
 80093be:	ea22 0000 	bic.w	r0, r2, r0
 80093c2:	61d8      	str	r0, [r3, #28]
  }
}
 80093c4:	4770      	bx	lr
 80093c6:	bf00      	nop
 80093c8:	40021000 	.word	0x40021000

080093cc <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80093cc:	b119      	cbz	r1, 80093d6 <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80093ce:	4b05      	ldr	r3, [pc, #20]	; (80093e4 <RCC_APB2PeriphResetCmd+0x18>)
 80093d0:	68da      	ldr	r2, [r3, #12]
 80093d2:	4310      	orrs	r0, r2
 80093d4:	e003      	b.n	80093de <RCC_APB2PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80093d6:	4b03      	ldr	r3, [pc, #12]	; (80093e4 <RCC_APB2PeriphResetCmd+0x18>)
 80093d8:	68da      	ldr	r2, [r3, #12]
 80093da:	ea22 0000 	bic.w	r0, r2, r0
 80093de:	60d8      	str	r0, [r3, #12]
  }
}
 80093e0:	4770      	bx	lr
 80093e2:	bf00      	nop
 80093e4:	40021000 	.word	0x40021000

080093e8 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80093e8:	b119      	cbz	r1, 80093f2 <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80093ea:	4b05      	ldr	r3, [pc, #20]	; (8009400 <RCC_APB1PeriphResetCmd+0x18>)
 80093ec:	691a      	ldr	r2, [r3, #16]
 80093ee:	4310      	orrs	r0, r2
 80093f0:	e003      	b.n	80093fa <RCC_APB1PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80093f2:	4b03      	ldr	r3, [pc, #12]	; (8009400 <RCC_APB1PeriphResetCmd+0x18>)
 80093f4:	691a      	ldr	r2, [r3, #16]
 80093f6:	ea22 0000 	bic.w	r0, r2, r0
 80093fa:	6118      	str	r0, [r3, #16]
  }
}
 80093fc:	4770      	bx	lr
 80093fe:	bf00      	nop
 8009400:	40021000 	.word	0x40021000

08009404 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8009404:	4b01      	ldr	r3, [pc, #4]	; (800940c <RCC_BackupResetCmd+0x8>)
 8009406:	6018      	str	r0, [r3, #0]
}
 8009408:	4770      	bx	lr
 800940a:	bf00      	nop
 800940c:	42420440 	.word	0x42420440

08009410 <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8009410:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8009412:	2b01      	cmp	r3, #1
  {
    statusreg = RCC->CR;
 8009414:	bf04      	itt	eq
 8009416:	4b08      	ldreq	r3, [pc, #32]	; (8009438 <RCC_GetFlagStatus+0x28>)
 8009418:	681b      	ldreq	r3, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
 800941a:	d005      	beq.n	8009428 <RCC_GetFlagStatus+0x18>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800941c:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 800941e:	bf0b      	itete	eq
 8009420:	4b05      	ldreq	r3, [pc, #20]	; (8009438 <RCC_GetFlagStatus+0x28>)
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8009422:	4b05      	ldrne	r3, [pc, #20]	; (8009438 <RCC_GetFlagStatus+0x28>)
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 8009424:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8009426:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 8009428:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800942c:	fa33 f000 	lsrs.w	r0, r3, r0
  {
    statusreg = RCC->BDCR;
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8009430:	f000 0001 	and.w	r0, r0, #1
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8009434:	4770      	bx	lr
 8009436:	bf00      	nop
 8009438:	40021000 	.word	0x40021000

0800943c <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800943c:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 800943e:	2300      	movs	r3, #0
 8009440:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8009442:	2031      	movs	r0, #49	; 0x31
 8009444:	f7ff ffe4 	bl	8009410 <RCC_GetFlagStatus>
    StartUpCounter++;  
 8009448:	9b01      	ldr	r3, [sp, #4]
 800944a:	3301      	adds	r3, #1
 800944c:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
 800944e:	9b01      	ldr	r3, [sp, #4]
 8009450:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8009454:	d001      	beq.n	800945a <RCC_WaitForHSEStartUp+0x1e>
 8009456:	2800      	cmp	r0, #0
 8009458:	d0f3      	beq.n	8009442 <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 800945a:	2031      	movs	r0, #49	; 0x31
 800945c:	f7ff ffd8 	bl	8009410 <RCC_GetFlagStatus>
 8009460:	3800      	subs	r0, #0
 8009462:	bf18      	it	ne
 8009464:	2001      	movne	r0, #1
  else
  {
    status = ERROR;
  }  
  return (status);
}
 8009466:	bd0e      	pop	{r1, r2, r3, pc}

08009468 <RTC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8009468:	b121      	cbz	r1, 8009474 <RTC_ITConfig+0xc>
  {
    RTC->CRH |= RTC_IT;
 800946a:	4b06      	ldr	r3, [pc, #24]	; (8009484 <RTC_ITConfig+0x1c>)
 800946c:	881a      	ldrh	r2, [r3, #0]
 800946e:	b292      	uxth	r2, r2
 8009470:	4310      	orrs	r0, r2
 8009472:	e004      	b.n	800947e <RTC_ITConfig+0x16>
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
 8009474:	4b03      	ldr	r3, [pc, #12]	; (8009484 <RTC_ITConfig+0x1c>)
 8009476:	881a      	ldrh	r2, [r3, #0]
 8009478:	b292      	uxth	r2, r2
 800947a:	ea22 0000 	bic.w	r0, r2, r0
 800947e:	8018      	strh	r0, [r3, #0]
  }
}
 8009480:	4770      	bx	lr
 8009482:	bf00      	nop
 8009484:	40002800 	.word	0x40002800

08009488 <RTC_EnterConfigMode>:
  * @retval None
  */
void RTC_EnterConfigMode(void)
{
  /* Set the CNF flag to enter in the Configuration Mode */
  RTC->CRL |= CRL_CNF_Set;
 8009488:	4b03      	ldr	r3, [pc, #12]	; (8009498 <RTC_EnterConfigMode+0x10>)
 800948a:	889a      	ldrh	r2, [r3, #4]
 800948c:	b292      	uxth	r2, r2
 800948e:	f042 0210 	orr.w	r2, r2, #16
 8009492:	809a      	strh	r2, [r3, #4]
}
 8009494:	4770      	bx	lr
 8009496:	bf00      	nop
 8009498:	40002800 	.word	0x40002800

0800949c <RTC_ExitConfigMode>:
  * @retval None
  */
void RTC_ExitConfigMode(void)
{
  /* Reset the CNF flag to exit from the Configuration Mode */
  RTC->CRL &= CRL_CNF_Reset;
 800949c:	4a03      	ldr	r2, [pc, #12]	; (80094ac <RTC_ExitConfigMode+0x10>)
 800949e:	8893      	ldrh	r3, [r2, #4]
 80094a0:	f023 0310 	bic.w	r3, r3, #16
 80094a4:	041b      	lsls	r3, r3, #16
 80094a6:	0c1b      	lsrs	r3, r3, #16
 80094a8:	8093      	strh	r3, [r2, #4]
}
 80094aa:	4770      	bx	lr
 80094ac:	40002800 	.word	0x40002800

080094b0 <RTC_SetCounter>:
  * @brief  Sets the RTC counter value.
  * @param  CounterValue: RTC counter new value.
  * @retval None
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
 80094b0:	b510      	push	{r4, lr}
 80094b2:	4604      	mov	r4, r0
  RTC_EnterConfigMode();
 80094b4:	f7ff ffe8 	bl	8009488 <RTC_EnterConfigMode>
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 80094b8:	4b03      	ldr	r3, [pc, #12]	; (80094c8 <RTC_SetCounter+0x18>)
 80094ba:	0c22      	lsrs	r2, r4, #16
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 80094bc:	b2a4      	uxth	r4, r4
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
  RTC_EnterConfigMode();
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 80094be:	831a      	strh	r2, [r3, #24]
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 80094c0:	839c      	strh	r4, [r3, #28]
  RTC_ExitConfigMode();
 80094c2:	f7ff ffeb 	bl	800949c <RTC_ExitConfigMode>
}
 80094c6:	bd10      	pop	{r4, pc}
 80094c8:	40002800 	.word	0x40002800

080094cc <RTC_SetPrescaler>:
  * @brief  Sets the RTC prescaler value.
  * @param  PrescalerValue: RTC prescaler new value.
  * @retval None
  */
void RTC_SetPrescaler(uint32_t PrescalerValue)
{
 80094cc:	b510      	push	{r4, lr}
 80094ce:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
 80094d0:	f7ff ffda 	bl	8009488 <RTC_EnterConfigMode>
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 80094d4:	4b04      	ldr	r3, [pc, #16]	; (80094e8 <RTC_SetPrescaler+0x1c>)
 80094d6:	f3c4 4203 	ubfx	r2, r4, #16, #4
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 80094da:	b2a4      	uxth	r4, r4
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 80094dc:	811a      	strh	r2, [r3, #8]
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 80094de:	819c      	strh	r4, [r3, #12]
  RTC_ExitConfigMode();
 80094e0:	f7ff ffdc 	bl	800949c <RTC_ExitConfigMode>
}
 80094e4:	bd10      	pop	{r4, pc}
 80094e6:	bf00      	nop
 80094e8:	40002800 	.word	0x40002800

080094ec <RTC_WaitForLastTask>:
  * @retval None
  */
void RTC_WaitForLastTask(void)
{
  /* Loop until RTOFF flag is set */
  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
 80094ec:	4b02      	ldr	r3, [pc, #8]	; (80094f8 <RTC_WaitForLastTask+0xc>)
 80094ee:	889a      	ldrh	r2, [r3, #4]
 80094f0:	f012 0f20 	tst.w	r2, #32
 80094f4:	d0fb      	beq.n	80094ee <RTC_WaitForLastTask+0x2>
  {
  }
}
 80094f6:	4770      	bx	lr
 80094f8:	40002800 	.word	0x40002800

080094fc <RTC_WaitForSynchro>:
  * @retval None
  */
void RTC_WaitForSynchro(void)
{
  /* Clear RSF flag */
  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
 80094fc:	4a05      	ldr	r2, [pc, #20]	; (8009514 <RTC_WaitForSynchro+0x18>)
 80094fe:	8893      	ldrh	r3, [r2, #4]
 8009500:	f023 0308 	bic.w	r3, r3, #8
 8009504:	041b      	lsls	r3, r3, #16
 8009506:	0c1b      	lsrs	r3, r3, #16
 8009508:	8093      	strh	r3, [r2, #4]
  /* Loop until RSF flag is set */
  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
 800950a:	8893      	ldrh	r3, [r2, #4]
 800950c:	f013 0f08 	tst.w	r3, #8
 8009510:	d0fb      	beq.n	800950a <RTC_WaitForSynchro+0xe>
  {
  }
}
 8009512:	4770      	bx	lr
 8009514:	40002800 	.word	0x40002800

08009518 <BKP_DeInit>:
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
  RCC_BackupResetCmd(ENABLE);
 8009518:	2001      	movs	r0, #1
  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
 800951a:	b508      	push	{r3, lr}
  RCC_BackupResetCmd(ENABLE);
 800951c:	f7ff ff72 	bl	8009404 <RCC_BackupResetCmd>
  RCC_BackupResetCmd(DISABLE);
 8009520:	2000      	movs	r0, #0
 8009522:	f7ff ff6f 	bl	8009404 <RCC_BackupResetCmd>
}
 8009526:	bd08      	pop	{r3, pc}

08009528 <PWR_BackupAccessCmd>:
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 8009528:	4b01      	ldr	r3, [pc, #4]	; (8009530 <PWR_BackupAccessCmd+0x8>)
 800952a:	6018      	str	r0, [r3, #0]
}
 800952c:	4770      	bx	lr
 800952e:	bf00      	nop
 8009530:	420e0020 	.word	0x420e0020

08009534 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8009534:	f040 60be 	orr.w	r0, r0, #99614720	; 0x5f00000
 8009538:	4b02      	ldr	r3, [pc, #8]	; (8009544 <NVIC_PriorityGroupConfig+0x10>)
 800953a:	f440 2020 	orr.w	r0, r0, #655360	; 0xa0000
 800953e:	60d8      	str	r0, [r3, #12]
}
 8009540:	4770      	bx	lr
 8009542:	bf00      	nop
 8009544:	e000ed00 	.word	0xe000ed00

08009548 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8009548:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 800954c:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8009550:	4b02      	ldr	r3, [pc, #8]	; (800955c <NVIC_SetVectorTable+0x14>)
 8009552:	ea41 0000 	orr.w	r0, r1, r0
 8009556:	6098      	str	r0, [r3, #8]
}
 8009558:	4770      	bx	lr
 800955a:	bf00      	nop
 800955c:	e000ed00 	.word	0xe000ed00

08009560 <SysTick_CLKSourceConfig>:
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8009560:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8009562:	bf0b      	itete	eq
 8009564:	4b05      	ldreq	r3, [pc, #20]	; (800957c <SysTick_CLKSourceConfig+0x1c>)
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8009566:	4b05      	ldrne	r3, [pc, #20]	; (800957c <SysTick_CLKSourceConfig+0x1c>)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8009568:	681a      	ldreq	r2, [r3, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 800956a:	681a      	ldrne	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 800956c:	bf0c      	ite	eq
 800956e:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8009572:	f022 0204 	bicne.w	r2, r2, #4
 8009576:	601a      	str	r2, [r3, #0]
  }
}
 8009578:	4770      	bx	lr
 800957a:	bf00      	nop
 800957c:	e000e010 	.word	0xe000e010

08009580 <Standard_GetConfiguration>:
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetConfiguration(uint16_t Length)
{
 8009580:	b510      	push	{r4, lr}
 8009582:	4c06      	ldr	r4, [pc, #24]	; (800959c <Standard_GetConfiguration+0x1c>)
  if (Length == 0)
 8009584:	b918      	cbnz	r0, 800958e <Standard_GetConfiguration+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 8009586:	6823      	ldr	r3, [r4, #0]
 8009588:	2201      	movs	r2, #1
 800958a:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_Configuration);
    return 0;
 800958c:	e005      	b.n	800959a <Standard_GetConfiguration+0x1a>
  }
  pUser_Standard_Requests->User_GetConfiguration();
 800958e:	4b04      	ldr	r3, [pc, #16]	; (80095a0 <Standard_GetConfiguration+0x20>)
 8009590:	681b      	ldr	r3, [r3, #0]
 8009592:	681b      	ldr	r3, [r3, #0]
 8009594:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_Configuration;
 8009596:	6820      	ldr	r0, [r4, #0]
 8009598:	300a      	adds	r0, #10
}
 800959a:	bd10      	pop	{r4, pc}
 800959c:	2000379c 	.word	0x2000379c
 80095a0:	20003798 	.word	0x20003798

080095a4 <Standard_GetInterface>:
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetInterface(uint16_t Length)
{
 80095a4:	b510      	push	{r4, lr}
 80095a6:	4c06      	ldr	r4, [pc, #24]	; (80095c0 <Standard_GetInterface+0x1c>)
  if (Length == 0)
 80095a8:	b918      	cbnz	r0, 80095b2 <Standard_GetInterface+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 80095aa:	6823      	ldr	r3, [r4, #0]
 80095ac:	2201      	movs	r2, #1
 80095ae:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
 80095b0:	e005      	b.n	80095be <Standard_GetInterface+0x1a>
  }
  pUser_Standard_Requests->User_GetInterface();
 80095b2:	4b04      	ldr	r3, [pc, #16]	; (80095c4 <Standard_GetInterface+0x20>)
 80095b4:	681b      	ldr	r3, [r3, #0]
 80095b6:	689b      	ldr	r3, [r3, #8]
 80095b8:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_AlternateSetting;
 80095ba:	6820      	ldr	r0, [r4, #0]
 80095bc:	300c      	adds	r0, #12
}
 80095be:	bd10      	pop	{r4, pc}
 80095c0:	2000379c 	.word	0x2000379c
 80095c4:	20003798 	.word	0x20003798

080095c8 <Standard_GetStatus>:
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
uint8_t *Standard_GetStatus(uint16_t Length)
{
 80095c8:	b508      	push	{r3, lr}
 80095ca:	4b27      	ldr	r3, [pc, #156]	; (8009668 <Standard_GetStatus+0xa0>)
  if (Length == 0)
 80095cc:	b918      	cbnz	r0, 80095d6 <Standard_GetStatus+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
 80095ce:	681b      	ldr	r3, [r3, #0]
 80095d0:	2202      	movs	r2, #2
 80095d2:	821a      	strh	r2, [r3, #16]
    return 0;
 80095d4:	e047      	b.n	8009666 <Standard_GetStatus+0x9e>
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 80095d6:	4825      	ldr	r0, [pc, #148]	; (800966c <Standard_GetStatus+0xa4>)
 80095d8:	2200      	movs	r2, #0

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80095da:	681b      	ldr	r3, [r3, #0]
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 80095dc:	8002      	strh	r2, [r0, #0]

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80095de:	781a      	ldrb	r2, [r3, #0]
 80095e0:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 80095e4:	d115      	bne.n	8009612 <Standard_GetStatus+0x4a>
  {
    /*Get Device Status */
    uint8_t Feature = pInformation->Current_Feature;

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
 80095e6:	7a5b      	ldrb	r3, [r3, #9]
 80095e8:	7802      	ldrb	r2, [r0, #0]
 80095ea:	f013 0f20 	tst.w	r3, #32
    {
      SetBit(StatusInfo0, 1);
 80095ee:	bf14      	ite	ne
 80095f0:	f042 0202 	orrne.w	r2, r2, #2
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 80095f4:	f022 0202 	biceq.w	r2, r2, #2
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
 80095f8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80095fc:	4b1b      	ldr	r3, [pc, #108]	; (800966c <Standard_GetStatus+0xa4>)
    {
      SetBit(StatusInfo0, 1);
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 80095fe:	7002      	strb	r2, [r0, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 8009600:	bf15      	itete	ne
 8009602:	781a      	ldrbne	r2, [r3, #0]
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 8009604:	781a      	ldrbeq	r2, [r3, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 8009606:	f042 0201 	orrne.w	r2, r2, #1
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 800960a:	f022 0201 	biceq.w	r2, r2, #1
 800960e:	701a      	strb	r2, [r3, #0]
 8009610:	e022      	b.n	8009658 <Standard_GetStatus+0x90>
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009612:	2a01      	cmp	r2, #1
 8009614:	d027      	beq.n	8009666 <Standard_GetStatus+0x9e>
  {
    return (uint8_t *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009616:	2a02      	cmp	r2, #2
 8009618:	d124      	bne.n	8009664 <Standard_GetStatus+0x9c>
  {
    uint8_t Related_Endpoint;
    uint8_t wIndex0 = pInformation->USBwIndex0;
 800961a:	795a      	ldrb	r2, [r3, #5]

    Related_Endpoint = (wIndex0 & 0x0f);
 800961c:	f002 030f 	and.w	r3, r2, #15
    if (ValBit(wIndex0, 7))
 8009620:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009624:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8009628:	d008      	beq.n	800963c <Standard_GetStatus+0x74>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
 800962a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800962e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009632:	681b      	ldr	r3, [r3, #0]
 8009634:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8009638:	2b10      	cmp	r3, #16
 800963a:	e008      	b.n	800964e <Standard_GetStatus+0x86>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 800963c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009640:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009644:	681b      	ldr	r3, [r3, #0]
 8009646:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800964a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
      {
        SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
 800964e:	bf02      	ittt	eq
 8009650:	7803      	ldrbeq	r3, [r0, #0]
 8009652:	f043 0301 	orreq.w	r3, r3, #1
 8009656:	7003      	strbeq	r3, [r0, #0]
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
 8009658:	4b05      	ldr	r3, [pc, #20]	; (8009670 <Standard_GetStatus+0xa8>)
 800965a:	681b      	ldr	r3, [r3, #0]
 800965c:	691b      	ldr	r3, [r3, #16]
 800965e:	4798      	blx	r3
  return (uint8_t *)&StatusInfo;
 8009660:	4802      	ldr	r0, [pc, #8]	; (800966c <Standard_GetStatus+0xa4>)
 8009662:	e000      	b.n	8009666 <Standard_GetStatus+0x9e>
    }

  }
  else
  {
    return NULL;
 8009664:	2000      	movs	r0, #0
  }
  pUser_Standard_Requests->User_GetStatus();
  return (uint8_t *)&StatusInfo;
}
 8009666:	bd08      	pop	{r3, pc}
 8009668:	2000379c 	.word	0x2000379c
 800966c:	200037a8 	.word	0x200037a8
 8009670:	20003798 	.word	0x20003798

08009674 <DataStageIn>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
 8009674:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 8009676:	4b27      	ldr	r3, [pc, #156]	; (8009714 <DataStageIn+0xa0>)
 8009678:	681c      	ldr	r4, [r3, #0]
  uint32_t save_wLength = pEPinfo->Usb_wLength;
 800967a:	8a23      	ldrh	r3, [r4, #16]
  uint32_t ControlState = pInformation->ControlState;
 800967c:	7a26      	ldrb	r6, [r4, #8]

  uint8_t *DataBuffer;
  uint32_t Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
 800967e:	f1d3 0201 	rsbs	r2, r3, #1
 8009682:	bf38      	it	cc
 8009684:	2200      	movcc	r2, #0
 8009686:	2e04      	cmp	r6, #4
 8009688:	bf14      	ite	ne
 800968a:	2600      	movne	r6, #0
 800968c:	f002 0601 	andeq.w	r6, r2, #1
 8009690:	b1ae      	cbz	r6, 80096be <DataStageIn+0x4a>
  {
    if(Data_Mul_MaxPacketSize == TRUE)
 8009692:	4921      	ldr	r1, [pc, #132]	; (8009718 <DataStageIn+0xa4>)
 8009694:	4a21      	ldr	r2, [pc, #132]	; (800971c <DataStageIn+0xa8>)
 8009696:	780b      	ldrb	r3, [r1, #0]
 8009698:	2b01      	cmp	r3, #1
 800969a:	d10c      	bne.n	80096b6 <DataStageIn+0x42>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 800969c:	4b20      	ldr	r3, [pc, #128]	; (8009720 <DataStageIn+0xac>)
      ControlState = LAST_IN_DATA;
 800969e:	2704      	movs	r7, #4
  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 80096a0:	6818      	ldr	r0, [r3, #0]
 80096a2:	4b20      	ldr	r3, [pc, #128]	; (8009724 <DataStageIn+0xb0>)
 80096a4:	b280      	uxth	r0, r0
 80096a6:	18c3      	adds	r3, r0, r3
 80096a8:	005b      	lsls	r3, r3, #1
 80096aa:	2000      	movs	r0, #0
 80096ac:	6018      	str	r0, [r3, #0]
 80096ae:	2330      	movs	r3, #48	; 0x30
 80096b0:	8013      	strh	r3, [r2, #0]
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
 80096b2:	7008      	strb	r0, [r1, #0]
 80096b4:	e02a      	b.n	800970c <DataStageIn+0x98>
    #ifdef STM32F10X_CL      
      PCD_EP_Read (ENDP0, 0, 0);
    #endif  /* STM32F10X_CL */ 
    
    #ifndef STM32F10X_CL 
      vSetEPTxStatus(EP_TX_STALL);
 80096b6:	2310      	movs	r3, #16
 80096b8:	8013      	strh	r3, [r2, #0]
      Data_Mul_MaxPacketSize = FALSE;
    }
    else 
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
 80096ba:	2707      	movs	r7, #7
 80096bc:	e026      	b.n	800970c <DataStageIn+0x98>
    }
    
    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
 80096be:	8aa5      	ldrh	r5, [r4, #20]
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
 80096c0:	42ab      	cmp	r3, r5
 80096c2:	bf8c      	ite	hi
 80096c4:	2702      	movhi	r7, #2
 80096c6:	2704      	movls	r7, #4
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
 80096c8:	429d      	cmp	r5, r3
 80096ca:	bf28      	it	cs
 80096cc:	461d      	movcs	r5, r3
 80096ce:	4628      	mov	r0, r5
 80096d0:	69a3      	ldr	r3, [r4, #24]
 80096d2:	4798      	blx	r3
 80096d4:	4603      	mov	r3, r0

#ifdef STM32F10X_CL
  PCD_EP_Write (ENDP0, DataBuffer, Length);
#else   
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
 80096d6:	4630      	mov	r0, r6
 80096d8:	9301      	str	r3, [sp, #4]
 80096da:	f000 fd87 	bl	800a1ec <GetEPTxAddr>
 80096de:	9b01      	ldr	r3, [sp, #4]
 80096e0:	462a      	mov	r2, r5
 80096e2:	4601      	mov	r1, r0
 80096e4:	4618      	mov	r0, r3
 80096e6:	f000 fca1 	bl	800a02c <UserToPMABufferCopy>
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);
 80096ea:	4629      	mov	r1, r5
 80096ec:	4630      	mov	r0, r6
 80096ee:	f000 fd99 	bl	800a224 <SetEPTxCount>

  pEPinfo->Usb_wLength -= Length;
 80096f2:	8a23      	ldrh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);
 80096f4:	2230      	movs	r2, #48	; 0x30
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
 80096f6:	1b5b      	subs	r3, r3, r5
 80096f8:	8223      	strh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
 80096fa:	8a63      	ldrh	r3, [r4, #18]
 80096fc:	18ed      	adds	r5, r5, r3
  vSetEPTxStatus(EP_TX_VALID);
 80096fe:	4b07      	ldr	r3, [pc, #28]	; (800971c <DataStageIn+0xa8>)
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
 8009700:	8265      	strh	r5, [r4, #18]
  vSetEPTxStatus(EP_TX_VALID);
 8009702:	801a      	strh	r2, [r3, #0]

  USB_StatusOut();/* Expect the host to abort the data IN stage */
 8009704:	4b08      	ldr	r3, [pc, #32]	; (8009728 <DataStageIn+0xb4>)
 8009706:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 800970a:	801a      	strh	r2, [r3, #0]

Expect_Status_Out:
  pInformation->ControlState = ControlState;
 800970c:	4b01      	ldr	r3, [pc, #4]	; (8009714 <DataStageIn+0xa0>)
 800970e:	681b      	ldr	r3, [r3, #0]
 8009710:	721f      	strb	r7, [r3, #8]
}
 8009712:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009714:	2000379c 	.word	0x2000379c
 8009718:	20000c1c 	.word	0x20000c1c
 800971c:	200037ac 	.word	0x200037ac
 8009720:	40005c50 	.word	0x40005c50
 8009724:	20003002 	.word	0x20003002
 8009728:	200037aa 	.word	0x200037aa

0800972c <Standard_SetConfiguration>:
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
 800972c:	b510      	push	{r4, lr}

  if ((pInformation->USBwValue0 <=
 800972e:	4b0a      	ldr	r3, [pc, #40]	; (8009758 <Standard_SetConfiguration+0x2c>)
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 8009730:	490a      	ldr	r1, [pc, #40]	; (800975c <Standard_SetConfiguration+0x30>)
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
 8009732:	681b      	ldr	r3, [r3, #0]
 8009734:	7849      	ldrb	r1, [r1, #1]
 8009736:	78da      	ldrb	r2, [r3, #3]
 8009738:	4291      	cmp	r1, r2
 800973a:	d30a      	bcc.n	8009752 <Standard_SetConfiguration+0x26>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 800973c:	7899      	ldrb	r1, [r3, #2]
 800973e:	b941      	cbnz	r1, 8009752 <Standard_SetConfiguration+0x26>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
 8009740:	889c      	ldrh	r4, [r3, #4]
 8009742:	b934      	cbnz	r4, 8009752 <Standard_SetConfiguration+0x26>
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
 8009744:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 8009746:	4b06      	ldr	r3, [pc, #24]	; (8009760 <Standard_SetConfiguration+0x34>)
 8009748:	681b      	ldr	r3, [r3, #0]
 800974a:	685b      	ldr	r3, [r3, #4]
 800974c:	4798      	blx	r3
    return USB_SUCCESS;
 800974e:	4620      	mov	r0, r4
 8009750:	e000      	b.n	8009754 <Standard_SetConfiguration+0x28>
  }
  else
  {
    return USB_UNSUPPORT;
 8009752:	2002      	movs	r0, #2
  }
}
 8009754:	bd10      	pop	{r4, pc}
 8009756:	bf00      	nop
 8009758:	2000379c 	.word	0x2000379c
 800975c:	200037a0 	.word	0x200037a0
 8009760:	20003798 	.word	0x20003798

08009764 <Standard_SetInterface>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
 8009764:	b538      	push	{r3, r4, r5, lr}
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
 8009766:	4a0e      	ldr	r2, [pc, #56]	; (80097a0 <Standard_SetInterface+0x3c>)
 8009768:	4c0e      	ldr	r4, [pc, #56]	; (80097a4 <Standard_SetInterface+0x40>)
 800976a:	6812      	ldr	r2, [r2, #0]
 800976c:	6823      	ldr	r3, [r4, #0]
 800976e:	7958      	ldrb	r0, [r3, #5]
 8009770:	78d9      	ldrb	r1, [r3, #3]
 8009772:	6993      	ldr	r3, [r2, #24]
 8009774:	4798      	blx	r3

  if (pInformation->Current_Configuration != 0)
 8009776:	6823      	ldr	r3, [r4, #0]
 8009778:	7a9a      	ldrb	r2, [r3, #10]
 800977a:	b17a      	cbz	r2, 800979c <Standard_SetInterface+0x38>
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
 800977c:	b970      	cbnz	r0, 800979c <Standard_SetInterface+0x38>
 800977e:	791a      	ldrb	r2, [r3, #4]
 8009780:	b962      	cbnz	r2, 800979c <Standard_SetInterface+0x38>
        || (pInformation->USBwValue1 != 0))
 8009782:	789d      	ldrb	r5, [r3, #2]
 8009784:	b955      	cbnz	r5, 800979c <Standard_SetInterface+0x38>
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
 8009786:	4b08      	ldr	r3, [pc, #32]	; (80097a8 <Standard_SetInterface+0x44>)
 8009788:	681b      	ldr	r3, [r3, #0]
 800978a:	68db      	ldr	r3, [r3, #12]
 800978c:	4798      	blx	r3
      pInformation->Current_Interface = pInformation->USBwIndex0;
 800978e:	6823      	ldr	r3, [r4, #0]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
 8009790:	4628      	mov	r0, r5
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
 8009792:	795a      	ldrb	r2, [r3, #5]
 8009794:	72da      	strb	r2, [r3, #11]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
 8009796:	78da      	ldrb	r2, [r3, #3]
 8009798:	731a      	strb	r2, [r3, #12]
      return USB_SUCCESS;
 800979a:	e000      	b.n	800979e <Standard_SetInterface+0x3a>
  if (pInformation->Current_Configuration != 0)
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
        || (pInformation->USBwValue1 != 0))
    {
      return  USB_UNSUPPORT;
 800979c:	2002      	movs	r0, #2
    }

  }

  return USB_UNSUPPORT;
}
 800979e:	bd38      	pop	{r3, r4, r5, pc}
 80097a0:	20003794 	.word	0x20003794
 80097a4:	2000379c 	.word	0x2000379c
 80097a8:	20003798 	.word	0x20003798

080097ac <Standard_ClearFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
 80097ac:	b510      	push	{r4, lr}
  uint32_t     Type_Rec = Type_Recipient;
 80097ae:	4b3f      	ldr	r3, [pc, #252]	; (80098ac <Standard_ClearFeature+0x100>)
 80097b0:	681b      	ldr	r3, [r3, #0]
 80097b2:	7818      	ldrb	r0, [r3, #0]
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80097b4:	f010 007f 	ands.w	r0, r0, #127	; 0x7f
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
 80097b8:	bf02      	ittt	eq
 80097ba:	7a5a      	ldrbeq	r2, [r3, #9]
 80097bc:	f022 0220 	biceq.w	r2, r2, #32
 80097c0:	725a      	strbeq	r2, [r3, #9]
{
  uint32_t     Type_Rec = Type_Recipient;
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80097c2:	d072      	beq.n	80098aa <Standard_ClearFeature+0xfe>
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 80097c4:	2802      	cmp	r0, #2
 80097c6:	d16f      	bne.n	80098a8 <Standard_ClearFeature+0xfc>
    DEVICE* pDev;
    uint32_t Related_Endpoint;
    uint32_t wIndex0;
    uint32_t rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
 80097c8:	885a      	ldrh	r2, [r3, #2]
 80097ca:	2a00      	cmp	r2, #0
 80097cc:	d16d      	bne.n	80098aa <Standard_ClearFeature+0xfe>
        || (pInformation->USBwIndex1 != 0))
 80097ce:	791a      	ldrb	r2, [r3, #4]
 80097d0:	2a00      	cmp	r2, #0
 80097d2:	d16a      	bne.n	80098aa <Standard_ClearFeature+0xfe>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
 80097d4:	795a      	ldrb	r2, [r3, #5]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 80097d6:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 80098b0 <Standard_ClearFeature+0x104>
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
 80097da:	f022 0080 	bic.w	r0, r2, #128	; 0x80
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
 80097de:	f012 0f80 	tst.w	r2, #128	; 0x80
 80097e2:	ea4f 0480 	mov.w	r4, r0, lsl #2
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 80097e6:	bf15      	itete	ne
 80097e8:	f104 4480 	addne.w	r4, r4, #1073741824	; 0x40000000
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 80097ec:	f104 4480 	addeq.w	r4, r4, #1073741824	; 0x40000000

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 80097f0:	f504 44b8 	addne.w	r4, r4, #23552	; 0x5c00
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 80097f4:	f504 44b8 	addeq.w	r4, r4, #23552	; 0x5c00

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 80097f8:	bf14      	ite	ne
 80097fa:	6821      	ldrne	r1, [r4, #0]
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 80097fc:	6821      	ldreq	r1, [r4, #0]
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 80097fe:	f89c c000 	ldrb.w	ip, [ip]

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8009802:	bf14      	ite	ne
 8009804:	f001 0130 	andne.w	r1, r1, #48	; 0x30
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009808:	f401 5140 	andeq.w	r1, r1, #12288	; 0x3000
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 800980c:	4560      	cmp	r0, ip
 800980e:	bf34      	ite	cc
 8009810:	f04f 0c00 	movcc.w	ip, #0
 8009814:	f04f 0c01 	movcs.w	ip, #1
 8009818:	2900      	cmp	r1, #0
 800981a:	bf14      	ite	ne
 800981c:	4661      	movne	r1, ip
 800981e:	f04c 0101 	orreq.w	r1, ip, #1
 8009822:	2900      	cmp	r1, #0
 8009824:	d140      	bne.n	80098a8 <Standard_ClearFeature+0xfc>
        || (pInformation->Current_Configuration == 0))
 8009826:	7a9b      	ldrb	r3, [r3, #10]
 8009828:	2b00      	cmp	r3, #0
 800982a:	d03d      	beq.n	80098a8 <Standard_ClearFeature+0xfc>
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
 800982c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009830:	ea4f 0480 	mov.w	r4, r0, lsl #2
 8009834:	d011      	beq.n	800985a <Standard_ClearFeature+0xae>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
 8009836:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 800983a:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 800983e:	6823      	ldr	r3, [r4, #0]
 8009840:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8009844:	2b10      	cmp	r3, #16
 8009846:	d129      	bne.n	800989c <Standard_ClearFeature+0xf0>
      {
      #ifndef STM32F10X_CL
        ClearDTOG_TX(Related_Endpoint);
 8009848:	b2c4      	uxtb	r4, r0
 800984a:	4620      	mov	r0, r4
 800984c:	f000 fc9a 	bl	800a184 <ClearDTOG_TX>
      #endif /* STM32F10X_CL */
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
 8009850:	4620      	mov	r0, r4
 8009852:	2130      	movs	r1, #48	; 0x30
 8009854:	f000 fc32 	bl	800a0bc <SetEPTxStatus>
 8009858:	e020      	b.n	800989c <Standard_ClearFeature+0xf0>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 800985a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 800985e:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 8009862:	6823      	ldr	r3, [r4, #0]
 8009864:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8009868:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800986c:	d116      	bne.n	800989c <Standard_ClearFeature+0xf0>
      {
        if (Related_Endpoint == ENDP0)
 800986e:	b930      	cbnz	r0, 800987e <Standard_ClearFeature+0xd2>
        {
          /* After clear the STALL, enable the default endpoint receiver */
//          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
          SetEPRxCount(Related_Endpoint, pProperty->MaxPacketSize);
 8009870:	4b10      	ldr	r3, [pc, #64]	; (80098b4 <Standard_ClearFeature+0x108>)
 8009872:	681b      	ldr	r3, [r3, #0]
 8009874:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8009878:	f000 fce2 	bl	800a240 <SetEPRxCount>
 800987c:	e002      	b.n	8009884 <Standard_ClearFeature+0xd8>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
        #ifndef STM32F10X_CL
          ClearDTOG_RX(Related_Endpoint);
 800987e:	b2c0      	uxtb	r0, r0
 8009880:	f000 fc6c 	bl	800a15c <ClearDTOG_RX>
        #endif /* STM32F10X_CL */
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 8009884:	6822      	ldr	r2, [r4, #0]
 8009886:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 800988a:	ea02 0303 	and.w	r3, r2, r3
 800988e:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8009892:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009896:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800989a:	6023      	str	r3, [r4, #0]
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
 800989c:	4b06      	ldr	r3, [pc, #24]	; (80098b8 <Standard_ClearFeature+0x10c>)
 800989e:	681b      	ldr	r3, [r3, #0]
 80098a0:	695b      	ldr	r3, [r3, #20]
 80098a2:	4798      	blx	r3
    return USB_SUCCESS;
 80098a4:	2000      	movs	r0, #0
 80098a6:	e000      	b.n	80098aa <Standard_ClearFeature+0xfe>
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
        || (pInformation->Current_Configuration == 0))
    {
      return USB_UNSUPPORT;
 80098a8:	2002      	movs	r0, #2
    pUser_Standard_Requests->User_ClearFeature();
    return USB_SUCCESS;
  }

  return USB_UNSUPPORT;
}
 80098aa:	bd10      	pop	{r4, pc}
 80098ac:	2000379c 	.word	0x2000379c
 80098b0:	200037a0 	.word	0x200037a0
 80098b4:	20003794 	.word	0x20003794
 80098b8:	20003798 	.word	0x20003798

080098bc <Standard_SetEndPointFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
 80098bc:	b508      	push	{r3, lr}
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 80098be:	4b2b      	ldr	r3, [pc, #172]	; (800996c <Standard_SetEndPointFeature+0xb0>)
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 80098c0:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 8009970 <Standard_SetEndPointFeature+0xb4>
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 80098c4:	6818      	ldr	r0, [r3, #0]
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 80098c6:	f89c c000 	ldrb.w	ip, [ip]
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 80098ca:	7941      	ldrb	r1, [r0, #5]
  rEP = wIndex0 & ~0x80;
 80098cc:	f021 0280 	bic.w	r2, r1, #128	; 0x80
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
 80098d0:	f011 0f80 	tst.w	r1, #128	; 0x80
 80098d4:	ea4f 0382 	mov.w	r3, r2, lsl #2
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 80098d8:	bf15      	itete	ne
 80098da:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 80098de:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 80098e2:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 80098e6:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 80098ea:	bf15      	itete	ne
 80098ec:	681b      	ldrne	r3, [r3, #0]
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 80098ee:	681b      	ldreq	r3, [r3, #0]

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 80098f0:	f003 0330 	andne.w	r3, r3, #48	; 0x30
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 80098f4:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 80098f8:	4562      	cmp	r2, ip
 80098fa:	d235      	bcs.n	8009968 <Standard_SetEndPointFeature+0xac>
      || pInformation->USBwValue != 0 || Status == 0
 80098fc:	f8b0 c002 	ldrh.w	ip, [r0, #2]
 8009900:	f1bc 0c00 	subs.w	ip, ip, #0
 8009904:	bf18      	it	ne
 8009906:	f04f 0c01 	movne.w	ip, #1
 800990a:	2b00      	cmp	r3, #0
 800990c:	bf14      	ite	ne
 800990e:	4663      	movne	r3, ip
 8009910:	f04c 0301 	orreq.w	r3, ip, #1
 8009914:	bb43      	cbnz	r3, 8009968 <Standard_SetEndPointFeature+0xac>
      || pInformation->Current_Configuration == 0)
 8009916:	7a83      	ldrb	r3, [r0, #10]
 8009918:	b333      	cbz	r3, 8009968 <Standard_SetEndPointFeature+0xac>
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
 800991a:	f011 0f80 	tst.w	r1, #128	; 0x80
 800991e:	ea4f 0382 	mov.w	r3, r2, lsl #2
 8009922:	d00b      	beq.n	800993c <Standard_SetEndPointFeature+0x80>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
 8009924:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009928:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 800992c:	6819      	ldr	r1, [r3, #0]
 800992e:	f648 72bf 	movw	r2, #36799	; 0x8fbf
 8009932:	ea01 0202 	and.w	r2, r1, r2
 8009936:	f082 0210 	eor.w	r2, r2, #16
 800993a:	e00a      	b.n	8009952 <Standard_SetEndPointFeature+0x96>
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
 800993c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009940:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009944:	6819      	ldr	r1, [r3, #0]
 8009946:	f64b 728f 	movw	r2, #49039	; 0xbf8f
 800994a:	ea01 0202 	and.w	r2, r1, r2
 800994e:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 8009952:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009956:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800995a:	601a      	str	r2, [r3, #0]
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
 800995c:	4b05      	ldr	r3, [pc, #20]	; (8009974 <Standard_SetEndPointFeature+0xb8>)
 800995e:	681b      	ldr	r3, [r3, #0]
 8009960:	699b      	ldr	r3, [r3, #24]
 8009962:	4798      	blx	r3
  return USB_SUCCESS;
 8009964:	2000      	movs	r0, #0
 8009966:	e000      	b.n	800996a <Standard_SetEndPointFeature+0xae>

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
 8009968:	2002      	movs	r0, #2
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
 800996a:	bd08      	pop	{r3, pc}
 800996c:	2000379c 	.word	0x2000379c
 8009970:	200037a0 	.word	0x200037a0
 8009974:	20003798 	.word	0x20003798

08009978 <Standard_SetDeviceFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
 8009978:	b508      	push	{r3, lr}
  SetBit(pInformation->Current_Feature, 5);
 800997a:	4b06      	ldr	r3, [pc, #24]	; (8009994 <Standard_SetDeviceFeature+0x1c>)
 800997c:	681b      	ldr	r3, [r3, #0]
 800997e:	7a5a      	ldrb	r2, [r3, #9]
 8009980:	f042 0220 	orr.w	r2, r2, #32
 8009984:	725a      	strb	r2, [r3, #9]
  pUser_Standard_Requests->User_SetDeviceFeature();
 8009986:	4b04      	ldr	r3, [pc, #16]	; (8009998 <Standard_SetDeviceFeature+0x20>)
 8009988:	681b      	ldr	r3, [r3, #0]
 800998a:	69db      	ldr	r3, [r3, #28]
 800998c:	4798      	blx	r3
  return USB_SUCCESS;
}
 800998e:	2000      	movs	r0, #0
 8009990:	bd08      	pop	{r3, pc}
 8009992:	bf00      	nop
 8009994:	2000379c 	.word	0x2000379c
 8009998:	20003798 	.word	0x20003798

0800999c <Standard_GetDescriptorData>:
*******************************************************************************/
uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
{
  uint32_t  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
 800999c:	4b05      	ldr	r3, [pc, #20]	; (80099b4 <Standard_GetDescriptorData+0x18>)
 800999e:	681a      	ldr	r2, [r3, #0]
 80099a0:	8a53      	ldrh	r3, [r2, #18]
  if (Length == 0)
 80099a2:	b918      	cbnz	r0, 80099ac <Standard_GetDescriptorData+0x10>
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
 80099a4:	8889      	ldrh	r1, [r1, #4]
 80099a6:	1acb      	subs	r3, r1, r3
 80099a8:	8213      	strh	r3, [r2, #16]
    return 0;
 80099aa:	e001      	b.n	80099b0 <Standard_GetDescriptorData+0x14>
  }

  return pDesc->Descriptor + wOffset;
 80099ac:	6808      	ldr	r0, [r1, #0]
 80099ae:	18c0      	adds	r0, r0, r3
}
 80099b0:	4770      	bx	lr
 80099b2:	bf00      	nop
 80099b4:	2000379c 	.word	0x2000379c

080099b8 <Post0_Process>:
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
uint8_t Post0_Process(void)
{
 80099b8:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
#endif /* STM32F10X_CL */
      
//  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 80099ba:	4b0c      	ldr	r3, [pc, #48]	; (80099ec <Post0_Process+0x34>)
 80099bc:	2000      	movs	r0, #0
 80099be:	681b      	ldr	r3, [r3, #0]
 80099c0:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 80099c4:	f000 fc3c 	bl	800a240 <SetEPRxCount>

  if (pInformation->ControlState == STALLED)
 80099c8:	4b09      	ldr	r3, [pc, #36]	; (80099f0 <Post0_Process+0x38>)
 80099ca:	681b      	ldr	r3, [r3, #0]
 80099cc:	7a18      	ldrb	r0, [r3, #8]
 80099ce:	2808      	cmp	r0, #8
 80099d0:	d106      	bne.n	80099e0 <Post0_Process+0x28>
  {
    vSetEPRxStatus(EP_RX_STALL);
 80099d2:	4b08      	ldr	r3, [pc, #32]	; (80099f4 <Post0_Process+0x3c>)
 80099d4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80099d8:	801a      	strh	r2, [r3, #0]
    vSetEPTxStatus(EP_TX_STALL);
 80099da:	4b07      	ldr	r3, [pc, #28]	; (80099f8 <Post0_Process+0x40>)
 80099dc:	2210      	movs	r2, #16
 80099de:	801a      	strh	r2, [r3, #0]
 80099e0:	2809      	cmp	r0, #9
 80099e2:	bf14      	ite	ne
 80099e4:	2000      	movne	r0, #0
 80099e6:	2001      	moveq	r0, #1
    OTGD_FS_EP0StartXfer(ep);    
  }  
#endif /* STM32F10X_CL */

  return (pInformation->ControlState == PAUSE);
}
 80099e8:	bd08      	pop	{r3, pc}
 80099ea:	bf00      	nop
 80099ec:	20003794 	.word	0x20003794
 80099f0:	2000379c 	.word	0x2000379c
 80099f4:	200037aa 	.word	0x200037aa
 80099f8:	200037ac 	.word	0x200037ac

080099fc <Out0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Out0_Process(void)
{
 80099fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t ControlState = pInformation->ControlState;
 80099fe:	4b38      	ldr	r3, [pc, #224]	; (8009ae0 <Out0_Process+0xe4>)
 8009a00:	681c      	ldr	r4, [r3, #0]
 8009a02:	7a23      	ldrb	r3, [r4, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8009a04:	2b02      	cmp	r3, #2
 8009a06:	bf14      	ite	ne
 8009a08:	2600      	movne	r6, #0
 8009a0a:	2601      	moveq	r6, #1
 8009a0c:	2b04      	cmp	r3, #4
 8009a0e:	bf08      	it	eq
 8009a10:	f046 0601 	orreq.w	r6, r6, #1
 8009a14:	2e00      	cmp	r6, #0
 8009a16:	d15b      	bne.n	8009ad0 <Out0_Process+0xd4>
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
 8009a18:	2b03      	cmp	r3, #3
 8009a1a:	bf14      	ite	ne
 8009a1c:	2200      	movne	r2, #0
 8009a1e:	2201      	moveq	r2, #1
 8009a20:	2b05      	cmp	r3, #5
 8009a22:	bf08      	it	eq
 8009a24:	f042 0201 	orreq.w	r2, r2, #1
 8009a28:	2a00      	cmp	r2, #0
 8009a2a:	d04b      	beq.n	8009ac4 <Out0_Process+0xc8>
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
 8009a2c:	69a3      	ldr	r3, [r4, #24]
void DataStageOut(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;
 8009a2e:	8a22      	ldrh	r2, [r4, #16]

  if (pEPinfo->CopyData && save_rLength)
 8009a30:	1e19      	subs	r1, r3, #0
 8009a32:	bf18      	it	ne
 8009a34:	2101      	movne	r1, #1
 8009a36:	2a00      	cmp	r2, #0
 8009a38:	bf0c      	ite	eq
 8009a3a:	2100      	moveq	r1, #0
 8009a3c:	f001 0101 	andne.w	r1, r1, #1
 8009a40:	b1a1      	cbz	r1, 8009a6c <Out0_Process+0x70>
  {
    uint8_t *Buffer;
    uint32_t Length;

    Length = pEPinfo->PacketSize;
 8009a42:	8aa5      	ldrh	r5, [r4, #20]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 8009a44:	4295      	cmp	r5, r2
 8009a46:	bf28      	it	cs
 8009a48:	4615      	movcs	r5, r2
 8009a4a:	4628      	mov	r0, r5
 8009a4c:	4798      	blx	r3
    pEPinfo->Usb_rLength -= Length;
 8009a4e:	8a23      	ldrh	r3, [r4, #16]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 8009a50:	4607      	mov	r7, r0
    pEPinfo->Usb_rLength -= Length;
 8009a52:	1b5b      	subs	r3, r3, r5
 8009a54:	8223      	strh	r3, [r4, #16]
    pEPinfo->Usb_rOffset += Length;
 8009a56:	8a63      	ldrh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 8009a58:	4630      	mov	r0, r6
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    pEPinfo->Usb_rLength -= Length;
    pEPinfo->Usb_rOffset += Length;
 8009a5a:	18eb      	adds	r3, r5, r3
 8009a5c:	8263      	strh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 8009a5e:	f000 fbd3 	bl	800a208 <GetEPRxAddr>
 8009a62:	462a      	mov	r2, r5
 8009a64:	4601      	mov	r1, r0
 8009a66:	4638      	mov	r0, r7
 8009a68:	f000 faf6 	bl	800a058 <PMAToUserBufferCopy>
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
 8009a6c:	8a23      	ldrh	r3, [r4, #16]
 8009a6e:	b153      	cbz	r3, 8009a86 <Out0_Process+0x8a>
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 8009a70:	4b1c      	ldr	r3, [pc, #112]	; (8009ae4 <Out0_Process+0xe8>)
 8009a72:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    SetEPTxCount(ENDP0, 0);
 8009a76:	2000      	movs	r0, #0
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 8009a78:	801a      	strh	r2, [r3, #0]
    SetEPTxCount(ENDP0, 0);
 8009a7a:	4601      	mov	r1, r0
 8009a7c:	f000 fbd2 	bl	800a224 <SetEPTxCount>
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 8009a80:	4b19      	ldr	r3, [pc, #100]	; (8009ae8 <Out0_Process+0xec>)
 8009a82:	2230      	movs	r2, #48	; 0x30
 8009a84:	801a      	strh	r2, [r3, #0]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
 8009a86:	8a23      	ldrh	r3, [r4, #16]
 8009a88:	8aa2      	ldrh	r2, [r4, #20]
 8009a8a:	429a      	cmp	r2, r3
 8009a8c:	d803      	bhi.n	8009a96 <Out0_Process+0x9a>
  {
    pInformation->ControlState = OUT_DATA;
 8009a8e:	4b14      	ldr	r3, [pc, #80]	; (8009ae0 <Out0_Process+0xe4>)
 8009a90:	2203      	movs	r2, #3
 8009a92:	681b      	ldr	r3, [r3, #0]
 8009a94:	e003      	b.n	8009a9e <Out0_Process+0xa2>
 8009a96:	4a12      	ldr	r2, [pc, #72]	; (8009ae0 <Out0_Process+0xe4>)
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
 8009a98:	b11b      	cbz	r3, 8009aa2 <Out0_Process+0xa6>
    {
      pInformation->ControlState = LAST_OUT_DATA;
 8009a9a:	6813      	ldr	r3, [r2, #0]
 8009a9c:	2205      	movs	r2, #5
 8009a9e:	721a      	strb	r2, [r3, #8]
 8009aa0:	e00c      	b.n	8009abc <Out0_Process+0xc0>
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
 8009aa2:	6812      	ldr	r2, [r2, #0]
 8009aa4:	2106      	movs	r1, #6
 8009aa6:	7211      	strb	r1, [r2, #8]
      USB_StatusIn();
 8009aa8:	4a10      	ldr	r2, [pc, #64]	; (8009aec <Out0_Process+0xf0>)
 8009aaa:	6811      	ldr	r1, [r2, #0]
 8009aac:	4a10      	ldr	r2, [pc, #64]	; (8009af0 <Out0_Process+0xf4>)
 8009aae:	b289      	uxth	r1, r1
 8009ab0:	188a      	adds	r2, r1, r2
 8009ab2:	0052      	lsls	r2, r2, #1
 8009ab4:	6013      	str	r3, [r2, #0]
 8009ab6:	4b0c      	ldr	r3, [pc, #48]	; (8009ae8 <Out0_Process+0xec>)
 8009ab8:	2230      	movs	r2, #48	; 0x30
 8009aba:	801a      	strh	r2, [r3, #0]
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
 8009abc:	4b08      	ldr	r3, [pc, #32]	; (8009ae0 <Out0_Process+0xe4>)
 8009abe:	681b      	ldr	r3, [r3, #0]
 8009ac0:	7a1b      	ldrb	r3, [r3, #8]
 8009ac2:	e006      	b.n	8009ad2 <Out0_Process+0xd6>
  }

  else if (ControlState == WAIT_STATUS_OUT)
 8009ac4:	2b07      	cmp	r3, #7
 8009ac6:	d103      	bne.n	8009ad0 <Out0_Process+0xd4>
  {
    (*pProperty->Process_Status_OUT)();
 8009ac8:	4b0a      	ldr	r3, [pc, #40]	; (8009af4 <Out0_Process+0xf8>)
 8009aca:	681b      	ldr	r3, [r3, #0]
 8009acc:	68db      	ldr	r3, [r3, #12]
 8009ace:	4798      	blx	r3


  /* Unexpect state, STALL the endpoint */
  else
  {
    ControlState = STALLED;
 8009ad0:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 8009ad2:	4a03      	ldr	r2, [pc, #12]	; (8009ae0 <Out0_Process+0xe4>)
 8009ad4:	6812      	ldr	r2, [r2, #0]
 8009ad6:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 8009ad8:	f7ff ff6e 	bl	80099b8 <Post0_Process>
}
 8009adc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009ade:	bf00      	nop
 8009ae0:	2000379c 	.word	0x2000379c
 8009ae4:	200037aa 	.word	0x200037aa
 8009ae8:	200037ac 	.word	0x200037ac
 8009aec:	40005c50 	.word	0x40005c50
 8009af0:	20003002 	.word	0x20003002
 8009af4:	20003794 	.word	0x20003794

08009af8 <Setup0_Process>:
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009af8:	4bb5      	ldr	r3, [pc, #724]	; (8009dd0 <Setup0_Process+0x2d8>)
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Setup0_Process(void)
{
 8009afa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009afc:	681a      	ldr	r2, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009afe:	4eb5      	ldr	r6, [pc, #724]	; (8009dd4 <Setup0_Process+0x2dc>)
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b00:	4bb5      	ldr	r3, [pc, #724]	; (8009dd8 <Setup0_Process+0x2e0>)
 8009b02:	b292      	uxth	r2, r2
 8009b04:	18d3      	adds	r3, r2, r3
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009b06:	6835      	ldr	r5, [r6, #0]
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b08:	005b      	lsls	r3, r3, #1
 8009b0a:	681f      	ldr	r7, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009b0c:	7a2b      	ldrb	r3, [r5, #8]
 8009b0e:	2b09      	cmp	r3, #9
 8009b10:	d01a      	beq.n	8009b48 <Setup0_Process+0x50>
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b12:	b2bf      	uxth	r7, r7
 8009b14:	f107 5700 	add.w	r7, r7, #536870912	; 0x20000000
 8009b18:	f507 5740 	add.w	r7, r7, #12288	; 0x3000
 8009b1c:	007f      	lsls	r7, r7, #1
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
 8009b1e:	463c      	mov	r4, r7
 8009b20:	f814 3b01 	ldrb.w	r3, [r4], #1
 8009b24:	702b      	strb	r3, [r5, #0]
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 8009b26:	787b      	ldrb	r3, [r7, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 8009b28:	370a      	adds	r7, #10
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 8009b2a:	706b      	strb	r3, [r5, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
 8009b2c:	f8b4 0003 	ldrh.w	r0, [r4, #3]
 8009b30:	f000 fbb6 	bl	800a2a0 <ByteSwap>
 8009b34:	8068      	strh	r0, [r5, #2]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 8009b36:	f8b4 0007 	ldrh.w	r0, [r4, #7]
 8009b3a:	6835      	ldr	r5, [r6, #0]
 8009b3c:	f000 fbb0 	bl	800a2a0 <ByteSwap>
 8009b40:	80a8      	strh	r0, [r5, #4]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength */
 8009b42:	6833      	ldr	r3, [r6, #0]
 8009b44:	887f      	ldrh	r7, [r7, #2]
 8009b46:	80df      	strh	r7, [r3, #6]
  }

  pInformation->ControlState = SETTING_UP;
 8009b48:	4ca2      	ldr	r4, [pc, #648]	; (8009dd4 <Setup0_Process+0x2dc>)
 8009b4a:	2201      	movs	r2, #1
 8009b4c:	6823      	ldr	r3, [r4, #0]
 8009b4e:	721a      	strb	r2, [r3, #8]
  if (pInformation->USBwLength == 0)
 8009b50:	88da      	ldrh	r2, [r3, #6]
 8009b52:	785d      	ldrb	r5, [r3, #1]
 8009b54:	2a00      	cmp	r2, #0
 8009b56:	d161      	bne.n	8009c1c <Setup0_Process+0x124>
{
  RESULT Result = USB_UNSUPPORT;
  uint32_t RequestNo = pInformation->USBbRequest;
  uint32_t ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009b58:	781a      	ldrb	r2, [r3, #0]
 8009b5a:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009b5e:	d12e      	bne.n	8009bbe <Setup0_Process+0xc6>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
 8009b60:	2d09      	cmp	r5, #9
 8009b62:	d102      	bne.n	8009b6a <Setup0_Process+0x72>
    {
      Result = Standard_SetConfiguration();
 8009b64:	f7ff fde2 	bl	800972c <Standard_SetConfiguration>
 8009b68:	e03b      	b.n	8009be2 <Setup0_Process+0xea>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
 8009b6a:	2d05      	cmp	r5, #5
 8009b6c:	d10d      	bne.n	8009b8a <Setup0_Process+0x92>
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
 8009b6e:	f993 2003 	ldrsb.w	r2, [r3, #3]
 8009b72:	2a00      	cmp	r2, #0
 8009b74:	db4d      	blt.n	8009c12 <Setup0_Process+0x11a>
 8009b76:	789a      	ldrb	r2, [r3, #2]
 8009b78:	2a00      	cmp	r2, #0
 8009b7a:	d14a      	bne.n	8009c12 <Setup0_Process+0x11a>
          || (pInformation->USBwIndex != 0)
 8009b7c:	889a      	ldrh	r2, [r3, #4]
 8009b7e:	2a00      	cmp	r2, #0
 8009b80:	d147      	bne.n	8009c12 <Setup0_Process+0x11a>
          || (pInformation->Current_Configuration != 0))
 8009b82:	7a9b      	ldrb	r3, [r3, #10]
 8009b84:	2b00      	cmp	r3, #0
 8009b86:	d035      	beq.n	8009bf4 <Setup0_Process+0xfc>
 8009b88:	e043      	b.n	8009c12 <Setup0_Process+0x11a>
         SetDeviceAddress(pInformation->USBwValue0);
      #endif  /* STM32F10X_CL */
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
 8009b8a:	2d03      	cmp	r5, #3
 8009b8c:	d10b      	bne.n	8009ba6 <Setup0_Process+0xae>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
 8009b8e:	78da      	ldrb	r2, [r3, #3]
 8009b90:	2a01      	cmp	r2, #1
 8009b92:	d127      	bne.n	8009be4 <Setup0_Process+0xec>
          && (pInformation->USBwIndex == 0)
 8009b94:	889a      	ldrh	r2, [r3, #4]
 8009b96:	bb2a      	cbnz	r2, 8009be4 <Setup0_Process+0xec>
          && (ValBit(pInformation->Current_Feature, 5)))
 8009b98:	7a5b      	ldrb	r3, [r3, #9]
 8009b9a:	f013 0f20 	tst.w	r3, #32
 8009b9e:	d021      	beq.n	8009be4 <Setup0_Process+0xec>
      {
        Result = Standard_SetDeviceFeature();
 8009ba0:	f7ff feea 	bl	8009978 <Standard_SetDeviceFeature>
 8009ba4:	e01d      	b.n	8009be2 <Setup0_Process+0xea>
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
 8009ba6:	2d01      	cmp	r5, #1
 8009ba8:	d11c      	bne.n	8009be4 <Setup0_Process+0xec>
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
 8009baa:	78da      	ldrb	r2, [r3, #3]
 8009bac:	2a01      	cmp	r2, #1
 8009bae:	d119      	bne.n	8009be4 <Setup0_Process+0xec>
          && pInformation->USBwIndex == 0
 8009bb0:	889a      	ldrh	r2, [r3, #4]
 8009bb2:	b9ba      	cbnz	r2, 8009be4 <Setup0_Process+0xec>
          && ValBit(pInformation->Current_Feature, 5))
 8009bb4:	7a5b      	ldrb	r3, [r3, #9]
 8009bb6:	f013 0f20 	tst.w	r3, #32
 8009bba:	d013      	beq.n	8009be4 <Setup0_Process+0xec>
 8009bbc:	e00a      	b.n	8009bd4 <Setup0_Process+0xdc>
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009bbe:	2a01      	cmp	r2, #1
 8009bc0:	d104      	bne.n	8009bcc <Setup0_Process+0xd4>
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
 8009bc2:	2d0b      	cmp	r5, #11
 8009bc4:	d10e      	bne.n	8009be4 <Setup0_Process+0xec>
    {
      Result = Standard_SetInterface();
 8009bc6:	f7ff fdcd 	bl	8009764 <Standard_SetInterface>
 8009bca:	e00a      	b.n	8009be2 <Setup0_Process+0xea>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009bcc:	2a02      	cmp	r2, #2
 8009bce:	d109      	bne.n	8009be4 <Setup0_Process+0xec>
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
 8009bd0:	2d01      	cmp	r5, #1
 8009bd2:	d102      	bne.n	8009bda <Setup0_Process+0xe2>
    {
      Result = Standard_ClearFeature();
 8009bd4:	f7ff fdea 	bl	80097ac <Standard_ClearFeature>
 8009bd8:	e003      	b.n	8009be2 <Setup0_Process+0xea>
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
 8009bda:	2d03      	cmp	r5, #3
 8009bdc:	d102      	bne.n	8009be4 <Setup0_Process+0xec>
    {
      Result = Standard_SetEndPointFeature();
 8009bde:	f7ff fe6d 	bl	80098bc <Standard_SetEndPointFeature>
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
 8009be2:	b138      	cbz	r0, 8009bf4 <Setup0_Process+0xfc>
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
 8009be4:	4b7d      	ldr	r3, [pc, #500]	; (8009ddc <Setup0_Process+0x2e4>)
 8009be6:	4628      	mov	r0, r5
 8009be8:	681b      	ldr	r3, [r3, #0]
 8009bea:	695b      	ldr	r3, [r3, #20]
 8009bec:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 8009bee:	2803      	cmp	r0, #3
 8009bf0:	d00d      	beq.n	8009c0e <Setup0_Process+0x116>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
 8009bf2:	b970      	cbnz	r0, 8009c12 <Setup0_Process+0x11a>
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
 8009bf4:	4b76      	ldr	r3, [pc, #472]	; (8009dd0 <Setup0_Process+0x2d8>)
 8009bf6:	2130      	movs	r1, #48	; 0x30
 8009bf8:	681a      	ldr	r2, [r3, #0]
 8009bfa:	4b79      	ldr	r3, [pc, #484]	; (8009de0 <Setup0_Process+0x2e8>)
 8009bfc:	b292      	uxth	r2, r2
 8009bfe:	18d3      	adds	r3, r2, r3
 8009c00:	005b      	lsls	r3, r3, #1
 8009c02:	2200      	movs	r2, #0
 8009c04:	601a      	str	r2, [r3, #0]
 8009c06:	4b77      	ldr	r3, [pc, #476]	; (8009de4 <Setup0_Process+0x2ec>)
 8009c08:	8019      	strh	r1, [r3, #0]
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
 8009c0a:	2306      	movs	r3, #6
 8009c0c:	e002      	b.n	8009c14 <Setup0_Process+0x11c>
  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    if (Result == USB_NOT_READY)
    {
      ControlState = PAUSE;
 8009c0e:	2309      	movs	r3, #9
 8009c10:	e000      	b.n	8009c14 <Setup0_Process+0x11c>
    }
  }

  if (Result != USB_SUCCESS)
  {
    ControlState = STALLED;
 8009c12:	2308      	movs	r3, #8
  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
 8009c14:	4a6f      	ldr	r2, [pc, #444]	; (8009dd4 <Setup0_Process+0x2dc>)
 8009c16:	6812      	ldr	r2, [r2, #0]
 8009c18:	7213      	strb	r3, [r2, #8]
 8009c1a:	e0d6      	b.n	8009dca <Setup0_Process+0x2d2>

  CopyRoutine = NULL;
  wOffset = 0;

  /*GET DESCRIPTOR*/
  if (Request_No == GET_DESCRIPTOR)
 8009c1c:	2d06      	cmp	r5, #6
 8009c1e:	d117      	bne.n	8009c50 <Setup0_Process+0x158>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009c20:	781a      	ldrb	r2, [r3, #0]
 8009c22:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 8009c26:	f040 808a 	bne.w	8009d3e <Setup0_Process+0x246>
    {
      uint8_t wValue1 = pInformation->USBwValue1;
 8009c2a:	789b      	ldrb	r3, [r3, #2]
      if (wValue1 == DEVICE_DESCRIPTOR)
 8009c2c:	2b01      	cmp	r3, #1
 8009c2e:	d103      	bne.n	8009c38 <Setup0_Process+0x140>
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
 8009c30:	4b6a      	ldr	r3, [pc, #424]	; (8009ddc <Setup0_Process+0x2e4>)
 8009c32:	681b      	ldr	r3, [r3, #0]
 8009c34:	69db      	ldr	r3, [r3, #28]
 8009c36:	e079      	b.n	8009d2c <Setup0_Process+0x234>
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
 8009c38:	2b02      	cmp	r3, #2
 8009c3a:	d103      	bne.n	8009c44 <Setup0_Process+0x14c>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
 8009c3c:	4b67      	ldr	r3, [pc, #412]	; (8009ddc <Setup0_Process+0x2e4>)
 8009c3e:	681b      	ldr	r3, [r3, #0]
 8009c40:	6a1b      	ldr	r3, [r3, #32]
 8009c42:	e073      	b.n	8009d2c <Setup0_Process+0x234>
      }
      else if (wValue1 == STRING_DESCRIPTOR)
 8009c44:	2b03      	cmp	r3, #3
 8009c46:	d17a      	bne.n	8009d3e <Setup0_Process+0x246>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
 8009c48:	4b64      	ldr	r3, [pc, #400]	; (8009ddc <Setup0_Process+0x2e4>)
 8009c4a:	681b      	ldr	r3, [r3, #0]
 8009c4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009c4e:	e06d      	b.n	8009d2c <Setup0_Process+0x234>
      }  /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
 8009c50:	2d00      	cmp	r5, #0
 8009c52:	d147      	bne.n	8009ce4 <Setup0_Process+0x1ec>
 8009c54:	8859      	ldrh	r1, [r3, #2]
 8009c56:	2900      	cmp	r1, #0
 8009c58:	d171      	bne.n	8009d3e <Setup0_Process+0x246>
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
 8009c5a:	685a      	ldr	r2, [r3, #4]
 8009c5c:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8009c60:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 8009c64:	d16b      	bne.n	8009d3e <Setup0_Process+0x246>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009c66:	781a      	ldrb	r2, [r3, #0]
 8009c68:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009c6c:	d103      	bne.n	8009c76 <Setup0_Process+0x17e>
        && (pInformation->USBwIndex == 0))
 8009c6e:	889b      	ldrh	r3, [r3, #4]
 8009c70:	2b00      	cmp	r3, #0
 8009c72:	d059      	beq.n	8009d28 <Setup0_Process+0x230>
 8009c74:	e063      	b.n	8009d3e <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009c76:	2a01      	cmp	r2, #1
 8009c78:	d109      	bne.n	8009c8e <Setup0_Process+0x196>
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
 8009c7a:	4a58      	ldr	r2, [pc, #352]	; (8009ddc <Setup0_Process+0x2e4>)
 8009c7c:	7958      	ldrb	r0, [r3, #5]
 8009c7e:	6812      	ldr	r2, [r2, #0]
 8009c80:	6993      	ldr	r3, [r2, #24]
 8009c82:	4798      	blx	r3
 8009c84:	2800      	cmp	r0, #0
 8009c86:	d15a      	bne.n	8009d3e <Setup0_Process+0x246>
          && (pInformation->Current_Configuration != 0))
 8009c88:	6823      	ldr	r3, [r4, #0]
 8009c8a:	7a9b      	ldrb	r3, [r3, #10]
 8009c8c:	e028      	b.n	8009ce0 <Setup0_Process+0x1e8>
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009c8e:	2a02      	cmp	r2, #2
 8009c90:	d155      	bne.n	8009d3e <Setup0_Process+0x246>
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 8009c92:	795b      	ldrb	r3, [r3, #5]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009c94:	4854      	ldr	r0, [pc, #336]	; (8009de8 <Setup0_Process+0x2f0>)
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 8009c96:	f003 020f 	and.w	r2, r3, #15
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
 8009c9a:	f013 0f80 	tst.w	r3, #128	; 0x80

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;
 8009c9e:	f003 0170 	and.w	r1, r3, #112	; 0x70
 8009ca2:	ea4f 0382 	mov.w	r3, r2, lsl #2

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009ca6:	bf15      	itete	ne
 8009ca8:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009cac:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009cb0:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009cb4:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009cb8:	bf14      	ite	ne
 8009cba:	681b      	ldrne	r3, [r3, #0]
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009cbc:	681b      	ldreq	r3, [r3, #0]
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009cbe:	7800      	ldrb	r0, [r0, #0]

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009cc0:	bf14      	ite	ne
 8009cc2:	f003 0330 	andne.w	r3, r3, #48	; 0x30
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009cc6:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009cca:	4282      	cmp	r2, r0
 8009ccc:	bf2c      	ite	cs
 8009cce:	2200      	movcs	r2, #0
 8009cd0:	2201      	movcc	r2, #1
 8009cd2:	2900      	cmp	r1, #0
 8009cd4:	bf14      	ite	ne
 8009cd6:	2200      	movne	r2, #0
 8009cd8:	f002 0201 	andeq.w	r2, r2, #1
 8009cdc:	2a00      	cmp	r2, #0
 8009cde:	d02e      	beq.n	8009d3e <Setup0_Process+0x246>
          && (Status != 0))
 8009ce0:	bb13      	cbnz	r3, 8009d28 <Setup0_Process+0x230>
 8009ce2:	e02c      	b.n	8009d3e <Setup0_Process+0x246>
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
 8009ce4:	2d08      	cmp	r5, #8
 8009ce6:	d106      	bne.n	8009cf6 <Setup0_Process+0x1fe>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009ce8:	781b      	ldrb	r3, [r3, #0]
 8009cea:	f013 0f7f 	tst.w	r3, #127	; 0x7f
    {
      CopyRoutine = Standard_GetConfiguration;
 8009cee:	bf08      	it	eq
 8009cf0:	4b3e      	ldreq	r3, [pc, #248]	; (8009dec <Setup0_Process+0x2f4>)
  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009cf2:	d01c      	beq.n	8009d2e <Setup0_Process+0x236>
 8009cf4:	e023      	b.n	8009d3e <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
 8009cf6:	2d0a      	cmp	r5, #10
 8009cf8:	d121      	bne.n	8009d3e <Setup0_Process+0x246>
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009cfa:	781a      	ldrb	r2, [r3, #0]
 8009cfc:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8009d00:	2a01      	cmp	r2, #1
 8009d02:	d11c      	bne.n	8009d3e <Setup0_Process+0x246>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
 8009d04:	7a9a      	ldrb	r2, [r3, #10]
 8009d06:	b1d2      	cbz	r2, 8009d3e <Setup0_Process+0x246>
 8009d08:	8859      	ldrh	r1, [r3, #2]
 8009d0a:	b9c1      	cbnz	r1, 8009d3e <Setup0_Process+0x246>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
 8009d0c:	685a      	ldr	r2, [r3, #4]
 8009d0e:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8009d12:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8009d16:	d112      	bne.n	8009d3e <Setup0_Process+0x246>
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 8009d18:	4a30      	ldr	r2, [pc, #192]	; (8009ddc <Setup0_Process+0x2e4>)
 8009d1a:	7958      	ldrb	r0, [r3, #5]
 8009d1c:	6812      	ldr	r2, [r2, #0]
 8009d1e:	6993      	ldr	r3, [r2, #24]
 8009d20:	4798      	blx	r3
    {
      CopyRoutine = Standard_GetInterface;
 8009d22:	4b33      	ldr	r3, [pc, #204]	; (8009df0 <Setup0_Process+0x2f8>)
  else if (Request_No == GET_INTERFACE)
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 8009d24:	b118      	cbz	r0, 8009d2e <Setup0_Process+0x236>
 8009d26:	e00a      	b.n	8009d3e <Setup0_Process+0x246>
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
          && (Status != 0))
      {
        CopyRoutine = Standard_GetStatus;
 8009d28:	4b32      	ldr	r3, [pc, #200]	; (8009df4 <Setup0_Process+0x2fc>)
 8009d2a:	e000      	b.n	8009d2e <Setup0_Process+0x236>
      CopyRoutine = Standard_GetInterface;
    }

  }
  
  if (CopyRoutine)
 8009d2c:	b13b      	cbz	r3, 8009d3e <Setup0_Process+0x246>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
 8009d2e:	6822      	ldr	r2, [r4, #0]
 8009d30:	2100      	movs	r1, #0
 8009d32:	8251      	strh	r1, [r2, #18]
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
 8009d34:	6193      	str	r3, [r2, #24]
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
 8009d36:	2000      	movs	r0, #0
 8009d38:	4798      	blx	r3
    Result = USB_SUCCESS;
 8009d3a:	2000      	movs	r0, #0
 8009d3c:	e00a      	b.n	8009d54 <Setup0_Process+0x25c>
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
 8009d3e:	4b27      	ldr	r3, [pc, #156]	; (8009ddc <Setup0_Process+0x2e4>)
 8009d40:	6822      	ldr	r2, [r4, #0]
 8009d42:	681b      	ldr	r3, [r3, #0]
 8009d44:	7850      	ldrb	r0, [r2, #1]
 8009d46:	691b      	ldr	r3, [r3, #16]
 8009d48:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 8009d4a:	2803      	cmp	r0, #3
    {
      pInformation->ControlState = PAUSE;
 8009d4c:	bf04      	itt	eq
 8009d4e:	4b21      	ldreq	r3, [pc, #132]	; (8009dd4 <Setup0_Process+0x2dc>)
 8009d50:	681b      	ldreq	r3, [r3, #0]
    Result = USB_SUCCESS;
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    if (Result == USB_NOT_READY)
 8009d52:	d006      	beq.n	8009d62 <Setup0_Process+0x26a>
      pInformation->ControlState = PAUSE;
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
 8009d54:	4b1f      	ldr	r3, [pc, #124]	; (8009dd4 <Setup0_Process+0x2dc>)
 8009d56:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009d5a:	681b      	ldr	r3, [r3, #0]
 8009d5c:	8a1a      	ldrh	r2, [r3, #16]
 8009d5e:	428a      	cmp	r2, r1
 8009d60:	d101      	bne.n	8009d66 <Setup0_Process+0x26e>
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
 8009d62:	2209      	movs	r2, #9
 8009d64:	e003      	b.n	8009d6e <Setup0_Process+0x276>
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
 8009d66:	2802      	cmp	r0, #2
 8009d68:	d000      	beq.n	8009d6c <Setup0_Process+0x274>
 8009d6a:	b912      	cbnz	r2, 8009d72 <Setup0_Process+0x27a>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
 8009d6c:	2208      	movs	r2, #8
 8009d6e:	721a      	strb	r2, [r3, #8]
 8009d70:	e02b      	b.n	8009dca <Setup0_Process+0x2d2>
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
 8009d72:	f993 1000 	ldrsb.w	r1, [r3]
 8009d76:	2900      	cmp	r1, #0
 8009d78:	da21      	bge.n	8009dbe <Setup0_Process+0x2c6>
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
 8009d7a:	88d9      	ldrh	r1, [r3, #6]
 8009d7c:	9101      	str	r1, [sp, #4]
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8009d7e:	9801      	ldr	r0, [sp, #4]
 8009d80:	4282      	cmp	r2, r0
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
 8009d82:	bf84      	itt	hi
 8009d84:	9a01      	ldrhi	r2, [sp, #4]
 8009d86:	821a      	strhhi	r2, [r3, #16]
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8009d88:	d811      	bhi.n	8009dae <Setup0_Process+0x2b6>
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    }
    
    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
 8009d8a:	428a      	cmp	r2, r1
 8009d8c:	d20f      	bcs.n	8009dae <Setup0_Process+0x2b6>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
 8009d8e:	4913      	ldr	r1, [pc, #76]	; (8009ddc <Setup0_Process+0x2e4>)
 8009d90:	6809      	ldr	r1, [r1, #0]
 8009d92:	f891 102c 	ldrb.w	r1, [r1, #44]	; 0x2c
 8009d96:	428a      	cmp	r2, r1
 8009d98:	d201      	bcs.n	8009d9e <Setup0_Process+0x2a6>
      {
        Data_Mul_MaxPacketSize = FALSE;
 8009d9a:	2100      	movs	r1, #0
 8009d9c:	e005      	b.n	8009daa <Setup0_Process+0x2b2>
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
 8009d9e:	fb92 f0f1 	sdiv	r0, r2, r1
 8009da2:	fb01 2210 	mls	r2, r1, r0, r2
 8009da6:	b912      	cbnz	r2, 8009dae <Setup0_Process+0x2b6>
      {
        Data_Mul_MaxPacketSize = TRUE;
 8009da8:	2101      	movs	r1, #1
 8009daa:	4a13      	ldr	r2, [pc, #76]	; (8009df8 <Setup0_Process+0x300>)
 8009dac:	7011      	strb	r1, [r2, #0]
      }
    }   

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
 8009dae:	4a0b      	ldr	r2, [pc, #44]	; (8009ddc <Setup0_Process+0x2e4>)
 8009db0:	6812      	ldr	r2, [r2, #0]
 8009db2:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8009db6:	829a      	strh	r2, [r3, #20]
    DataStageIn();
 8009db8:	f7ff fc5c 	bl	8009674 <DataStageIn>
 8009dbc:	e005      	b.n	8009dca <Setup0_Process+0x2d2>
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
 8009dbe:	2203      	movs	r2, #3
 8009dc0:	721a      	strb	r2, [r3, #8]
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
 8009dc2:	4b0e      	ldr	r3, [pc, #56]	; (8009dfc <Setup0_Process+0x304>)
 8009dc4:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8009dc8:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
 8009dca:	f7ff fdf5 	bl	80099b8 <Post0_Process>
}
 8009dce:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009dd0:	40005c50 	.word	0x40005c50
 8009dd4:	2000379c 	.word	0x2000379c
 8009dd8:	20003004 	.word	0x20003004
 8009ddc:	20003794 	.word	0x20003794
 8009de0:	20003002 	.word	0x20003002
 8009de4:	200037ac 	.word	0x200037ac
 8009de8:	200037a0 	.word	0x200037a0
 8009dec:	08009581 	.word	0x08009581
 8009df0:	080095a5 	.word	0x080095a5
 8009df4:	080095c9 	.word	0x080095c9
 8009df8:	20000c1c 	.word	0x20000c1c
 8009dfc:	200037aa 	.word	0x200037aa

08009e00 <SetDeviceAddress>:
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(uint8_t Val)
{
 8009e00:	b530      	push	{r4, r5, lr}
#ifdef STM32F10X_CL 
  PCD_EP_SetAddress ((uint8_t)Val);
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;
 8009e02:	4b0f      	ldr	r3, [pc, #60]	; (8009e40 <SetDeviceAddress+0x40>)
 8009e04:	f893 c000 	ldrb.w	ip, [r3]

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 8009e08:	2300      	movs	r3, #0
 8009e0a:	e012      	b.n	8009e32 <SetDeviceAddress+0x32>
 8009e0c:	b2da      	uxtb	r2, r3
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
 8009e0e:	0091      	lsls	r1, r2, #2
 8009e10:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8009e14:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 8009e18:	680d      	ldr	r5, [r1, #0]
 8009e1a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009e1e:	f042 0480 	orr.w	r4, r2, #128	; 0x80
 8009e22:	f640 720f 	movw	r2, #3855	; 0xf0f
 8009e26:	ea05 0202 	and.w	r2, r5, r2
 8009e2a:	ea44 0202 	orr.w	r2, r4, r2
 8009e2e:	600a      	str	r2, [r1, #0]
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 8009e30:	3301      	adds	r3, #1
 8009e32:	4563      	cmp	r3, ip
 8009e34:	d3ea      	bcc.n	8009e0c <SetDeviceAddress+0xc>
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
 8009e36:	4b03      	ldr	r3, [pc, #12]	; (8009e44 <SetDeviceAddress+0x44>)
 8009e38:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8009e3c:	6018      	str	r0, [r3, #0]
#endif  /* STM32F10X_CL */  
}
 8009e3e:	bd30      	pop	{r4, r5, pc}
 8009e40:	200037a0 	.word	0x200037a0
 8009e44:	40005c4c 	.word	0x40005c4c

08009e48 <In0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t In0_Process(void)
{
 8009e48:	b510      	push	{r4, lr}
  uint32_t ControlState = pInformation->ControlState;
 8009e4a:	4c16      	ldr	r4, [pc, #88]	; (8009ea4 <In0_Process+0x5c>)
 8009e4c:	6823      	ldr	r3, [r4, #0]
 8009e4e:	7a1a      	ldrb	r2, [r3, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8009e50:	2a02      	cmp	r2, #2
 8009e52:	bf14      	ite	ne
 8009e54:	2100      	movne	r1, #0
 8009e56:	2101      	moveq	r1, #1
 8009e58:	2a04      	cmp	r2, #4
 8009e5a:	bf08      	it	eq
 8009e5c:	f041 0101 	orreq.w	r1, r1, #1
 8009e60:	b121      	cbz	r1, 8009e6c <In0_Process+0x24>
  {
    DataStageIn();
 8009e62:	f7ff fc07 	bl	8009674 <DataStageIn>
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
 8009e66:	6823      	ldr	r3, [r4, #0]
 8009e68:	7a1b      	ldrb	r3, [r3, #8]
 8009e6a:	e014      	b.n	8009e96 <In0_Process+0x4e>
  }

  else if (ControlState == WAIT_STATUS_IN)
 8009e6c:	2a06      	cmp	r2, #6
 8009e6e:	d111      	bne.n	8009e94 <In0_Process+0x4c>
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8009e70:	785a      	ldrb	r2, [r3, #1]
 8009e72:	2a05      	cmp	r2, #5
 8009e74:	d10a      	bne.n	8009e8c <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 8009e76:	781a      	ldrb	r2, [r3, #0]
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8009e78:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 8009e7c:	d106      	bne.n	8009e8c <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
 8009e7e:	78d8      	ldrb	r0, [r3, #3]
 8009e80:	f7ff ffbe 	bl	8009e00 <SetDeviceAddress>
      pUser_Standard_Requests->User_SetDeviceAddress();
 8009e84:	4b08      	ldr	r3, [pc, #32]	; (8009ea8 <In0_Process+0x60>)
 8009e86:	681b      	ldr	r3, [r3, #0]
 8009e88:	6a1b      	ldr	r3, [r3, #32]
 8009e8a:	4798      	blx	r3
    }
    (*pProperty->Process_Status_IN)();
 8009e8c:	4b07      	ldr	r3, [pc, #28]	; (8009eac <In0_Process+0x64>)
 8009e8e:	681b      	ldr	r3, [r3, #0]
 8009e90:	689b      	ldr	r3, [r3, #8]
 8009e92:	4798      	blx	r3
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
 8009e94:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 8009e96:	4a03      	ldr	r2, [pc, #12]	; (8009ea4 <In0_Process+0x5c>)
 8009e98:	6812      	ldr	r2, [r2, #0]
 8009e9a:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 8009e9c:	f7ff fd8c 	bl	80099b8 <Post0_Process>
}
 8009ea0:	bd10      	pop	{r4, pc}
 8009ea2:	bf00      	nop
 8009ea4:	2000379c 	.word	0x2000379c
 8009ea8:	20003798 	.word	0x20003798
 8009eac:	20003794 	.word	0x20003794

08009eb0 <NOP_Process>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
}
 8009eb0:	4770      	bx	lr
	...

08009eb4 <CTR_LP>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
 8009eb4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint16_t wEPVal = 0;
 8009eb6:	2200      	movs	r2, #0
 8009eb8:	f8ad 2006 	strh.w	r2, [sp, #6]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009ebc:	4f54      	ldr	r7, [pc, #336]	; (800a010 <CTR_LP+0x15c>)
 8009ebe:	4e55      	ldr	r6, [pc, #340]	; (800a014 <CTR_LP+0x160>)
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8009ec0:	e09d      	b.n	8009ffe <CTR_LP+0x14a>
  {
    /* extract highest priority endpoint number */
    EPindex = (uint8_t)(wIstr & ISTR_EP_ID);
    if (EPindex == 0)
 8009ec2:	f013 050f 	ands.w	r5, r3, #15
 8009ec6:	d171      	bne.n	8009fac <CTR_LP+0xf8>

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009ec8:	683a      	ldr	r2, [r7, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8009eca:	f013 0f10 	tst.w	r3, #16

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009ece:	b292      	uxth	r2, r2
 8009ed0:	8032      	strh	r2, [r6, #0]
	    SaveTState = SaveRState & EPTX_STAT;
 8009ed2:	8831      	ldrh	r1, [r6, #0]
 8009ed4:	4a50      	ldr	r2, [pc, #320]	; (800a018 <CTR_LP+0x164>)
 8009ed6:	f001 0130 	and.w	r1, r1, #48	; 0x30
 8009eda:	8011      	strh	r1, [r2, #0]
	    SaveRState &=  EPRX_STAT;	
 8009edc:	8832      	ldrh	r2, [r6, #0]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009ede:	4c4c      	ldr	r4, [pc, #304]	; (800a010 <CTR_LP+0x15c>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	
 8009ee0:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8009ee4:	8032      	strh	r2, [r6, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8009ee6:	6839      	ldr	r1, [r7, #0]
 8009ee8:	f64b 72bf 	movw	r2, #49087	; 0xbfbf
 8009eec:	ea01 0202 	and.w	r2, r1, r2
 8009ef0:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8009ef4:	f082 0220 	eor.w	r2, r2, #32
 8009ef8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009efc:	f042 0280 	orr.w	r2, r2, #128	; 0x80

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009f00:	4d44      	ldr	r5, [pc, #272]	; (800a014 <CTR_LP+0x160>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8009f02:	603a      	str	r2, [r7, #0]

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8009f04:	d108      	bne.n	8009f18 <CTR_LP+0x64>

        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */


        _ClearEP_CTR_TX(ENDP0);
 8009f06:	6822      	ldr	r2, [r4, #0]
 8009f08:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8009f0c:	ea02 0303 	and.w	r3, r2, r3
 8009f10:	6023      	str	r3, [r4, #0]
        In0_Process();
 8009f12:	f7ff ff99 	bl	8009e48 <In0_Process>
 8009f16:	e01e      	b.n	8009f56 <CTR_LP+0xa2>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
 8009f18:	683b      	ldr	r3, [r7, #0]
 8009f1a:	b29b      	uxth	r3, r3
 8009f1c:	f8ad 3006 	strh.w	r3, [sp, #6]
        
        if ((wEPVal &EP_SETUP) != 0)
 8009f20:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009f24:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009f28:	d008      	beq.n	8009f3c <CTR_LP+0x88>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
 8009f2a:	6822      	ldr	r2, [r4, #0]
 8009f2c:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009f30:	ea02 0303 	and.w	r3, r2, r3
 8009f34:	6023      	str	r3, [r4, #0]
          Setup0_Process();
 8009f36:	f7ff fddf 	bl	8009af8 <Setup0_Process>
 8009f3a:	e00c      	b.n	8009f56 <CTR_LP+0xa2>

		      _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
 8009f3c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009f40:	b21b      	sxth	r3, r3
 8009f42:	2b00      	cmp	r3, #0
 8009f44:	da5b      	bge.n	8009ffe <CTR_LP+0x14a>
        {
          _ClearEP_CTR_RX(ENDP0);
 8009f46:	6822      	ldr	r2, [r4, #0]
 8009f48:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009f4c:	ea02 0303 	and.w	r3, r2, r3
 8009f50:	6023      	str	r3, [r4, #0]
          Out0_Process();
 8009f52:	f7ff fd53 	bl	80099fc <Out0_Process>
          /* before terminate set Tx & Rx status */
     
		     _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
 8009f56:	6822      	ldr	r2, [r4, #0]
 8009f58:	f64b 73bf 	movw	r3, #49087	; 0xbfbf
 8009f5c:	ea02 0303 	and.w	r3, r2, r3
 8009f60:	882a      	ldrh	r2, [r5, #0]
 8009f62:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 8009f66:	b292      	uxth	r2, r2
 8009f68:	b10a      	cbz	r2, 8009f6e <CTR_LP+0xba>
 8009f6a:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8009f6e:	4a29      	ldr	r2, [pc, #164]	; (800a014 <CTR_LP+0x160>)
 8009f70:	8812      	ldrh	r2, [r2, #0]
 8009f72:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8009f76:	b292      	uxth	r2, r2
 8009f78:	b10a      	cbz	r2, 8009f7e <CTR_LP+0xca>
 8009f7a:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8009f7e:	4a26      	ldr	r2, [pc, #152]	; (800a018 <CTR_LP+0x164>)
 8009f80:	8812      	ldrh	r2, [r2, #0]
 8009f82:	f002 0210 	and.w	r2, r2, #16
 8009f86:	b292      	uxth	r2, r2
 8009f88:	b10a      	cbz	r2, 8009f8e <CTR_LP+0xda>
 8009f8a:	f083 0310 	eor.w	r3, r3, #16
 8009f8e:	4a22      	ldr	r2, [pc, #136]	; (800a018 <CTR_LP+0x164>)
 8009f90:	8812      	ldrh	r2, [r2, #0]
 8009f92:	f002 0220 	and.w	r2, r2, #32
 8009f96:	b292      	uxth	r2, r2
 8009f98:	b10a      	cbz	r2, 8009f9e <CTR_LP+0xea>
 8009f9a:	f083 0320 	eor.w	r3, r3, #32
 8009f9e:	4a1f      	ldr	r2, [pc, #124]	; (800a01c <CTR_LP+0x168>)
 8009fa0:	ea43 0202 	orr.w	r2, r3, r2
 8009fa4:	4b1a      	ldr	r3, [pc, #104]	; (800a010 <CTR_LP+0x15c>)
 8009fa6:	b292      	uxth	r2, r2
 8009fa8:	601a      	str	r2, [r3, #0]
          return;
 8009faa:	e02f      	b.n	800a00c <CTR_LP+0x158>
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
 8009fac:	00ac      	lsls	r4, r5, #2
 8009fae:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8009fb2:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 8009fb6:	6823      	ldr	r3, [r4, #0]
 8009fb8:	b29b      	uxth	r3, r3
 8009fba:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & EP_CTR_RX) != 0)
 8009fbe:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009fc2:	b21b      	sxth	r3, r3
 8009fc4:	2b00      	cmp	r3, #0
 8009fc6:	da0a      	bge.n	8009fde <CTR_LP+0x12a>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 8009fc8:	6822      	ldr	r2, [r4, #0]
 8009fca:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009fce:	ea02 0303 	and.w	r3, r2, r3

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 8009fd2:	4a13      	ldr	r2, [pc, #76]	; (800a020 <CTR_LP+0x16c>)
      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
      if ((wEPVal & EP_CTR_RX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 8009fd4:	6023      	str	r3, [r4, #0]

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 8009fd6:	1e6b      	subs	r3, r5, #1
 8009fd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009fdc:	4798      	blx	r3

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
 8009fde:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009fe2:	f013 0f80 	tst.w	r3, #128	; 0x80
 8009fe6:	d00a      	beq.n	8009ffe <CTR_LP+0x14a>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 8009fe8:	6822      	ldr	r2, [r4, #0]
 8009fea:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8009fee:	ea02 0303 	and.w	r3, r2, r3

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 8009ff2:	4a0c      	ldr	r2, [pc, #48]	; (800a024 <CTR_LP+0x170>)
 8009ff4:	3d01      	subs	r5, #1
      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 8009ff6:	6023      	str	r3, [r4, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 8009ff8:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
 8009ffc:	4798      	blx	r3
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8009ffe:	4a0a      	ldr	r2, [pc, #40]	; (800a028 <CTR_LP+0x174>)
 800a000:	6813      	ldr	r3, [r2, #0]
 800a002:	b29b      	uxth	r3, r3
 800a004:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800a008:	f47f af5b 	bne.w	8009ec2 <CTR_LP+0xe>
      } /* if((wEPVal & EP_CTR_TX) != 0) */

    }/* if(EPindex == 0) else */

  }/* while(...) */
}
 800a00c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800a00e:	bf00      	nop
 800a010:	40005c00 	.word	0x40005c00
 800a014:	200037aa 	.word	0x200037aa
 800a018:	200037ac 	.word	0x200037ac
 800a01c:	ffff8080 	.word	0xffff8080
 800a020:	20000028 	.word	0x20000028
 800a024:	2000000c 	.word	0x2000000c
 800a028:	40005c44 	.word	0x40005c44

0800a02c <UserToPMABufferCopy>:
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 800a02c:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
 800a030:	3201      	adds	r2, #1
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 800a032:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 800a036:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 800a038:	0852      	lsrs	r2, r2, #1
 800a03a:	e008      	b.n	800a04e <UserToPMABufferCopy+0x22>
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 800a03c:	f810 cc01 	ldrb.w	ip, [r0, #-1]
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (uint16_t) * pbUsrBuf;
 800a040:	f810 3c02 	ldrb.w	r3, [r0, #-2]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a044:	3a01      	subs	r2, #1
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 800a046:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
    *pdwVal++ = temp2;
 800a04a:	f821 3c04 	strh.w	r3, [r1, #-4]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a04e:	3002      	adds	r0, #2
 800a050:	3104      	adds	r1, #4
 800a052:	2a00      	cmp	r2, #0
 800a054:	d1f2      	bne.n	800a03c <UserToPMABufferCopy+0x10>
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
    pdwVal++;
    pbUsrBuf++;
  }
}
 800a056:	4770      	bx	lr

0800a058 <PMAToUserBufferCopy>:
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 800a058:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
 800a05c:	3201      	adds	r2, #1
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 800a05e:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 800a062:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 800a064:	0852      	lsrs	r2, r2, #1
 800a066:	e004      	b.n	800a072 <PMAToUserBufferCopy+0x1a>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 800a068:	f851 3b04 	ldr.w	r3, [r1], #4
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a06c:	3a01      	subs	r2, #1
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 800a06e:	f820 3b02 	strh.w	r3, [r0], #2
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a072:	2a00      	cmp	r2, #0
 800a074:	d1f8      	bne.n	800a068 <PMAToUserBufferCopy+0x10>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
    pbUsrBuf++;
  }
}
 800a076:	4770      	bx	lr

0800a078 <SetBTABLE>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetBTABLE(uint16_t wRegValue)
{
  _SetBTABLE(wRegValue);
 800a078:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 800a07c:	4a02      	ldr	r2, [pc, #8]	; (800a088 <SetBTABLE+0x10>)
 800a07e:	ea00 0303 	and.w	r3, r0, r3
 800a082:	6013      	str	r3, [r2, #0]
}
 800a084:	4770      	bx	lr
 800a086:	bf00      	nop
 800a088:	40005c50 	.word	0x40005c50

0800a08c <SetEPType>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPType(uint8_t bEpNum, uint16_t wType)
{
  _SetEPType(bEpNum, wType);
 800a08c:	0080      	lsls	r0, r0, #2
 800a08e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a092:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a096:	6803      	ldr	r3, [r0, #0]
 800a098:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 800a09c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a0a0:	ea43 0101 	orr.w	r1, r3, r1
 800a0a4:	b289      	uxth	r1, r1
 800a0a6:	6001      	str	r1, [r0, #0]
}
 800a0a8:	4770      	bx	lr

0800a0aa <GetEPType>:
* Output         : None.
* Return         : Endpoint Type
*******************************************************************************/
uint16_t GetEPType(uint8_t bEpNum)
{
  return(_GetEPType(bEpNum));
 800a0aa:	0080      	lsls	r0, r0, #2
 800a0ac:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a0b0:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a0b4:	6800      	ldr	r0, [r0, #0]
 800a0b6:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
}
 800a0ba:	4770      	bx	lr

0800a0bc <SetEPTxStatus>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(uint8_t bEpNum, uint16_t wState)
{
  _SetEPTxStatus(bEpNum, wState);
 800a0bc:	0080      	lsls	r0, r0, #2
 800a0be:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a0c2:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a0c6:	6802      	ldr	r2, [r0, #0]
 800a0c8:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 800a0cc:	ea02 0303 	and.w	r3, r2, r3
 800a0d0:	f001 0210 	and.w	r2, r1, #16
 800a0d4:	b292      	uxth	r2, r2
 800a0d6:	b10a      	cbz	r2, 800a0dc <SetEPTxStatus+0x20>
 800a0d8:	f083 0310 	eor.w	r3, r3, #16
 800a0dc:	f001 0120 	and.w	r1, r1, #32
 800a0e0:	b289      	uxth	r1, r1
 800a0e2:	b109      	cbz	r1, 800a0e8 <SetEPTxStatus+0x2c>
 800a0e4:	f083 0320 	eor.w	r3, r3, #32
 800a0e8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a0ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a0f0:	6003      	str	r3, [r0, #0]
}
 800a0f2:	4770      	bx	lr

0800a0f4 <SetEPTxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxValid(uint8_t bEpNum)
{
  _SetEPTxStatus(bEpNum, EP_TX_VALID);
 800a0f4:	0080      	lsls	r0, r0, #2
 800a0f6:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a0fa:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a0fe:	6802      	ldr	r2, [r0, #0]
 800a100:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 800a104:	ea02 0303 	and.w	r3, r2, r3
 800a108:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 800a10c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a110:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a114:	6003      	str	r3, [r0, #0]
}
 800a116:	4770      	bx	lr

0800a118 <SetEPRxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(uint8_t bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
 800a118:	0080      	lsls	r0, r0, #2
 800a11a:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a11e:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a122:	6802      	ldr	r2, [r0, #0]
 800a124:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 800a128:	ea02 0303 	and.w	r3, r2, r3
 800a12c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800a130:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a134:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a138:	6003      	str	r3, [r0, #0]
}
 800a13a:	4770      	bx	lr

0800a13c <Clear_Status_Out>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(uint8_t bEpNum)
{
  _ClearEP_KIND(bEpNum);
 800a13c:	0080      	lsls	r0, r0, #2
 800a13e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a142:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a146:	6802      	ldr	r2, [r0, #0]
 800a148:	f640 630f 	movw	r3, #3599	; 0xe0f
 800a14c:	ea02 0303 	and.w	r3, r2, r3
 800a150:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a154:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a158:	6003      	str	r3, [r0, #0]
}
 800a15a:	4770      	bx	lr

0800a15c <ClearDTOG_RX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(uint8_t bEpNum)
{
  _ClearDTOG_RX(bEpNum);
 800a15c:	0080      	lsls	r0, r0, #2
 800a15e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a162:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a166:	6803      	ldr	r3, [r0, #0]
 800a168:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 800a16c:	d009      	beq.n	800a182 <ClearDTOG_RX+0x26>
 800a16e:	6802      	ldr	r2, [r0, #0]
 800a170:	f640 730f 	movw	r3, #3855	; 0xf0f
 800a174:	ea02 0303 	and.w	r3, r2, r3
 800a178:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800a17c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a180:	6003      	str	r3, [r0, #0]
}
 800a182:	4770      	bx	lr

0800a184 <ClearDTOG_TX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(uint8_t bEpNum)
{
  _ClearDTOG_TX(bEpNum);
 800a184:	0080      	lsls	r0, r0, #2
 800a186:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a18a:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a18e:	6803      	ldr	r3, [r0, #0]
 800a190:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a194:	d009      	beq.n	800a1aa <ClearDTOG_TX+0x26>
 800a196:	6802      	ldr	r2, [r0, #0]
 800a198:	f640 730f 	movw	r3, #3855	; 0xf0f
 800a19c:	ea02 0303 	and.w	r3, r2, r3
 800a1a0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a1a4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800a1a8:	6003      	str	r3, [r0, #0]
}
 800a1aa:	4770      	bx	lr

0800a1ac <SetEPTxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPTxAddr(bEpNum, wAddr);
 800a1ac:	4b06      	ldr	r3, [pc, #24]	; (800a1c8 <SetEPTxAddr+0x1c>)
 800a1ae:	0849      	lsrs	r1, r1, #1
 800a1b0:	681b      	ldr	r3, [r3, #0]
 800a1b2:	0049      	lsls	r1, r1, #1
 800a1b4:	b29b      	uxth	r3, r3
 800a1b6:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a1ba:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
 800a1be:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
 800a1c2:	0040      	lsls	r0, r0, #1
 800a1c4:	6001      	str	r1, [r0, #0]
}
 800a1c6:	4770      	bx	lr
 800a1c8:	40005c50 	.word	0x40005c50

0800a1cc <SetEPRxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPRxAddr(bEpNum, wAddr);
 800a1cc:	4b05      	ldr	r3, [pc, #20]	; (800a1e4 <SetEPRxAddr+0x18>)
 800a1ce:	0849      	lsrs	r1, r1, #1
 800a1d0:	681b      	ldr	r3, [r3, #0]
 800a1d2:	0049      	lsls	r1, r1, #1
 800a1d4:	b29b      	uxth	r3, r3
 800a1d6:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a1da:	4b03      	ldr	r3, [pc, #12]	; (800a1e8 <SetEPRxAddr+0x1c>)
 800a1dc:	18c3      	adds	r3, r0, r3
 800a1de:	005b      	lsls	r3, r3, #1
 800a1e0:	6019      	str	r1, [r3, #0]
}
 800a1e2:	4770      	bx	lr
 800a1e4:	40005c50 	.word	0x40005c50
 800a1e8:	20003004 	.word	0x20003004

0800a1ec <GetEPTxAddr>:
* Output         : None.
* Return         : Rx buffer address. 
*******************************************************************************/
uint16_t GetEPTxAddr(uint8_t bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
 800a1ec:	4b05      	ldr	r3, [pc, #20]	; (800a204 <GetEPTxAddr+0x18>)
 800a1ee:	681b      	ldr	r3, [r3, #0]
 800a1f0:	b29b      	uxth	r3, r3
 800a1f2:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800a1f6:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800a1fa:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800a1fe:	005b      	lsls	r3, r3, #1
 800a200:	8818      	ldrh	r0, [r3, #0]
}
 800a202:	4770      	bx	lr
 800a204:	40005c50 	.word	0x40005c50

0800a208 <GetEPRxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
uint16_t GetEPRxAddr(uint8_t bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
 800a208:	4b04      	ldr	r3, [pc, #16]	; (800a21c <GetEPRxAddr+0x14>)
 800a20a:	681b      	ldr	r3, [r3, #0]
 800a20c:	b29b      	uxth	r3, r3
 800a20e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a212:	4b03      	ldr	r3, [pc, #12]	; (800a220 <GetEPRxAddr+0x18>)
 800a214:	18c3      	adds	r3, r0, r3
 800a216:	005b      	lsls	r3, r3, #1
 800a218:	8818      	ldrh	r0, [r3, #0]
}
 800a21a:	4770      	bx	lr
 800a21c:	40005c50 	.word	0x40005c50
 800a220:	20003004 	.word	0x20003004

0800a224 <SetEPTxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPTxCount(bEpNum, wCount);
 800a224:	4b04      	ldr	r3, [pc, #16]	; (800a238 <SetEPTxCount+0x14>)
 800a226:	681b      	ldr	r3, [r3, #0]
 800a228:	b29b      	uxth	r3, r3
 800a22a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a22e:	4b03      	ldr	r3, [pc, #12]	; (800a23c <SetEPTxCount+0x18>)
 800a230:	18c3      	adds	r3, r0, r3
 800a232:	005b      	lsls	r3, r3, #1
 800a234:	6019      	str	r1, [r3, #0]
}
 800a236:	4770      	bx	lr
 800a238:	40005c50 	.word	0x40005c50
 800a23c:	20003002 	.word	0x20003002

0800a240 <SetEPRxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPRxCount(bEpNum, wCount);
 800a240:	4b0d      	ldr	r3, [pc, #52]	; (800a278 <SetEPRxCount+0x38>)
 800a242:	681a      	ldr	r2, [r3, #0]
 800a244:	4b0d      	ldr	r3, [pc, #52]	; (800a27c <SetEPRxCount+0x3c>)
 800a246:	b292      	uxth	r2, r2
 800a248:	18d3      	adds	r3, r2, r3
 800a24a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a24e:	0040      	lsls	r0, r0, #1
 800a250:	293e      	cmp	r1, #62	; 0x3e
 800a252:	d909      	bls.n	800a268 <SetEPRxCount+0x28>
 800a254:	094b      	lsrs	r3, r1, #5
 800a256:	f011 0f1f 	tst.w	r1, #31
 800a25a:	d101      	bne.n	800a260 <SetEPRxCount+0x20>
 800a25c:	3b01      	subs	r3, #1
 800a25e:	b29b      	uxth	r3, r3
 800a260:	029b      	lsls	r3, r3, #10
 800a262:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a266:	e005      	b.n	800a274 <SetEPRxCount+0x34>
 800a268:	084b      	lsrs	r3, r1, #1
 800a26a:	f011 0f01 	tst.w	r1, #1
 800a26e:	bf18      	it	ne
 800a270:	3301      	addne	r3, #1
 800a272:	029b      	lsls	r3, r3, #10
 800a274:	6003      	str	r3, [r0, #0]
}
 800a276:	4770      	bx	lr
 800a278:	40005c50 	.word	0x40005c50
 800a27c:	20003006 	.word	0x20003006

0800a280 <GetEPRxCount>:
* Output         : None.
* Return         : Rx count value.
*******************************************************************************/
uint16_t GetEPRxCount(uint8_t bEpNum)
{
  return(_GetEPRxCount(bEpNum));
 800a280:	4b05      	ldr	r3, [pc, #20]	; (800a298 <GetEPRxCount+0x18>)
 800a282:	681b      	ldr	r3, [r3, #0]
 800a284:	b29b      	uxth	r3, r3
 800a286:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a28a:	4b04      	ldr	r3, [pc, #16]	; (800a29c <GetEPRxCount+0x1c>)
 800a28c:	18c3      	adds	r3, r0, r3
 800a28e:	005b      	lsls	r3, r3, #1
 800a290:	6818      	ldr	r0, [r3, #0]
 800a292:	0580      	lsls	r0, r0, #22
 800a294:	0d80      	lsrs	r0, r0, #22
}
 800a296:	4770      	bx	lr
 800a298:	40005c50 	.word	0x40005c50
 800a29c:	20003006 	.word	0x20003006

0800a2a0 <ByteSwap>:
uint16_t ByteSwap(uint16_t wSwW)
{
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
 800a2a0:	b2c3      	uxtb	r3, r0
 800a2a2:	0a00      	lsrs	r0, r0, #8
* Input          : wSwW: word to Swap.
* Output         : None.
* Return         : resulted word.
*******************************************************************************/
uint16_t ByteSwap(uint16_t wSwW)
{
 800a2a4:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
  return(wRet);
}
 800a2a8:	4770      	bx	lr
	...

0800a2ac <APP_LCD_Data>:
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 800a2ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a2ae:	4c16      	ldr	r4, [pc, #88]	; (800a308 <APP_LCD_Data+0x5c>)
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 800a2b0:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a2b2:	7820      	ldrb	r0, [r4, #0]
 800a2b4:	2501      	movs	r5, #1
 800a2b6:	fa15 f200 	lsls.w	r2, r5, r0
 800a2ba:	4e14      	ldr	r6, [pc, #80]	; (800a30c <APP_LCD_Data+0x60>)
 800a2bc:	6833      	ldr	r3, [r6, #0]
 800a2be:	421a      	tst	r2, r3
    return -1;
 800a2c0:	bf08      	it	eq
 800a2c2:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a2c6:	d01d      	beq.n	800a304 <APP_LCD_Data+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 800a2c8:	f640 11c4 	movw	r1, #2500	; 0x9c4
 800a2cc:	f7fd f8bc 	bl	8007448 <MIOS32_BOARD_J15_PollUnbusy>
 800a2d0:	2800      	cmp	r0, #0
 800a2d2:	da08      	bge.n	800a2e6 <APP_LCD_Data+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a2d4:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 800a2d6:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a2da:	409d      	lsls	r5, r3
 800a2dc:	6833      	ldr	r3, [r6, #0]
 800a2de:	ea23 0505 	bic.w	r5, r3, r5
 800a2e2:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 800a2e4:	e00e      	b.n	800a304 <APP_LCD_Data+0x58>
  }

  // write data
  MIOS32_BOARD_J15_DataSet(data);
 800a2e6:	4638      	mov	r0, r7
 800a2e8:	f7fd f81c 	bl	8007324 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(1);
 800a2ec:	4628      	mov	r0, r5
 800a2ee:	f7fd f879 	bl	80073e4 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a2f2:	4629      	mov	r1, r5
 800a2f4:	7820      	ldrb	r0, [r4, #0]
 800a2f6:	f7fd f88d 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a2fa:	7820      	ldrb	r0, [r4, #0]
 800a2fc:	2100      	movs	r1, #0
 800a2fe:	f7fd f889 	bl	8007414 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 800a302:	2000      	movs	r0, #0
}
 800a304:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a306:	bf00      	nop
 800a308:	200007af 	.word	0x200007af
 800a30c:	20000c20 	.word	0x20000c20

0800a310 <APP_LCD_Cmd>:
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 800a310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a312:	4c16      	ldr	r4, [pc, #88]	; (800a36c <APP_LCD_Cmd+0x5c>)
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 800a314:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a316:	7820      	ldrb	r0, [r4, #0]
 800a318:	2501      	movs	r5, #1
 800a31a:	fa15 f200 	lsls.w	r2, r5, r0
 800a31e:	4e14      	ldr	r6, [pc, #80]	; (800a370 <APP_LCD_Cmd+0x60>)
 800a320:	6833      	ldr	r3, [r6, #0]
 800a322:	421a      	tst	r2, r3
    return -1;
 800a324:	bf08      	it	eq
 800a326:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a32a:	d01d      	beq.n	800a368 <APP_LCD_Cmd+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 800a32c:	f640 11c4 	movw	r1, #2500	; 0x9c4
 800a330:	f7fd f88a 	bl	8007448 <MIOS32_BOARD_J15_PollUnbusy>
 800a334:	2800      	cmp	r0, #0
 800a336:	da08      	bge.n	800a34a <APP_LCD_Cmd+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a338:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 800a33a:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a33e:	409d      	lsls	r5, r3
 800a340:	6833      	ldr	r3, [r6, #0]
 800a342:	ea23 0505 	bic.w	r5, r3, r5
 800a346:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 800a348:	e00e      	b.n	800a368 <APP_LCD_Cmd+0x58>
  }

  // write command
  MIOS32_BOARD_J15_DataSet(cmd);
 800a34a:	4638      	mov	r0, r7
 800a34c:	f7fc ffea 	bl	8007324 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 800a350:	2000      	movs	r0, #0
 800a352:	f7fd f847 	bl	80073e4 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a356:	4629      	mov	r1, r5
 800a358:	7820      	ldrb	r0, [r4, #0]
 800a35a:	f7fd f85b 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a35e:	7820      	ldrb	r0, [r4, #0]
 800a360:	2100      	movs	r1, #0
 800a362:	f7fd f857 	bl	8007414 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 800a366:	2000      	movs	r0, #0
}
 800a368:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a36a:	bf00      	nop
 800a36c:	200007af 	.word	0x200007af
 800a370:	20000c20 	.word	0x20000c20

0800a374 <APP_LCD_Init>:
// Initializes application specific LCD driver
// IN: <mode>: optional configuration
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
 800a374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a376:	4606      	mov	r6, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800a378:	f04f 30ff 	mov.w	r0, #4294967295
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 800a37c:	2e00      	cmp	r6, #0
 800a37e:	d15b      	bne.n	800a438 <APP_LCD_Init+0xc4>
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 800a380:	2001      	movs	r0, #1
 800a382:	f7fc ff6b 	bl	800725c <MIOS32_BOARD_J15_PortInit>
 800a386:	2800      	cmp	r0, #0
    return -2; // failed to initialize J15
 800a388:	bfb8      	it	lt
 800a38a:	f06f 0001 	mvnlt.w	r0, #1
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 800a38e:	db53      	blt.n	800a438 <APP_LCD_Init+0xc4>
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 800a390:	4c2a      	ldr	r4, [pc, #168]	; (800a43c <APP_LCD_Init+0xc8>)
 800a392:	2501      	movs	r5, #1
 800a394:	7823      	ldrb	r3, [r4, #0]
 800a396:	4f2a      	ldr	r7, [pc, #168]	; (800a440 <APP_LCD_Init+0xcc>)
 800a398:	fa15 f303 	lsls.w	r3, r5, r3
 800a39c:	683a      	ldr	r2, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 800a39e:	2038      	movs	r0, #56	; 0x38

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 800a3a0:	4313      	orrs	r3, r2
 800a3a2:	603b      	str	r3, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 800a3a4:	f7fc ffbe 	bl	8007324 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 800a3a8:	4630      	mov	r0, r6
 800a3aa:	f7fd f81b 	bl	80073e4 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a3ae:	4629      	mov	r1, r5
 800a3b0:	7820      	ldrb	r0, [r4, #0]
 800a3b2:	f7fd f82f 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a3b6:	4631      	mov	r1, r6
 800a3b8:	7820      	ldrb	r0, [r4, #0]
 800a3ba:	f7fd f82b 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_RW_Set(0);
 800a3be:	4630      	mov	r0, r6
 800a3c0:	f7fd f81c 	bl	80073fc <MIOS32_BOARD_J15_RW_Set>
#ifdef MIOS32_DONT_USE_DELAY
  u32 delay;
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a3c4:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a3c8:	f7fd f8d0 	bl	800756c <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a3cc:	4629      	mov	r1, r5
 800a3ce:	7820      	ldrb	r0, [r4, #0]
 800a3d0:	f7fd f820 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a3d4:	4631      	mov	r1, r6
 800a3d6:	7820      	ldrb	r0, [r4, #0]
 800a3d8:	f7fd f81c 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a3dc:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a3e0:	f7fd f8c4 	bl	800756c <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a3e4:	4629      	mov	r1, r5
 800a3e6:	7820      	ldrb	r0, [r4, #0]
 800a3e8:	f7fd f814 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a3ec:	4631      	mov	r1, r6
 800a3ee:	7820      	ldrb	r0, [r4, #0]
 800a3f0:	f7fd f810 	bl	8007414 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a3f4:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a3f8:	f7fd f8b8 	bl	800756c <MIOS32_DELAY_Wait_uS>
#endif

  APP_LCD_Cmd(0x08); // Display Off
 800a3fc:	2008      	movs	r0, #8
 800a3fe:	f7ff ff87 	bl	800a310 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // Display On
 800a402:	200c      	movs	r0, #12
 800a404:	f7ff ff84 	bl	800a310 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x06); // Entry Mode
 800a408:	2006      	movs	r0, #6
 800a40a:	f7ff ff81 	bl	800a310 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x01); // Clear Display
 800a40e:	4628      	mov	r0, r5
 800a410:	f7ff ff7e 	bl	800a310 <APP_LCD_Cmd>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a414:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a418:	f7fd f8a8 	bl	800756c <MIOS32_DELAY_Wait_uS>
  // modify cursor mapping, so that it complies with 3-line dog displays
  u8 cursor_map[] = {0x00, 0x10, 0x20, 0x30}; // offset line 0/1/2/3
  MIOS32_LCD_CursorMapSet(cursor_map);
#endif

  APP_LCD_Cmd(0x38); // experience from PIC based MIOS: without these lines
 800a41c:	2038      	movs	r0, #56	; 0x38
 800a41e:	f7ff ff77 	bl	800a310 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // the LCD won't work correctly after a second APP_LCD_Init
 800a422:	200c      	movs	r0, #12
 800a424:	f7ff ff74 	bl	800a310 <APP_LCD_Cmd>

  return (display_available & (1 << mios32_lcd_device)) ? 0 : -1; // return -1 if display not available
 800a428:	7823      	ldrb	r3, [r4, #0]
 800a42a:	409d      	lsls	r5, r3
 800a42c:	683b      	ldr	r3, [r7, #0]
 800a42e:	421d      	tst	r5, r3
 800a430:	bf0c      	ite	eq
 800a432:	f04f 30ff 	moveq.w	r0, #4294967295
 800a436:	2000      	movne	r0, #0
}
 800a438:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a43a:	bf00      	nop
 800a43c:	200007af 	.word	0x200007af
 800a440:	20000c20 	.word	0x20000c20

0800a444 <APP_LCD_Clear>:
// Clear Screen
// IN: -
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Clear(void)
{
 800a444:	b508      	push	{r3, lr}
  // -> send clear command
  return APP_LCD_Cmd(0x01);
 800a446:	2001      	movs	r0, #1
 800a448:	f7ff ff62 	bl	800a310 <APP_LCD_Cmd>
}
 800a44c:	bd08      	pop	{r3, pc}
	...

0800a450 <APP_LCD_CursorSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 800a450:	2903      	cmp	r1, #3
// Sets cursor to given position
// IN: <column> and <line>
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
 800a452:	b508      	push	{r3, lr}
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
    return -1;
 800a454:	bf88      	it	hi
 800a456:	f04f 30ff 	movhi.w	r0, #4294967295
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 800a45a:	d807      	bhi.n	800a46c <APP_LCD_CursorSet+0x1c>
    return -1;

  // -> set cursor address
  return APP_LCD_Cmd(0x80 | (mios32_lcd_cursor_map[line] + column));
 800a45c:	4b04      	ldr	r3, [pc, #16]	; (800a470 <APP_LCD_CursorSet+0x20>)
 800a45e:	5c5b      	ldrb	r3, [r3, r1]
 800a460:	1818      	adds	r0, r3, r0
 800a462:	f060 007f 	orn	r0, r0, #127	; 0x7f
 800a466:	b2c0      	uxtb	r0, r0
 800a468:	f7ff ff52 	bl	800a310 <APP_LCD_Cmd>
}
 800a46c:	bd08      	pop	{r3, pc}
 800a46e:	bf00      	nop
 800a470:	20003788 	.word	0x20003788

0800a474 <APP_LCD_GCursorSet>:
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_GCursorSet(u16 x, u16 y)
{
  // n.a.
  return -1;
}
 800a474:	f04f 30ff 	mov.w	r0, #4294967295
 800a478:	4770      	bx	lr

0800a47a <APP_LCD_BColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BColourSet(u32 rgb)
{
  return -1; // n.a.
}
 800a47a:	f04f 30ff 	mov.w	r0, #4294967295
 800a47e:	4770      	bx	lr

0800a480 <APP_LCD_FColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_FColourSet(u32 rgb)
{
  return -1; // n.a.
}
 800a480:	f04f 30ff 	mov.w	r0, #4294967295
 800a484:	4770      	bx	lr

0800a486 <APP_LCD_BitmapPrint>:
// Transfers a Bitmap within given boundaries to the LCD
// IN: bitmap
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BitmapPrint(mios32_lcd_bitmap_t bitmap)
{
 800a486:	b084      	sub	sp, #16
 800a488:	ab01      	add	r3, sp, #4
 800a48a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  return -1; // n.a.
}
 800a48e:	f04f 30ff 	mov.w	r0, #4294967295
 800a492:	b004      	add	sp, #16
 800a494:	4770      	bx	lr
	...

0800a498 <__libc_init_array>:
 800a498:	b570      	push	{r4, r5, r6, lr}
 800a49a:	4d0d      	ldr	r5, [pc, #52]	; (800a4d0 <__libc_init_array+0x38>)
 800a49c:	4e0d      	ldr	r6, [pc, #52]	; (800a4d4 <__libc_init_array+0x3c>)
 800a49e:	2400      	movs	r4, #0
 800a4a0:	1b76      	subs	r6, r6, r5
 800a4a2:	10b6      	asrs	r6, r6, #2
 800a4a4:	e003      	b.n	800a4ae <__libc_init_array+0x16>
 800a4a6:	f855 3b04 	ldr.w	r3, [r5], #4
 800a4aa:	4798      	blx	r3
 800a4ac:	3401      	adds	r4, #1
 800a4ae:	42b4      	cmp	r4, r6
 800a4b0:	d3f9      	bcc.n	800a4a6 <__libc_init_array+0xe>
 800a4b2:	4d09      	ldr	r5, [pc, #36]	; (800a4d8 <__libc_init_array+0x40>)
 800a4b4:	4e09      	ldr	r6, [pc, #36]	; (800a4dc <__libc_init_array+0x44>)
 800a4b6:	f7fa febb 	bl	8005230 <_init>
 800a4ba:	1b76      	subs	r6, r6, r5
 800a4bc:	10b6      	asrs	r6, r6, #2
 800a4be:	2400      	movs	r4, #0
 800a4c0:	e003      	b.n	800a4ca <__libc_init_array+0x32>
 800a4c2:	f855 3b04 	ldr.w	r3, [r5], #4
 800a4c6:	4798      	blx	r3
 800a4c8:	3401      	adds	r4, #1
 800a4ca:	42b4      	cmp	r4, r6
 800a4cc:	d3f9      	bcc.n	800a4c2 <__libc_init_array+0x2a>
 800a4ce:	bd70      	pop	{r4, r5, r6, pc}
 800a4d0:	0800b1b0 	.word	0x0800b1b0
 800a4d4:	0800b1b0 	.word	0x0800b1b0
 800a4d8:	0800b1b0 	.word	0x0800b1b0
 800a4dc:	0800b1b0 	.word	0x0800b1b0

0800a4e0 <memcpy>:
 800a4e0:	2300      	movs	r3, #0
 800a4e2:	e005      	b.n	800a4f0 <memcpy+0x10>
 800a4e4:	f811 c003 	ldrb.w	ip, [r1, r3]
 800a4e8:	3a01      	subs	r2, #1
 800a4ea:	f800 c003 	strb.w	ip, [r0, r3]
 800a4ee:	3301      	adds	r3, #1
 800a4f0:	2a00      	cmp	r2, #0
 800a4f2:	d1f7      	bne.n	800a4e4 <memcpy+0x4>
 800a4f4:	4770      	bx	lr

0800a4f6 <memset>:
 800a4f6:	4603      	mov	r3, r0
 800a4f8:	e002      	b.n	800a500 <memset+0xa>
 800a4fa:	f803 1b01 	strb.w	r1, [r3], #1
 800a4fe:	3a01      	subs	r2, #1
 800a500:	2a00      	cmp	r2, #0
 800a502:	d1fa      	bne.n	800a4fa <memset+0x4>
 800a504:	4770      	bx	lr

0800a506 <strcpy>:
 800a506:	2300      	movs	r3, #0
 800a508:	5cca      	ldrb	r2, [r1, r3]
 800a50a:	54c2      	strb	r2, [r0, r3]
 800a50c:	3301      	adds	r3, #1
 800a50e:	2a00      	cmp	r2, #0
 800a510:	d1fa      	bne.n	800a508 <strcpy+0x2>
 800a512:	4770      	bx	lr

0800a514 <strlen>:
 800a514:	4603      	mov	r3, r0
 800a516:	461a      	mov	r2, r3
 800a518:	f813 1b01 	ldrb.w	r1, [r3], #1
 800a51c:	2900      	cmp	r1, #0
 800a51e:	d1fa      	bne.n	800a516 <strlen+0x2>
 800a520:	1a10      	subs	r0, r2, r0
 800a522:	4770      	bx	lr

0800a524 <strncpy>:
 800a524:	b510      	push	{r4, lr}
 800a526:	4684      	mov	ip, r0
 800a528:	e007      	b.n	800a53a <strncpy+0x16>
 800a52a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800a52e:	4663      	mov	r3, ip
 800a530:	f803 4b01 	strb.w	r4, [r3], #1
 800a534:	3a01      	subs	r2, #1
 800a536:	469c      	mov	ip, r3
 800a538:	b12c      	cbz	r4, 800a546 <strncpy+0x22>
 800a53a:	2a00      	cmp	r2, #0
 800a53c:	d1f5      	bne.n	800a52a <strncpy+0x6>
 800a53e:	e004      	b.n	800a54a <strncpy+0x26>
 800a540:	f803 4b01 	strb.w	r4, [r3], #1
 800a544:	3a01      	subs	r2, #1
 800a546:	2a00      	cmp	r2, #0
 800a548:	d1fa      	bne.n	800a540 <strncpy+0x1c>
 800a54a:	bd10      	pop	{r4, pc}
