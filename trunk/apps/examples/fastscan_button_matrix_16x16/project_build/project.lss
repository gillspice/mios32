
project_build/project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .mios32_bsl   00004000  08000000  08000000  00008000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .isr_vector   000001e4  08004000  08004000  0000c000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000063ac  080041e4  080041e4  0000c1e4  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000c78  0800a590  0800a590  00012590  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00000058  20000000  0800b208  00018000  2**3  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00003758  20000058  0800b260  00018058  2**3  ALLOC
  6 ._usrstack    00000100  200037b0  200037b0  00018058  2**0  CONTENTS
  7 .ARM.attributes 00000031  00000000  00000000  00018158  2**0  CONTENTS, READONLY
  8 .comment      00000011  00000000  00000000  00018189  2**0  CONTENTS, READONLY
  9 .debug_aranges 000021c8  00000000  00000000  000181a0  2**3  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00005786  00000000  00000000  0001a368  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0001b8e2  00000000  00000000  0001faee  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000064fe  00000000  00000000  0003b3d0  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000c955  00000000  00000000  000418ce  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00004bbc  00000000  00000000  0004e224  2**2  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00009e81  00000000  00000000  00052de0  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000fb66  00000000  00000000  0005cc61  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubtypes 0000245f  00000000  00000000  0006c7c7  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00002308  00000000  00000000  0006ec26  2**0  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080041e4 <APP_Init>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
{
 80041e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  // initialize all LEDs
  MIOS32_BOARD_LED_Init(0xffffffff);
 80041e6:	f04f 30ff 	mov.w	r0, #4294967295
 80041ea:	f002 ff93 	bl	8007114 <MIOS32_BOARD_LED_Init>
 80041ee:	4b29      	ldr	r3, [pc, #164]	; (8004294 <APP_Init+0xb0>)


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
    din_value[row] = 0xffffffff; // default state: buttons depressed
 80041f0:	f04f 32ff 	mov.w	r2, #4294967295
};

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
 80041f4:	f103 0144 	add.w	r1, r3, #68	; 0x44


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
    din_value[row] = 0xffffffff; // default state: buttons depressed
 80041f8:	f843 2f04 	str.w	r2, [r3, #4]!
  MIOS32_BOARD_LED_Init(0xffffffff);


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
 80041fc:	428b      	cmp	r3, r1
 80041fe:	d1fb      	bne.n	80041f8 <APP_Init+0x14>
 8004200:	4b25      	ldr	r3, [pc, #148]	; (8004298 <APP_Init+0xb4>)
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
    last_timestamp[i] = 0;
 8004202:	2400      	movs	r4, #0
};

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
 8004204:	f503 62c0 	add.w	r2, r3, #1536	; 0x600
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
    last_timestamp[i] = 0;
 8004208:	f843 4f04 	str.w	r4, [r3, #4]!
    din_value[row] = 0xffffffff; // default state: buttons depressed
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
 800420c:	4293      	cmp	r3, r2
 800420e:	d1fb      	bne.n	8004208 <APP_Init+0x24>
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
 8004210:	b2e0      	uxtb	r0, r4
 8004212:	2104      	movs	r1, #4
    last_timestamp[i] = 0;
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
 8004214:	3401      	adds	r4, #1
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
 8004216:	f002 ffb9 	bl	800718c <MIOS32_BOARD_J5_PinInit>
    last_timestamp[i] = 0;
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
 800421a:	2c0c      	cmp	r4, #12
 800421c:	d1f8      	bne.n	8004210 <APP_Init+0x2c>
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
	
  //Initialize pin 7 as an output to be row 17
  MIOS32_BOARD_J5_PinInit(7, MIOS32_BOARD_PIN_MODE_OUTPUT_PP);
 800421e:	2105      	movs	r1, #5
 8004220:	2007      	movs	r0, #7
 8004222:	f002 ffb3 	bl	800718c <MIOS32_BOARD_J5_PinInit>
	
  // initialize keyboard delay values
  keyboard_delay_fastest = INITIAL_KEYBOARD_DELAY_FASTEST;
 8004226:	4b1d      	ldr	r3, [pc, #116]	; (800429c <APP_Init+0xb8>)
 8004228:	2400      	movs	r4, #0
 800422a:	601c      	str	r4, [r3, #0]
  keyboard_delay_slowest = INITIAL_KEYBOARD_DELAY_SLOWEST;
 800422c:	4b1c      	ldr	r3, [pc, #112]	; (80042a0 <APP_Init+0xbc>)
 800422e:	227f      	movs	r2, #127	; 0x7f
 8004230:	601a      	str	r2, [r3, #0]
  
  no_velocity=MIOS32_BOARD_J5_PinGet(1);
 8004232:	2001      	movs	r0, #1
 8004234:	f003 f816 	bl	8007264 <MIOS32_BOARD_J5_PinGet>
 8004238:	4b1a      	ldr	r3, [pc, #104]	; (80042a4 <APP_Init+0xc0>)
 800423a:	4601      	mov	r1, r0
 800423c:	6018      	str	r0, [r3, #0]
  MIOS32_MIDI_SendDebugMessage("no_velocity:%02x",no_velocity);
 800423e:	481a      	ldr	r0, [pc, #104]	; (80042a8 <APP_Init+0xc4>)
 8004240:	f001 fb44 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  
  if (MIOS32_BOARD_J5_PinGet(0)){
 8004244:	4620      	mov	r0, r4
 8004246:	f003 f80d 	bl	8007264 <MIOS32_BOARD_J5_PinGet>
 800424a:	4b18      	ldr	r3, [pc, #96]	; (80042ac <APP_Init+0xc8>)
 800424c:	b150      	cbz	r0, 8004264 <APP_Init+0x80>
	selected_midi_port=0x20;
 800424e:	2220      	movs	r2, #32
 8004250:	601a      	str	r2, [r3, #0]
	MIOS32_LCD_CursorSet(0, 0); // X, Y
 8004252:	4621      	mov	r1, r4
 8004254:	4620      	mov	r0, r4
 8004256:	f001 f911 	bl	800547c <MIOS32_LCD_CursorSet>
    MIOS32_LCD_PrintFormattedString("UART");
 800425a:	4815      	ldr	r0, [pc, #84]	; (80042b0 <APP_Init+0xcc>)
 800425c:	f001 f9d0 	bl	8005600 <MIOS32_LCD_PrintFormattedString>
	MIOS32_MIDI_SendDebugMessage("UART");
 8004260:	4813      	ldr	r0, [pc, #76]	; (80042b0 <APP_Init+0xcc>)
 8004262:	e008      	b.n	8004276 <APP_Init+0x92>
	}
  else {
	selected_midi_port=0x10;
 8004264:	2210      	movs	r2, #16
 8004266:	601a      	str	r2, [r3, #0]
	MIOS32_LCD_CursorSet(0, 0); // X, Y
 8004268:	4601      	mov	r1, r0
 800426a:	f001 f907 	bl	800547c <MIOS32_LCD_CursorSet>
    MIOS32_LCD_PrintFormattedString("USB");
 800426e:	4811      	ldr	r0, [pc, #68]	; (80042b4 <APP_Init+0xd0>)
 8004270:	f001 f9c6 	bl	8005600 <MIOS32_LCD_PrintFormattedString>
	MIOS32_MIDI_SendDebugMessage("USB");
 8004274:	480f      	ldr	r0, [pc, #60]	; (80042b4 <APP_Init+0xd0>)
 8004276:	f001 fb29 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
	}

  // start matrix scan task
  xTaskCreate(TASK_MatrixScan, (signed portCHAR *)"MatrixScan", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_MATRIX_SCAN, NULL);
 800427a:	2302      	movs	r3, #2
 800427c:	9300      	str	r3, [sp, #0]
 800427e:	490e      	ldr	r1, [pc, #56]	; (80042b8 <APP_Init+0xd4>)
 8004280:	2300      	movs	r3, #0
 8004282:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004286:	480d      	ldr	r0, [pc, #52]	; (80042bc <APP_Init+0xd8>)
 8004288:	9301      	str	r3, [sp, #4]
 800428a:	9302      	str	r3, [sp, #8]
 800428c:	9303      	str	r3, [sp, #12]
 800428e:	f000 fb3b 	bl	8004908 <xTaskGenericCreate>
}
 8004292:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8004294:	20000058 	.word	0x20000058
 8004298:	200000a4 	.word	0x200000a4
 800429c:	20000058 	.word	0x20000058
 80042a0:	200000a4 	.word	0x200000a4
 80042a4:	20000c2c 	.word	0x20000c2c
 80042a8:	0800aa90 	.word	0x0800aa90
 80042ac:	20000c28 	.word	0x20000c28
 80042b0:	0800aaa1 	.word	0x0800aaa1
 80042b4:	0800aaa6 	.word	0x0800aaa6
 80042b8:	0800aaaa 	.word	0x0800aaaa
 80042bc:	080044c9 	.word	0x080044c9

080042c0 <APP_Background>:

/////////////////////////////////////////////////////////////////////////////
// This task is running endless in background
/////////////////////////////////////////////////////////////////////////////
void APP_Background(void)
{
 80042c0:	b510      	push	{r4, lr}
  // endless loop
  while( 1 ) {
    // toggle the state of all LEDs (allows to measure the execution speed with a scope)
    MIOS32_BOARD_LED_Set(0xffffffff, ~MIOS32_BOARD_LED_Get());
	
	no_velocity=MIOS32_BOARD_J5_PinGet(1);
 80042c2:	4c06      	ldr	r4, [pc, #24]	; (80042dc <APP_Background+0x1c>)
    old_state[pin] = 1;

  // endless loop
  while( 1 ) {
    // toggle the state of all LEDs (allows to measure the execution speed with a scope)
    MIOS32_BOARD_LED_Set(0xffffffff, ~MIOS32_BOARD_LED_Get());
 80042c4:	f002 ff5a 	bl	800717c <MIOS32_BOARD_LED_Get>
 80042c8:	43c1      	mvns	r1, r0
 80042ca:	f04f 30ff 	mov.w	r0, #4294967295
 80042ce:	f002 ff41 	bl	8007154 <MIOS32_BOARD_LED_Set>
	
	no_velocity=MIOS32_BOARD_J5_PinGet(1);
 80042d2:	2001      	movs	r0, #1
 80042d4:	f002 ffc6 	bl	8007264 <MIOS32_BOARD_J5_PinGet>
 80042d8:	6020      	str	r0, [r4, #0]
 80042da:	e7f3      	b.n	80042c4 <APP_Background+0x4>
 80042dc:	20000c2c 	.word	0x20000c2c

080042e0 <APP_MIDI_NotifyPackage>:
/////////////////////////////////////////////////////////////////////////////
void APP_MIDI_NotifyPackage(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
	
// forward USB0->UART0 and UART0->USB0
  switch( port ) {
 80042e0:	2810      	cmp	r0, #16

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a MIDI package has been received
/////////////////////////////////////////////////////////////////////////////
void APP_MIDI_NotifyPackage(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 80042e2:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80042e4:	4605      	mov	r5, r0
 80042e6:	460c      	mov	r4, r1
	
// forward USB0->UART0 and UART0->USB0
  switch( port ) {
 80042e8:	d002      	beq.n	80042f0 <APP_MIDI_NotifyPackage+0x10>
 80042ea:	2820      	cmp	r0, #32
 80042ec:	d118      	bne.n	8004320 <APP_MIDI_NotifyPackage+0x40>
 80042ee:	e014      	b.n	800431a <APP_MIDI_NotifyPackage+0x3a>
    case 0x10:  MIOS32_MIDI_SendPackage(0x20, midi_package);
 80042f0:	2020      	movs	r0, #32
 80042f2:	f001 f9ed 	bl	80056d0 <MIOS32_MIDI_SendPackage>
				MIOS32_LCD_CursorSet(0, 0); // X, Y
 80042f6:	2000      	movs	r0, #0
 80042f8:	4601      	mov	r1, r0
 80042fa:	f001 f8bf 	bl	800547c <MIOS32_LCD_CursorSet>
				MIOS32_LCD_PrintFormattedString("%02X %X %02X %02X %02X",
 80042fe:	f3c4 4107 	ubfx	r1, r4, #16, #8
 8004302:	f004 020f 	and.w	r2, r4, #15
 8004306:	f3c4 2307 	ubfx	r3, r4, #8, #8
 800430a:	9100      	str	r1, [sp, #0]
 800430c:	0e24      	lsrs	r4, r4, #24
 800430e:	4629      	mov	r1, r5
 8004310:	4804      	ldr	r0, [pc, #16]	; (8004324 <APP_MIDI_NotifyPackage+0x44>)
 8004312:	9401      	str	r4, [sp, #4]
 8004314:	f001 f974 	bl	8005600 <MIOS32_LCD_PrintFormattedString>
					port,
                   midi_package.type,
                   midi_package.evnt0, midi_package.evnt1, midi_package.evnt2);
	break;
 8004318:	e002      	b.n	8004320 <APP_MIDI_NotifyPackage+0x40>
	
    case 0x20: MIOS32_MIDI_SendPackage(0x10,  midi_package); break;
 800431a:	2010      	movs	r0, #16
 800431c:	f001 f9d8 	bl	80056d0 <MIOS32_MIDI_SendPackage>
  }
}
 8004320:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8004322:	bf00      	nop
 8004324:	0800aab5 	.word	0x0800aab5

08004328 <APP_DIN_NotifyToggle>:
// This hook is called when a button has been toggled
// pin_value is 1 when button released, and 0 when button pressed
/////////////////////////////////////////////////////////////////////////////
void APP_DIN_NotifyToggle(u32 pin, u32 pin_value)
{
}
 8004328:	4770      	bx	lr

0800432a <APP_ENC_NotifyChange>:
// incrementer is positive when encoder has been turned clockwise, else
// it is negative
/////////////////////////////////////////////////////////////////////////////
void APP_ENC_NotifyChange(u32 encoder, s32 incrementer)
{
}
 800432a:	4770      	bx	lr

0800432c <APP_AIN_NotifyChange>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a pot has been moved
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
 800432c:	b508      	push	{r3, lr}
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 800432e:	4b06      	ldr	r3, [pc, #24]	; (8004348 <APP_AIN_NotifyChange+0x1c>)

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a pot has been moved
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
 8004330:	4602      	mov	r2, r0
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 8004332:	7818      	ldrb	r0, [r3, #0]
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);
 8004334:	094b      	lsrs	r3, r1, #5
 8004336:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 800433a:	b2d2      	uxtb	r2, r2
 800433c:	b2db      	uxtb	r3, r3
 800433e:	2100      	movs	r1, #0
 8004340:	f001 fa19 	bl	8005776 <MIOS32_MIDI_SendCC>
  u16 value_14bit = pin_value << 2;

  // send Pitch Bender event
  MIOS32_MIDI_SendPitchBend(selected_midi_port, pin, value_14bit);
#endif
}
 8004344:	bd08      	pop	{r3, pc}
 8004346:	bf00      	nop
 8004348:	20000c28 	.word	0x20000c28

0800434c <BUTTON_NotifyToggle>:
// This task is called each mS to scan the button matrix
/////////////////////////////////////////////////////////////////////////////

// will be called on button pin changes (see TASK_BLM_Check)
void BUTTON_NotifyToggle(u8 row, u8 column, u8 pin_value, u32 timestamp)
{
 800434c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800434e:	468c      	mov	ip, r1
 8004350:	b089      	sub	sp, #36	; 0x24
 8004352:	4606      	mov	r6, r0
 8004354:	4617      	mov	r7, r2
 8004356:	9305      	str	r3, [sp, #20]
  // determine pin number based on row/column
  // based on pin map for fadar keyboard provided by Robin (see doc/ directory)
  // tested with utils/test_pinmap.pl

#if DEBUG_VERBOSE_LEVEL >= 3
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d\n",
 8004358:	4662      	mov	r2, ip
 800435a:	484e      	ldr	r0, [pc, #312]	; (8004494 <BUTTON_NotifyToggle+0x148>)
 800435c:	4631      	mov	r1, r6
 800435e:	463b      	mov	r3, r7
 8004360:	f8cd c010 	str.w	ip, [sp, #16]
 8004364:	f001 fab2 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>

  // combine to pin value
//  if( column < 8 ) {
    // left half
//    if( row >= 0 && row <= 0x9 ) {
      pin = (column << 3) | bit3to1;
 8004368:	f8dd c010 	ldr.w	ip, [sp, #16]

  // pin number (counted from 0) consists of:
  //   bit #0 if row -> pin bit #0
  //int bit0 = row & 1;
  //   bit #2..0 of column -> pin bit #3..1
  int bit3to1 = row & 0x7;
 800436c:	f006 0407 	and.w	r4, r6, #7

  // combine to pin value
//  if( column < 8 ) {
    // left half
//    if( row >= 0 && row <= 0x9 ) {
      pin = (column << 3) | bit3to1;
 8004370:	ea44 04cc 	orr.w	r4, r4, ip, lsl #3
 // }

  // following check ensures that we never continue with an unexpected/invalid pin number.
  // e.g. this could address a memory location outside the last_timestamp[] array!
  // print a warning message in this case for analysis purposes
  if( pin < 0 || pin >= KEYBOARD_NUM_PINS ) {
 8004374:	f5b4 7fc0 	cmp.w	r4, #384	; 0x180
#if DEBUG_VERBOSE_LEVEL >= 1
    DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d NOT MAPPED!\n",
 8004378:	bf24      	itt	cs
 800437a:	9400      	strcs	r4, [sp, #0]
 800437c:	4846      	ldrcs	r0, [pc, #280]	; (8004498 <BUTTON_NotifyToggle+0x14c>)
 // }

  // following check ensures that we never continue with an unexpected/invalid pin number.
  // e.g. this could address a memory location outside the last_timestamp[] array!
  // print a warning message in this case for analysis purposes
  if( pin < 0 || pin >= KEYBOARD_NUM_PINS ) {
 800437e:	d246      	bcs.n	800440e <BUTTON_NotifyToggle+0xc2>

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch

  // the note number lookup
  int note_number = note_table[pin];
 8004380:	4b46      	ldr	r3, [pc, #280]	; (800449c <BUTTON_NotifyToggle+0x150>)
#endif
    return;
  }

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch
 8004382:	f3c6 05c0 	ubfx	r5, r6, #3, #1

  // the note number lookup
  int note_number = note_table[pin];
 8004386:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
  //    - send Note On event
  // c) first switch changes from 0->1 (pin_value == 1): 
  //    - send Note Off event (resp. Note On with velocity 0)
  //    - clear captured timestamp (allows to check for valid delay on next transition)

  unsigned key_ix = pin & 0xfffffffe;
 800438a:	f024 0301 	bic.w	r3, r4, #1

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch

  // the note number lookup
  int note_number = note_table[pin];
 800438e:	2a7f      	cmp	r2, #127	; 0x7f
 8004390:	bfa8      	it	ge
 8004392:	227f      	movge	r2, #127	; 0x7f
  unsigned key_ix = pin & 0xfffffffe;
  int delay = -1;
  u8 send_note_on = 0;
  u8 send_note_off = 0;

  if( pin_value == 0 ) {
 8004394:	b9bf      	cbnz	r7, 80043c6 <BUTTON_NotifyToggle+0x7a>
 8004396:	4942      	ldr	r1, [pc, #264]	; (80044a0 <BUTTON_NotifyToggle+0x154>)
    if( second_switch == 0 ) { // first switch
 8004398:	b91d      	cbnz	r5, 80043a2 <BUTTON_NotifyToggle+0x56>
      last_timestamp[key_ix] = timestamp;
 800439a:	9a05      	ldr	r2, [sp, #20]
 800439c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 80043a0:	e031      	b.n	8004406 <BUTTON_NotifyToggle+0xba>
 //     if (no_velocity)
 //      send_note_on = 1;

    } else { // second switch
      if( last_timestamp[key_ix] ) {
 80043a2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80043a6:	2b00      	cmp	r3, #0
 80043a8:	d02d      	beq.n	8004406 <BUTTON_NotifyToggle+0xba>
	delay = timestamp - last_timestamp[key_ix];
 80043aa:	f8dd e014 	ldr.w	lr, [sp, #20]
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
     if (no_velocity)
 80043ae:	483d      	ldr	r0, [pc, #244]	; (80044a4 <BUTTON_NotifyToggle+0x158>)
 //     if (no_velocity)
 //      send_note_on = 1;

    } else { // second switch
      if( last_timestamp[key_ix] ) {
	delay = timestamp - last_timestamp[key_ix];
 80043b0:	ebc3 030e 	rsb	r3, r3, lr
 80043b4:	9306      	str	r3, [sp, #24]
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 80043b6:	493c      	ldr	r1, [pc, #240]	; (80044a8 <BUTTON_NotifyToggle+0x15c>)
 80043b8:	4b3c      	ldr	r3, [pc, #240]	; (80044ac <BUTTON_NotifyToggle+0x160>)
     if (no_velocity)
 80043ba:	6800      	ldr	r0, [r0, #0]
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 80043bc:	681b      	ldr	r3, [r3, #0]
 80043be:	6809      	ldr	r1, [r1, #0]
     if (no_velocity)
 80043c0:	2800      	cmp	r0, #0
 80043c2:	d13b      	bne.n	800443c <BUTTON_NotifyToggle+0xf0>
 80043c4:	e029      	b.n	800441a <BUTTON_NotifyToggle+0xce>
	delay = timestamp - last_timestamp[key_ix];
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
 80043c6:	b9f5      	cbnz	r5, 8004406 <BUTTON_NotifyToggle+0xba>
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, 0x00);
 80043c8:	b2d2      	uxtb	r2, r2
 80043ca:	9206      	str	r2, [sp, #24]
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
      last_timestamp[key_ix] = 0;
 80043cc:	4934      	ldr	r1, [pc, #208]	; (80044a0 <BUTTON_NotifyToggle+0x154>)
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, 0x00);
 80043ce:	4a38      	ldr	r2, [pc, #224]	; (80044b0 <BUTTON_NotifyToggle+0x164>)
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
      last_timestamp[key_ix] = 0;
 80043d0:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, 0x00);
 80043d4:	2020      	movs	r0, #32
 80043d6:	7811      	ldrb	r1, [r2, #0]
 80043d8:	462b      	mov	r3, r5
 80043da:	9a06      	ldr	r2, [sp, #24]
 80043dc:	f8cd c010 	str.w	ip, [sp, #16]
 80043e0:	f001 f9c3 	bl	800576a <MIOS32_MIDI_SendNoteOn>
	MIOS32_MIDI_SendNoteOn(0x10, channel, note_number, 0x00);
 80043e4:	4b32      	ldr	r3, [pc, #200]	; (80044b0 <BUTTON_NotifyToggle+0x164>)
 80043e6:	2010      	movs	r0, #16
 80043e8:	7819      	ldrb	r1, [r3, #0]
 80043ea:	9a06      	ldr	r2, [sp, #24]
 80043ec:	462b      	mov	r3, r5
 80043ee:	f001 f9bc 	bl	800576a <MIOS32_MIDI_SendNoteOn>
	

#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE OFF\n",
 80043f2:	f8dd e014 	ldr.w	lr, [sp, #20]
 80043f6:	9400      	str	r4, [sp, #0]
 80043f8:	f8cd e004 	str.w	lr, [sp, #4]
 80043fc:	482d      	ldr	r0, [pc, #180]	; (80044b4 <BUTTON_NotifyToggle+0x168>)
 80043fe:	4631      	mov	r1, r6
 8004400:	f8dd c010 	ldr.w	ip, [sp, #16]
 8004404:	e004      	b.n	8004410 <BUTTON_NotifyToggle+0xc4>
	      row, column, pin_value, pin, timestamp);
#endif
  } else {
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> IGNORE\n",
 8004406:	9905      	ldr	r1, [sp, #20]
 8004408:	482b      	ldr	r0, [pc, #172]	; (80044b8 <BUTTON_NotifyToggle+0x16c>)
 800440a:	9400      	str	r4, [sp, #0]
 800440c:	9101      	str	r1, [sp, #4]
 800440e:	4631      	mov	r1, r6
 8004410:	4662      	mov	r2, ip
 8004412:	463b      	mov	r3, r7
 8004414:	f001 fa5a 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
 8004418:	e039      	b.n	800448e <BUTTON_NotifyToggle+0x142>
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 800441a:	f8dd e018 	ldr.w	lr, [sp, #24]
 800441e:	257f      	movs	r5, #127	; 0x7f
 8004420:	ebc3 000e 	rsb	r0, r3, lr
 8004424:	4345      	muls	r5, r0
 8004426:	1acb      	subs	r3, r1, r3
 8004428:	fbb5 f5f3 	udiv	r5, r5, r3
 800442c:	f1c5 057f 	rsb	r5, r5, #127	; 0x7f
     if (no_velocity)
       velocity = 127;

    // saturate to ensure that range 1..127 won't be exceeded
    if( velocity < 1 )
 8004430:	2d00      	cmp	r5, #0
 8004432:	dd05      	ble.n	8004440 <BUTTON_NotifyToggle+0xf4>
      velocity = 1;
    if( velocity > 127 )
      velocity = 127;
 8004434:	2d7f      	cmp	r5, #127	; 0x7f
 8004436:	bfa8      	it	ge
 8004438:	257f      	movge	r5, #127	; 0x7f
 800443a:	e002      	b.n	8004442 <BUTTON_NotifyToggle+0xf6>

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
     if (no_velocity)
       velocity = 127;
 800443c:	257f      	movs	r5, #127	; 0x7f
 800443e:	e000      	b.n	8004442 <BUTTON_NotifyToggle+0xf6>

    // saturate to ensure that range 1..127 won't be exceeded
    if( velocity < 1 )
      velocity = 1;
 8004440:	2501      	movs	r5, #1
    if( velocity > 127 )
      velocity = 127;

    last_velocity=velocity_table[velocity];
 8004442:	4b1e      	ldr	r3, [pc, #120]	; (80044bc <BUTTON_NotifyToggle+0x170>)
 8004444:	491e      	ldr	r1, [pc, #120]	; (80044c0 <BUTTON_NotifyToggle+0x174>)
 8004446:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, last_velocity);
 800444a:	4f19      	ldr	r7, [pc, #100]	; (80044b0 <BUTTON_NotifyToggle+0x164>)
    if( velocity < 1 )
      velocity = 1;
    if( velocity > 127 )
      velocity = 127;

    last_velocity=velocity_table[velocity];
 800444c:	600b      	str	r3, [r1, #0]
    MIOS32_MIDI_SendNoteOn(0x20, channel, note_number, last_velocity);
 800444e:	b2d2      	uxtb	r2, r2
 8004450:	7839      	ldrb	r1, [r7, #0]
 8004452:	b2db      	uxtb	r3, r3
 8004454:	2020      	movs	r0, #32
 8004456:	f8cd c010 	str.w	ip, [sp, #16]
 800445a:	9207      	str	r2, [sp, #28]
 800445c:	f001 f985 	bl	800576a <MIOS32_MIDI_SendNoteOn>
	MIOS32_MIDI_SendNoteOn(0x10, channel, note_number, last_velocity);
 8004460:	4a17      	ldr	r2, [pc, #92]	; (80044c0 <BUTTON_NotifyToggle+0x174>)
 8004462:	7839      	ldrb	r1, [r7, #0]
 8004464:	7813      	ldrb	r3, [r2, #0]
 8004466:	2010      	movs	r0, #16
 8004468:	9a07      	ldr	r2, [sp, #28]
 800446a:	f001 f97e 	bl	800576a <MIOS32_MIDI_SendNoteOn>
	
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
 800446e:	9b05      	ldr	r3, [sp, #20]
 8004470:	f8dd c010 	ldr.w	ip, [sp, #16]
 8004474:	f8dd e018 	ldr.w	lr, [sp, #24]
 8004478:	9301      	str	r3, [sp, #4]
 800447a:	4812      	ldr	r0, [pc, #72]	; (80044c4 <BUTTON_NotifyToggle+0x178>)
 800447c:	4631      	mov	r1, r6
 800447e:	4662      	mov	r2, ip
 8004480:	2300      	movs	r3, #0
 8004482:	9400      	str	r4, [sp, #0]
 8004484:	f8cd e008 	str.w	lr, [sp, #8]
 8004488:	9503      	str	r5, [sp, #12]
 800448a:	f001 fa1f 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> IGNORE\n",
	      row, column, pin_value, pin, timestamp);
#endif
  }
}
 800448e:	b009      	add	sp, #36	; 0x24
 8004490:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004492:	bf00      	nop
 8004494:	0800aacc 	.word	0x0800aacc
 8004498:	0800aaf5 	.word	0x0800aaf5
 800449c:	0800a590 	.word	0x0800a590
 80044a0:	200000a8 	.word	0x200000a8
 80044a4:	20000c2c 	.word	0x20000c2c
 80044a8:	200000a4 	.word	0x200000a4
 80044ac:	20000058 	.word	0x20000058
 80044b0:	200000a0 	.word	0x200000a0
 80044b4:	0800ab3d 	.word	0x0800ab3d
 80044b8:	0800ab8a 	.word	0x0800ab8a
 80044bc:	0800a890 	.word	0x0800a890
 80044c0:	20000c24 	.word	0x20000c24
 80044c4:	0800abd5 	.word	0x0800abd5

080044c8 <TASK_MatrixScan>:


static void TASK_MatrixScan(void *pvParameters)
{
 80044c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
	    if( changed & mask ){
		  if (row == 16) {
			channel = channel_table[column - 8];
 80044ca:	4f55      	ldr	r7, [pc, #340]	; (8004620 <TASK_MatrixScan+0x158>)
  }
}


static void TASK_MatrixScan(void *pvParameters)
{
 80044cc:	b08d      	sub	sp, #52	; 0x34
  while( 1 ) {
    // wait for next timesplice (1 mS)
    vTaskDelay(1 / portTICK_RATE_MS);
 80044ce:	2001      	movs	r0, #1
 80044d0:	f000 fc16 	bl	8004d00 <vTaskDelay>

    // determine timestamp (we need it for delay measurements)
    mios32_sys_time_t t = MIOS32_SYS_TimeGet();
 80044d4:	a80a      	add	r0, sp, #40	; 0x28
 80044d6:	f002 f8d1 	bl	800667c <MIOS32_SYS_TimeGet>
    u32 timestamp = 1000*t.seconds + t.fraction_ms;
 80044da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80044dc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80044de:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80044e2:	fb01 3302 	mla	r3, r1, r2, r3
 80044e6:	f04f 35ff 	mov.w	r5, #4294967295
 80044ea:	9308      	str	r3, [sp, #32]
 80044ec:	4e4d      	ldr	r6, [pc, #308]	; (8004624 <TASK_MatrixScan+0x15c>)
    //   - shift selection pattern for *next* row to DOUT registers
    //   - read DIN values of previously selected row
    // since we need to select the first row before the first DIN values are latched, we loop from -1
    // to handle the initial state
    int row;
    for(row=-1; row<MATRIX_NUM_ROWS; ++row) {
 80044ee:	9505      	str	r5, [sp, #20]
 80044f0:	e00e      	b.n	8004510 <TASK_MatrixScan+0x48>
      if( row >= 0 ) { // not required for initial scan
	// latch DIN values
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 80044f2:	2100      	movs	r1, #0
 80044f4:	460a      	mov	r2, r1
 80044f6:	2001      	movs	r0, #1
 80044f8:	f002 f9f0 	bl	80068dc <MIOS32_SPI_RC_PinSet>
	MIOS32_DELAY_Wait_uS(1);
 80044fc:	2001      	movs	r0, #1
 80044fe:	f003 f857 	bl	80075b0 <MIOS32_DELAY_Wait_uS>
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8004502:	2001      	movs	r0, #1
 8004504:	2100      	movs	r1, #0
 8004506:	4602      	mov	r2, r0
 8004508:	f002 f9e8 	bl	80068dc <MIOS32_SPI_RC_PinSet>
 800450c:	3501      	adds	r5, #1
 800450e:	3604      	adds	r6, #4
      }

      // determine selection mask for next row (written into DOUT registers while reading DIN registers)
	  u16 select_row_pattern = ~(1 << (row+1));
 8004510:	9905      	ldr	r1, [sp, #20]
 8004512:	2401      	movs	r4, #1
 8004514:	3101      	adds	r1, #1
 8004516:	fa14 f301 	lsls.w	r3, r4, r1
 800451a:	43db      	mvns	r3, r3
 800451c:	b29b      	uxth	r3, r3
 800451e:	9105      	str	r1, [sp, #20]
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 8004520:	4620      	mov	r0, r4
 8004522:	21ff      	movs	r1, #255	; 0xff
	MIOS32_DELAY_Wait_uS(1);
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
      }

      // determine selection mask for next row (written into DOUT registers while reading DIN registers)
	  u16 select_row_pattern = ~(1 << (row+1));
 8004524:	9304      	str	r3, [sp, #16]
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 8004526:	f002 fa21 	bl	800696c <MIOS32_SPI_TransferByte>
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 800452a:	9a04      	ldr	r2, [sp, #16]
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 800452c:	9006      	str	r0, [sp, #24]
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 800452e:	0a11      	lsrs	r1, r2, #8
 8004530:	4620      	mov	r0, r4
 8004532:	f002 fa1b 	bl	800696c <MIOS32_SPI_TransferByte>
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 8004536:	9b04      	ldr	r3, [sp, #16]
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 8004538:	9007      	str	r0, [sp, #28]
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 800453a:	b2d9      	uxtb	r1, r3
 800453c:	4620      	mov	r0, r4
 800453e:	f002 fa15 	bl	800696c <MIOS32_SPI_TransferByte>

      // latch new DOUT value
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004542:	2100      	movs	r1, #0
 8004544:	460a      	mov	r2, r1
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 8004546:	9004      	str	r0, [sp, #16]

      // latch new DOUT value
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004548:	4620      	mov	r0, r4
 800454a:	f002 f9c7 	bl	80068dc <MIOS32_SPI_RC_PinSet>
      MIOS32_DELAY_Wait_uS(1);
 800454e:	4620      	mov	r0, r4
 8004550:	f003 f82e 	bl	80075b0 <MIOS32_DELAY_Wait_uS>
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8004554:	2100      	movs	r1, #0
 8004556:	4620      	mov	r0, r4
 8004558:	4622      	mov	r2, r4
 800455a:	f002 f9bf 	bl	80068dc <MIOS32_SPI_RC_PinSet>
	  if ( row == 15 ) {MIOS32_BOARD_J5_PinSet(7, 0);}
 800455e:	2d0f      	cmp	r5, #15
 8004560:	d104      	bne.n	800456c <TASK_MatrixScan+0xa4>
 8004562:	2007      	movs	r0, #7
 8004564:	2100      	movs	r1, #0
 8004566:	f002 fe59 	bl	800721c <MIOS32_BOARD_J5_PinSet>
 800456a:	e006      	b.n	800457a <TASK_MatrixScan+0xb2>
	  else {MIOS32_BOARD_J5_PinSet(7, 1);}
 800456c:	2007      	movs	r0, #7
 800456e:	4621      	mov	r1, r4
 8004570:	f002 fe54 	bl	800721c <MIOS32_BOARD_J5_PinSet>

      if( row >= 0 ) {
 8004574:	f1b5 3fff 	cmp.w	r5, #4294967295
 8004578:	d04d      	beq.n	8004616 <TASK_MatrixScan+0x14e>
	// combine read DIN bytes to 24bit value
	u32 din_pattern = 0xff000000 | (din2 << 16) | (din1 << 8) | din0;
 800457a:	9906      	ldr	r1, [sp, #24]
 800457c:	b2cb      	uxtb	r3, r1
 800457e:	9904      	ldr	r1, [sp, #16]
 8004580:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8004584:	b2ca      	uxtb	r2, r1
 8004586:	9907      	ldr	r1, [sp, #28]
 8004588:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800458c:	b2ca      	uxtb	r2, r1
 800458e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

	// check if values have been changed via XOR combination with previously scanned value
	u32 changed = din_pattern ^ din_value[row];
 8004592:	f856 3c04 	ldr.w	r3, [r6, #-4]
	  if ( row == 15 ) {MIOS32_BOARD_J5_PinSet(7, 0);}
	  else {MIOS32_BOARD_J5_PinSet(7, 1);}

      if( row >= 0 ) {
	// combine read DIN bytes to 24bit value
	u32 din_pattern = 0xff000000 | (din2 << 16) | (din1 << 8) | din0;
 8004596:	9204      	str	r2, [sp, #16]

	// check if values have been changed via XOR combination with previously scanned value
	u32 changed = din_pattern ^ din_value[row];
	if( changed ) {
 8004598:	4053      	eors	r3, r2
 800459a:	9306      	str	r3, [sp, #24]
 800459c:	d03b      	beq.n	8004616 <TASK_MatrixScan+0x14e>
	  // store changed value
	  din_value[row] = din_pattern;
 800459e:	f8df c088 	ldr.w	ip, [pc, #136]	; 8004628 <TASK_MatrixScan+0x160>
 80045a2:	f846 2c04 	str.w	r2, [r6, #-4]
			#if DEBUG_VERBOSE_LEVEL >= 1
			DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x,  pin_value=%d, channel=%02x /n",row, column, (din_pattern & mask) ? 1 : 0, channel);
			#endif
			}
		  else {
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);}
 80045a6:	b2ea      	uxtb	r2, r5
 80045a8:	9609      	str	r6, [sp, #36]	; 0x24
	  // store changed value
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
 80045aa:	2400      	movs	r4, #0
			#if DEBUG_VERBOSE_LEVEL >= 1
			DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x,  pin_value=%d, channel=%02x /n",row, column, (din_pattern & mask) ? 1 : 0, channel);
			#endif
			}
		  else {
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);}
 80045ac:	462e      	mov	r6, r5
 80045ae:	9207      	str	r2, [sp, #28]
 80045b0:	4665      	mov	r5, ip
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
 80045b2:	2301      	movs	r3, #1
 80045b4:	fa13 f204 	lsls.w	r2, r3, r4
	    if( changed & mask ){
 80045b8:	9906      	ldr	r1, [sp, #24]
 80045ba:	420a      	tst	r2, r1
 80045bc:	d025      	beq.n	800460a <TASK_MatrixScan+0x142>
 80045be:	9b04      	ldr	r3, [sp, #16]
		  if (row == 16) {
 80045c0:	2e10      	cmp	r6, #16
 80045c2:	ea02 0203 	and.w	r2, r2, r3
 80045c6:	d118      	bne.n	80045fa <TASK_MatrixScan+0x132>
			channel = channel_table[column - 8];
 80045c8:	f855 3c20 	ldr.w	r3, [r5, #-32]
			MIOS32_LCD_CursorSet (0,1);
 80045cc:	2101      	movs	r1, #1
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
	    if( changed & mask ){
		  if (row == 16) {
			channel = channel_table[column - 8];
 80045ce:	603b      	str	r3, [r7, #0]
			MIOS32_LCD_CursorSet (0,1);
 80045d0:	2000      	movs	r0, #0
 80045d2:	9203      	str	r2, [sp, #12]
 80045d4:	f000 ff52 	bl	800547c <MIOS32_LCD_CursorSet>
			MIOS32_LCD_PrintFormattedString("%02d", channel + 1);
 80045d8:	6839      	ldr	r1, [r7, #0]
 80045da:	4814      	ldr	r0, [pc, #80]	; (800462c <TASK_MatrixScan+0x164>)
 80045dc:	3101      	adds	r1, #1
 80045de:	f001 f80f 	bl	8005600 <MIOS32_LCD_PrintFormattedString>
			#if DEBUG_VERBOSE_LEVEL >= 1
			DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x,  pin_value=%d, channel=%02x /n",row, column, (din_pattern & mask) ? 1 : 0, channel);
 80045e2:	9a03      	ldr	r2, [sp, #12]
 80045e4:	4631      	mov	r1, r6
 80045e6:	1e13      	subs	r3, r2, #0
 80045e8:	bf18      	it	ne
 80045ea:	2301      	movne	r3, #1
 80045ec:	683a      	ldr	r2, [r7, #0]
 80045ee:	4810      	ldr	r0, [pc, #64]	; (8004630 <TASK_MatrixScan+0x168>)
 80045f0:	9200      	str	r2, [sp, #0]
 80045f2:	4622      	mov	r2, r4
 80045f4:	f001 f96a 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
 80045f8:	e007      	b.n	800460a <TASK_MatrixScan+0x142>
			#endif
			}
		  else {
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);}
 80045fa:	b2e1      	uxtb	r1, r4
 80045fc:	3a00      	subs	r2, #0
 80045fe:	bf18      	it	ne
 8004600:	2201      	movne	r2, #1
 8004602:	9807      	ldr	r0, [sp, #28]
 8004604:	9b08      	ldr	r3, [sp, #32]
 8004606:	f7ff fea1 	bl	800434c <BUTTON_NotifyToggle>
	  // store changed value
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
 800460a:	3401      	adds	r4, #1
 800460c:	3504      	adds	r5, #4
 800460e:	2c18      	cmp	r4, #24
 8004610:	d1cf      	bne.n	80045b2 <TASK_MatrixScan+0xea>
 8004612:	4635      	mov	r5, r6
 8004614:	9e09      	ldr	r6, [sp, #36]	; 0x24
    //   - shift selection pattern for *next* row to DOUT registers
    //   - read DIN values of previously selected row
    // since we need to select the first row before the first DIN values are latched, we loop from -1
    // to handle the initial state
    int row;
    for(row=-1; row<MATRIX_NUM_ROWS; ++row) {
 8004616:	9905      	ldr	r1, [sp, #20]
 8004618:	2911      	cmp	r1, #17
 800461a:	f47f af6a 	bne.w	80044f2 <TASK_MatrixScan+0x2a>
 800461e:	e756      	b.n	80044ce <TASK_MatrixScan+0x6>
 8004620:	200000a0 	.word	0x200000a0
 8004624:	2000005c 	.word	0x2000005c
 8004628:	0800ac84 	.word	0x0800ac84
 800462c:	0800ac39 	.word	0x0800ac39
 8004630:	0800ac3e 	.word	0x0800ac3e

08004634 <TASK_MIDI_Hooks>:
// MIDI task (separated from TASK_Hooks() to ensure parallel handling of
// MIDI events if a hook in TASK_Hooks() blocks)
/////////////////////////////////////////////////////////////////////////////
#if !defined(MIOS32_DONT_USE_MIDI)
static void TASK_MIDI_Hooks(void *pvParameters)
{
 8004634:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 8004636:	f000 fa61 	bl	8004afc <xTaskGetTickCount>
 800463a:	ac02      	add	r4, sp, #8
 800463c:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8004640:	2101      	movs	r1, #1
 8004642:	4620      	mov	r0, r4
 8004644:	f000 fb84 	bl	8004d50 <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 8004648:	f000 fa58 	bl	8004afc <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 800464c:	9a01      	ldr	r2, [sp, #4]
 800464e:	1f43      	subs	r3, r0, #5
 8004650:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 8004652:	bf38      	it	cc
 8004654:	9001      	strcc	r0, [sp, #4]

    // handle timeout/expire counters and USB packages
    MIOS32_MIDI_Periodic_mS();
 8004656:	f001 fc8f 	bl	8005f78 <MIOS32_MIDI_Periodic_mS>

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 800465a:	4802      	ldr	r0, [pc, #8]	; (8004664 <TASK_MIDI_Hooks+0x30>)
 800465c:	f001 faf2 	bl	8005c44 <MIOS32_MIDI_Receive_Handler>
  }
 8004660:	e7ee      	b.n	8004640 <TASK_MIDI_Hooks+0xc>
 8004662:	bf00      	nop
 8004664:	080042e1 	.word	0x080042e1

08004668 <TASK_Hooks>:

/////////////////////////////////////////////////////////////////////////////
// Remaining application hooks
/////////////////////////////////////////////////////////////////////////////
static void TASK_Hooks(void *pvParameters)
{
 8004668:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 800466a:	f000 fa47 	bl	8004afc <xTaskGetTickCount>
 800466e:	ac02      	add	r4, sp, #8
 8004670:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8004674:	2101      	movs	r1, #1
 8004676:	4620      	mov	r0, r4
 8004678:	f000 fb6a 	bl	8004d50 <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 800467c:	f000 fa3e 	bl	8004afc <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 8004680:	9a01      	ldr	r2, [sp, #4]
 8004682:	1f43      	subs	r3, r0, #5
 8004684:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 8004686:	bf38      	it	cc
 8004688:	9001      	strcc	r0, [sp, #4]

#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
    // check for DIN pin changes, call APP_DIN_NotifyToggle on each toggled pin
    MIOS32_DIN_Handler(APP_DIN_NotifyToggle);
 800468a:	4806      	ldr	r0, [pc, #24]	; (80046a4 <TASK_Hooks+0x3c>)
 800468c:	f000 fe6c 	bl	8005368 <MIOS32_DIN_Handler>

    // check for encoder changes, call APP_ENC_NotifyChanged on each change
# ifndef MIOS32_DONT_USE_ENC
    MIOS32_ENC_Handler(APP_ENC_NotifyChange);
 8004690:	4805      	ldr	r0, [pc, #20]	; (80046a8 <TASK_Hooks+0x40>)
 8004692:	f000 fecd 	bl	8005430 <MIOS32_ENC_Handler>
# endif
#endif

#if !defined(MIOS32_DONT_USE_AIN)
    // check for AIN pin changes, call APP_AIN_NotifyChange on each pin change
    MIOS32_AIN_Handler(APP_AIN_NotifyChange);
 8004696:	4805      	ldr	r0, [pc, #20]	; (80046ac <TASK_Hooks+0x44>)
 8004698:	f003 f8c8 	bl	800782c <MIOS32_AIN_Handler>
#endif

#if !defined(MIOS32_DONT_USE_COM)
    // check for incoming COM messages
    MIOS32_COM_Receive_Handler();
 800469c:	f001 fcf3 	bl	8006086 <MIOS32_COM_Receive_Handler>
#endif
  }
 80046a0:	e7e8      	b.n	8004674 <TASK_Hooks+0xc>
 80046a2:	bf00      	nop
 80046a4:	08004329 	.word	0x08004329
 80046a8:	0800432b 	.word	0x0800432b
 80046ac:	0800432d 	.word	0x0800432d

080046b0 <main>:

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 80046b0:	b530      	push	{r4, r5, lr}
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 80046b2:	2000      	movs	r0, #0

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 80046b4:	b085      	sub	sp, #20
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 80046b6:	f001 ff51 	bl	800655c <MIOS32_SYS_Init>
#endif
#ifndef MIOS32_DONT_USE_DELAY
  MIOS32_DELAY_Init(0);
 80046ba:	2000      	movs	r0, #0
 80046bc:	f002 ff56 	bl	800756c <MIOS32_DELAY_Init>
#endif
#ifndef MIOS32_DONT_USE_BOARD
  MIOS32_BOARD_Init(0);
 80046c0:	2000      	movs	r0, #0
 80046c2:	f002 fd1d 	bl	8007100 <MIOS32_BOARD_Init>
#endif
#ifndef MIOS32_DONT_USE_SPI
  MIOS32_SPI_Init(0);
 80046c6:	2000      	movs	r0, #0
 80046c8:	f002 fc2a 	bl	8006f20 <MIOS32_SPI_Init>
#endif
#ifndef MIOS32_DONT_USE_SRIO
  MIOS32_SRIO_Init(0);
 80046cc:	2000      	movs	r0, #0
 80046ce:	f000 fdd3 	bl	8005278 <MIOS32_SRIO_Init>
#endif
#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DIN_Init(0);
 80046d2:	2000      	movs	r0, #0
 80046d4:	f000 fe1a 	bl	800530c <MIOS32_DIN_Init>
#endif
#if !defined(MIOS32_DONT_USE_DOUT) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DOUT_Init(0);
 80046d8:	2000      	movs	r0, #0
 80046da:	f000 fe6d 	bl	80053b8 <MIOS32_DOUT_Init>
#endif
#if !defined(MIOS32_DONT_USE_ENC) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_ENC_Init(0);
 80046de:	2000      	movs	r0, #0
 80046e0:	f000 fe78 	bl	80053d4 <MIOS32_ENC_Init>
#endif
#if !defined(MIOS32_DONT_USE_MF)
  MIOS32_MF_Init(0);
 80046e4:	2000      	movs	r0, #0
 80046e6:	f001 fe9b 	bl	8006420 <MIOS32_MF_Init>
#endif
#if !defined(MIOS32_DONT_USE_AIN)
  MIOS32_AIN_Init(0);
 80046ea:	2000      	movs	r0, #0
 80046ec:	f002 ff6c 	bl	80075c8 <MIOS32_AIN_Init>
#endif
#ifndef MIOS32_DONT_USE_IIC_BS
  MIOS32_IIC_BS_Init(0);
 80046f0:	2000      	movs	r0, #0
 80046f2:	f001 fe92 	bl	800641a <MIOS32_IIC_BS_Init>
#endif
#ifndef MIOS32_DONT_USE_USB
  MIOS32_USB_Init(0);
 80046f6:	2000      	movs	r0, #0
 80046f8:	f003 faa8 	bl	8007c4c <MIOS32_USB_Init>
#endif
#ifndef MIOS32_DONT_USE_MIDI
  MIOS32_MIDI_Init(0);
 80046fc:	2000      	movs	r0, #0
 80046fe:	f000 ff9b 	bl	8005638 <MIOS32_MIDI_Init>
#endif
#ifndef MIOS32_DONT_USE_OSC
  MIOS32_OSC_Init(0);
 8004702:	2000      	movs	r0, #0
 8004704:	f001 fc86 	bl	8006014 <MIOS32_OSC_Init>
#endif
#ifndef MIOS32_DONT_USE_COM
  MIOS32_COM_Init(0);
 8004708:	2000      	movs	r0, #0
 800470a:	f001 fc89 	bl	8006020 <MIOS32_COM_Init>
#endif
#ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_Init(0);
 800470e:	2000      	movs	r0, #0
 8004710:	f000 feee 	bl	80054f0 <MIOS32_LCD_Init>
#ifdef MIOS32_USE_I2S
  MIOS32_I2S_Init(0);
#endif

  // call C++ constructors
  __libc_init_array();
 8004714:	f005 fee2 	bl	800a4dc <__libc_init_array>

  // initialize application
  APP_Init();
 8004718:	f7ff fd64 	bl	80041e4 <APP_Init>

#if MIOS32_LCD_BOOT_MSG_DELAY
  // print boot message
# ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_PrintBootMessage();
 800471c:	f000 ff50 	bl	80055c0 <MIOS32_LCD_PrintBootMessage>
 8004720:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
    MIOS32_DELAY_Wait_uS(1000);
 8004724:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004728:	f002 ff42 	bl	80075b0 <MIOS32_DELAY_Wait_uS>
# endif

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
 800472c:	f114 34ff 	adds.w	r4, r4, #4294967295
 8004730:	d1f8      	bne.n	8004724 <main+0x74>
    MIOS32_DELAY_Wait_uS(1000);
# endif
#endif

  // start the task which calls the application hooks
  xTaskCreate(TASK_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 8004732:	2503      	movs	r5, #3
 8004734:	4623      	mov	r3, r4
 8004736:	490d      	ldr	r1, [pc, #52]	; (800476c <main+0xbc>)
 8004738:	f44f 7280 	mov.w	r2, #256	; 0x100
 800473c:	480c      	ldr	r0, [pc, #48]	; (8004770 <main+0xc0>)
 800473e:	9500      	str	r5, [sp, #0]
 8004740:	9401      	str	r4, [sp, #4]
 8004742:	9402      	str	r4, [sp, #8]
 8004744:	9403      	str	r4, [sp, #12]
 8004746:	f000 f8df 	bl	8004908 <xTaskGenericCreate>
#if !defined(MIOS32_DONT_USE_MIDI)
  xTaskCreate(TASK_MIDI_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 800474a:	4908      	ldr	r1, [pc, #32]	; (800476c <main+0xbc>)
 800474c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004750:	4623      	mov	r3, r4
 8004752:	4808      	ldr	r0, [pc, #32]	; (8004774 <main+0xc4>)
 8004754:	9500      	str	r5, [sp, #0]
 8004756:	9401      	str	r4, [sp, #4]
 8004758:	9402      	str	r4, [sp, #8]
 800475a:	9403      	str	r4, [sp, #12]
 800475c:	f000 f8d4 	bl	8004908 <xTaskGenericCreate>
#endif

  // start the scheduler
  vTaskStartScheduler();
 8004760:	f000 f9a0 	bl	8004aa4 <vTaskStartScheduler>

  // Will only get here if there was not enough heap space to create the idle task
  return 0;
}
 8004764:	4620      	mov	r0, r4
 8004766:	b005      	add	sp, #20
 8004768:	bd30      	pop	{r4, r5, pc}
 800476a:	bf00      	nop
 800476c:	0800acc4 	.word	0x0800acc4
 8004770:	08004669 	.word	0x08004669
 8004774:	08004635 	.word	0x08004635

08004778 <vApplicationTickHook>:
  APP_SRIO_ServicePrepare();

  // start next SRIO scan - IRQ notification to SRIO_ServiceFinish()
  MIOS32_SRIO_ScanStart(SRIO_ServiceFinish);
#endif
}
 8004778:	4770      	bx	lr

0800477a <vApplicationIdleHook>:

/////////////////////////////////////////////////////////////////////////////
// Idle Hook (called by FreeRTOS when nothing else to do)
/////////////////////////////////////////////////////////////////////////////
void vApplicationIdleHook(void)
{
 800477a:	b508      	push	{r3, lr}
  // branch endless to application
  while( 1 ) {
    APP_Background();
 800477c:	f7ff fda0 	bl	80042c0 <APP_Background>
 8004780:	e7fc      	b.n	800477c <vApplicationIdleHook+0x2>
	...

08004784 <_abort>:
// This function aborts any operations, but keeps MIDI alive (for uploading
// a new firmware)
// If MIDI isn't enabled, the status LED will be flashed
/////////////////////////////////////////////////////////////////////////////
void _abort(void)
{
 8004784:	b570      	push	{r4, r5, r6, lr}
  // stop other tasks from running
  portENTER_CRITICAL();
 8004786:	f000 fbf1 	bl	8004f6c <vPortEnterCritical>

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
 800478a:	2400      	movs	r4, #0
  while( 1 ) {
    ++delay_ctr;

    if( (delay_ctr % 100) == 0 ) {
 800478c:	2664      	movs	r6, #100	; 0x64
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);

    if( (delay_ctr % 10000) == 0 ) {
 800478e:	f242 7510 	movw	r5, #10000	; 0x2710

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
  while( 1 ) {
    ++delay_ctr;
 8004792:	3401      	adds	r4, #1

    if( (delay_ctr % 100) == 0 ) {
 8004794:	fbb4 f3f6 	udiv	r3, r4, r6
 8004798:	fb06 4313 	mls	r3, r6, r3, r4
 800479c:	b90b      	cbnz	r3, 80047a2 <_abort+0x1e>
      // handle timeout/expire counters and USB packages
      MIOS32_MIDI_Periodic_mS();
 800479e:	f001 fbeb 	bl	8005f78 <MIOS32_MIDI_Periodic_mS>
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 80047a2:	4808      	ldr	r0, [pc, #32]	; (80047c4 <_abort+0x40>)
 80047a4:	f001 fa4e 	bl	8005c44 <MIOS32_MIDI_Receive_Handler>

    if( (delay_ctr % 10000) == 0 ) {
 80047a8:	fbb4 f3f5 	udiv	r3, r4, r5
 80047ac:	fb05 4313 	mls	r3, r5, r3, r4
 80047b0:	2b00      	cmp	r3, #0
 80047b2:	d1ee      	bne.n	8004792 <_abort+0xe>
      // toggle board LED
      MIOS32_BOARD_LED_Set(1, ~MIOS32_BOARD_LED_Get());
 80047b4:	f002 fce2 	bl	800717c <MIOS32_BOARD_LED_Get>
 80047b8:	43c1      	mvns	r1, r0
 80047ba:	2001      	movs	r0, #1
 80047bc:	f002 fcca 	bl	8007154 <MIOS32_BOARD_LED_Set>
 80047c0:	e7e7      	b.n	8004792 <_abort+0xe>
 80047c2:	bf00      	nop
 80047c4:	080042e1 	.word	0x080042e1

080047c8 <HardFault_Handler_c>:

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 80047c8:	b510      	push	{r4, lr}
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 80047ca:	6803      	ldr	r3, [r0, #0]

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 80047cc:	b088      	sub	sp, #32
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 80047ce:	9307      	str	r3, [sp, #28]
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 80047d0:	6843      	ldr	r3, [r0, #4]
  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 80047d2:	4c33      	ldr	r4, [pc, #204]	; (80048a0 <HardFault_Handler_c+0xd8>)
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 80047d4:	9306      	str	r3, [sp, #24]
  stacked_r2 = ((unsigned long) hardfault_args[2]);
 80047d6:	6883      	ldr	r3, [r0, #8]
 80047d8:	9305      	str	r3, [sp, #20]
  stacked_r3 = ((unsigned long) hardfault_args[3]);
 80047da:	68c3      	ldr	r3, [r0, #12]
 80047dc:	9304      	str	r3, [sp, #16]

  stacked_r12 = ((unsigned long) hardfault_args[4]);
 80047de:	6903      	ldr	r3, [r0, #16]
 80047e0:	9303      	str	r3, [sp, #12]
  stacked_lr = ((unsigned long) hardfault_args[5]);
 80047e2:	6943      	ldr	r3, [r0, #20]
 80047e4:	9302      	str	r3, [sp, #8]
  stacked_pc = ((unsigned long) hardfault_args[6]);
 80047e6:	6983      	ldr	r3, [r0, #24]
 80047e8:	9301      	str	r3, [sp, #4]
  stacked_psr = ((unsigned long) hardfault_args[7]);
 80047ea:	69c3      	ldr	r3, [r0, #28]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 80047ec:	4620      	mov	r0, r4
  stacked_r3 = ((unsigned long) hardfault_args[3]);

  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
 80047ee:	9300      	str	r3, [sp, #0]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 80047f0:	f001 f86c 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("!!! HARD FAULT !!!\n");
 80047f4:	482b      	ldr	r0, [pc, #172]	; (80048a4 <HardFault_Handler_c+0xdc>)
 80047f6:	f001 f869 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("==================\n");
 80047fa:	4620      	mov	r0, r4
 80047fc:	f001 f866 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R0 = %08x\n", stacked_r0);
 8004800:	9907      	ldr	r1, [sp, #28]
 8004802:	4829      	ldr	r0, [pc, #164]	; (80048a8 <HardFault_Handler_c+0xe0>)
 8004804:	f001 f862 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R1 = %08x\n", stacked_r1);
 8004808:	9906      	ldr	r1, [sp, #24]
 800480a:	4828      	ldr	r0, [pc, #160]	; (80048ac <HardFault_Handler_c+0xe4>)
 800480c:	f001 f85e 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R2 = %08x\n", stacked_r2);
 8004810:	9905      	ldr	r1, [sp, #20]
 8004812:	4827      	ldr	r0, [pc, #156]	; (80048b0 <HardFault_Handler_c+0xe8>)
 8004814:	f001 f85a 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R3 = %08x\n", stacked_r3);
 8004818:	9904      	ldr	r1, [sp, #16]
 800481a:	4826      	ldr	r0, [pc, #152]	; (80048b4 <HardFault_Handler_c+0xec>)
 800481c:	f001 f856 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R12 = %08x\n", stacked_r12);
 8004820:	9903      	ldr	r1, [sp, #12]
 8004822:	4825      	ldr	r0, [pc, #148]	; (80048b8 <HardFault_Handler_c+0xf0>)
 8004824:	f001 f852 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("LR = %08x\n", stacked_lr);
 8004828:	9902      	ldr	r1, [sp, #8]
 800482a:	4824      	ldr	r0, [pc, #144]	; (80048bc <HardFault_Handler_c+0xf4>)
 800482c:	f001 f84e 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PC = %08x\n", stacked_pc);
 8004830:	9901      	ldr	r1, [sp, #4]
 8004832:	4823      	ldr	r0, [pc, #140]	; (80048c0 <HardFault_Handler_c+0xf8>)
 8004834:	f001 f84a 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PSR = %08x\n", stacked_psr);
 8004838:	9900      	ldr	r1, [sp, #0]
 800483a:	4822      	ldr	r0, [pc, #136]	; (80048c4 <HardFault_Handler_c+0xfc>)
 800483c:	f001 f846 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("BFAR = %08x\n", (*((volatile unsigned long *)(0xE000ED38))));
 8004840:	4b21      	ldr	r3, [pc, #132]	; (80048c8 <HardFault_Handler_c+0x100>)
 8004842:	4822      	ldr	r0, [pc, #136]	; (80048cc <HardFault_Handler_c+0x104>)
 8004844:	6819      	ldr	r1, [r3, #0]
 8004846:	f001 f841 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("CFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED28))));
 800484a:	4b21      	ldr	r3, [pc, #132]	; (80048d0 <HardFault_Handler_c+0x108>)
 800484c:	4821      	ldr	r0, [pc, #132]	; (80048d4 <HardFault_Handler_c+0x10c>)
 800484e:	6819      	ldr	r1, [r3, #0]
 8004850:	f001 f83c 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("HFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED2C))));
 8004854:	4b20      	ldr	r3, [pc, #128]	; (80048d8 <HardFault_Handler_c+0x110>)
 8004856:	4821      	ldr	r0, [pc, #132]	; (80048dc <HardFault_Handler_c+0x114>)
 8004858:	6819      	ldr	r1, [r3, #0]
 800485a:	f001 f837 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("DFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED30))));
 800485e:	4b20      	ldr	r3, [pc, #128]	; (80048e0 <HardFault_Handler_c+0x118>)
 8004860:	4820      	ldr	r0, [pc, #128]	; (80048e4 <HardFault_Handler_c+0x11c>)
 8004862:	6819      	ldr	r1, [r3, #0]
 8004864:	f001 f832 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("AFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED3C))));
 8004868:	4b1f      	ldr	r3, [pc, #124]	; (80048e8 <HardFault_Handler_c+0x120>)
 800486a:	4820      	ldr	r0, [pc, #128]	; (80048ec <HardFault_Handler_c+0x124>)
 800486c:	6819      	ldr	r1, [r3, #0]
 800486e:	f001 f82d 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>

#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 8004872:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8004876:	f000 fed6 	bl	8005626 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 800487a:	2000      	movs	r0, #0
 800487c:	f000 fed7 	bl	800562e <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 8004880:	2000      	movs	r0, #0
 8004882:	f000 fdf5 	bl	8005470 <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 8004886:	f000 fe5b 	bl	8005540 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 800488a:	2000      	movs	r0, #0
 800488c:	4601      	mov	r1, r0
 800488e:	f000 fdf5 	bl	800547c <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("!! HARD FAULT !!");
 8004892:	4817      	ldr	r0, [pc, #92]	; (80048f0 <HardFault_Handler_c+0x128>)
 8004894:	f000 fe86 	bl	80055a4 <MIOS32_LCD_PrintString>
#endif

  _abort();
 8004898:	f7ff ff74 	bl	8004784 <_abort>
}
 800489c:	b008      	add	sp, #32
 800489e:	bd10      	pop	{r4, pc}
 80048a0:	0800ad20 	.word	0x0800ad20
 80048a4:	0800ad34 	.word	0x0800ad34
 80048a8:	0800ad48 	.word	0x0800ad48
 80048ac:	0800ad53 	.word	0x0800ad53
 80048b0:	0800ad5e 	.word	0x0800ad5e
 80048b4:	0800ad69 	.word	0x0800ad69
 80048b8:	0800ad74 	.word	0x0800ad74
 80048bc:	0800ad80 	.word	0x0800ad80
 80048c0:	0800ad8b 	.word	0x0800ad8b
 80048c4:	0800ad96 	.word	0x0800ad96
 80048c8:	e000ed38 	.word	0xe000ed38
 80048cc:	0800ada2 	.word	0x0800ada2
 80048d0:	e000ed28 	.word	0xe000ed28
 80048d4:	0800adaf 	.word	0x0800adaf
 80048d8:	e000ed2c 	.word	0xe000ed2c
 80048dc:	0800adbc 	.word	0x0800adbc
 80048e0:	e000ed30 	.word	0xe000ed30
 80048e4:	0800adc9 	.word	0x0800adc9
 80048e8:	e000ed3c 	.word	0xe000ed3c
 80048ec:	0800add6 	.word	0x0800add6
 80048f0:	0800ade3 	.word	0x0800ade3

080048f4 <HardFault_Handler>:


void HardFault_Handler(void)
{
  __asm("TST LR, #4");
 80048f4:	f01e 0f04 	tst.w	lr, #4
  __asm("ITE EQ");
 80048f8:	bf0c      	ite	eq
  __asm("MRSEQ R0, MSP");
 80048fa:	f3ef 8008 	mrseq	r0, MSP
  __asm("MRSNE R0, PSP");
 80048fe:	f3ef 8009 	mrsne	r0, PSP
  __asm("B HardFault_Handler_c");
 8004902:	f7ff bf61 	b.w	80047c8 <HardFault_Handler_c>
}
 8004906:	4770      	bx	lr

08004908 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8004908:	b5f0      	push	{r4, r5, r6, r7, lr}
 800490a:	b085      	sub	sp, #20
 800490c:	9303      	str	r3, [sp, #12]
 800490e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004910:	9002      	str	r0, [sp, #8]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8004912:	2048      	movs	r0, #72	; 0x48
 8004914:	9300      	str	r3, [sp, #0]
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8004916:	460e      	mov	r6, r1
 8004918:	4614      	mov	r4, r2
 800491a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 800491c:	f000 fbfc 	bl	8005118 <pvPortMalloc>

	if( pxNewTCB != NULL )
 8004920:	9b00      	ldr	r3, [sp, #0]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8004922:	4605      	mov	r5, r0

	if( pxNewTCB != NULL )
 8004924:	2800      	cmp	r0, #0
 8004926:	f000 809b 	beq.w	8004a60 <xTaskGenericCreate+0x158>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 800492a:	b91b      	cbnz	r3, 8004934 <xTaskGenericCreate+0x2c>
 800492c:	00a0      	lsls	r0, r4, #2
 800492e:	f000 fbf3 	bl	8005118 <pvPortMalloc>
 8004932:	4603      	mov	r3, r0
 8004934:	632b      	str	r3, [r5, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8004936:	b91b      	cbnz	r3, 8004940 <xTaskGenericCreate+0x38>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8004938:	4628      	mov	r0, r5
 800493a:	f000 fbb7 	bl	80050ac <vPortFree>
 800493e:	e08f      	b.n	8004a60 <xTaskGenericCreate+0x158>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 8004940:	00a2      	lsls	r2, r4, #2
 8004942:	21a5      	movs	r1, #165	; 0xa5
 8004944:	4618      	mov	r0, r3
 8004946:	f005 fdf8 	bl	800a53a <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 800494a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800494c:	3c01      	subs	r4, #1
 800494e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 8004952:	f023 0307 	bic.w	r3, r3, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8004956:	4631      	mov	r1, r6
 8004958:	2210      	movs	r2, #16
 800495a:	f105 0034 	add.w	r0, r5, #52	; 0x34
 800495e:	9300      	str	r3, [sp, #0]
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 8004960:	2400      	movs	r4, #0
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8004962:	f005 fe01 	bl	800a568 <strncpy>
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8004966:	1d2e      	adds	r6, r5, #4
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 8004968:	2f04      	cmp	r7, #4
 800496a:	bf34      	ite	cc
 800496c:	463a      	movcc	r2, r7
 800496e:	2204      	movcs	r2, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
 8004970:	62ea      	str	r2, [r5, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8004972:	646a      	str	r2, [r5, #68]	; 0x44
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 8004974:	f885 4043 	strb.w	r4, [r5, #67]	; 0x43
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8004978:	4630      	mov	r0, r6
 800497a:	9201      	str	r2, [sp, #4]
 800497c:	f000 fa6b 	bl	8004e56 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8004980:	f105 0018 	add.w	r0, r5, #24
 8004984:	f000 fa67 	bl	8004e56 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8004988:	9a01      	ldr	r2, [sp, #4]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800498a:	9b00      	ldr	r3, [sp, #0]
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 800498c:	f1c2 0205 	rsb	r2, r2, #5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004990:	4618      	mov	r0, r3
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8004992:	61aa      	str	r2, [r5, #24]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004994:	9902      	ldr	r1, [sp, #8]
 8004996:	9a03      	ldr	r2, [sp, #12]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8004998:	612d      	str	r5, [r5, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 800499a:	626d      	str	r5, [r5, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800499c:	f000 fa95 	bl	8004eca <pxPortInitialiseStack>
 80049a0:	6028      	str	r0, [r5, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
 80049a2:	f000 fae3 	bl	8004f6c <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 80049a6:	4b31      	ldr	r3, [pc, #196]	; (8004a6c <xTaskGenericCreate+0x164>)
 80049a8:	681a      	ldr	r2, [r3, #0]
 80049aa:	3201      	adds	r2, #1
 80049ac:	601a      	str	r2, [r3, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	2b01      	cmp	r3, #1
 80049b2:	d126      	bne.n	8004a02 <xTaskGenericCreate+0xfa>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 80049b4:	4b2e      	ldr	r3, [pc, #184]	; (8004a70 <xTaskGenericCreate+0x168>)
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80049b6:	4a2f      	ldr	r2, [pc, #188]	; (8004a74 <xTaskGenericCreate+0x16c>)
		{
			uxCurrentNumberOfTasks++;
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 80049b8:	601d      	str	r5, [r3, #0]
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80049ba:	2314      	movs	r3, #20
 80049bc:	fb03 2004 	mla	r0, r3, r4, r2

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 80049c0:	3401      	adds	r4, #1
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80049c2:	9201      	str	r2, [sp, #4]
 80049c4:	9300      	str	r3, [sp, #0]
 80049c6:	f000 fa3b 	bl	8004e40 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 80049ca:	2c05      	cmp	r4, #5
 80049cc:	9a01      	ldr	r2, [sp, #4]
 80049ce:	9b00      	ldr	r3, [sp, #0]
 80049d0:	d1f4      	bne.n	80049bc <xTaskGenericCreate+0xb4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 80049d2:	4b29      	ldr	r3, [pc, #164]	; (8004a78 <xTaskGenericCreate+0x170>)
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 80049d4:	4c29      	ldr	r4, [pc, #164]	; (8004a7c <xTaskGenericCreate+0x174>)
	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 80049d6:	4618      	mov	r0, r3
 80049d8:	9300      	str	r3, [sp, #0]
 80049da:	f000 fa31 	bl	8004e40 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 80049de:	4620      	mov	r0, r4
 80049e0:	f000 fa2e 	bl	8004e40 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 80049e4:	4826      	ldr	r0, [pc, #152]	; (8004a80 <xTaskGenericCreate+0x178>)
 80049e6:	f000 fa2b 	bl	8004e40 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 80049ea:	4826      	ldr	r0, [pc, #152]	; (8004a84 <xTaskGenericCreate+0x17c>)
 80049ec:	f000 fa28 	bl	8004e40 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 80049f0:	4825      	ldr	r0, [pc, #148]	; (8004a88 <xTaskGenericCreate+0x180>)
 80049f2:	f000 fa25 	bl	8004e40 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80049f6:	9b00      	ldr	r3, [sp, #0]
 80049f8:	4a24      	ldr	r2, [pc, #144]	; (8004a8c <xTaskGenericCreate+0x184>)
 80049fa:	6013      	str	r3, [r2, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80049fc:	4b24      	ldr	r3, [pc, #144]	; (8004a90 <xTaskGenericCreate+0x188>)
 80049fe:	601c      	str	r4, [r3, #0]
 8004a00:	e008      	b.n	8004a14 <xTaskGenericCreate+0x10c>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8004a02:	4b24      	ldr	r3, [pc, #144]	; (8004a94 <xTaskGenericCreate+0x18c>)
 8004a04:	681b      	ldr	r3, [r3, #0]
 8004a06:	b92b      	cbnz	r3, 8004a14 <xTaskGenericCreate+0x10c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8004a08:	4b19      	ldr	r3, [pc, #100]	; (8004a70 <xTaskGenericCreate+0x168>)
 8004a0a:	681a      	ldr	r2, [r3, #0]
 8004a0c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8004a0e:	42ba      	cmp	r2, r7
					{
						pxCurrentTCB = pxNewTCB;
 8004a10:	bf98      	it	ls
 8004a12:	601d      	strls	r5, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8004a14:	4a20      	ldr	r2, [pc, #128]	; (8004a98 <xTaskGenericCreate+0x190>)
 8004a16:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004a18:	6811      	ldr	r1, [r2, #0]
 8004a1a:	428b      	cmp	r3, r1
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8004a1c:	bf88      	it	hi
 8004a1e:	6013      	strhi	r3, [r2, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 8004a20:	4a1e      	ldr	r2, [pc, #120]	; (8004a9c <xTaskGenericCreate+0x194>)
 8004a22:	6811      	ldr	r1, [r2, #0]
 8004a24:	3101      	adds	r1, #1
 8004a26:	6011      	str	r1, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 8004a28:	4a1d      	ldr	r2, [pc, #116]	; (8004aa0 <xTaskGenericCreate+0x198>)
 8004a2a:	6811      	ldr	r1, [r2, #0]
 8004a2c:	428b      	cmp	r3, r1
 8004a2e:	bf88      	it	hi
 8004a30:	6013      	strhi	r3, [r2, #0]
 8004a32:	4a10      	ldr	r2, [pc, #64]	; (8004a74 <xTaskGenericCreate+0x16c>)
 8004a34:	2014      	movs	r0, #20
 8004a36:	fb00 2003 	mla	r0, r0, r3, r2
 8004a3a:	4631      	mov	r1, r6
 8004a3c:	f000 fa0e 	bl	8004e5c <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 8004a40:	f000 faa0 	bl	8004f84 <vPortExitCritical>
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
 8004a44:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004a46:	b103      	cbz	r3, 8004a4a <xTaskGenericCreate+0x142>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 8004a48:	601d      	str	r5, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
 8004a4a:	4b12      	ldr	r3, [pc, #72]	; (8004a94 <xTaskGenericCreate+0x18c>)
 8004a4c:	681b      	ldr	r3, [r3, #0]
 8004a4e:	b153      	cbz	r3, 8004a66 <xTaskGenericCreate+0x15e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8004a50:	4b07      	ldr	r3, [pc, #28]	; (8004a70 <xTaskGenericCreate+0x168>)
 8004a52:	681b      	ldr	r3, [r3, #0]
 8004a54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004a56:	42bb      	cmp	r3, r7
 8004a58:	d205      	bcs.n	8004a66 <xTaskGenericCreate+0x15e>
			{
				portYIELD_WITHIN_API();
 8004a5a:	f000 fa7f 	bl	8004f5c <vPortYieldFromISR>
 8004a5e:	e002      	b.n	8004a66 <xTaskGenericCreate+0x15e>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004a60:	f04f 30ff 	mov.w	r0, #4294967295
 8004a64:	e000      	b.n	8004a68 <xTaskGenericCreate+0x160>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
 8004a66:	2001      	movs	r0, #1
			}
		}
	}

	return xReturn;
}
 8004a68:	b005      	add	sp, #20
 8004a6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004a6c:	200007a0 	.word	0x200007a0
 8004a70:	2000074c 	.word	0x2000074c
 8004a74:	200006e4 	.word	0x200006e4
 8004a78:	20000774 	.word	0x20000774
 8004a7c:	20000788 	.word	0x20000788
 8004a80:	20000750 	.word	0x20000750
 8004a84:	200006bc 	.word	0x200006bc
 8004a88:	200006d0 	.word	0x200006d0
 8004a8c:	200006b0 	.word	0x200006b0
 8004a90:	20000768 	.word	0x20000768
 8004a94:	200006b4 	.word	0x200006b4
 8004a98:	200007a4 	.word	0x200007a4
 8004a9c:	20000770 	.word	0x20000770
 8004aa0:	2000076c 	.word	0x2000076c

08004aa4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8004aa4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 8004aa6:	2400      	movs	r4, #0
 8004aa8:	4623      	mov	r3, r4
 8004aaa:	480c      	ldr	r0, [pc, #48]	; (8004adc <vTaskStartScheduler+0x38>)
 8004aac:	490c      	ldr	r1, [pc, #48]	; (8004ae0 <vTaskStartScheduler+0x3c>)
 8004aae:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004ab2:	9400      	str	r4, [sp, #0]
 8004ab4:	9401      	str	r4, [sp, #4]
 8004ab6:	9402      	str	r4, [sp, #8]
 8004ab8:	9403      	str	r4, [sp, #12]
 8004aba:	f7ff ff25 	bl	8004908 <xTaskGenericCreate>

	if( xReturn == pdPASS )
 8004abe:	2801      	cmp	r0, #1
void vTaskStartScheduler( void )
{
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 8004ac0:	4603      	mov	r3, r0

	if( xReturn == pdPASS )
 8004ac2:	d109      	bne.n	8004ad8 <vTaskStartScheduler+0x34>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8004ac4:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004ac8:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 8004acc:	4a05      	ldr	r2, [pc, #20]	; (8004ae4 <vTaskStartScheduler+0x40>)
 8004ace:	6013      	str	r3, [r2, #0]
		xTickCount = ( portTickType ) 0;
 8004ad0:	4b05      	ldr	r3, [pc, #20]	; (8004ae8 <vTaskStartScheduler+0x44>)
 8004ad2:	601c      	str	r4, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 8004ad4:	f000 fa22 	bl	8004f1c <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
 8004ad8:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8004ada:	bf00      	nop
 8004adc:	08004c99 	.word	0x08004c99
 8004ae0:	0800adf4 	.word	0x0800adf4
 8004ae4:	200006b4 	.word	0x200006b4
 8004ae8:	20000764 	.word	0x20000764

08004aec <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8004aec:	4b02      	ldr	r3, [pc, #8]	; (8004af8 <vTaskSuspendAll+0xc>)
 8004aee:	681a      	ldr	r2, [r3, #0]
 8004af0:	3201      	adds	r2, #1
 8004af2:	601a      	str	r2, [r3, #0]
}
 8004af4:	4770      	bx	lr
 8004af6:	bf00      	nop
 8004af8:	20000748 	.word	0x20000748

08004afc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
 8004afc:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
 8004afe:	f000 fa35 	bl	8004f6c <vPortEnterCritical>
	{
		xTicks = xTickCount;
 8004b02:	4b03      	ldr	r3, [pc, #12]	; (8004b10 <xTaskGetTickCount+0x14>)
 8004b04:	681c      	ldr	r4, [r3, #0]
	}
	portEXIT_CRITICAL();
 8004b06:	f000 fa3d 	bl	8004f84 <vPortExitCritical>

	return xTicks;
}
 8004b0a:	4620      	mov	r0, r4
 8004b0c:	bd10      	pop	{r4, pc}
 8004b0e:	bf00      	nop
 8004b10:	20000764 	.word	0x20000764

08004b14 <vTaskIncrementTick>:
void vTaskIncrementTick( void )
{
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004b14:	4b26      	ldr	r3, [pc, #152]	; (8004bb0 <vTaskIncrementTick+0x9c>)
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 8004b16:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004b18:	681b      	ldr	r3, [r3, #0]
 8004b1a:	2b00      	cmp	r3, #0
 8004b1c:	d13c      	bne.n	8004b98 <vTaskIncrementTick+0x84>
	{
		++xTickCount;
 8004b1e:	4b25      	ldr	r3, [pc, #148]	; (8004bb4 <vTaskIncrementTick+0xa0>)
 8004b20:	681a      	ldr	r2, [r3, #0]
 8004b22:	3201      	adds	r2, #1
 8004b24:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
 8004b26:	681b      	ldr	r3, [r3, #0]
 8004b28:	2b00      	cmp	r3, #0
 8004b2a:	d128      	bne.n	8004b7e <vTaskIncrementTick+0x6a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004b2c:	4a22      	ldr	r2, [pc, #136]	; (8004bb8 <vTaskIncrementTick+0xa4>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004b2e:	4b23      	ldr	r3, [pc, #140]	; (8004bbc <vTaskIncrementTick+0xa8>)
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004b30:	6811      	ldr	r1, [r2, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004b32:	6818      	ldr	r0, [r3, #0]
 8004b34:	6010      	str	r0, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
 8004b36:	6019      	str	r1, [r3, #0]
			xNumOfOverflows++;
 8004b38:	4b21      	ldr	r3, [pc, #132]	; (8004bc0 <vTaskIncrementTick+0xac>)
 8004b3a:	681a      	ldr	r2, [r3, #0]
 8004b3c:	3201      	adds	r2, #1
 8004b3e:	601a      	str	r2, [r3, #0]
 8004b40:	e01d      	b.n	8004b7e <vTaskIncrementTick+0x6a>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8004b42:	6839      	ldr	r1, [r7, #0]
 8004b44:	685a      	ldr	r2, [r3, #4]
 8004b46:	4291      	cmp	r1, r2
 8004b48:	d32c      	bcc.n	8004ba4 <vTaskIncrementTick+0x90>
 8004b4a:	1d1a      	adds	r2, r3, #4
 8004b4c:	4610      	mov	r0, r2
 8004b4e:	9201      	str	r2, [sp, #4]
 8004b50:	9300      	str	r3, [sp, #0]
 8004b52:	f000 f9aa 	bl	8004eaa <vListRemove>
 8004b56:	9b00      	ldr	r3, [sp, #0]
 8004b58:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004b5a:	b122      	cbz	r2, 8004b66 <vTaskIncrementTick+0x52>
 8004b5c:	f103 0018 	add.w	r0, r3, #24
 8004b60:	f000 f9a3 	bl	8004eaa <vListRemove>
 8004b64:	9b00      	ldr	r3, [sp, #0]
 8004b66:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8004b68:	6823      	ldr	r3, [r4, #0]
 8004b6a:	9901      	ldr	r1, [sp, #4]
 8004b6c:	4298      	cmp	r0, r3
 8004b6e:	bf88      	it	hi
 8004b70:	6020      	strhi	r0, [r4, #0]
 8004b72:	2314      	movs	r3, #20
 8004b74:	fb03 6000 	mla	r0, r3, r0, r6
 8004b78:	f000 f970 	bl	8004e5c <vListInsertEnd>
 8004b7c:	e003      	b.n	8004b86 <vTaskIncrementTick+0x72>
 8004b7e:	4d0e      	ldr	r5, [pc, #56]	; (8004bb8 <vTaskIncrementTick+0xa4>)
 8004b80:	4f0c      	ldr	r7, [pc, #48]	; (8004bb4 <vTaskIncrementTick+0xa0>)
 8004b82:	4c10      	ldr	r4, [pc, #64]	; (8004bc4 <vTaskIncrementTick+0xb0>)
 8004b84:	4e10      	ldr	r6, [pc, #64]	; (8004bc8 <vTaskIncrementTick+0xb4>)
 8004b86:	682b      	ldr	r3, [r5, #0]
 8004b88:	681b      	ldr	r3, [r3, #0]
 8004b8a:	b15b      	cbz	r3, 8004ba4 <vTaskIncrementTick+0x90>
 8004b8c:	682b      	ldr	r3, [r5, #0]
 8004b8e:	68db      	ldr	r3, [r3, #12]
 8004b90:	68db      	ldr	r3, [r3, #12]
 8004b92:	2b00      	cmp	r3, #0
 8004b94:	d1d5      	bne.n	8004b42 <vTaskIncrementTick+0x2e>
 8004b96:	e005      	b.n	8004ba4 <vTaskIncrementTick+0x90>
	}
	else
	{
		++uxMissedTicks;
 8004b98:	4b0c      	ldr	r3, [pc, #48]	; (8004bcc <vTaskIncrementTick+0xb8>)
 8004b9a:	681a      	ldr	r2, [r3, #0]
 8004b9c:	3201      	adds	r2, #1
 8004b9e:	601a      	str	r2, [r3, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
 8004ba0:	f7ff fdea 	bl	8004778 <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
 8004ba4:	4b09      	ldr	r3, [pc, #36]	; (8004bcc <vTaskIncrementTick+0xb8>)
 8004ba6:	681b      	ldr	r3, [r3, #0]
 8004ba8:	b90b      	cbnz	r3, 8004bae <vTaskIncrementTick+0x9a>
		{
			vApplicationTickHook();
 8004baa:	f7ff fde5 	bl	8004778 <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8004bae:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004bb0:	20000748 	.word	0x20000748
 8004bb4:	20000764 	.word	0x20000764
 8004bb8:	200006b0 	.word	0x200006b0
 8004bbc:	20000768 	.word	0x20000768
 8004bc0:	200006ac 	.word	0x200006ac
 8004bc4:	2000076c 	.word	0x2000076c
 8004bc8:	200006e4 	.word	0x200006e4
 8004bcc:	200006a8 	.word	0x200006a8

08004bd0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8004bd0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
 8004bd2:	f000 f9cb 	bl	8004f6c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8004bd6:	4b28      	ldr	r3, [pc, #160]	; (8004c78 <xTaskResumeAll+0xa8>)
 8004bd8:	681a      	ldr	r2, [r3, #0]
 8004bda:	3a01      	subs	r2, #1
 8004bdc:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004bde:	681d      	ldr	r5, [r3, #0]
 8004be0:	2d00      	cmp	r5, #0
 8004be2:	d144      	bne.n	8004c6e <xTaskResumeAll+0x9e>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 8004be4:	4b25      	ldr	r3, [pc, #148]	; (8004c7c <xTaskResumeAll+0xac>)
 8004be6:	681c      	ldr	r4, [r3, #0]
 8004be8:	2c00      	cmp	r4, #0
 8004bea:	d041      	beq.n	8004c70 <xTaskResumeAll+0xa0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8004bec:	4f24      	ldr	r7, [pc, #144]	; (8004c80 <xTaskResumeAll+0xb0>)
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
 8004bee:	4e25      	ldr	r6, [pc, #148]	; (8004c84 <xTaskResumeAll+0xb4>)
 8004bf0:	e01b      	b.n	8004c2a <xTaskResumeAll+0x5a>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
 8004bf2:	f104 0018 	add.w	r0, r4, #24
 8004bf6:	f000 f958 	bl	8004eaa <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 8004bfa:	1d21      	adds	r1, r4, #4
 8004bfc:	4608      	mov	r0, r1
 8004bfe:	9101      	str	r1, [sp, #4]
 8004c00:	f000 f953 	bl	8004eaa <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8004c04:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004c06:	6833      	ldr	r3, [r6, #0]
 8004c08:	9901      	ldr	r1, [sp, #4]
 8004c0a:	4298      	cmp	r0, r3
 8004c0c:	4b1e      	ldr	r3, [pc, #120]	; (8004c88 <xTaskResumeAll+0xb8>)
 8004c0e:	bf88      	it	hi
 8004c10:	6030      	strhi	r0, [r6, #0]
 8004c12:	2214      	movs	r2, #20
 8004c14:	fb02 3000 	mla	r0, r2, r0, r3
 8004c18:	f000 f920 	bl	8004e5c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004c1c:	4a1b      	ldr	r2, [pc, #108]	; (8004c8c <xTaskResumeAll+0xbc>)
 8004c1e:	6813      	ldr	r3, [r2, #0]
 8004c20:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004c22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
 8004c24:	429a      	cmp	r2, r3
 8004c26:	bf28      	it	cs
 8004c28:	2501      	movcs	r5, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8004c2a:	683b      	ldr	r3, [r7, #0]
 8004c2c:	b11b      	cbz	r3, 8004c36 <xTaskResumeAll+0x66>
 8004c2e:	68fb      	ldr	r3, [r7, #12]
 8004c30:	68dc      	ldr	r4, [r3, #12]
 8004c32:	2c00      	cmp	r4, #0
 8004c34:	d1dd      	bne.n	8004bf2 <xTaskResumeAll+0x22>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 8004c36:	4c16      	ldr	r4, [pc, #88]	; (8004c90 <xTaskResumeAll+0xc0>)
 8004c38:	6823      	ldr	r3, [r4, #0]
 8004c3a:	b92b      	cbnz	r3, 8004c48 <xTaskResumeAll+0x78>
 8004c3c:	e008      	b.n	8004c50 <xTaskResumeAll+0x80>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
 8004c3e:	f7ff ff69 	bl	8004b14 <vTaskIncrementTick>
						--uxMissedTicks;
 8004c42:	6823      	ldr	r3, [r4, #0]
 8004c44:	3b01      	subs	r3, #1
 8004c46:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 8004c48:	6823      	ldr	r3, [r4, #0]
 8004c4a:	2b00      	cmp	r3, #0
 8004c4c:	d1f7      	bne.n	8004c3e <xTaskResumeAll+0x6e>
 8004c4e:	e007      	b.n	8004c60 <xTaskResumeAll+0x90>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8004c50:	2d01      	cmp	r5, #1
 8004c52:	d005      	beq.n	8004c60 <xTaskResumeAll+0x90>
 8004c54:	4a0f      	ldr	r2, [pc, #60]	; (8004c94 <xTaskResumeAll+0xc4>)
 8004c56:	6812      	ldr	r2, [r2, #0]
 8004c58:	2a01      	cmp	r2, #1
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8004c5a:	bf18      	it	ne
 8004c5c:	461c      	movne	r4, r3
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8004c5e:	d107      	bne.n	8004c70 <xTaskResumeAll+0xa0>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 8004c60:	4b0c      	ldr	r3, [pc, #48]	; (8004c94 <xTaskResumeAll+0xc4>)
 8004c62:	2200      	movs	r2, #0
 8004c64:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8004c66:	f000 f979 	bl	8004f5c <vPortYieldFromISR>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 8004c6a:	2401      	movs	r4, #1
 8004c6c:	e000      	b.n	8004c70 <xTaskResumeAll+0xa0>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8004c6e:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
 8004c70:	f000 f988 	bl	8004f84 <vPortExitCritical>

	return xAlreadyYielded;
}
 8004c74:	4620      	mov	r0, r4
 8004c76:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004c78:	20000748 	.word	0x20000748
 8004c7c:	200007a0 	.word	0x200007a0
 8004c80:	20000750 	.word	0x20000750
 8004c84:	2000076c 	.word	0x2000076c
 8004c88:	200006e4 	.word	0x200006e4
 8004c8c:	2000074c 	.word	0x2000074c
 8004c90:	200006a8 	.word	0x200006a8
 8004c94:	2000079c 	.word	0x2000079c

08004c98 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8004c98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8004c9a:	4e15      	ldr	r6, [pc, #84]	; (8004cf0 <prvIdleTask+0x58>)
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004c9c:	4d15      	ldr	r5, [pc, #84]	; (8004cf4 <prvIdleTask+0x5c>)

				portENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
 8004c9e:	4f16      	ldr	r7, [pc, #88]	; (8004cf8 <prvIdleTask+0x60>)
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8004ca0:	6833      	ldr	r3, [r6, #0]
 8004ca2:	b1e3      	cbz	r3, 8004cde <prvIdleTask+0x46>
		{
			vTaskSuspendAll();
 8004ca4:	f7ff ff22 	bl	8004aec <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004ca8:	682c      	ldr	r4, [r5, #0]
			xTaskResumeAll();
 8004caa:	f7ff ff91 	bl	8004bd0 <xTaskResumeAll>

			if( !xListIsEmpty )
 8004cae:	b1b4      	cbz	r4, 8004cde <prvIdleTask+0x46>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
 8004cb0:	f000 f95c 	bl	8004f6c <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8004cb4:	682c      	ldr	r4, [r5, #0]
 8004cb6:	b10c      	cbz	r4, 8004cbc <prvIdleTask+0x24>
 8004cb8:	68eb      	ldr	r3, [r5, #12]
 8004cba:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8004cbc:	1d20      	adds	r0, r4, #4
 8004cbe:	f000 f8f4 	bl	8004eaa <vListRemove>
					--uxCurrentNumberOfTasks;
 8004cc2:	683b      	ldr	r3, [r7, #0]
 8004cc4:	3b01      	subs	r3, #1
 8004cc6:	603b      	str	r3, [r7, #0]
					--uxTasksDeleted;
 8004cc8:	6833      	ldr	r3, [r6, #0]
 8004cca:	3b01      	subs	r3, #1
 8004ccc:	6033      	str	r3, [r6, #0]
				}
				portEXIT_CRITICAL();
 8004cce:	f000 f959 	bl	8004f84 <vPortExitCritical>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8004cd2:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004cd4:	f000 f9ea 	bl	80050ac <vPortFree>
		vPortFree( pxTCB );
 8004cd8:	4620      	mov	r0, r4
 8004cda:	f000 f9e7 	bl	80050ac <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8004cde:	4a07      	ldr	r2, [pc, #28]	; (8004cfc <prvIdleTask+0x64>)
 8004ce0:	6813      	ldr	r3, [r2, #0]
 8004ce2:	2b01      	cmp	r3, #1
 8004ce4:	d901      	bls.n	8004cea <prvIdleTask+0x52>
			{
				taskYIELD();
 8004ce6:	f000 f939 	bl	8004f5c <vPortYieldFromISR>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8004cea:	f7ff fd46 	bl	800477a <vApplicationIdleHook>
		}
		#endif
	}
 8004cee:	e7d7      	b.n	8004ca0 <prvIdleTask+0x8>
 8004cf0:	200006b8 	.word	0x200006b8
 8004cf4:	200006bc 	.word	0x200006bc
 8004cf8:	200007a0 	.word	0x200007a0
 8004cfc:	200006e4 	.word	0x200006e4

08004d00 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8004d00:	b570      	push	{r4, r5, r6, lr}
 8004d02:	4604      	mov	r4, r0
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
 8004d04:	b1c0      	cbz	r0, 8004d38 <vTaskDelay+0x38>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8004d06:	4e0e      	ldr	r6, [pc, #56]	; (8004d40 <vTaskDelay+0x40>)
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
 8004d08:	f7ff fef0 	bl	8004aec <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8004d0c:	6835      	ldr	r5, [r6, #0]
 8004d0e:	1965      	adds	r5, r4, r5

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d10:	4c0c      	ldr	r4, [pc, #48]	; (8004d44 <vTaskDelay+0x44>)
 8004d12:	6820      	ldr	r0, [r4, #0]
 8004d14:	3004      	adds	r0, #4
 8004d16:	f000 f8c8 	bl	8004eaa <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8004d1a:	6823      	ldr	r3, [r4, #0]
 8004d1c:	605d      	str	r5, [r3, #4]

				if( xTimeToWake < xTickCount )
 8004d1e:	6833      	ldr	r3, [r6, #0]
 8004d20:	429d      	cmp	r5, r3
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d22:	bf34      	ite	cc
 8004d24:	4b08      	ldrcc	r3, [pc, #32]	; (8004d48 <vTaskDelay+0x48>)
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d26:	4b09      	ldrcs	r3, [pc, #36]	; (8004d4c <vTaskDelay+0x4c>)
 8004d28:	6818      	ldr	r0, [r3, #0]
 8004d2a:	6821      	ldr	r1, [r4, #0]
 8004d2c:	3104      	adds	r1, #4
 8004d2e:	f000 f8a2 	bl	8004e76 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
 8004d32:	f7ff ff4d 	bl	8004bd0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 8004d36:	b908      	cbnz	r0, 8004d3c <vTaskDelay+0x3c>
		{
			portYIELD_WITHIN_API();
 8004d38:	f000 f910 	bl	8004f5c <vPortYieldFromISR>
		}
	}
 8004d3c:	bd70      	pop	{r4, r5, r6, pc}
 8004d3e:	bf00      	nop
 8004d40:	20000764 	.word	0x20000764
 8004d44:	2000074c 	.word	0x2000074c
 8004d48:	20000768 	.word	0x20000768
 8004d4c:	200006b0 	.word	0x200006b0

08004d50 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8004d50:	b538      	push	{r3, r4, r5, lr}
 8004d52:	460c      	mov	r4, r1
 8004d54:	4605      	mov	r5, r0
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
 8004d56:	f7ff fec9 	bl	8004aec <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
 8004d5a:	4a17      	ldr	r2, [pc, #92]	; (8004db8 <vTaskDelayUntil+0x68>)
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004d5c:	682b      	ldr	r3, [r5, #0]

			if( xTickCount < *pxPreviousWakeTime )
 8004d5e:	6811      	ldr	r1, [r2, #0]
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004d60:	18e4      	adds	r4, r4, r3

			if( xTickCount < *pxPreviousWakeTime )
 8004d62:	4299      	cmp	r1, r3
 8004d64:	d202      	bcs.n	8004d6c <vTaskDelayUntil+0x1c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 8004d66:	429c      	cmp	r4, r3
 8004d68:	d208      	bcs.n	8004d7c <vTaskDelayUntil+0x2c>
 8004d6a:	e001      	b.n	8004d70 <vTaskDelayUntil+0x20>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 8004d6c:	429c      	cmp	r4, r3
 8004d6e:	d307      	bcc.n	8004d80 <vTaskDelayUntil+0x30>
 8004d70:	6813      	ldr	r3, [r2, #0]
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8004d72:	429c      	cmp	r4, r3
 8004d74:	bf94      	ite	ls
 8004d76:	2300      	movls	r3, #0
 8004d78:	2301      	movhi	r3, #1
 8004d7a:	e002      	b.n	8004d82 <vTaskDelayUntil+0x32>
 8004d7c:	2300      	movs	r3, #0
 8004d7e:	e000      	b.n	8004d82 <vTaskDelayUntil+0x32>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
 8004d80:	2301      	movs	r3, #1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8004d82:	602c      	str	r4, [r5, #0]

			if( xShouldDelay )
 8004d84:	b18b      	cbz	r3, 8004daa <vTaskDelayUntil+0x5a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d86:	4d0d      	ldr	r5, [pc, #52]	; (8004dbc <vTaskDelayUntil+0x6c>)
 8004d88:	6828      	ldr	r0, [r5, #0]
 8004d8a:	3004      	adds	r0, #4
 8004d8c:	f000 f88d 	bl	8004eaa <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8004d90:	682b      	ldr	r3, [r5, #0]
 8004d92:	605c      	str	r4, [r3, #4]

				if( xTimeToWake < xTickCount )
 8004d94:	4b08      	ldr	r3, [pc, #32]	; (8004db8 <vTaskDelayUntil+0x68>)
 8004d96:	681b      	ldr	r3, [r3, #0]
 8004d98:	429c      	cmp	r4, r3
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d9a:	bf34      	ite	cc
 8004d9c:	4b08      	ldrcc	r3, [pc, #32]	; (8004dc0 <vTaskDelayUntil+0x70>)
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004d9e:	4b09      	ldrcs	r3, [pc, #36]	; (8004dc4 <vTaskDelayUntil+0x74>)
 8004da0:	6818      	ldr	r0, [r3, #0]
 8004da2:	6829      	ldr	r1, [r5, #0]
 8004da4:	3104      	adds	r1, #4
 8004da6:	f000 f866 	bl	8004e76 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8004daa:	f7ff ff11 	bl	8004bd0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 8004dae:	b908      	cbnz	r0, 8004db4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
 8004db0:	f000 f8d4 	bl	8004f5c <vPortYieldFromISR>
		}
	}
 8004db4:	bd38      	pop	{r3, r4, r5, pc}
 8004db6:	bf00      	nop
 8004db8:	20000764 	.word	0x20000764
 8004dbc:	2000074c 	.word	0x2000074c
 8004dc0:	20000768 	.word	0x20000768
 8004dc4:	200006b0 	.word	0x200006b0

08004dc8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8004dc8:	4b18      	ldr	r3, [pc, #96]	; (8004e2c <vTaskSwitchContext+0x64>)

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8004dca:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8004dcc:	681b      	ldr	r3, [r3, #0]
 8004dce:	b133      	cbz	r3, 8004dde <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8004dd0:	2201      	movs	r2, #1
 8004dd2:	4b17      	ldr	r3, [pc, #92]	; (8004e30 <vTaskSwitchContext+0x68>)
 8004dd4:	e028      	b.n	8004e28 <vTaskSwitchContext+0x60>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
 8004dd6:	6818      	ldr	r0, [r3, #0]
 8004dd8:	3801      	subs	r0, #1
 8004dda:	6018      	str	r0, [r3, #0]
 8004ddc:	e002      	b.n	8004de4 <vTaskSwitchContext+0x1c>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8004dde:	4b15      	ldr	r3, [pc, #84]	; (8004e34 <vTaskSwitchContext+0x6c>)
 8004de0:	4915      	ldr	r1, [pc, #84]	; (8004e38 <vTaskSwitchContext+0x70>)
 8004de2:	2214      	movs	r2, #20
 8004de4:	f8d3 c000 	ldr.w	ip, [r3]
 8004de8:	4813      	ldr	r0, [pc, #76]	; (8004e38 <vTaskSwitchContext+0x70>)
 8004dea:	fb02 fc0c 	mul.w	ip, r2, ip
 8004dee:	f851 400c 	ldr.w	r4, [r1, ip]
 8004df2:	2c00      	cmp	r4, #0
 8004df4:	d0ef      	beq.n	8004dd6 <vTaskSwitchContext+0xe>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8004df6:	4b0f      	ldr	r3, [pc, #60]	; (8004e34 <vTaskSwitchContext+0x6c>)
 8004df8:	f04f 0c14 	mov.w	ip, #20
 8004dfc:	6819      	ldr	r1, [r3, #0]
 8004dfe:	fb0c fc01 	mul.w	ip, ip, r1
 8004e02:	eb00 030c 	add.w	r3, r0, ip
 8004e06:	685a      	ldr	r2, [r3, #4]
 8004e08:	f10c 0c08 	add.w	ip, ip, #8
 8004e0c:	6852      	ldr	r2, [r2, #4]
 8004e0e:	4460      	add	r0, ip
 8004e10:	4282      	cmp	r2, r0
 8004e12:	605a      	str	r2, [r3, #4]
 8004e14:	bf04      	itt	eq
 8004e16:	6852      	ldreq	r2, [r2, #4]
 8004e18:	605a      	streq	r2, [r3, #4]
 8004e1a:	4b07      	ldr	r3, [pc, #28]	; (8004e38 <vTaskSwitchContext+0x70>)
 8004e1c:	2214      	movs	r2, #20
 8004e1e:	fb02 3101 	mla	r1, r2, r1, r3
 8004e22:	684b      	ldr	r3, [r1, #4]
 8004e24:	68da      	ldr	r2, [r3, #12]
 8004e26:	4b05      	ldr	r3, [pc, #20]	; (8004e3c <vTaskSwitchContext+0x74>)
 8004e28:	601a      	str	r2, [r3, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
 8004e2a:	bd10      	pop	{r4, pc}
 8004e2c:	20000748 	.word	0x20000748
 8004e30:	2000079c 	.word	0x2000079c
 8004e34:	2000076c 	.word	0x2000076c
 8004e38:	200006e4 	.word	0x200006e4
 8004e3c:	2000074c 	.word	0x2000074c

08004e40 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004e40:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004e44:	f04f 32ff 	mov.w	r2, #4294967295
 8004e48:	6082      	str	r2, [r0, #8]
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004e4a:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8004e4c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8004e4e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = 0;
 8004e50:	2300      	movs	r3, #0
 8004e52:	6003      	str	r3, [r0, #0]
}
 8004e54:	4770      	bx	lr

08004e56 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8004e56:	2300      	movs	r3, #0
 8004e58:	6103      	str	r3, [r0, #16]
}
 8004e5a:	4770      	bx	lr

08004e5c <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8004e5c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004e5e:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8004e60:	608b      	str	r3, [r1, #8]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004e62:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004e64:	685a      	ldr	r2, [r3, #4]
 8004e66:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004e68:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004e6a:	6803      	ldr	r3, [r0, #0]

	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8004e6c:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004e6e:	3301      	adds	r3, #1
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004e70:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8004e72:	6003      	str	r3, [r0, #0]
}
 8004e74:	4770      	bx	lr

08004e76 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8004e76:	680a      	ldr	r2, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004e78:	f1b2 3fff 	cmp.w	r2, #4294967295
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8004e7c:	bf0c      	ite	eq
 8004e7e:	6903      	ldreq	r3, [r0, #16]
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004e80:	f100 0308 	addne.w	r3, r0, #8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004e84:	d101      	bne.n	8004e8a <vListInsert+0x14>
 8004e86:	e006      	b.n	8004e96 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004e88:	685b      	ldr	r3, [r3, #4]
 8004e8a:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8004e8e:	f8dc c000 	ldr.w	ip, [ip]
 8004e92:	4594      	cmp	ip, r2
 8004e94:	d9f8      	bls.n	8004e88 <vListInsert+0x12>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004e96:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004e98:	6108      	str	r0, [r1, #16]
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004e9a:	6091      	str	r1, [r2, #8]
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004e9c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004e9e:	6059      	str	r1, [r3, #4]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8004ea0:	608b      	str	r3, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004ea2:	6803      	ldr	r3, [r0, #0]
 8004ea4:	3301      	adds	r3, #1
 8004ea6:	6003      	str	r3, [r0, #0]
}
 8004ea8:	4770      	bx	lr

08004eaa <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004eaa:	6843      	ldr	r3, [r0, #4]
 8004eac:	6882      	ldr	r2, [r0, #8]
 8004eae:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8004eb0:	6882      	ldr	r2, [r0, #8]
 8004eb2:	6053      	str	r3, [r2, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8004eb4:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8004eb6:	6859      	ldr	r1, [r3, #4]
 8004eb8:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8004eba:	bf08      	it	eq
 8004ebc:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8004ebe:	2200      	movs	r2, #0
 8004ec0:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8004ec2:	681a      	ldr	r2, [r3, #0]
 8004ec4:	3a01      	subs	r2, #1
 8004ec6:	601a      	str	r2, [r3, #0]
}
 8004ec8:	4770      	bx	lr

08004eca <pxPortInitialiseStack>:
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8004eca:	1f03      	subs	r3, r0, #4
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8004ecc:	f04f 7c80 	mov.w	ip, #16777216	; 0x1000000
 8004ed0:	f840 cc04 	str.w	ip, [r0, #-4]
	pxTopOfStack--;
 8004ed4:	1f18      	subs	r0, r3, #4
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8004ed6:	f843 1c04 	str.w	r1, [r3, #-4]
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
 8004eda:	2100      	movs	r1, #0
 8004edc:	f840 1c04 	str.w	r1, [r0, #-4]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8004ee0:	f840 2c18 	str.w	r2, [r0, #-24]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8004ee4:	f1a3 003c 	sub.w	r0, r3, #60	; 0x3c

	return pxTopOfStack;
}
 8004ee8:	4770      	bx	lr
	...

08004eec <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8004eec:	4b06      	ldr	r3, [pc, #24]	; (8004f08 <pxCurrentTCBConst2>)
 8004eee:	6819      	ldr	r1, [r3, #0]
 8004ef0:	6808      	ldr	r0, [r1, #0]
 8004ef2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004ef6:	f380 8809 	msr	PSP, r0
 8004efa:	f04f 0000 	mov.w	r0, #0
 8004efe:	f380 8811 	msr	BASEPRI, r0
 8004f02:	f04e 0e0d 	orr.w	lr, lr, #13
 8004f06:	4770      	bx	lr

08004f08 <pxCurrentTCBConst2>:
 8004f08:	2000074c 	.word	0x2000074c

08004f0c <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8004f0c:	4802      	ldr	r0, [pc, #8]	; (8004f18 <vPortStartFirstTask+0xc>)
 8004f0e:	6800      	ldr	r0, [r0, #0]
 8004f10:	6800      	ldr	r0, [r0, #0]
 8004f12:	f380 8808 	msr	MSP, r0
 8004f16:	df00      	svc	0
 8004f18:	e000ed08 	.word	0xe000ed08

08004f1c <xPortStartScheduler>:
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004f1c:	4b0b      	ldr	r3, [pc, #44]	; (8004f4c <xPortStartScheduler+0x30>)

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8004f1e:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004f20:	681a      	ldr	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004f22:	2400      	movs	r4, #0
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004f24:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8004f28:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8004f2a:	681a      	ldr	r2, [r3, #0]
 8004f2c:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8004f30:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004f32:	4a07      	ldr	r2, [pc, #28]	; (8004f50 <xPortStartScheduler+0x34>)
 8004f34:	4b07      	ldr	r3, [pc, #28]	; (8004f54 <xPortStartScheduler+0x38>)
 8004f36:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8004f38:	2207      	movs	r2, #7
 8004f3a:	3b04      	subs	r3, #4
 8004f3c:	601a      	str	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004f3e:	4b06      	ldr	r3, [pc, #24]	; (8004f58 <xPortStartScheduler+0x3c>)
 8004f40:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8004f42:	f7ff ffe3 	bl	8004f0c <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 8004f46:	4620      	mov	r0, r4
 8004f48:	bd10      	pop	{r4, pc}
 8004f4a:	bf00      	nop
 8004f4c:	e000ed20 	.word	0xe000ed20
 8004f50:	0001193f 	.word	0x0001193f
 8004f54:	e000e014 	.word	0xe000e014
 8004f58:	20000000 	.word	0x20000000

08004f5c <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004f5c:	4b02      	ldr	r3, [pc, #8]	; (8004f68 <vPortYieldFromISR+0xc>)
 8004f5e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004f62:	601a      	str	r2, [r3, #0]
}
 8004f64:	4770      	bx	lr
 8004f66:	bf00      	nop
 8004f68:	e000ed04 	.word	0xe000ed04

08004f6c <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
 8004f6c:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004f70:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8004f74:	4b02      	ldr	r3, [pc, #8]	; (8004f80 <vPortEnterCritical+0x14>)
 8004f76:	681a      	ldr	r2, [r3, #0]
 8004f78:	3201      	adds	r2, #1
 8004f7a:	601a      	str	r2, [r3, #0]
}
 8004f7c:	4770      	bx	lr
 8004f7e:	bf00      	nop
 8004f80:	20000000 	.word	0x20000000

08004f84 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 8004f84:	4a04      	ldr	r2, [pc, #16]	; (8004f98 <vPortExitCritical+0x14>)
 8004f86:	6813      	ldr	r3, [r2, #0]
 8004f88:	3b01      	subs	r3, #1
 8004f8a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004f8c:	b91b      	cbnz	r3, 8004f96 <vPortExitCritical+0x12>
	{
		portENABLE_INTERRUPTS();
 8004f8e:	f04f 0000 	mov.w	r0, #0
 8004f92:	f380 8811 	msr	BASEPRI, r0
	}
}
 8004f96:	4770      	bx	lr
 8004f98:	20000000 	.word	0x20000000

08004f9c <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8004f9c:	f3ef 8009 	mrs	r0, PSP
 8004fa0:	4b0c      	ldr	r3, [pc, #48]	; (8004fd4 <pxCurrentTCBConst>)
 8004fa2:	681a      	ldr	r2, [r3, #0]
 8004fa4:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004fa8:	6010      	str	r0, [r2, #0]
 8004faa:	e92d 4008 	stmdb	sp!, {r3, lr}
 8004fae:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004fb2:	f380 8811 	msr	BASEPRI, r0
 8004fb6:	f7ff ff07 	bl	8004dc8 <vTaskSwitchContext>
 8004fba:	f04f 0000 	mov.w	r0, #0
 8004fbe:	f380 8811 	msr	BASEPRI, r0
 8004fc2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8004fc6:	6819      	ldr	r1, [r3, #0]
 8004fc8:	6808      	ldr	r0, [r1, #0]
 8004fca:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004fce:	f380 8809 	msr	PSP, r0
 8004fd2:	4770      	bx	lr

08004fd4 <pxCurrentTCBConst>:
 8004fd4:	2000074c 	.word	0x2000074c

08004fd8 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8004fd8:	b508      	push	{r3, lr}
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004fda:	4b07      	ldr	r3, [pc, #28]	; (8004ff8 <xPortSysTickHandler+0x20>)
 8004fdc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004fe0:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8004fe2:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004fe6:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8004fea:	f7ff fd93 	bl	8004b14 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8004fee:	f04f 0000 	mov.w	r0, #0
 8004ff2:	f380 8811 	msr	BASEPRI, r0
}
 8004ff6:	bd08      	pop	{r3, pc}
 8004ff8:	e000ed04 	.word	0xe000ed04

08004ffc <umm_make_new_block>:

// ----------------------------------------------------------------------------

static void umm_make_new_block( unsigned short int c,
                                unsigned short int blocks,
                                unsigned short int freemask ) {
 8004ffc:	b5f0      	push	{r4, r5, r6, r7, lr}

     UMM_NBLOCK(c+blocks) = UMM_NBLOCK(c) & UMM_BLOCKNO_MASK;
 8004ffe:	240c      	movs	r4, #12
 8005000:	fb04 fc00 	mul.w	ip, r4, r0
 8005004:	1809      	adds	r1, r1, r0
 8005006:	4b0b      	ldr	r3, [pc, #44]	; (8005034 <umm_make_new_block+0x38>)
 8005008:	fb04 f501 	mul.w	r5, r4, r1
 800500c:	f833 600c 	ldrh.w	r6, [r3, ip]
 8005010:	195f      	adds	r7, r3, r5
 8005012:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
 8005016:	535e      	strh	r6, [r3, r5]
     UMM_PBLOCK(c+blocks) = c;
 8005018:	8078      	strh	r0, [r7, #2]

     UMM_PBLOCK(UMM_NBLOCK(c) & UMM_BLOCKNO_MASK) = (c+blocks);
 800501a:	f833 000c 	ldrh.w	r0, [r3, ip]
 800501e:	b289      	uxth	r1, r1
 8005020:	0440      	lsls	r0, r0, #17
 8005022:	0c40      	lsrs	r0, r0, #17
 8005024:	fb04 3400 	mla	r4, r4, r0, r3
 8005028:	8061      	strh	r1, [r4, #2]
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
 800502a:	ea42 0101 	orr.w	r1, r2, r1
 800502e:	f823 100c 	strh.w	r1, [r3, ip]
}
 8005032:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005034:	20000c3c 	.word	0x20000c3c

08005038 <umm_disconnect_from_free_list>:
// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 8005038:	210c      	movs	r1, #12
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
}

// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
 800503a:	b510      	push	{r4, lr}
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 800503c:	4348      	muls	r0, r1
 800503e:	4b0a      	ldr	r3, [pc, #40]	; (8005068 <umm_disconnect_from_free_list+0x30>)
 8005040:	181a      	adds	r2, r3, r0
 8005042:	f8b2 c006 	ldrh.w	ip, [r2, #6]
 8005046:	8894      	ldrh	r4, [r2, #4]
 8005048:	fb01 3c0c 	mla	ip, r1, ip, r3
 800504c:	f8ac 4004 	strh.w	r4, [ip, #4]
    UMM_PFREE(UMM_NFREE(c)) = UMM_PFREE(c);
 8005050:	f8b2 c004 	ldrh.w	ip, [r2, #4]
 8005054:	88d2      	ldrh	r2, [r2, #6]
 8005056:	fb01 310c 	mla	r1, r1, ip, r3
 800505a:	80ca      	strh	r2, [r1, #6]

    // And clear the free block indicator

    UMM_NBLOCK(c) &= (~UMM_FREELIST_MASK);
 800505c:	5a1a      	ldrh	r2, [r3, r0]
 800505e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8005062:	521a      	strh	r2, [r3, r0]
}
 8005064:	bd10      	pop	{r4, pc}
 8005066:	bf00      	nop
 8005068:	20000c3c 	.word	0x20000c3c

0800506c <umm_assimilate_up>:

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 800506c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 800506e:	250c      	movs	r5, #12
 8005070:	fb05 f600 	mul.w	r6, r5, r0
 8005074:	4c0c      	ldr	r4, [pc, #48]	; (80050a8 <umm_assimilate_up+0x3c>)

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 8005076:	4607      	mov	r7, r0

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 8005078:	5ba0      	ldrh	r0, [r4, r6]
 800507a:	fb05 f300 	mul.w	r3, r5, r0
 800507e:	5ee3      	ldrsh	r3, [r4, r3]
 8005080:	2b00      	cmp	r3, #0
 8005082:	da0f      	bge.n	80050a4 <umm_assimilate_up+0x38>

    DBG_LOG_DEBUG( "Assimilate up to next block, which is FREE\n" );

    // Disconnect the next block from the FREE list

    umm_disconnect_from_free_list( UMM_NBLOCK(c) );
 8005084:	f7ff ffd8 	bl	8005038 <umm_disconnect_from_free_list>

    // Assimilate the next block with this one

    UMM_PBLOCK(UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK) = c;
 8005088:	5ba3      	ldrh	r3, [r4, r6]
 800508a:	436b      	muls	r3, r5
 800508c:	5ae3      	ldrh	r3, [r4, r3]
 800508e:	045b      	lsls	r3, r3, #17
 8005090:	0c5b      	lsrs	r3, r3, #17
 8005092:	fb05 4303 	mla	r3, r5, r3, r4
 8005096:	805f      	strh	r7, [r3, #2]
    UMM_NBLOCK(c) = UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK;
 8005098:	5ba3      	ldrh	r3, [r4, r6]
 800509a:	435d      	muls	r5, r3
 800509c:	5b63      	ldrh	r3, [r4, r5]
 800509e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80050a2:	53a3      	strh	r3, [r4, r6]
  } 
}
 80050a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80050a6:	bf00      	nop
 80050a8:	20000c3c 	.word	0x20000c3c

080050ac <vPortFree>:
    return( UMM_PBLOCK(c) );
}

// ----------------------------------------------------------------------------

void umm_free( void *ptr ) {
 80050ac:	b570      	push	{r4, r5, r6, lr}
 80050ae:	4606      	mov	r6, r0

  unsigned short int c;

  // If we're being asked to free a NULL pointer, well that's just silly!

  if( (void *)0 == ptr ) {
 80050b0:	2800      	cmp	r0, #0
 80050b2:	d02e      	beq.n	8005112 <vPortFree+0x66>
  //
  UMM_CRITICAL_ENTRY();

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 80050b4:	4c17      	ldr	r4, [pc, #92]	; (8005114 <vPortFree+0x68>)
 80050b6:	250c      	movs	r5, #12
 80050b8:	1b36      	subs	r6, r6, r4
  // NOTE:  See the new umm_info() function that you can use to see if a ptr is
  //        on the free list!

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 80050ba:	f7ff fd17 	bl	8004aec <vTaskSuspendAll>

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 80050be:	fbb6 f6f5 	udiv	r6, r6, r5
 80050c2:	b2b6      	uxth	r6, r6

  DBG_LOG_DEBUG( "Freeing block %6d\n", c );

  // Now let's assimilate this block with the next one if possible.

  umm_assimilate_up( c );
 80050c4:	4630      	mov	r0, r6
 80050c6:	f7ff ffd1 	bl	800506c <umm_assimilate_up>

  // Then assimilate with the previous block if possible

  if( UMM_NBLOCK(UMM_PBLOCK(c)) & UMM_FREELIST_MASK ) {
 80050ca:	fb05 f306 	mul.w	r3, r5, r6
 80050ce:	18e2      	adds	r2, r4, r3
 80050d0:	8850      	ldrh	r0, [r2, #2]
 80050d2:	4368      	muls	r0, r5
 80050d4:	5e21      	ldrsh	r1, [r4, r0]
 80050d6:	2900      	cmp	r1, #0
 80050d8:	da0b      	bge.n	80050f2 <vPortFree+0x46>

// ----------------------------------------------------------------------------

static unsigned short int umm_assimilate_down( unsigned short int c, unsigned short int freemask ) {

    UMM_NBLOCK(UMM_PBLOCK(c)) = UMM_NBLOCK(c) | freemask;
 80050da:	5ae1      	ldrh	r1, [r4, r3]
 80050dc:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 80050e0:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 80050e4:	5221      	strh	r1, [r4, r0]
    UMM_PBLOCK(UMM_NBLOCK(c)) = UMM_PBLOCK(c);
 80050e6:	5ae3      	ldrh	r3, [r4, r3]
 80050e8:	8852      	ldrh	r2, [r2, #2]
 80050ea:	fb05 4403 	mla	r4, r5, r3, r4
 80050ee:	8062      	strh	r2, [r4, #2]
 80050f0:	e00d      	b.n	800510e <vPortFree+0x62>
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 80050f2:	88a1      	ldrh	r1, [r4, #4]
 80050f4:	fb05 4501 	mla	r5, r5, r1, r4
    UMM_NFREE(c)            = UMM_NFREE(0);
 80050f8:	8091      	strh	r1, [r2, #4]
    UMM_PFREE(c)            = 0;
 80050fa:	2100      	movs	r1, #0
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 80050fc:	80ee      	strh	r6, [r5, #6]
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
    UMM_NFREE(0)            = c;
 80050fe:	80a6      	strh	r6, [r4, #4]

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
 8005100:	80d1      	strh	r1, [r2, #6]
    UMM_NFREE(0)            = c;

    UMM_NBLOCK(c)          |= UMM_FREELIST_MASK;
 8005102:	5ae2      	ldrh	r2, [r4, r3]
 8005104:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8005108:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 800510c:	52e2      	strh	r2, [r4, r3]
  }
#endif

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 800510e:	f7ff fd5f 	bl	8004bd0 <xTaskResumeAll>
}
 8005112:	bd70      	pop	{r4, r5, r6, pc}
 8005114:	20000c3c 	.word	0x20000c3c

08005118 <pvPortMalloc>:

// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {
 8005118:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800511a:	4606      	mov	r6, r0
  // the very first thing we do is figure out if we're being asked to allocate
  // a size of 0 - and if we are we'll simply return a null pointer. if not
  // then reduce the size by 1 byte so that the subsequent calculations on
  // the number of blocks to allocate are easier...

  if( 0 == size ) {
 800511c:	2800      	cmp	r0, #0
 800511e:	d07f      	beq.n	8005220 <pvPortMalloc+0x108>
    return( (void *)NULL );
  }

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 8005120:	f7ff fce4 	bl	8004aec <vTaskSuspendAll>
  //
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
 8005124:	2e08      	cmp	r6, #8
 8005126:	d907      	bls.n	8005138 <pvPortMalloc+0x20>
    return( 1 );

  // If it's for more than that, then we need to figure out the number of
  // additional whole blocks the size of an umm_block are required.

  size -= ( 1 + (sizeof(((umm_block *)0)->body)) );
 8005128:	f1a6 0109 	sub.w	r1, r6, #9

  return( 2 + size/(sizeof(umm_block)) );
 800512c:	230c      	movs	r3, #12
 800512e:	fbb1 f1f3 	udiv	r1, r1, r3
 8005132:	3102      	adds	r1, #2
 8005134:	b289      	uxth	r1, r1
 8005136:	e000      	b.n	800513a <pvPortMalloc+0x22>
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
    return( 1 );
 8005138:	2101      	movs	r1, #1
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 800513a:	483a      	ldr	r0, [pc, #232]	; (8005224 <pvPortMalloc+0x10c>)

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;
 800513c:	f647 73ff 	movw	r3, #32767	; 0x7fff
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 8005140:	8884      	ldrh	r4, [r0, #4]
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 8005142:	2500      	movs	r5, #0
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
 8005144:	4622      	mov	r2, r4
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 8005146:	f04f 0e0c 	mov.w	lr, #12
 800514a:	e018      	b.n	800517e <pvPortMalloc+0x66>
    blockSize = (UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK) - cf;
 800514c:	f830 500c 	ldrh.w	r5, [r0, ip]
 8005150:	046d      	lsls	r5, r5, #17
 8005152:	ebc4 4555 	rsb	r5, r4, r5, lsr #17
 8005156:	b2ad      	uxth	r5, r5
#if defined UMM_FIRST_FIT
    // This is the first block that fits!
    if( (blockSize >= blocks) )
        break;
#elif defined UMM_BEST_FIT
    if( (blockSize >= blocks) && (blockSize < bestSize) ) {
 8005158:	428d      	cmp	r5, r1
 800515a:	bf34      	ite	cc
 800515c:	f04f 0c00 	movcc.w	ip, #0
 8005160:	f04f 0c01 	movcs.w	ip, #1
 8005164:	429d      	cmp	r5, r3
 8005166:	bf2c      	ite	cs
 8005168:	f04f 0c00 	movcs.w	ip, #0
 800516c:	f00c 0c01 	andcc.w	ip, ip, #1
 8005170:	f1bc 0f00 	cmp.w	ip, #0
 8005174:	bf18      	it	ne
 8005176:	4622      	movne	r2, r4
 8005178:	bf18      	it	ne
 800517a:	462b      	movne	r3, r5
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 800517c:	4634      	mov	r4, r6
  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 800517e:	fb0e fc04 	mul.w	ip, lr, r4
 8005182:	eb00 060c 	add.w	r6, r0, ip
 8005186:	88b6      	ldrh	r6, [r6, #4]
 8005188:	2e00      	cmp	r6, #0
 800518a:	d1df      	bne.n	800514c <pvPortMalloc+0x34>
#endif

    cf = UMM_NFREE(cf);
  }

  if( 0x7FFF != bestSize ) {
 800518c:	f647 70ff 	movw	r0, #32767	; 0x7fff
 8005190:	4283      	cmp	r3, r0
 8005192:	bf18      	it	ne
 8005194:	461d      	movne	r5, r3
 8005196:	bf18      	it	ne
 8005198:	4614      	movne	r4, r2
    cf        = bestBlock;
    blockSize = bestSize;
  }

  if( UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK ) {
 800519a:	220c      	movs	r2, #12
 800519c:	4362      	muls	r2, r4
 800519e:	4b21      	ldr	r3, [pc, #132]	; (8005224 <pvPortMalloc+0x10c>)
 80051a0:	5a9a      	ldrh	r2, [r3, r2]
 80051a2:	0452      	lsls	r2, r2, #17
 80051a4:	0c56      	lsrs	r6, r2, #17
 80051a6:	b182      	cbz	r2, 80051ca <pvPortMalloc+0xb2>
    // This is an existing block in the memory heap, we just need to split off
    // what we need, unlink it from the free list and mark it as in use, and
    // link the rest of the block back into the freelist as if it was a new
    // block on the free list...

    if( blockSize == blocks ) {
 80051a8:	428d      	cmp	r5, r1
 80051aa:	d103      	bne.n	80051b4 <pvPortMalloc+0x9c>
      // It's an exact fit and we don't neet to split off a block.
      DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - exact\n", blocks, cf );

      // Disconnect this block from the FREE list

      umm_disconnect_from_free_list( cf );
 80051ac:	4620      	mov	r0, r4
 80051ae:	f7ff ff43 	bl	8005038 <umm_disconnect_from_free_list>
 80051b2:	e02e      	b.n	8005212 <pvPortMalloc+0xfa>

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 80051b4:	1a6d      	subs	r5, r5, r1
 80051b6:	b2ad      	uxth	r5, r5
 80051b8:	4620      	mov	r0, r4
 80051ba:	4629      	mov	r1, r5
 80051bc:	f44f 4200 	mov.w	r2, #32768	; 0x8000

     cf += blockSize-blocks;
 80051c0:	192c      	adds	r4, r5, r4

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 80051c2:	f7ff ff1b 	bl	8004ffc <umm_make_new_block>

     cf += blockSize-blocks;
 80051c6:	b2a4      	uxth	r4, r4
 80051c8:	e023      	b.n	8005212 <pvPortMalloc+0xfa>
    // We're at the end of the heap - allocate a new block, but check to see if
    // there's enough memory left for the requested block! Actually, we may need
    // one more than that if we're initializing the umm_heap for the first
    // time, which happens in the next conditional...

    if( UMM_NUMBLOCKS <= cf+blocks+1 ) {
 80051ca:	1862      	adds	r2, r4, r1
 80051cc:	f5b2 7f55 	cmp.w	r2, #852	; 0x354
 80051d0:	db06      	blt.n	80051e0 <pvPortMalloc+0xc8>
      DBG_LOG_WARNING(  "Can't allocate %5d blocks at %5d\n", blocks, cf );
 80051d2:	4622      	mov	r2, r4
 80051d4:	4814      	ldr	r0, [pc, #80]	; (8005228 <pvPortMalloc+0x110>)
 80051d6:	f000 fb79 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>

      // Release the critical section...
      //
      UMM_CRITICAL_EXIT();
 80051da:	f7ff fcf9 	bl	8004bd0 <xTaskResumeAll>

      return( (void *)NULL );
 80051de:	e01f      	b.n	8005220 <pvPortMalloc+0x108>

    // Now check to see if we need to initialize the free list...this assumes
    // that the BSS is set to 0 on startup. We should rarely get to the end of
    // the free list so this is the "cheapest" place to put the initialization!

    if( 0 == cf ) {
 80051e0:	b91c      	cbnz	r4, 80051ea <pvPortMalloc+0xd2>
      DBG_LOG_DEBUG( "Initializing malloc free block pointer\n" );
      UMM_NBLOCK(0) = 1;
 80051e2:	2201      	movs	r2, #1
 80051e4:	801a      	strh	r2, [r3, #0]
      UMM_NFREE(0)  = 1;
 80051e6:	809a      	strh	r2, [r3, #4]
      cf            = 1;
 80051e8:	3401      	adds	r4, #1
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 80051ea:	220c      	movs	r2, #12
 80051ec:	fb02 f304 	mul.w	r3, r2, r4
 80051f0:	4e0c      	ldr	r6, [pc, #48]	; (8005224 <pvPortMalloc+0x10c>)
 80051f2:	1865      	adds	r5, r4, r1
 80051f4:	18f1      	adds	r1, r6, r3
 80051f6:	88c8      	ldrh	r0, [r1, #6]
 80051f8:	b2af      	uxth	r7, r5
 80051fa:	fb02 6000 	mla	r0, r2, r0, r6

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 80051fe:	fb02 6505 	mla	r5, r2, r5, r6
      cf            = 1;
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 8005202:	8087      	strh	r7, [r0, #4]

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 8005204:	4628      	mov	r0, r5
 8005206:	9301      	str	r3, [sp, #4]
 8005208:	f005 f98c 	bl	800a524 <memcpy>

    UMM_NBLOCK(cf)           = cf+blocks;
 800520c:	9b01      	ldr	r3, [sp, #4]
    UMM_PBLOCK(cf+blocks)    = cf;
 800520e:	806c      	strh	r4, [r5, #2]

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );

    UMM_NBLOCK(cf)           = cf+blocks;
 8005210:	52f7      	strh	r7, [r6, r3]
    UMM_PBLOCK(cf+blocks)    = cf;
  }

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 8005212:	f7ff fcdd 	bl	8004bd0 <xTaskResumeAll>

  return( (void *)&UMM_DATA(cf) );
 8005216:	4b03      	ldr	r3, [pc, #12]	; (8005224 <pvPortMalloc+0x10c>)
 8005218:	260c      	movs	r6, #12
 800521a:	fb06 3604 	mla	r6, r6, r4, r3
 800521e:	3604      	adds	r6, #4
}
 8005220:	4630      	mov	r0, r6
 8005222:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005224:	20000c3c 	.word	0x20000c3c
 8005228:	0800aef8 	.word	0x0800aef8

0800522c <Reset_Handler>:
 * @param  None
 * @retval : None
*/

void Reset_Handler(void)
{
 800522c:	4668      	mov	r0, sp
 800522e:	f020 0107 	bic.w	r1, r0, #7
 8005232:	468d      	mov	sp, r1
 8005234:	b501      	push	{r0, lr}
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8005236:	4a0a      	ldr	r2, [pc, #40]	; (8005260 <Reset_Handler+0x34>)
 8005238:	4b0a      	ldr	r3, [pc, #40]	; (8005264 <Reset_Handler+0x38>)
 800523a:	490b      	ldr	r1, [pc, #44]	; (8005268 <Reset_Handler+0x3c>)
 800523c:	e003      	b.n	8005246 <Reset_Handler+0x1a>
  {
    *(pulDest++) = *(pulSrc++);
 800523e:	f852 0b04 	ldr.w	r0, [r2], #4
 8005242:	f843 0b04 	str.w	r0, [r3], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8005246:	428b      	cmp	r3, r1
 8005248:	d3f9      	bcc.n	800523e <Reset_Handler+0x12>
 800524a:	4b08      	ldr	r3, [pc, #32]	; (800526c <Reset_Handler+0x40>)
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 800524c:	4908      	ldr	r1, [pc, #32]	; (8005270 <Reset_Handler+0x44>)
  {
    *(pulDest++) = 0;
 800524e:	2200      	movs	r2, #0
 8005250:	e001      	b.n	8005256 <Reset_Handler+0x2a>
 8005252:	f843 2b04 	str.w	r2, [r3], #4
  for(pulDest = &_sdata; pulDest < &_edata; )
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8005256:	428b      	cmp	r3, r1
 8005258:	d3fb      	bcc.n	8005252 <Reset_Handler+0x26>
  {
    *(pulDest++) = 0;
  }

  /* Call the application's entry point.*/
  main();
 800525a:	f7ff fa29 	bl	80046b0 <main>
 800525e:	e7fe      	b.n	800525e <Reset_Handler+0x32>
 8005260:	0800b208 	.word	0x0800b208
 8005264:	20000000 	.word	0x20000000
 8005268:	20000058 	.word	0x20000058
 800526c:	20000058 	.word	0x20000058
 8005270:	200037b0 	.word	0x200037b0

08005274 <_init>:
}

// dummy for newer gcc versions
void _init()
{
}
 8005274:	4770      	bx	lr

08005276 <Default_Handler>:
 * @param  None     
 * @retval : None       
*/

void Default_Handler(void) 
{
 8005276:	e7fe      	b.n	8005276 <Default_Handler>

08005278 <MIOS32_SRIO_Init>:
//! Initializes SPI pins and peripheral
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
 8005278:	b538      	push	{r3, r4, r5, lr}
  // currently only mode 0 supported
  if( mode != 0 )
 800527a:	bb50      	cbnz	r0, 80052d2 <MIOS32_SRIO_Init+0x5a>
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 800527c:	4b16      	ldr	r3, [pc, #88]	; (80052d8 <MIOS32_SRIO_Init+0x60>)

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 800527e:	4d17      	ldr	r5, [pc, #92]	; (80052dc <MIOS32_SRIO_Init+0x64>)
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 8005280:	f8df e05c 	ldr.w	lr, [pc, #92]	; 80052e0 <MIOS32_SRIO_Init+0x68>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 8005284:	f8df c05c 	ldr.w	ip, [pc, #92]	; 80052e4 <MIOS32_SRIO_Init+0x6c>
    mios32_srio_din_changed[i] = 0;   // no change
 8005288:	4917      	ldr	r1, [pc, #92]	; (80052e8 <MIOS32_SRIO_Init+0x70>)
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 800528a:	6018      	str	r0, [r3, #0]

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 800528c:	4603      	mov	r3, r0
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 800528e:	22ff      	movs	r2, #255	; 0xff

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 8005290:	542b      	strb	r3, [r5, r0]
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 8005292:	f80e 2000 	strb.w	r2, [lr, r0]
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 8005296:	f80c 2000 	strb.w	r2, [ip, r0]
    mios32_srio_din_changed[i] = 0;   // no change
 800529a:	540b      	strb	r3, [r1, r0]
 800529c:	3001      	adds	r0, #1

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 800529e:	2400      	movs	r4, #0
  srio_scan_finished_hook = NULL;

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 80052a0:	2810      	cmp	r0, #16
 80052a2:	d1f4      	bne.n	800528e <MIOS32_SRIO_Init+0x16>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
    mios32_srio_din_changed[i] = 0;   // no change
  }

  // initial state of RCLK
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 80052a4:	2001      	movs	r0, #1
 80052a6:	4602      	mov	r2, r0
 80052a8:	4621      	mov	r1, r4
 80052aa:	f001 fb17 	bl	80068dc <MIOS32_SPI_RC_PinSet>

  // init GPIO structure
  // using 2 MHz instead of 50 MHz to avoid fast transients which can cause flickering!
  // optionally using open drain mode for cheap and sufficient levelshifting from 3.3V to 5V
#if MIOS32_SRIO_OUTPUTS_OD
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 80052ae:	2103      	movs	r1, #3
 80052b0:	2001      	movs	r0, #1
 80052b2:	f001 fa63 	bl	800677c <MIOS32_SPI_IO_Init>
#else
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK);
#endif

  // init SPI port for baudrate of ca. 2 uS period @ 72 MHz
  MIOS32_SPI_TransferModeInit(MIOS32_SRIO_SPI, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_64);
 80052b6:	2205      	movs	r2, #5
 80052b8:	2001      	movs	r0, #1
 80052ba:	2103      	movs	r1, #3
 80052bc:	f001 fdac 	bl	8006e18 <MIOS32_SPI_TransferModeInit>

  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;
 80052c0:	4b0a      	ldr	r3, [pc, #40]	; (80052ec <MIOS32_SRIO_Init+0x74>)
 80052c2:	2201      	movs	r2, #1
 80052c4:	701a      	strb	r2, [r3, #0]

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 80052c6:	4b0a      	ldr	r3, [pc, #40]	; (80052f0 <MIOS32_SRIO_Init+0x78>)
  debounce_ctr = 0;
  
  return 0;
 80052c8:	4620      	mov	r0, r4
  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 80052ca:	701c      	strb	r4, [r3, #0]
  debounce_ctr = 0;
 80052cc:	4b09      	ldr	r3, [pc, #36]	; (80052f4 <MIOS32_SRIO_Init+0x7c>)
 80052ce:	701c      	strb	r4, [r3, #0]
  
  return 0;
 80052d0:	e001      	b.n	80052d6 <MIOS32_SRIO_Init+0x5e>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80052d2:	f04f 30ff 	mov.w	r0, #4294967295
  // initial debounce time (debouncing disabled)
  debounce_time = 0;
  debounce_ctr = 0;
  
  return 0;
}
 80052d6:	bd38      	pop	{r3, r4, r5, pc}
 80052d8:	200007a8 	.word	0x200007a8
 80052dc:	20003448 	.word	0x20003448
 80052e0:	20003468 	.word	0x20003468
 80052e4:	20003458 	.word	0x20003458
 80052e8:	20003438 	.word	0x20003438
 80052ec:	200007ad 	.word	0x200007ad
 80052f0:	200007ac 	.word	0x200007ac
 80052f4:	200007ae 	.word	0x200007ae

080052f8 <MIOS32_SRIO_DebounceStart>:
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 80052f8:	4b02      	ldr	r3, [pc, #8]	; (8005304 <MIOS32_SRIO_DebounceStart+0xc>)
  return 0; // no error
}
 80052fa:	2000      	movs	r0, #0
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 80052fc:	781a      	ldrb	r2, [r3, #0]
 80052fe:	4b02      	ldr	r3, [pc, #8]	; (8005308 <MIOS32_SRIO_DebounceStart+0x10>)
 8005300:	701a      	strb	r2, [r3, #0]
  return 0; // no error
}
 8005302:	4770      	bx	lr
 8005304:	200007ac 	.word	0x200007ac
 8005308:	200007ae 	.word	0x200007ae

0800530c <MIOS32_DIN_Init>:
s32 MIOS32_DIN_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 800530c:	b960      	cbnz	r0, 8005328 <MIOS32_DIN_Init+0x1c>
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 800530e:	f8df c020 	ldr.w	ip, [pc, #32]	; 8005330 <MIOS32_DIN_Init+0x24>
    mios32_srio_din_changed[i] = 0;
 8005312:	4a08      	ldr	r2, [pc, #32]	; (8005334 <MIOS32_DIN_Init+0x28>)
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 8005314:	21ff      	movs	r1, #255	; 0xff
    mios32_srio_din_changed[i] = 0;
 8005316:	4603      	mov	r3, r0
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 8005318:	f80c 1000 	strb.w	r1, [ip, r0]
    mios32_srio_din_changed[i] = 0;
 800531c:	5413      	strb	r3, [r2, r0]
 800531e:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8005320:	2810      	cmp	r0, #16
 8005322:	d1f9      	bne.n	8005318 <MIOS32_DIN_Init+0xc>
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
 8005324:	2000      	movs	r0, #0
 8005326:	e001      	b.n	800532c <MIOS32_DIN_Init+0x20>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005328:	f04f 30ff 	mov.w	r0, #4294967295
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
}
 800532c:	4770      	bx	lr
 800532e:	bf00      	nop
 8005330:	20003468 	.word	0x20003468
 8005334:	20003438 	.word	0x20003438

08005338 <MIOS32_DIN_SRChangedGetAndClear>:
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 8005338:	280f      	cmp	r0, #15
//! \param[in] mask pin mask (8bit value)
//! \return 8bit value which contains the selected (masked) change flags
//! \return no error status (-1)! - if unavailable SR selected, 0x00 will be returned
/////////////////////////////////////////////////////////////////////////////
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
 800533a:	b570      	push	{r4, r5, r6, lr}
 800533c:	4604      	mov	r4, r0
 800533e:	460e      	mov	r6, r1
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 8005340:	d80c      	bhi.n	800535c <MIOS32_DIN_SRChangedGetAndClear+0x24>
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
 8005342:	f001 f9cf 	bl	80066e4 <MIOS32_IRQ_Disable>
  changed = mios32_srio_din_changed[sr] & mask;
 8005346:	4b07      	ldr	r3, [pc, #28]	; (8005364 <MIOS32_DIN_SRChangedGetAndClear+0x2c>)
 8005348:	5d1d      	ldrb	r5, [r3, r4]
  mios32_srio_din_changed[sr] &= ~mask;
 800534a:	5d1a      	ldrb	r2, [r3, r4]
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
  changed = mios32_srio_din_changed[sr] & mask;
 800534c:	ea06 0505 	and.w	r5, r6, r5
  mios32_srio_din_changed[sr] &= ~mask;
 8005350:	ea22 0606 	bic.w	r6, r2, r6
 8005354:	551e      	strb	r6, [r3, r4]
  MIOS32_IRQ_Enable();
 8005356:	f001 f9db 	bl	8006710 <MIOS32_IRQ_Enable>

  return changed;
 800535a:	e000      	b.n	800535e <MIOS32_DIN_SRChangedGetAndClear+0x26>
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;
 800535c:	2500      	movs	r5, #0
  changed = mios32_srio_din_changed[sr] & mask;
  mios32_srio_din_changed[sr] &= ~mask;
  MIOS32_IRQ_Enable();

  return changed;
}
 800535e:	4628      	mov	r0, r5
 8005360:	bd70      	pop	{r4, r5, r6, pc}
 8005362:	bf00      	nop
 8005364:	20003438 	.word	0x20003438

08005368 <MIOS32_DIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_Handler(void *_callback)
{
 8005368:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800536a:	4606      	mov	r6, r0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
    return -1;
 800536c:	f04f 30ff 	mov.w	r0, #4294967295
#if MIOS32_SRIO_NUM_SR == 0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
 8005370:	b1fe      	cbz	r6, 80053b2 <MIOS32_DIN_Handler+0x4a>
 8005372:	2400      	movs	r4, #0

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
    
    // check if there are pin changes (mask all pins)
    changed = MIOS32_DIN_SRChangedGetAndClear(sr, 0xff);
 8005374:	4620      	mov	r0, r4
 8005376:	21ff      	movs	r1, #255	; 0xff
 8005378:	f7ff ffde 	bl	8005338 <MIOS32_DIN_SRChangedGetAndClear>
 800537c:	4607      	mov	r7, r0

    // any pin change at this SR?
    if( !changed )
 800537e:	b1a0      	cbz	r0, 80053aa <MIOS32_DIN_Handler+0x42>
 8005380:	2500      	movs	r5, #0

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 8005382:	00e3      	lsls	r3, r4, #3
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
 8005384:	fa57 f205 	asrs.w	r2, r7, r5
 8005388:	f012 0f01 	tst.w	r2, #1
 800538c:	d00a      	beq.n	80053a4 <MIOS32_DIN_Handler+0x3c>
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 800538e:	4a09      	ldr	r2, [pc, #36]	; (80053b4 <MIOS32_DIN_Handler+0x4c>)
 8005390:	18e8      	adds	r0, r5, r3
 8005392:	5d11      	ldrb	r1, [r2, r4]
 8005394:	9301      	str	r3, [sp, #4]
 8005396:	4129      	asrs	r1, r5
 8005398:	f001 0101 	and.w	r1, r1, #1
 800539c:	47b0      	blx	r6

	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
 800539e:	f7ff ffab 	bl	80052f8 <MIOS32_SRIO_DebounceStart>
 80053a2:	9b01      	ldr	r3, [sp, #4]
    // any pin change at this SR?
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
 80053a4:	3501      	adds	r5, #1
 80053a6:	2d08      	cmp	r5, #8
 80053a8:	d1ec      	bne.n	8005384 <MIOS32_DIN_Handler+0x1c>
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
 80053aa:	3401      	adds	r4, #1
 80053ac:	2c10      	cmp	r4, #16
 80053ae:	d1e1      	bne.n	8005374 <MIOS32_DIN_Handler+0xc>
	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
      }
  }

  return 0;
 80053b0:	2000      	movs	r0, #0
}
 80053b2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80053b4:	20003468 	.word	0x20003468

080053b8 <MIOS32_DOUT_Init>:
s32 MIOS32_DOUT_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 80053b8:	b938      	cbnz	r0, 80053ca <MIOS32_DOUT_Init+0x12>
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
 80053ba:	4a05      	ldr	r2, [pc, #20]	; (80053d0 <MIOS32_DOUT_Init+0x18>)
 80053bc:	4603      	mov	r3, r0
 80053be:	5413      	strb	r3, [r2, r0]
 80053c0:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 80053c2:	2810      	cmp	r0, #16
 80053c4:	d1fb      	bne.n	80053be <MIOS32_DOUT_Init+0x6>
    mios32_srio_dout[i] = 0;
  }

  return 0;
 80053c6:	2000      	movs	r0, #0
 80053c8:	e001      	b.n	80053ce <MIOS32_DOUT_Init+0x16>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80053ca:	f04f 30ff 	mov.w	r0, #4294967295
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
  }

  return 0;
}
 80053ce:	4770      	bx	lr
 80053d0:	20003448 	.word	0x20003448

080053d4 <MIOS32_ENC_Init>:
//! Initializes encoder driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Init(u32 mode)
{
 80053d4:	b510      	push	{r4, lr}
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 80053d6:	bb20      	cbnz	r0, 8005422 <MIOS32_ENC_Init+0x4e>
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 80053d8:	4c13      	ldr	r4, [pc, #76]	; (8005428 <MIOS32_ENC_Init+0x54>)

    enc_state[i].state = 0xf; // all pins released
 80053da:	4914      	ldr	r1, [pc, #80]	; (800542c <MIOS32_ENC_Init+0x58>)
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 80053dc:	4602      	mov	r2, r0
 80053de:	f804 2020 	strb.w	r2, [r4, r0, lsl #2]

    enc_state[i].state = 0xf; // all pins released
 80053e2:	f811 3030 	ldrb.w	r3, [r1, r0, lsl #3]
    enc_state[i].decinc = 0;
 80053e6:	f043 030f 	orr.w	r3, r3, #15
 80053ea:	f36f 1304 	bfc	r3, #4, #1
 80053ee:	f801 3030 	strb.w	r3, [r1, r0, lsl #3]
    enc_state[i].incrementer = 0;
 80053f2:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
 80053f6:	f893 c003 	ldrb.w	ip, [r3, #3]
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 80053fa:	3001      	adds	r0, #1
    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
 80053fc:	f00c 0cf0 	and.w	ip, ip, #240	; 0xf0
 8005400:	f36f 1c07 	bfc	ip, #4, #4
 8005404:	f883 c003 	strb.w	ip, [r3, #3]
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 8005408:	f893 c005 	ldrb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 800540c:	2840      	cmp	r0, #64	; 0x40
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 800540e:	f36f 0c03 	bfc	ip, #0, #4
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder

    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
 8005412:	705a      	strb	r2, [r3, #1]
    enc_state[i].accelerator = 0;
 8005414:	709a      	strb	r2, [r3, #2]
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
 8005416:	711a      	strb	r2, [r3, #4]
    enc_state[i].predivider = 0;
 8005418:	f883 c005 	strb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 800541c:	d1df      	bne.n	80053de <MIOS32_ENC_Init+0xa>
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
 800541e:	2000      	movs	r0, #0
 8005420:	e001      	b.n	8005426 <MIOS32_ENC_Init+0x52>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005422:	f04f 30ff 	mov.w	r0, #4294967295
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
}
 8005426:	bd10      	pop	{r4, pc}
 8005428:	20003478 	.word	0x20003478
 800542c:	20003578 	.word	0x20003578

08005430 <MIOS32_ENC_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Handler(void *_callback)
{
 8005430:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005432:	4605      	mov	r5, r0
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
    return -1;
 8005434:	f04f 30ff 	mov.w	r0, #4294967295
  u8 enc;
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
 8005438:	b1bd      	cbz	r5, 800546a <MIOS32_ENC_Handler+0x3a>
 800543a:	2400      	movs	r4, #0
  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
    if( (incrementer = enc_state[enc].incrementer) ) {
 800543c:	4f0b      	ldr	r7, [pc, #44]	; (800546c <MIOS32_ENC_Handler+0x3c>)
      enc_state[enc].incrementer = 0;
 800543e:	4626      	mov	r6, r4

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
 8005440:	f001 f950 	bl	80066e4 <MIOS32_IRQ_Disable>
    if( (incrementer = enc_state[enc].incrementer) ) {
 8005444:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
 8005448:	f993 1001 	ldrsb.w	r1, [r3, #1]
 800544c:	b139      	cbz	r1, 800545e <MIOS32_ENC_Handler+0x2e>
      enc_state[enc].incrementer = 0;
 800544e:	705e      	strb	r6, [r3, #1]
      MIOS32_IRQ_Enable();
 8005450:	9101      	str	r1, [sp, #4]
 8005452:	f001 f95d 	bl	8006710 <MIOS32_IRQ_Enable>

      // call the hook
      callback(enc, incrementer);
 8005456:	4620      	mov	r0, r4
 8005458:	9901      	ldr	r1, [sp, #4]
 800545a:	47a8      	blx	r5
 800545c:	e001      	b.n	8005462 <MIOS32_ENC_Handler+0x32>
    } else {
      MIOS32_IRQ_Enable();
 800545e:	f001 f957 	bl	8006710 <MIOS32_IRQ_Enable>
 8005462:	3401      	adds	r4, #1
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
 8005464:	2c40      	cmp	r4, #64	; 0x40
 8005466:	d1eb      	bne.n	8005440 <MIOS32_ENC_Handler+0x10>
    } else {
      MIOS32_IRQ_Enable();
    }
  }

  return 0; // no error
 8005468:	2000      	movs	r0, #0
}
 800546a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800546c:	20003578 	.word	0x20003578

08005470 <MIOS32_LCD_DeviceSet>:
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 8005470:	4b01      	ldr	r3, [pc, #4]	; (8005478 <MIOS32_LCD_DeviceSet+0x8>)
 8005472:	7018      	strb	r0, [r3, #0]

  return 0; // no error
}
 8005474:	2000      	movs	r0, #0
 8005476:	4770      	bx	lr
 8005478:	200007af 	.word	0x200007af

0800547c <MIOS32_LCD_CursorSet>:
//! \param[in] column number
//! \param[in] line number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorSet(u16 column, u16 line)
{
 800547c:	b508      	push	{r3, lr}
  // set character position
  mios32_lcd_column = column;
 800547e:	4b0b      	ldr	r3, [pc, #44]	; (80054ac <MIOS32_LCD_CursorSet+0x30>)
 8005480:	8018      	strh	r0, [r3, #0]
  mios32_lcd_line = line;
 8005482:	4b0b      	ldr	r3, [pc, #44]	; (80054b0 <MIOS32_LCD_CursorSet+0x34>)
 8005484:	8019      	strh	r1, [r3, #0]

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
  if( font_bitmap.width ) {
 8005486:	4b0b      	ldr	r3, [pc, #44]	; (80054b4 <MIOS32_LCD_CursorSet+0x38>)
 8005488:	889a      	ldrh	r2, [r3, #4]
 800548a:	b112      	cbz	r2, 8005492 <MIOS32_LCD_CursorSet+0x16>
    font_width = font_bitmap.width;
 800548c:	b2d2      	uxtb	r2, r2
    font_height = font_bitmap.height;
 800548e:	799b      	ldrb	r3, [r3, #6]
 8005490:	e001      	b.n	8005496 <MIOS32_LCD_CursorSet+0x1a>
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
 8005492:	2308      	movs	r3, #8
  // set character position
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
 8005494:	2206      	movs	r2, #6
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 8005496:	4342      	muls	r2, r0
 8005498:	f8df c01c 	ldr.w	ip, [pc, #28]	; 80054b8 <MIOS32_LCD_CursorSet+0x3c>
  mios32_lcd_y = line * font_height;
 800549c:	434b      	muls	r3, r1
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 800549e:	f8ac 2000 	strh.w	r2, [ip]
  mios32_lcd_y = line * font_height;
 80054a2:	4a06      	ldr	r2, [pc, #24]	; (80054bc <MIOS32_LCD_CursorSet+0x40>)
 80054a4:	8013      	strh	r3, [r2, #0]

  // forward new cursor position to app driver
  return APP_LCD_CursorSet(column, line);
 80054a6:	f004 fff5 	bl	800a494 <APP_LCD_CursorSet>
}
 80054aa:	bd08      	pop	{r3, pc}
 80054ac:	20003786 	.word	0x20003786
 80054b0:	2000378c 	.word	0x2000378c
 80054b4:	20003778 	.word	0x20003778
 80054b8:	20003790 	.word	0x20003790
 80054bc:	20003784 	.word	0x20003784

080054c0 <MIOS32_LCD_GCursorSet>:
//! \param[in] x position
//! \param[in] y position
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_GCursorSet(u16 x, u16 y)
{
 80054c0:	b508      	push	{r3, lr}
  mios32_lcd_x = x;
 80054c2:	4b03      	ldr	r3, [pc, #12]	; (80054d0 <MIOS32_LCD_GCursorSet+0x10>)
 80054c4:	8018      	strh	r0, [r3, #0]
  mios32_lcd_y = y;
 80054c6:	4b03      	ldr	r3, [pc, #12]	; (80054d4 <MIOS32_LCD_GCursorSet+0x14>)
 80054c8:	8019      	strh	r1, [r3, #0]

  // forward new cursor position to app driver
  return APP_LCD_GCursorSet(x, y);
 80054ca:	f004 fff5 	bl	800a4b8 <APP_LCD_GCursorSet>
}
 80054ce:	bd08      	pop	{r3, pc}
 80054d0:	20003790 	.word	0x20003790
 80054d4:	20003784 	.word	0x20003784

080054d8 <MIOS32_LCD_CursorMapSet>:
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
    mios32_lcd_cursor_map[i] = map_table[i];
 80054d8:	4a04      	ldr	r2, [pc, #16]	; (80054ec <MIOS32_LCD_CursorMapSet+0x14>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 80054da:	2300      	movs	r3, #0
    mios32_lcd_cursor_map[i] = map_table[i];
 80054dc:	5cc1      	ldrb	r1, [r0, r3]
 80054de:	5499      	strb	r1, [r3, r2]
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 80054e0:	3301      	adds	r3, #1
 80054e2:	2b04      	cmp	r3, #4
 80054e4:	d1fa      	bne.n	80054dc <MIOS32_LCD_CursorMapSet+0x4>
    mios32_lcd_cursor_map[i] = map_table[i];

  return 0; // no error
}
 80054e6:	2000      	movs	r0, #0
 80054e8:	4770      	bx	lr
 80054ea:	bf00      	nop
 80054ec:	20003788 	.word	0x20003788

080054f0 <MIOS32_LCD_Init>:
//! Initializes LCD driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Init(u32 mode)
{
 80054f0:	b513      	push	{r0, r1, r4, lr}
 80054f2:	4604      	mov	r4, r0
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80054f4:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_Init(u32 mode)
{
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
 80054f8:	b9d4      	cbnz	r4, 8005530 <MIOS32_LCD_Init+0x40>
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 80054fa:	4b0e      	ldr	r3, [pc, #56]	; (8005534 <MIOS32_LCD_Init+0x44>)

  // disable font bitmap
  font_bitmap.width = 0;

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 80054fc:	a802      	add	r0, sp, #8
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 80054fe:	701c      	strb	r4, [r3, #0]

  // disable font bitmap
  font_bitmap.width = 0;
 8005500:	4b0d      	ldr	r3, [pc, #52]	; (8005538 <MIOS32_LCD_Init+0x48>)
 8005502:	809c      	strh	r4, [r3, #4]

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 8005504:	4b0d      	ldr	r3, [pc, #52]	; (800553c <MIOS32_LCD_Init+0x4c>)
 8005506:	681b      	ldr	r3, [r3, #0]
 8005508:	f840 3d04 	str.w	r3, [r0, #-4]!
  MIOS32_LCD_CursorMapSet(cursor_map);
 800550c:	f7ff ffe4 	bl	80054d8 <MIOS32_LCD_CursorMapSet>
  // note: this has to be done before APP_LCD_Init() is called, so that
  // the driver is able to modify the default cursor mapping
  // usage example: "dog" LCDs

  // call application specific init function
  if( (ret=APP_LCD_Init(mode)) < 0 )
 8005510:	4620      	mov	r0, r4
 8005512:	f004 ff51 	bl	800a3b8 <APP_LCD_Init>
 8005516:	2800      	cmp	r0, #0
 8005518:	db0a      	blt.n	8005530 <MIOS32_LCD_Init+0x40>
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
  // -> forward to app_lcd
  return APP_LCD_Clear();
 800551a:	f004 ffb5 	bl	800a488 <APP_LCD_Clear>

  // clear screen
  MIOS32_LCD_Clear();

  // set character and graphical cursor to initial position
  MIOS32_LCD_CursorSet(0, 0);
 800551e:	4621      	mov	r1, r4
 8005520:	4620      	mov	r0, r4
 8005522:	f7ff ffab 	bl	800547c <MIOS32_LCD_CursorSet>
  MIOS32_LCD_GCursorSet(0, 0);
 8005526:	4620      	mov	r0, r4
 8005528:	4621      	mov	r1, r4
 800552a:	f7ff ffc9 	bl	80054c0 <MIOS32_LCD_GCursorSet>

  return 0; // no error
 800552e:	4620      	mov	r0, r4
}
 8005530:	bd1c      	pop	{r2, r3, r4, pc}
 8005532:	bf00      	nop
 8005534:	2000378e 	.word	0x2000378e
 8005538:	20003778 	.word	0x20003778
 800553c:	0800af1c 	.word	0x0800af1c

08005540 <MIOS32_LCD_Clear>:
/////////////////////////////////////////////////////////////////////////////
//! Clear Screen
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
 8005540:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_Clear();
 8005542:	f004 ffa1 	bl	800a488 <APP_LCD_Clear>
}
 8005546:	bd08      	pop	{r3, pc}

08005548 <MIOS32_LCD_PrintChar>:
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 8005548:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 800554a:	4b13      	ldr	r3, [pc, #76]	; (8005598 <MIOS32_LCD_PrintChar+0x50>)
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 800554c:	4684      	mov	ip, r0
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 800554e:	781b      	ldrb	r3, [r3, #0]
 8005550:	2b01      	cmp	r3, #1
 8005552:	d117      	bne.n	8005584 <MIOS32_LCD_PrintChar+0x3c>
    if( !font_bitmap.width )
 8005554:	4b11      	ldr	r3, [pc, #68]	; (800559c <MIOS32_LCD_PrintChar+0x54>)
      return -1;    // font not initialized yet!
 8005556:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_PrintChar(char c)
{
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
 800555a:	889a      	ldrh	r2, [r3, #4]
 800555c:	b1d2      	cbz	r2, 8005594 <MIOS32_LCD_PrintChar+0x4c>
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 800555e:	f10d 0e04 	add.w	lr, sp, #4
 8005562:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8005566:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
 800556a:	88da      	ldrh	r2, [r3, #6]
 800556c:	8919      	ldrh	r1, [r3, #8]
 800556e:	08d2      	lsrs	r2, r2, #3
 8005570:	434a      	muls	r2, r1
 8005572:	fb0c 0c02 	mla	ip, ip, r2, r0

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 8005576:	f8cd c004 	str.w	ip, [sp, #4]
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
    status = APP_LCD_BitmapPrint(bitmap);
 800557a:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 800557e:	f004 ffa4 	bl	800a4ca <APP_LCD_BitmapPrint>
 8005582:	e001      	b.n	8005588 <MIOS32_LCD_PrintChar+0x40>
  } else {
    status = APP_LCD_Data(c);
 8005584:	f004 feb4 	bl	800a2f0 <APP_LCD_Data>
  }

  if( status >= 0 ) {
 8005588:	2800      	cmp	r0, #0
 800558a:	db03      	blt.n	8005594 <MIOS32_LCD_PrintChar+0x4c>
    // increment cursor
    ++mios32_lcd_column;
 800558c:	4b04      	ldr	r3, [pc, #16]	; (80055a0 <MIOS32_LCD_PrintChar+0x58>)
 800558e:	881a      	ldrh	r2, [r3, #0]
 8005590:	3201      	adds	r2, #1
 8005592:	801a      	strh	r2, [r3, #0]
  }

  return status;
}
 8005594:	b005      	add	sp, #20
 8005596:	bd00      	pop	{pc}
 8005598:	2000378e 	.word	0x2000378e
 800559c:	20003778 	.word	0x20003778
 80055a0:	20003786 	.word	0x20003786

080055a4 <MIOS32_LCD_PrintString>:
//! Prints a \\0 (zero) terminated string
//! \param[in] str pointer to string
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
 80055a4:	b538      	push	{r3, r4, r5, lr}
 80055a6:	4605      	mov	r5, r0
  s32 status = 0;
 80055a8:	2400      	movs	r4, #0

  while( *str != '\0' )
 80055aa:	e002      	b.n	80055b2 <MIOS32_LCD_PrintString+0xe>
    status |= MIOS32_LCD_PrintChar(*str++);
 80055ac:	f7ff ffcc 	bl	8005548 <MIOS32_LCD_PrintChar>
 80055b0:	4304      	orrs	r4, r0
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
  s32 status = 0;

  while( *str != '\0' )
 80055b2:	f815 0b01 	ldrb.w	r0, [r5], #1
 80055b6:	2800      	cmp	r0, #0
 80055b8:	d1f8      	bne.n	80055ac <MIOS32_LCD_PrintString+0x8>
    status |= MIOS32_LCD_PrintChar(*str++);

  return status;
}
 80055ba:	4620      	mov	r0, r4
 80055bc:	bd38      	pop	{r3, r4, r5, pc}
	...

080055c0 <MIOS32_LCD_PrintBootMessage>:
//! The message is automatically print by the programming model after each reset.<BR>
//! It will also be returned on a SysEx query.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintBootMessage(void)
{
 80055c0:	b538      	push	{r3, r4, r5, lr}
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 80055c2:	4b0c      	ldr	r3, [pc, #48]	; (80055f4 <MIOS32_LCD_PrintBootMessage+0x34>)
 80055c4:	2400      	movs	r4, #0
 80055c6:	701c      	strb	r4, [r3, #0]
s32 MIOS32_LCD_PrintBootMessage(void)
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
 80055c8:	4621      	mov	r1, r4
 80055ca:	4620      	mov	r0, r4
 80055cc:	f7ff ff56 	bl	800547c <MIOS32_LCD_CursorSet>
 80055d0:	4605      	mov	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 80055d2:	4809      	ldr	r0, [pc, #36]	; (80055f8 <MIOS32_LCD_PrintBootMessage+0x38>)
 80055d4:	f7ff ffe6 	bl	80055a4 <MIOS32_LCD_PrintString>
  status |= MIOS32_LCD_CursorSet(0, 1);
 80055d8:	2101      	movs	r1, #1
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 80055da:	ea40 0505 	orr.w	r5, r0, r5
  status |= MIOS32_LCD_CursorSet(0, 1);
 80055de:	4620      	mov	r0, r4
 80055e0:	f7ff ff4c 	bl	800547c <MIOS32_LCD_CursorSet>
 80055e4:	4305      	orrs	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE2);
 80055e6:	4805      	ldr	r0, [pc, #20]	; (80055fc <MIOS32_LCD_PrintBootMessage+0x3c>)
 80055e8:	f7ff ffdc 	bl	80055a4 <MIOS32_LCD_PrintString>
 80055ec:	ea45 0000 	orr.w	r0, r5, r0

  return status;
}
 80055f0:	bd38      	pop	{r3, r4, r5, pc}
 80055f2:	bf00      	nop
 80055f4:	200007af 	.word	0x200007af
 80055f8:	0800af20 	.word	0x0800af20
 80055fc:	0800af31 	.word	0x0800af31

08005600 <MIOS32_LCD_PrintFormattedString>:
//! \param[in] *format zero-terminated format string - 64 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
 8005600:	b40f      	push	{r0, r1, r2, r3}
 8005602:	b510      	push	{r4, lr}
 8005604:	b092      	sub	sp, #72	; 0x48
 8005606:	aa14      	add	r2, sp, #80	; 0x50
 8005608:	f852 1b04 	ldr.w	r1, [r2], #4
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
  vsprintf((char *)buffer, format, args);
 800560c:	ac01      	add	r4, sp, #4
 800560e:	4620      	mov	r0, r4
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
 8005610:	9211      	str	r2, [sp, #68]	; 0x44
  vsprintf((char *)buffer, format, args);
 8005612:	f003 fa0a 	bl	8008a2a <vsprintf>
  return MIOS32_LCD_PrintString(buffer);
 8005616:	4620      	mov	r0, r4
 8005618:	f7ff ffc4 	bl	80055a4 <MIOS32_LCD_PrintString>
}
 800561c:	b012      	add	sp, #72	; 0x48
 800561e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8005622:	b004      	add	sp, #16
 8005624:	4770      	bx	lr

08005626 <MIOS32_LCD_BColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_BColourSet(u32 rgb)
{
 8005626:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_BColourSet(rgb);
 8005628:	f004 ff49 	bl	800a4be <APP_LCD_BColourSet>
}
 800562c:	bd08      	pop	{r3, pc}

0800562e <MIOS32_LCD_FColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_FColourSet(u32 rgb)
{
 800562e:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_FColourSet(rgb);
 8005630:	f004 ff48 	bl	800a4c4 <APP_LCD_FColourSet>
}
 8005634:	bd08      	pop	{r3, pc}
	...

08005638 <MIOS32_MIDI_Init>:
//! Initializes MIDI layer
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
 8005638:	b538      	push	{r3, r4, r5, lr}
 800563a:	4604      	mov	r4, r0
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800563c:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 8005640:	2c00      	cmp	r4, #0
 8005642:	d12c      	bne.n	800569e <MIOS32_MIDI_Init+0x66>
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
 8005644:	4a16      	ldr	r2, [pc, #88]	; (80056a0 <MIOS32_MIDI_Init+0x68>)
 8005646:	2310      	movs	r3, #16
 8005648:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 800564a:	4a16      	ldr	r2, [pc, #88]	; (80056a4 <MIOS32_MIDI_Init+0x6c>)
  timeout_callback_func = NULL;
  debug_command_callback_func = NULL;

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 800564c:	4620      	mov	r0, r4
  if( mode != 0 )
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 800564e:	7013      	strb	r3, [r2, #0]

  // disable callback functions
  direct_rx_callback_func = NULL;
 8005650:	4b15      	ldr	r3, [pc, #84]	; (80056a8 <MIOS32_MIDI_Init+0x70>)
 8005652:	601c      	str	r4, [r3, #0]
  direct_tx_callback_func = NULL;
 8005654:	4b15      	ldr	r3, [pc, #84]	; (80056ac <MIOS32_MIDI_Init+0x74>)
 8005656:	601c      	str	r4, [r3, #0]
  sysex_callback_func = NULL;
 8005658:	4b15      	ldr	r3, [pc, #84]	; (80056b0 <MIOS32_MIDI_Init+0x78>)
 800565a:	601c      	str	r4, [r3, #0]
  timeout_callback_func = NULL;
 800565c:	4b15      	ldr	r3, [pc, #84]	; (80056b4 <MIOS32_MIDI_Init+0x7c>)
 800565e:	601c      	str	r4, [r3, #0]
  debug_command_callback_func = NULL;
 8005660:	4b15      	ldr	r3, [pc, #84]	; (80056b8 <MIOS32_MIDI_Init+0x80>)
 8005662:	601c      	str	r4, [r3, #0]

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 8005664:	f002 fc54 	bl	8007f10 <MIOS32_USB_MIDI_Init>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;
 8005668:	0fc5      	lsrs	r5, r0, #31
  if( MIOS32_USB_MIDI_Init(0) < 0 )
    ret |= (1 << 0);
#endif

#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
 800566a:	4620      	mov	r0, r4
 800566c:	f000 fd2c 	bl	80060c8 <MIOS32_UART_MIDI_Init>
 8005670:	2800      	cmp	r0, #0
    ret |= (1 << 1);
 8005672:	bfb8      	it	lt
 8005674:	f045 0502 	orrlt.w	r5, r5, #2
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 8005678:	2000      	movs	r0, #0
 800567a:	f000 fec3 	bl	8006404 <MIOS32_IIC_MIDI_Init>
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
 800567e:	4a0f      	ldr	r2, [pc, #60]	; (80056bc <MIOS32_MIDI_Init+0x84>)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
    ret |= (1 << 1);
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 8005680:	2800      	cmp	r0, #0
    ret |= (1 << 2);
 8005682:	bfb8      	it	lt
 8005684:	f045 0504 	orrlt.w	r5, r5, #4
#endif

  last_sysex_port = DEFAULT;
 8005688:	2300      	movs	r3, #0
 800568a:	7013      	strb	r3, [r2, #0]
  sysex_state.ALL = 0;
 800568c:	4a0c      	ldr	r2, [pc, #48]	; (80056c0 <MIOS32_MIDI_Init+0x88>)

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
  sysex_timeout_ctr_flags.ALL = 0;

  return -ret;
 800568e:	4268      	negs	r0, r5
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
  sysex_state.ALL = 0;
 8005690:	7013      	strb	r3, [r2, #0]

  // TODO: allow to change device ID (read from flash, resp. BSL based EEPROM emulation)
  sysex_device_id = 0x00;
 8005692:	4a0c      	ldr	r2, [pc, #48]	; (80056c4 <MIOS32_MIDI_Init+0x8c>)
 8005694:	7013      	strb	r3, [r2, #0]

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
 8005696:	4a0c      	ldr	r2, [pc, #48]	; (80056c8 <MIOS32_MIDI_Init+0x90>)
 8005698:	8013      	strh	r3, [r2, #0]
  sysex_timeout_ctr_flags.ALL = 0;
 800569a:	4a0c      	ldr	r2, [pc, #48]	; (80056cc <MIOS32_MIDI_Init+0x94>)
 800569c:	6013      	str	r3, [r2, #0]

  return -ret;
}
 800569e:	bd38      	pop	{r3, r4, r5, pc}
 80056a0:	20000004 	.word	0x20000004
 80056a4:	20000005 	.word	0x20000005
 80056a8:	200007b8 	.word	0x200007b8
 80056ac:	200007b0 	.word	0x200007b0
 80056b0:	200007d4 	.word	0x200007d4
 80056b4:	200007d8 	.word	0x200007d8
 80056b8:	200007cc 	.word	0x200007cc
 80056bc:	200007bc 	.word	0x200007bc
 80056c0:	200007c4 	.word	0x200007c4
 80056c4:	200007bd 	.word	0x200007bd
 80056c8:	200007be 	.word	0x200007be
 80056cc:	200007d0 	.word	0x200007d0

080056d0 <MIOS32_MIDI_SendPackage>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 80056d0:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] package MIDI package
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
 80056d4:	b570      	push	{r4, r5, r6, lr}
 80056d6:	4605      	mov	r5, r0
 80056d8:	460c      	mov	r4, r1
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 80056da:	d104      	bne.n	80056e6 <MIOS32_MIDI_SendPackage+0x16>
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
 80056dc:	2801      	cmp	r0, #1
 80056de:	bf0c      	ite	eq
 80056e0:	4b16      	ldreq	r3, [pc, #88]	; (800573c <MIOS32_MIDI_SendPackage+0x6c>)
 80056e2:	4b17      	ldrne	r3, [pc, #92]	; (8005740 <MIOS32_MIDI_SendPackage+0x70>)
 80056e4:	781d      	ldrb	r5, [r3, #0]

  // insert subport number into package
  package.cable = port & 0xf;

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 80056e6:	4b17      	ldr	r3, [pc, #92]	; (8005744 <MIOS32_MIDI_SendPackage+0x74>)
  if( !(port & 0xf0) ) {
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
  }

  // insert subport number into package
  package.cable = port & 0xf;
 80056e8:	f005 060f 	and.w	r6, r5, #15

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 80056ec:	681b      	ldr	r3, [r3, #0]
 80056ee:	b12b      	cbz	r3, 80056fc <MIOS32_MIDI_SendPackage+0x2c>
 80056f0:	f366 1407 	bfi	r4, r6, #4, #4
    s32 status;
    if( (status=direct_tx_callback_func(port, package)) )
 80056f4:	4628      	mov	r0, r5
 80056f6:	4621      	mov	r1, r4
 80056f8:	4798      	blx	r3
 80056fa:	b9e8      	cbnz	r0, 8005738 <MIOS32_MIDI_SendPackage+0x68>
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 80056fc:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 8005700:	2d20      	cmp	r5, #32
 8005702:	d00c      	beq.n	800571e <MIOS32_MIDI_SendPackage+0x4e>
 8005704:	2d30      	cmp	r5, #48	; 0x30
 8005706:	d011      	beq.n	800572c <MIOS32_MIDI_SendPackage+0x5c>
 8005708:	2d10      	cmp	r5, #16
      return -1; // IIC_MIDI has been disabled
#endif
      
    default:
      // invalid port
      return -1;
 800570a:	bf18      	it	ne
 800570c:	f04f 30ff 	movne.w	r0, #4294967295
    if( (status=direct_tx_callback_func(port, package)) )
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 8005710:	d112      	bne.n	8005738 <MIOS32_MIDI_SendPackage+0x68>
 8005712:	f366 1407 	bfi	r4, r6, #4, #4
    case USB0://..15
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      return MIOS32_USB_MIDI_PackageSend(package);
 8005716:	4620      	mov	r0, r4
 8005718:	f002 fc6c 	bl	8007ff4 <MIOS32_USB_MIDI_PackageSend>
 800571c:	e00c      	b.n	8005738 <MIOS32_MIDI_SendPackage+0x68>
 800571e:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // USB has been disabled
#endif

    case UART0://..15
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
      return MIOS32_UART_MIDI_PackageSend(package.cable, package);
 8005722:	4630      	mov	r0, r6
 8005724:	4621      	mov	r1, r4
 8005726:	f000 fd89 	bl	800623c <MIOS32_UART_MIDI_PackageSend>
 800572a:	e005      	b.n	8005738 <MIOS32_MIDI_SendPackage+0x68>
 800572c:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // UART_MIDI has been disabled
#endif

    case IIC0://..15
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      return MIOS32_IIC_MIDI_PackageSend(package.cable, package);
 8005730:	4630      	mov	r0, r6
 8005732:	4621      	mov	r1, r4
 8005734:	f000 fe6b 	bl	800640e <MIOS32_IIC_MIDI_PackageSend>
      
    default:
      // invalid port
      return -1;
  }
}
 8005738:	bd70      	pop	{r4, r5, r6, pc}
 800573a:	bf00      	nop
 800573c:	20000005 	.word	0x20000005
 8005740:	20000004 	.word	0x20000004
 8005744:	200007b0 	.word	0x200007b0

08005748 <MIOS32_MIDI_SendEvent>:
//! \param[in] evnt2 third MIDI byte
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendEvent(mios32_midi_port_t port, u8 evnt0, u8 evnt1, u8 evnt2)
{
 8005748:	b508      	push	{r3, lr}

  // MEMO: don't optimize this function by calling MIOS32_MIDI_SendSpecialEvent
  // from here, because the 4 * u8 parameter list of this function leads
  // to best compile results (4*u8 combined to a single u32)

  package.type  = evnt0 >> 4;
 800574a:	f04f 0c00 	mov.w	ip, #0
 800574e:	ea4f 1e11 	mov.w	lr, r1, lsr #4
 8005752:	f36e 0c03 	bfi	ip, lr, #0, #4
  package.evnt0 = evnt0;
 8005756:	f361 2c0f 	bfi	ip, r1, #8, #8
  package.evnt1 = evnt1;
 800575a:	f362 4c17 	bfi	ip, r2, #16, #8
  package.evnt2 = evnt2;
 800575e:	f363 6c1f 	bfi	ip, r3, #24, #8
  return MIOS32_MIDI_SendPackage(port, package);
 8005762:	4661      	mov	r1, ip
 8005764:	f7ff ffb4 	bl	80056d0 <MIOS32_MIDI_SendPackage>
}
 8005768:	bd08      	pop	{r3, pc}

0800576a <MIOS32_MIDI_SendNoteOn>:

s32 MIOS32_MIDI_SendNoteOff(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x80 | chn, note, vel); }

s32 MIOS32_MIDI_SendNoteOn(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x90 | chn, note, vel); }
 800576a:	b508      	push	{r3, lr}
 800576c:	f041 0190 	orr.w	r1, r1, #144	; 0x90
 8005770:	f7ff ffea 	bl	8005748 <MIOS32_MIDI_SendEvent>
 8005774:	bd08      	pop	{r3, pc}

08005776 <MIOS32_MIDI_SendCC>:

s32 MIOS32_MIDI_SendPolyPressure(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xa0 | chn, note, val); }

s32 MIOS32_MIDI_SendCC(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 cc_number, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xb0 | chn, cc_number,   val); }
 8005776:	b508      	push	{r3, lr}
 8005778:	f041 01b0 	orr.w	r1, r1, #176	; 0xb0
 800577c:	f7ff ffe4 	bl	8005748 <MIOS32_MIDI_SendEvent>
 8005780:	bd08      	pop	{r3, pc}

08005782 <MIOS32_MIDI_SendSysEx>:
//! \param[in] count number of bytes
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendSysEx(mios32_midi_port_t port, u8 *stream, u32 count)
{
 8005782:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005784:	b085      	sub	sp, #20
 8005786:	4617      	mov	r7, r2
 8005788:	9003      	str	r0, [sp, #12]
 800578a:	460d      	mov	r5, r1
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 800578c:	2600      	movs	r6, #0
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 800578e:	2306      	movs	r3, #6
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 8005790:	2207      	movs	r2, #7
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 8005792:	f04f 0c04 	mov.w	ip, #4
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 8005796:	e040      	b.n	800581a <MIOS32_MIDI_SendSysEx+0x98>
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 8005798:	1bb9      	subs	r1, r7, r6
 800579a:	2902      	cmp	r1, #2
 800579c:	d014      	beq.n	80057c8 <MIOS32_MIDI_SendSysEx+0x46>
 800579e:	2903      	cmp	r1, #3
 80057a0:	d01f      	beq.n	80057e2 <MIOS32_MIDI_SendSysEx+0x60>
 80057a2:	2901      	cmp	r1, #1
 80057a4:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 80057a6:	bf18      	it	ne
 80057a8:	f36c 0403 	bfine	r4, ip, #0, #4
 80057ac:	f106 0601 	add.w	r6, r6, #1
	package.evnt0 = stream[offset++];
 80057b0:	bf18      	it	ne
 80057b2:	f361 240f 	bfine	r4, r1, #8, #8

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 80057b6:	d11a      	bne.n	80057ee <MIOS32_MIDI_SendSysEx+0x6c>
      case 1: 
	package.type = 0x5; // SysEx ends with following single byte. 
 80057b8:	2005      	movs	r0, #5
 80057ba:	f360 0403 	bfi	r4, r0, #0, #4
	package.evnt0 = stream[offset++];
 80057be:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = 0x00;
 80057c2:	f36f 4417 	bfc	r4, #16, #8
 80057c6:	e009      	b.n	80057dc <MIOS32_MIDI_SendSysEx+0x5a>
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
	package.evnt0 = stream[offset++];
 80057c8:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 80057ca:	f363 0403 	bfi	r4, r3, #0, #4
	package.evnt0 = stream[offset++];
 80057ce:	3601      	adds	r6, #1
 80057d0:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = stream[offset++];
 80057d4:	5da9      	ldrb	r1, [r5, r6]
 80057d6:	3601      	adds	r6, #1
 80057d8:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = 0x00;
 80057dc:	f36f 641f 	bfc	r4, #24, #8
	break;
 80057e0:	e00d      	b.n	80057fe <MIOS32_MIDI_SendSysEx+0x7c>
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
	package.evnt0 = stream[offset++];
 80057e2:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 80057e4:	f362 0403 	bfi	r4, r2, #0, #4
	package.evnt0 = stream[offset++];
 80057e8:	f361 240f 	bfi	r4, r1, #8, #8
 80057ec:	3601      	adds	r6, #1
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
 80057ee:	5da9      	ldrb	r1, [r5, r6]
 80057f0:	3601      	adds	r6, #1
 80057f2:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = stream[offset++];
 80057f6:	5da9      	ldrb	r1, [r5, r6]
 80057f8:	3601      	adds	r6, #1
 80057fa:	f361 641f 	bfi	r4, r1, #24, #8
    }

    res=MIOS32_MIDI_SendPackage(port, package);
 80057fe:	9803      	ldr	r0, [sp, #12]
 8005800:	4621      	mov	r1, r4
 8005802:	9201      	str	r2, [sp, #4]
 8005804:	9302      	str	r3, [sp, #8]
 8005806:	f8cd c000 	str.w	ip, [sp]
 800580a:	f7ff ff61 	bl	80056d0 <MIOS32_MIDI_SendPackage>

    // expection? (e.g., port not available)
    if( res < 0 )
 800580e:	2800      	cmp	r0, #0
 8005810:	9a01      	ldr	r2, [sp, #4]
 8005812:	9b02      	ldr	r3, [sp, #8]
 8005814:	f8dd c000 	ldr.w	ip, [sp]
 8005818:	db02      	blt.n	8005820 <MIOS32_MIDI_SendSysEx+0x9e>
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 800581a:	42be      	cmp	r6, r7
 800581c:	d3bc      	bcc.n	8005798 <MIOS32_MIDI_SendSysEx+0x16>
    // expection? (e.g., port not available)
    if( res < 0 )
      return res;
  }

  return 0;
 800581e:	2000      	movs	r0, #0
}
 8005820:	b005      	add	sp, #20
 8005822:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005824 <MIOS32_MIDI_SYSEX_SendAckStr>:

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 8005824:	b510      	push	{r4, lr}
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005826:	23f0      	movs	r3, #240	; 0xf0

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 8005828:	b0a0      	sub	sp, #128	; 0x80
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 800582a:	f88d 3000 	strb.w	r3, [sp]
 800582e:	2300      	movs	r3, #0
 8005830:	f88d 3001 	strb.w	r3, [sp, #1]
 8005834:	f88d 3002 	strb.w	r3, [sp, #2]
 8005838:	337e      	adds	r3, #126	; 0x7e
 800583a:	f88d 3003 	strb.w	r3, [sp, #3]
 800583e:	2332      	movs	r3, #50	; 0x32
 8005840:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005844:	4b0e      	ldr	r3, [pc, #56]	; (8005880 <MIOS32_MIDI_SYSEX_SendAckStr+0x5c>)
}

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
 8005846:	f10d 0c6b 	add.w	ip, sp, #107	; 0x6b

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 800584a:	781b      	ldrb	r3, [r3, #0]
 800584c:	f88d 3005 	strb.w	r3, [sp, #5]

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;
 8005850:	230f      	movs	r3, #15
 8005852:	f88d 3006 	strb.w	r3, [sp, #6]
 8005856:	466b      	mov	r3, sp
 8005858:	1dda      	adds	r2, r3, #7
 800585a:	e003      	b.n	8005864 <MIOS32_MIDI_SYSEX_SendAckStr+0x40>

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
    *sysex_buffer_ptr++ = str[i];
 800585c:	f802 4b01 	strb.w	r4, [r2], #1

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
 8005860:	4562      	cmp	r2, ip
 8005862:	d003      	beq.n	800586c <MIOS32_MIDI_SYSEX_SendAckStr+0x48>
 8005864:	f811 4b01 	ldrb.w	r4, [r1], #1
 8005868:	2c00      	cmp	r4, #0
 800586a:	d1f7      	bne.n	800585c <MIOS32_MIDI_SYSEX_SendAckStr+0x38>
    *sysex_buffer_ptr++ = str[i];

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 800586c:	21f7      	movs	r1, #247	; 0xf7
 800586e:	f802 1b01 	strb.w	r1, [r2], #1

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 8005872:	1ad2      	subs	r2, r2, r3
 8005874:	4669      	mov	r1, sp
 8005876:	f7ff ff84 	bl	8005782 <MIOS32_MIDI_SendSysEx>
}
 800587a:	b020      	add	sp, #128	; 0x80
 800587c:	bd10      	pop	{r4, pc}
 800587e:	bf00      	nop
 8005880:	200007bd 	.word	0x200007bd

08005884 <MIOS32_MIDI_SYSEX_SendAck>:
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 8005884:	b500      	push	{lr}
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005886:	23f0      	movs	r3, #240	; 0xf0
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 8005888:	b089      	sub	sp, #36	; 0x24
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 800588a:	f88d 3000 	strb.w	r3, [sp]
 800588e:	2300      	movs	r3, #0
 8005890:	f88d 3001 	strb.w	r3, [sp, #1]
 8005894:	f88d 3002 	strb.w	r3, [sp, #2]
 8005898:	337e      	adds	r3, #126	; 0x7e
 800589a:	f88d 3003 	strb.w	r3, [sp, #3]
 800589e:	2332      	movs	r3, #50	; 0x32
 80058a0:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80058a4:	4b08      	ldr	r3, [pc, #32]	; (80058c8 <MIOS32_MIDI_SYSEX_SendAck+0x44>)

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
 80058a6:	f88d 1006 	strb.w	r1, [sp, #6]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80058aa:	781b      	ldrb	r3, [r3, #0]

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;
 80058ac:	f88d 2007 	strb.w	r2, [sp, #7]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80058b0:	f88d 3005 	strb.w	r3, [sp, #5]

  // send footer
  *sysex_buffer_ptr++ = 0xf7;

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80058b4:	4669      	mov	r1, sp
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 80058b6:	23f7      	movs	r3, #247	; 0xf7

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80058b8:	2209      	movs	r2, #9
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 80058ba:	f88d 3008 	strb.w	r3, [sp, #8]

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80058be:	f7ff ff60 	bl	8005782 <MIOS32_MIDI_SendSysEx>
}
 80058c2:	b009      	add	sp, #36	; 0x24
 80058c4:	bd00      	pop	{pc}
 80058c6:	bf00      	nop
 80058c8:	200007bd 	.word	0x200007bd

080058cc <MIOS32_MIDI_SendDebugMessage>:
//! \param[in] *format zero-terminated format string - 128 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendDebugMessage(char *format, ...)
{
 80058cc:	b40f      	push	{r0, r1, r2, r3}
 80058ce:	b530      	push	{r4, r5, lr}
 80058d0:	b0a5      	sub	sp, #148	; 0x94
 80058d2:	9c28      	ldr	r4, [sp, #160]	; 0xa0

  // failsave: if format string is longer than 100 chars, break here
  // note that this is a weak protection: if %s is used, or a lot of other format tokens,
  // the resulting string could still lead to a buffer overflow
  // other the other hand we don't want to allocate too many byte for buffer[] to save stack
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
 80058d4:	ad02      	add	r5, sp, #8
  if( strlen(format) > 100 ) {
 80058d6:	4620      	mov	r0, r4
 80058d8:	f004 fe3e 	bl	800a558 <strlen>
 80058dc:	2864      	cmp	r0, #100	; 0x64
 80058de:	d91e      	bls.n	800591e <MIOS32_MIDI_SendDebugMessage+0x52>
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
 80058e0:	4628      	mov	r0, r5
 80058e2:	4920      	ldr	r1, [pc, #128]	; (8005964 <MIOS32_MIDI_SendDebugMessage+0x98>)
 80058e4:	f004 fe31 	bl	800a54a <strcpy>
    vsprintf(str, format, args);
  }

  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 80058e8:	23f0      	movs	r3, #240	; 0xf0
 80058ea:	f88d 3000 	strb.w	r3, [sp]
 80058ee:	2300      	movs	r3, #0
 80058f0:	f88d 3001 	strb.w	r3, [sp, #1]
 80058f4:	f88d 3002 	strb.w	r3, [sp, #2]
 80058f8:	337e      	adds	r3, #126	; 0x7e
 80058fa:	f88d 3003 	strb.w	r3, [sp, #3]
 80058fe:	2332      	movs	r3, #50	; 0x32
 8005900:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005904:	4b18      	ldr	r3, [pc, #96]	; (8005968 <MIOS32_MIDI_SendDebugMessage+0x9c>)

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
 8005906:	2208      	movs	r2, #8
  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005908:	781b      	ldrb	r3, [r3, #0]
 800590a:	f88d 3005 	strb.w	r3, [sp, #5]

  // debug message: ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_DEBUG;
 800590e:	230d      	movs	r3, #13
 8005910:	f88d 3006 	strb.w	r3, [sp, #6]

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string
 8005914:	3333      	adds	r3, #51	; 0x33
 8005916:	f88d 3007 	strb.w	r3, [sp, #7]
 800591a:	ab02      	add	r3, sp, #8
 800591c:	e00f      	b.n	800593e <MIOS32_MIDI_SendDebugMessage+0x72>
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 800591e:	aa29      	add	r2, sp, #164	; 0xa4
    vsprintf(str, format, args);
 8005920:	4628      	mov	r0, r5
 8005922:	4621      	mov	r1, r4
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 8005924:	9223      	str	r2, [sp, #140]	; 0x8c
    vsprintf(str, format, args);
 8005926:	f003 f880 	bl	8008a2a <vsprintf>
 800592a:	e7dd      	b.n	80058e8 <MIOS32_MIDI_SendDebugMessage+0x1c>

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
 800592c:	3201      	adds	r2, #1
 800592e:	b292      	uxth	r2, r2
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 8005930:	f000 007f 	and.w	r0, r0, #127	; 0x7f
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 8005934:	2a88      	cmp	r2, #136	; 0x88
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 8005936:	f803 0c01 	strb.w	r0, [r3, #-1]
 800593a:	4619      	mov	r1, r3
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 800593c:	d004      	beq.n	8005948 <MIOS32_MIDI_SendDebugMessage+0x7c>
 800593e:	4619      	mov	r1, r3
 8005940:	f813 0b01 	ldrb.w	r0, [r3], #1
 8005944:	2800      	cmp	r0, #0
 8005946:	d1f1      	bne.n	800592c <MIOS32_MIDI_SendDebugMessage+0x60>
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005948:	23f7      	movs	r3, #247	; 0xf7
 800594a:	700b      	strb	r3, [r1, #0]
  ++len;

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 800594c:	4b07      	ldr	r3, [pc, #28]	; (800596c <MIOS32_MIDI_SendDebugMessage+0xa0>)
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
  ++len;
 800594e:	3201      	adds	r2, #1

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 8005950:	7818      	ldrb	r0, [r3, #0]
 8005952:	b292      	uxth	r2, r2
 8005954:	4669      	mov	r1, sp
 8005956:	f7ff ff14 	bl	8005782 <MIOS32_MIDI_SendSysEx>
}
 800595a:	b025      	add	sp, #148	; 0x94
 800595c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8005960:	b004      	add	sp, #16
 8005962:	4770      	bx	lr
 8005964:	0800af64 	.word	0x0800af64
 8005968:	200007bd 	.word	0x200007bd
 800596c:	20000005 	.word	0x20000005

08005970 <MIOS32_MIDI_SYSEX_Cmd>:

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 8005970:	b530      	push	{r4, r5, lr}
 8005972:	460b      	mov	r3, r1
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 8005974:	4959      	ldr	r1, [pc, #356]	; (8005adc <MIOS32_MIDI_SYSEX_Cmd+0x16c>)

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 8005976:	b08b      	sub	sp, #44	; 0x2c
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 8005978:	7809      	ldrb	r1, [r1, #0]

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 800597a:	4604      	mov	r4, r0
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 800597c:	290d      	cmp	r1, #13
 800597e:	d05e      	beq.n	8005a3e <MIOS32_MIDI_SYSEX_Cmd+0xce>
 8005980:	d801      	bhi.n	8005986 <MIOS32_MIDI_SYSEX_Cmd+0x16>
 8005982:	b139      	cbz	r1, 8005994 <MIOS32_MIDI_SYSEX_Cmd+0x24>
 8005984:	e09d      	b.n	8005ac2 <MIOS32_MIDI_SYSEX_Cmd+0x152>
 8005986:	290e      	cmp	r1, #14
 8005988:	f000 80a5 	beq.w	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
 800598c:	290f      	cmp	r1, #15
 800598e:	f040 8098 	bne.w	8005ac2 <MIOS32_MIDI_SYSEX_Cmd+0x152>
 8005992:	e08a      	b.n	8005aaa <MIOS32_MIDI_SYSEX_Cmd+0x13a>
static s32 MIOS32_MIDI_SYSEX_Cmd_Query(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 query_req = 0;
  char str_buffer[40];

  switch( cmd_state ) {
 8005994:	b11b      	cbz	r3, 800599e <MIOS32_MIDI_SYSEX_Cmd+0x2e>
 8005996:	2b01      	cmp	r3, #1
 8005998:	4b51      	ldr	r3, [pc, #324]	; (8005ae0 <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 800599a:	d102      	bne.n	80059a2 <MIOS32_MIDI_SYSEX_Cmd+0x32>
 800599c:	e056      	b.n	8005a4c <MIOS32_MIDI_SYSEX_Cmd+0xdc>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      query_req = 0;
 800599e:	4a50      	ldr	r2, [pc, #320]	; (8005ae0 <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 80059a0:	e098      	b.n	8005ad4 <MIOS32_MIDI_SYSEX_Cmd+0x164>
    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      query_req = midi_in;
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      switch( query_req ) {
 80059a2:	781b      	ldrb	r3, [r3, #0]
 80059a4:	2b05      	cmp	r3, #5
 80059a6:	d025      	beq.n	80059f4 <MIOS32_MIDI_SYSEX_Cmd+0x84>
 80059a8:	d80a      	bhi.n	80059c0 <MIOS32_MIDI_SYSEX_Cmd+0x50>
 80059aa:	2b02      	cmp	r3, #2
 80059ac:	d017      	beq.n	80059de <MIOS32_MIDI_SYSEX_Cmd+0x6e>
 80059ae:	d802      	bhi.n	80059b6 <MIOS32_MIDI_SYSEX_Cmd+0x46>
 80059b0:	2b01      	cmp	r3, #1
 80059b2:	d140      	bne.n	8005a36 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80059b4:	e011      	b.n	80059da <MIOS32_MIDI_SYSEX_Cmd+0x6a>
 80059b6:	2b03      	cmp	r3, #3
 80059b8:	d013      	beq.n	80059e2 <MIOS32_MIDI_SYSEX_Cmd+0x72>
 80059ba:	2b04      	cmp	r3, #4
 80059bc:	d13b      	bne.n	8005a36 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80059be:	e012      	b.n	80059e6 <MIOS32_MIDI_SYSEX_Cmd+0x76>
 80059c0:	2b08      	cmp	r3, #8
 80059c2:	d02f      	beq.n	8005a24 <MIOS32_MIDI_SYSEX_Cmd+0xb4>
 80059c4:	d804      	bhi.n	80059d0 <MIOS32_MIDI_SYSEX_Cmd+0x60>
 80059c6:	2b06      	cmp	r3, #6
 80059c8:	d01e      	beq.n	8005a08 <MIOS32_MIDI_SYSEX_Cmd+0x98>
 80059ca:	2b07      	cmp	r3, #7
 80059cc:	d133      	bne.n	8005a36 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80059ce:	e01e      	b.n	8005a0e <MIOS32_MIDI_SYSEX_Cmd+0x9e>
 80059d0:	2b09      	cmp	r3, #9
 80059d2:	d029      	beq.n	8005a28 <MIOS32_MIDI_SYSEX_Cmd+0xb8>
 80059d4:	2b7f      	cmp	r3, #127	; 0x7f
 80059d6:	d12e      	bne.n	8005a36 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80059d8:	e02a      	b.n	8005a30 <MIOS32_MIDI_SYSEX_Cmd+0xc0>
        case 0x01: // operating system
	  MIOS32_MIDI_SYSEX_SendAckStr(port, "MIOS32");
 80059da:	4942      	ldr	r1, [pc, #264]	; (8005ae4 <MIOS32_MIDI_SYSEX_Cmd+0x174>)
 80059dc:	e025      	b.n	8005a2a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x02: // Board
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_BOARD_STR);
 80059de:	4942      	ldr	r1, [pc, #264]	; (8005ae8 <MIOS32_MIDI_SYSEX_Cmd+0x178>)
 80059e0:	e023      	b.n	8005a2a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x03: // Core Family
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_FAMILY_STR);
 80059e2:	4942      	ldr	r1, [pc, #264]	; (8005aec <MIOS32_MIDI_SYSEX_Cmd+0x17c>)
 80059e4:	e021      	b.n	8005a2a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
 80059e6:	f000 fd5b 	bl	80064a0 <MIOS32_SYS_ChipIDGet>
 80059ea:	466d      	mov	r5, sp
 80059ec:	4602      	mov	r2, r0
 80059ee:	4940      	ldr	r1, [pc, #256]	; (8005af0 <MIOS32_MIDI_SYSEX_Cmd+0x180>)
 80059f0:	4668      	mov	r0, sp
 80059f2:	e012      	b.n	8005a1a <MIOS32_MIDI_SYSEX_Cmd+0xaa>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 80059f4:	4668      	mov	r0, sp
 80059f6:	f000 fd69 	bl	80064cc <MIOS32_SYS_SerialNumberGet>
 80059fa:	2800      	cmp	r0, #0
 80059fc:	466d      	mov	r5, sp
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
 80059fe:	bfbc      	itt	lt
 8005a00:	4620      	movlt	r0, r4
 8005a02:	493c      	ldrlt	r1, [pc, #240]	; (8005af4 <MIOS32_MIDI_SYSEX_Cmd+0x184>)
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 8005a04:	da0b      	bge.n	8005a1e <MIOS32_MIDI_SYSEX_Cmd+0xae>
 8005a06:	e010      	b.n	8005a2a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
	  break;
        case 0x06: // Flash Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_FlashSizeGet());
 8005a08:	f000 fd50 	bl	80064ac <MIOS32_SYS_FlashSizeGet>
 8005a0c:	e001      	b.n	8005a12 <MIOS32_MIDI_SYSEX_Cmd+0xa2>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  break;
        case 0x07: // RAM Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_RAMSizeGet());
 8005a0e:	f000 fd55 	bl	80064bc <MIOS32_SYS_RAMSizeGet>
 8005a12:	4939      	ldr	r1, [pc, #228]	; (8005af8 <MIOS32_MIDI_SYSEX_Cmd+0x188>)
 8005a14:	4602      	mov	r2, r0
 8005a16:	466d      	mov	r5, sp
 8005a18:	4668      	mov	r0, sp
 8005a1a:	f002 fff7 	bl	8008a0c <sprintf>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
 8005a1e:	4620      	mov	r0, r4
 8005a20:	4669      	mov	r1, sp
 8005a22:	e002      	b.n	8005a2a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x08: // Application Name Line #1
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE1);
 8005a24:	4935      	ldr	r1, [pc, #212]	; (8005afc <MIOS32_MIDI_SYSEX_Cmd+0x18c>)
 8005a26:	e000      	b.n	8005a2a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x09: // Application Name Line #2
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE2);
 8005a28:	4935      	ldr	r1, [pc, #212]	; (8005b00 <MIOS32_MIDI_SYSEX_Cmd+0x190>)
 8005a2a:	f7ff fefb 	bl	8005824 <MIOS32_MIDI_SYSEX_SendAckStr>
 8005a2e:	e052      	b.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
#if MIOS32_MIDI_BSL_ENHANCEMENTS
	  // release halt state (or sending upload request) instead of reseting the core
	  BSL_SYSEX_ReleaseHaltState();
#else
	  // reset core (this will send an upload request)
	  MIOS32_SYS_Reset();
 8005a30:	f000 fcfa 	bl	8006428 <MIOS32_SYS_Reset>
 8005a34:	e04f      	b.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  // but other core families could contain an empty stumb!
#endif
	  break;
        default: 
	  // unknown query
	  MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNKNOWN_QUERY);
 8005a36:	4620      	mov	r0, r4
 8005a38:	210e      	movs	r1, #14
 8005a3a:	220d      	movs	r2, #13
 8005a3c:	e03e      	b.n	8005abc <MIOS32_MIDI_SYSEX_Cmd+0x14c>
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Debug(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 debug_req = 0xff;

  switch( cmd_state ) {
 8005a3e:	b11b      	cbz	r3, 8005a48 <MIOS32_MIDI_SYSEX_Cmd+0xd8>
 8005a40:	2b01      	cmp	r3, #1
 8005a42:	4d30      	ldr	r5, [pc, #192]	; (8005b04 <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 8005a44:	d114      	bne.n	8005a70 <MIOS32_MIDI_SYSEX_Cmd+0x100>
 8005a46:	e003      	b.n	8005a50 <MIOS32_MIDI_SYSEX_Cmd+0xe0>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
 8005a48:	4b2e      	ldr	r3, [pc, #184]	; (8005b04 <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 8005a4a:	22ff      	movs	r2, #255	; 0xff
 8005a4c:	701a      	strb	r2, [r3, #0]
 8005a4e:	e042      	b.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005a50:	782b      	ldrb	r3, [r5, #0]
 8005a52:	2bff      	cmp	r3, #255	; 0xff
	debug_req = midi_in;
 8005a54:	bf08      	it	eq
 8005a56:	702a      	strbeq	r2, [r5, #0]
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005a58:	d03d      	beq.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	debug_req = midi_in;
      } else {
	switch( debug_req ) {
 8005a5a:	2b00      	cmp	r3, #0
 8005a5c:	d13b      	bne.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  case 0x00: // input string
	    if( debug_command_callback_func != NULL )
 8005a5e:	4b2a      	ldr	r3, [pc, #168]	; (8005b08 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 8005a60:	681b      	ldr	r3, [r3, #0]
 8005a62:	2b00      	cmp	r3, #0
 8005a64:	d037      	beq.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	      debug_command_callback_func(last_sysex_port, (char)midi_in);
 8005a66:	4929      	ldr	r1, [pc, #164]	; (8005b0c <MIOS32_MIDI_SYSEX_Cmd+0x19c>)
 8005a68:	7808      	ldrb	r0, [r1, #0]
 8005a6a:	4611      	mov	r1, r2
 8005a6c:	4798      	blx	r3
 8005a6e:	e032      	b.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	}
      }
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      if( debug_req == 0x00 ) {
 8005a70:	782a      	ldrb	r2, [r5, #0]
 8005a72:	b9ba      	cbnz	r2, 8005aa4 <MIOS32_MIDI_SYSEX_Cmd+0x134>
	// send acknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8005a74:	210f      	movs	r1, #15
 8005a76:	f7ff ff05 	bl	8005884 <MIOS32_MIDI_SYSEX_SendAck>

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
 8005a7a:	782b      	ldrb	r3, [r5, #0]
 8005a7c:	2b00      	cmp	r3, #0
 8005a7e:	d12a      	bne.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
 8005a80:	4b21      	ldr	r3, [pc, #132]	; (8005b08 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 8005a82:	681b      	ldr	r3, [r3, #0]
 8005a84:	2b00      	cmp	r3, #0
 8005a86:	d126      	bne.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 8005a88:	4b21      	ldr	r3, [pc, #132]	; (8005b10 <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 8005a8a:	2c01      	cmp	r4, #1
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 8005a8c:	781d      	ldrb	r5, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 8005a8e:	4821      	ldr	r0, [pc, #132]	; (8005b14 <MIOS32_MIDI_SYSEX_Cmd+0x1a4>)
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
    return -1;

  debug_port = port;
 8005a90:	bf18      	it	ne
 8005a92:	701c      	strbne	r4, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 8005a94:	4621      	mov	r1, r4
 8005a96:	f7ff ff19 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 8005a9a:	2d01      	cmp	r5, #1
    return -1;

  debug_port = port;
 8005a9c:	bf1c      	itt	ne
 8005a9e:	4b1c      	ldrne	r3, [pc, #112]	; (8005b10 <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
 8005aa0:	701d      	strbne	r5, [r3, #0]
 8005aa2:	e018      	b.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  MIOS32_MIDI_DebugPortSet(prev_debug_port);
	}

      } else {
	// send disacknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNSUPPORTED_DEBUG);
 8005aa4:	210e      	movs	r1, #14
 8005aa6:	2210      	movs	r2, #16
 8005aa8:	e008      	b.n	8005abc <MIOS32_MIDI_SYSEX_Cmd+0x14c>
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
 8005aaa:	4a1b      	ldr	r2, [pc, #108]	; (8005b18 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
/////////////////////////////////////////////////////////////////////////////
// Command 0F: Ping (just send back acknowledge if no additional byte has been received)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {
 8005aac:	b113      	cbz	r3, 8005ab4 <MIOS32_MIDI_SYSEX_Cmd+0x144>
 8005aae:	2b01      	cmp	r3, #1
 8005ab0:	4a19      	ldr	r2, [pc, #100]	; (8005b18 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 8005ab2:	d101      	bne.n	8005ab8 <MIOS32_MIDI_SYSEX_Cmd+0x148>
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      sysex_state.PING_BYTE_RECEIVED = 1;
 8005ab4:	6053      	str	r3, [r2, #4]
 8005ab6:	e00e      	b.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      // TODO: send 0xf7 if merger enabled

      // send acknowledge if no additional byte has been received
      // to avoid feedback loop if two cores are directly connected
      if( !sysex_state.PING_BYTE_RECEIVED )
 8005ab8:	6852      	ldr	r2, [r2, #4]
 8005aba:	b962      	cbnz	r2, 8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8005abc:	f7ff fee2 	bl	8005884 <MIOS32_MIDI_SYSEX_SendAck>
 8005ac0:	e009      	b.n	8005ad6 <MIOS32_MIDI_SYSEX_Cmd+0x166>
      MIOS32_MIDI_SYSEX_Cmd_Ping(port, cmd_state, midi_in);
      break;
    default:
      // unknown command
      // TODO: send 0xf7 if merger enabled
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
 8005ac2:	210e      	movs	r1, #14
 8005ac4:	460a      	mov	r2, r1
 8005ac6:	4620      	mov	r0, r4
 8005ac8:	f7ff fedc 	bl	8005884 <MIOS32_MIDI_SYSEX_SendAck>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005acc:	4a12      	ldr	r2, [pc, #72]	; (8005b18 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 8005ace:	2300      	movs	r3, #0
 8005ad0:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005ad2:	4a02      	ldr	r2, [pc, #8]	; (8005adc <MIOS32_MIDI_SYSEX_Cmd+0x16c>)
 8005ad4:	7013      	strb	r3, [r2, #0]
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
      MIOS32_MIDI_SYSEX_CmdFinished();      
  }

  return 0; // no error
}
 8005ad6:	2000      	movs	r0, #0
 8005ad8:	b00b      	add	sp, #44	; 0x2c
 8005ada:	bd30      	pop	{r4, r5, pc}
 8005adc:	200007b4 	.word	0x200007b4
 8005ae0:	200007c0 	.word	0x200007c0
 8005ae4:	0800afb7 	.word	0x0800afb7
 8005ae8:	0800afbe 	.word	0x0800afbe
 8005aec:	0800afce 	.word	0x0800afce
 8005af0:	0800afd8 	.word	0x0800afd8
 8005af4:	0800afdd 	.word	0x0800afdd
 8005af8:	0800afdf 	.word	0x0800afdf
 8005afc:	0800af20 	.word	0x0800af20
 8005b00:	0800af31 	.word	0x0800af31
 8005b04:	20000006 	.word	0x20000006
 8005b08:	200007cc 	.word	0x200007cc
 8005b0c:	200007bc 	.word	0x200007bc
 8005b10:	20000005 	.word	0x20000005
 8005b14:	0800afe2 	.word	0x0800afe2
 8005b18:	200007c4 	.word	0x200007c4

08005b1c <MIOS32_MIDI_SYSEX_Parser>:
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005b1c:	29f7      	cmp	r1, #247	; 0xf7

/////////////////////////////////////////////////////////////////////////////
// This function parses an incoming sysex stream for MIOS32 commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
 8005b1e:	b510      	push	{r4, lr}
 8005b20:	460a      	mov	r2, r1
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005b22:	d85c      	bhi.n	8005bde <MIOS32_MIDI_SYSEX_Parser+0xc2>
    return 0;

  // TODO: here we could send an error notification, that multiple devices are trying to access the device
  if( sysex_state.MY_SYSEX && port != last_sysex_port )
 8005b24:	4b2f      	ldr	r3, [pc, #188]	; (8005be4 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b26:	781c      	ldrb	r4, [r3, #0]
 8005b28:	f004 0308 	and.w	r3, r4, #8
 8005b2c:	b2db      	uxtb	r3, r3
 8005b2e:	b11b      	cbz	r3, 8005b38 <MIOS32_MIDI_SYSEX_Parser+0x1c>
 8005b30:	492d      	ldr	r1, [pc, #180]	; (8005be8 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005b32:	7809      	ldrb	r1, [r1, #0]
 8005b34:	4281      	cmp	r1, r0
 8005b36:	d14f      	bne.n	8005bd8 <MIOS32_MIDI_SYSEX_Parser+0xbc>
  // USB upload is only allowed via USB0
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
 8005b38:	f1a0 0111 	sub.w	r1, r0, #17
 8005b3c:	b2c9      	uxtb	r1, r1
 8005b3e:	2906      	cmp	r1, #6
 8005b40:	d94a      	bls.n	8005bd8 <MIOS32_MIDI_SYSEX_Parser+0xbc>
    return -1;

  last_sysex_port = port;
 8005b42:	4929      	ldr	r1, [pc, #164]	; (8005be8 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005b44:	7008      	strb	r0, [r1, #0]

  // branch depending on state
  if( !sysex_state.MY_SYSEX ) {
 8005b46:	bb0b      	cbnz	r3, 8005b8c <MIOS32_MIDI_SYSEX_Parser+0x70>
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
 8005b48:	4b26      	ldr	r3, [pc, #152]	; (8005be4 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b4a:	781b      	ldrb	r3, [r3, #0]
 8005b4c:	f003 0307 	and.w	r3, r3, #7
 8005b50:	2b04      	cmp	r3, #4
 8005b52:	d803      	bhi.n	8005b5c <MIOS32_MIDI_SYSEX_Parser+0x40>
 8005b54:	4925      	ldr	r1, [pc, #148]	; (8005bec <MIOS32_MIDI_SYSEX_Parser+0xd0>)
 8005b56:	5cc9      	ldrb	r1, [r1, r3]
 8005b58:	4291      	cmp	r1, r2
 8005b5a:	d123      	bne.n	8005ba4 <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005b5c:	f004 0407 	and.w	r4, r4, #7
 8005b60:	2c05      	cmp	r4, #5
 8005b62:	d103      	bne.n	8005b6c <MIOS32_MIDI_SYSEX_Parser+0x50>
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
 8005b64:	4922      	ldr	r1, [pc, #136]	; (8005bf0 <MIOS32_MIDI_SYSEX_Parser+0xd4>)
 8005b66:	7809      	ldrb	r1, [r1, #0]
 8005b68:	4291      	cmp	r1, r2
 8005b6a:	d11b      	bne.n	8005ba4 <MIOS32_MIDI_SYSEX_Parser+0x88>
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005b6c:	3301      	adds	r3, #1
 8005b6e:	f003 0207 	and.w	r2, r3, #7
 8005b72:	4b1c      	ldr	r3, [pc, #112]	; (8005be4 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005b74:	2a05      	cmp	r2, #5
 8005b76:	7819      	ldrb	r1, [r3, #0]
 8005b78:	f362 0102 	bfi	r1, r2, #0, #3
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005b7c:	bf84      	itt	hi
 8005b7e:	b2ca      	uxtbhi	r2, r1
 8005b80:	f042 0208 	orrhi.w	r2, r2, #8
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005b84:	7019      	strb	r1, [r3, #0]
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005b86:	bf88      	it	hi
 8005b88:	701a      	strbhi	r2, [r3, #0]
 8005b8a:	e028      	b.n	8005bde <MIOS32_MIDI_SYSEX_Parser+0xc2>
      }
    }
  } else {
    // check for end of SysEx message or invalid status byte
    if( midi_in >= 0x80 ) {
 8005b8c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005b90:	d00e      	beq.n	8005bb0 <MIOS32_MIDI_SYSEX_Parser+0x94>
      if( midi_in == 0xf7 && sysex_state.CMD ) {
 8005b92:	2af7      	cmp	r2, #247	; 0xf7
 8005b94:	d106      	bne.n	8005ba4 <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005b96:	f004 0410 	and.w	r4, r4, #16
 8005b9a:	b2e4      	uxtb	r4, r4
 8005b9c:	b114      	cbz	r4, 8005ba4 <MIOS32_MIDI_SYSEX_Parser+0x88>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
 8005b9e:	2102      	movs	r1, #2
 8005ba0:	f7ff fee6 	bl	8005970 <MIOS32_MIDI_SYSEX_Cmd>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005ba4:	4b0f      	ldr	r3, [pc, #60]	; (8005be4 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005ba6:	2000      	movs	r0, #0
 8005ba8:	7018      	strb	r0, [r3, #0]
  sysex_cmd = 0;
 8005baa:	4b12      	ldr	r3, [pc, #72]	; (8005bf4 <MIOS32_MIDI_SYSEX_Parser+0xd8>)
 8005bac:	7018      	strb	r0, [r3, #0]
 8005bae:	e017      	b.n	8005be0 <MIOS32_MIDI_SYSEX_Parser+0xc4>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
      }
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
 8005bb0:	f004 0410 	and.w	r4, r4, #16
 8005bb4:	b2e4      	uxtb	r4, r4
 8005bb6:	b95c      	cbnz	r4, 8005bd0 <MIOS32_MIDI_SYSEX_Parser+0xb4>
	sysex_state.CMD = 1;
 8005bb8:	4b0a      	ldr	r3, [pc, #40]	; (8005be4 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005bba:	7819      	ldrb	r1, [r3, #0]
 8005bbc:	f041 0110 	orr.w	r1, r1, #16
 8005bc0:	7019      	strb	r1, [r3, #0]
	sysex_cmd = midi_in;
 8005bc2:	4b0c      	ldr	r3, [pc, #48]	; (8005bf4 <MIOS32_MIDI_SYSEX_Parser+0xd8>)
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005bc4:	4621      	mov	r1, r4
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
 8005bc6:	701a      	strb	r2, [r3, #0]
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005bc8:	f7ff fed2 	bl	8005970 <MIOS32_MIDI_SYSEX_Cmd>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005bcc:	4620      	mov	r0, r4
 8005bce:	e007      	b.n	8005be0 <MIOS32_MIDI_SYSEX_Parser+0xc4>
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
      }
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
 8005bd0:	2101      	movs	r1, #1
 8005bd2:	f7ff fecd 	bl	8005970 <MIOS32_MIDI_SYSEX_Cmd>
 8005bd6:	e002      	b.n	8005bde <MIOS32_MIDI_SYSEX_Parser+0xc2>
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
    return -1;
 8005bd8:	f04f 30ff 	mov.w	r0, #4294967295
 8005bdc:	e000      	b.n	8005be0 <MIOS32_MIDI_SYSEX_Parser+0xc4>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005bde:	2000      	movs	r0, #0
}
 8005be0:	bd10      	pop	{r4, pc}
 8005be2:	bf00      	nop
 8005be4:	200007c4 	.word	0x200007c4
 8005be8:	200007bc 	.word	0x200007bc
 8005bec:	0800b078 	.word	0x0800b078
 8005bf0:	200007bd 	.word	0x200007bd
 8005bf4:	200007b4 	.word	0x200007b4

08005bf8 <MIOS32_MIDI_TimeOut>:

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005bf8:	b510      	push	{r4, lr}
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005bfa:	4a0d      	ldr	r2, [pc, #52]	; (8005c30 <MIOS32_MIDI_TimeOut+0x38>)

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005bfc:	4604      	mov	r4, r0
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005bfe:	7813      	ldrb	r3, [r2, #0]
 8005c00:	f003 0308 	and.w	r3, r3, #8
 8005c04:	b2db      	uxtb	r3, r3
 8005c06:	b13b      	cbz	r3, 8005c18 <MIOS32_MIDI_TimeOut+0x20>
 8005c08:	4b0a      	ldr	r3, [pc, #40]	; (8005c34 <MIOS32_MIDI_TimeOut+0x3c>)
 8005c0a:	781b      	ldrb	r3, [r3, #0]
 8005c0c:	4283      	cmp	r3, r0
 8005c0e:	d103      	bne.n	8005c18 <MIOS32_MIDI_TimeOut+0x20>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005c10:	2300      	movs	r3, #0
 8005c12:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005c14:	4a08      	ldr	r2, [pc, #32]	; (8005c38 <MIOS32_MIDI_TimeOut+0x40>)
 8005c16:	7013      	strb	r3, [r2, #0]
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
    MIOS32_MIDI_SYSEX_CmdFinished();

  // optional hook to application
  if( timeout_callback_func != NULL )
 8005c18:	4b08      	ldr	r3, [pc, #32]	; (8005c3c <MIOS32_MIDI_TimeOut+0x44>)
 8005c1a:	681b      	ldr	r3, [r3, #0]
 8005c1c:	b10b      	cbz	r3, 8005c22 <MIOS32_MIDI_TimeOut+0x2a>
    timeout_callback_func(port);
 8005c1e:	4620      	mov	r0, r4
 8005c20:	4798      	blx	r3

#if 1
  // this debug message should always be active, so that common users are informed about the exception
  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_Receive_Handler] Timeout on port 0x%02x\n", port);
 8005c22:	4621      	mov	r1, r4
 8005c24:	4806      	ldr	r0, [pc, #24]	; (8005c40 <MIOS32_MIDI_TimeOut+0x48>)
 8005c26:	f7ff fe51 	bl	80058cc <MIOS32_MIDI_SendDebugMessage>
#endif

  return 0; // no error
}
 8005c2a:	2000      	movs	r0, #0
 8005c2c:	bd10      	pop	{r4, pc}
 8005c2e:	bf00      	nop
 8005c30:	200007c4 	.word	0x200007c4
 8005c34:	200007bc 	.word	0x200007bc
 8005c38:	200007b4 	.word	0x200007b4
 8005c3c:	200007d8 	.word	0x200007d8
 8005c40:	0800b030 	.word	0x0800b030

08005c44 <MIOS32_MIDI_Receive_Handler>:
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c44:	b5f0      	push	{r4, r5, r6, r7, lr}

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005c46:	2200      	movs	r2, #0
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c48:	b089      	sub	sp, #36	; 0x24
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005c4a:	2101      	movs	r1, #1
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005c4c:	4605      	mov	r5, r0
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005c4e:	9104      	str	r1, [sp, #16]

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005c50:	9201      	str	r2, [sp, #4]
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
 8005c52:	9203      	str	r2, [sp, #12]
  u8 port;
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
 8005c54:	4613      	mov	r3, r2
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005c56:	4fc5      	ldr	r7, [pc, #788]	; (8005f6c <MIOS32_MIDI_Receive_Handler+0x328>)
 8005c58:	e000      	b.n	8005c5c <MIOS32_MIDI_Receive_Handler+0x18>

      MIOS32_MIDI_TimeOut(timeout_port);
      sysex_timeout_ctr_flags.ALL = 0;
      again = 0;
    }
  } while( again );
 8005c5a:	9b05      	ldr	r3, [sp, #20]
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8005c5c:	1c5a      	adds	r2, r3, #1
 8005c5e:	b2d2      	uxtb	r2, r2
 8005c60:	9205      	str	r2, [sp, #20]
 8005c62:	2b0b      	cmp	r3, #11
 8005c64:	d851      	bhi.n	8005d0a <MIOS32_MIDI_Receive_Handler+0xc6>
 8005c66:	e8df f003 	tbb	[pc, r3]
 8005c6a:	0e06      	.short	0x0e06
 8005c6c:	26201a14 	.word	0x26201a14
 8005c70:	3e38322c 	.word	0x3e38322c
 8005c74:	4a44      	.short	0x4a44
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      case 0: status = MIOS32_USB_MIDI_PackageReceive(&package); port = USB0 + package.cable; break;
 8005c76:	a807      	add	r0, sp, #28
 8005c78:	f002 f9d6 	bl	8008028 <MIOS32_USB_MIDI_PackageReceive>
 8005c7c:	9c07      	ldr	r4, [sp, #28]
 8005c7e:	f3c4 1403 	ubfx	r4, r4, #4, #4
 8005c82:	3410      	adds	r4, #16
 8005c84:	e052      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 0: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART0_ASSIGNMENT == 1
      case 1: status = MIOS32_UART_MIDI_PackageReceive(0, &package); port = UART0; break;
 8005c86:	2000      	movs	r0, #0
 8005c88:	a907      	add	r1, sp, #28
 8005c8a:	f000 fae3 	bl	8006254 <MIOS32_UART_MIDI_PackageReceive>
 8005c8e:	2420      	movs	r4, #32
 8005c90:	e04c      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 1: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART1_ASSIGNMENT == 1
      case 2: status = MIOS32_UART_MIDI_PackageReceive(1, &package); port = UART1; break;
 8005c92:	2001      	movs	r0, #1
 8005c94:	a907      	add	r1, sp, #28
 8005c96:	f000 fadd 	bl	8006254 <MIOS32_UART_MIDI_PackageReceive>
 8005c9a:	2421      	movs	r4, #33	; 0x21
 8005c9c:	e046      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 2: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART2_ASSIGNMENT == 1
      case 3: status = MIOS32_UART_MIDI_PackageReceive(2, &package); port = UART2; break;
 8005c9e:	2002      	movs	r0, #2
 8005ca0:	a907      	add	r1, sp, #28
 8005ca2:	f000 fad7 	bl	8006254 <MIOS32_UART_MIDI_PackageReceive>
 8005ca6:	2422      	movs	r4, #34	; 0x22
 8005ca8:	e040      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 3: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 4: status = MIOS32_IIC_MIDI_PackageReceive(0, &package); port = IIC0; break;
 8005caa:	2000      	movs	r0, #0
 8005cac:	a907      	add	r1, sp, #28
 8005cae:	f000 fbb1 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005cb2:	2430      	movs	r4, #48	; 0x30
 8005cb4:	e03a      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 4: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 5: status = MIOS32_IIC_MIDI_PackageReceive(1, &package); port = IIC1; break;
 8005cb6:	2001      	movs	r0, #1
 8005cb8:	a907      	add	r1, sp, #28
 8005cba:	f000 fbab 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005cbe:	2431      	movs	r4, #49	; 0x31
 8005cc0:	e034      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 5: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 6: status = MIOS32_IIC_MIDI_PackageReceive(2, &package); port = IIC2; break;
 8005cc2:	2002      	movs	r0, #2
 8005cc4:	a907      	add	r1, sp, #28
 8005cc6:	f000 fba5 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005cca:	2432      	movs	r4, #50	; 0x32
 8005ccc:	e02e      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 6: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 7: status = MIOS32_IIC_MIDI_PackageReceive(3, &package); port = IIC3; break;
 8005cce:	2003      	movs	r0, #3
 8005cd0:	a907      	add	r1, sp, #28
 8005cd2:	f000 fb9f 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005cd6:	2433      	movs	r4, #51	; 0x33
 8005cd8:	e028      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 7: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 8: status = MIOS32_IIC_MIDI_PackageReceive(4, &package); port = IIC4; break;
 8005cda:	2004      	movs	r0, #4
 8005cdc:	a907      	add	r1, sp, #28
 8005cde:	f000 fb99 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005ce2:	2434      	movs	r4, #52	; 0x34
 8005ce4:	e022      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 8: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 9: status = MIOS32_IIC_MIDI_PackageReceive(5, &package); port = IIC5; break;
 8005ce6:	2005      	movs	r0, #5
 8005ce8:	a907      	add	r1, sp, #28
 8005cea:	f000 fb93 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005cee:	2435      	movs	r4, #53	; 0x35
 8005cf0:	e01c      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 9: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 10: status = MIOS32_IIC_MIDI_PackageReceive(6, &package); port = IIC6; break;
 8005cf2:	2006      	movs	r0, #6
 8005cf4:	a907      	add	r1, sp, #28
 8005cf6:	f000 fb8d 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005cfa:	2436      	movs	r4, #54	; 0x36
 8005cfc:	e016      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 10: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 11: status = MIOS32_IIC_MIDI_PackageReceive(7, &package); port = IIC7; break;
 8005cfe:	2007      	movs	r0, #7
 8005d00:	a907      	add	r1, sp, #28
 8005d02:	f000 fb87 	bl	8006414 <MIOS32_IIC_MIDI_PackageReceive>
 8005d06:	2437      	movs	r4, #55	; 0x37
 8005d08:	e010      	b.n	8005d2c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
 8005d0a:	9a01      	ldr	r2, [sp, #4]
 8005d0c:	9903      	ldr	r1, [sp, #12]
 8005d0e:	1e13      	subs	r3, r2, #0
 8005d10:	bf18      	it	ne
 8005d12:	2301      	movne	r3, #1
 8005d14:	2909      	cmp	r1, #9
 8005d16:	bf8c      	ite	hi
 8005d18:	2300      	movhi	r3, #0
 8005d1a:	f003 0301 	andls.w	r3, r3, #1
 8005d1e:	2b00      	cmp	r3, #0
 8005d20:	f000 811f 	beq.w	8005f62 <MIOS32_MIDI_Receive_Handler+0x31e>
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
 8005d24:	2200      	movs	r2, #0
 8005d26:	9201      	str	r2, [sp, #4]
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
 8005d28:	9205      	str	r2, [sp, #20]
 8005d2a:	e0e8      	b.n	8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
	}
	status = -1; // empty round - no message
    }

    // timeout detected by interface?
    if( status == -10 ) {
 8005d2c:	f110 0f0a 	cmn.w	r0, #10
 8005d30:	d104      	bne.n	8005d3c <MIOS32_MIDI_Receive_Handler+0xf8>
      MIOS32_MIDI_TimeOut(port);
 8005d32:	4620      	mov	r0, r4
 8005d34:	f7ff ff60 	bl	8005bf8 <MIOS32_MIDI_TimeOut>
      again = 0;
 8005d38:	2300      	movs	r3, #0
 8005d3a:	e112      	b.n	8005f62 <MIOS32_MIDI_Receive_Handler+0x31e>
    } else if( status >= 0 ) { // message received?
 8005d3c:	2800      	cmp	r0, #0
 8005d3e:	f2c0 80de 	blt.w	8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d42:	9901      	ldr	r1, [sp, #4]
      ++total_packages_forwarded;
 8005d44:	9a03      	ldr	r2, [sp, #12]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d46:	1c4b      	adds	r3, r1, #1
 8005d48:	b2db      	uxtb	r3, r3
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d4a:	9907      	ldr	r1, [sp, #28]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005d4c:	9301      	str	r3, [sp, #4]
      ++total_packages_forwarded;
 8005d4e:	1c53      	adds	r3, r2, #1
 8005d50:	b2db      	uxtb	r3, r3

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d52:	f36f 1107 	bfc	r1, #4, #4
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;
 8005d56:	9303      	str	r3, [sp, #12]

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005d58:	f001 030f 	and.w	r3, r1, #15
 8005d5c:	f103 0208 	add.w	r2, r3, #8
 8005d60:	f002 020f 	and.w	r2, r2, #15
 8005d64:	2a06      	cmp	r2, #6
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005d66:	9107      	str	r1, [sp, #28]

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005d68:	d804      	bhi.n	8005d74 <MIOS32_MIDI_Receive_Handler+0x130>
	if( callback_package != NULL )
	  callback_package(port, package);
 8005d6a:	4620      	mov	r0, r4
      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
 8005d6c:	2d00      	cmp	r5, #0
 8005d6e:	f040 80c5 	bne.w	8005efc <MIOS32_MIDI_Receive_Handler+0x2b8>
 8005d72:	e0c4      	b.n	8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;

	switch( package.type ) {
 8005d74:	1e9a      	subs	r2, r3, #2
 8005d76:	2a0d      	cmp	r2, #13
 8005d78:	f200 80c1 	bhi.w	8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005d7c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005d80:	00710071 	.word	0x00710071
 8005d84:	006d000e 	.word	0x006d000e
 8005d88:	00740074 	.word	0x00740074
 8005d8c:	00bf00bf 	.word	0x00bf00bf
 8005d90:	00bf00bf 	.word	0x00bf00bf
 8005d94:	00bf00bf 	.word	0x00bf00bf
 8005d98:	000e00bf 	.word	0x000e00bf
	    break;

	  case 0x4: // SysEx starts or continues (3 bytes)
	  case 0xf: // Single byte is interpreted as SysEx as well (I noticed that portmidi sometimes sends single bytes!)

	    if( package.evnt0 >= 0xf8 ) { // relevant for package type 0xf
 8005d9c:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005da0:	29f7      	cmp	r1, #247	; 0xf7
 8005da2:	d85e      	bhi.n	8005e62 <MIOS32_MIDI_Receive_Handler+0x21e>
	      if( callback_package != NULL )
		callback_package(port, package); // -> realtime event is forwarded as event
	      break;
	    }

	    if( package.evnt0 == 0xf0 ) {
 8005da4:	29f0      	cmp	r1, #240	; 0xf0
 8005da6:	d11c      	bne.n	8005de2 <MIOS32_MIDI_Receive_Handler+0x19e>
	      // cheap timeout mechanism - see comments above the sysex_timeout_ctr declaration
	      if( !sysex_timeout_ctr_flags.ALL ) {
 8005da8:	4a71      	ldr	r2, [pc, #452]	; (8005f70 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005daa:	6813      	ldr	r3, [r2, #0]
 8005dac:	b9cb      	cbnz	r3, 8005de2 <MIOS32_MIDI_Receive_Handler+0x19e>
		switch( port & 0xf0 ) {
 8005dae:	f004 02f0 	and.w	r2, r4, #240	; 0xf0
 8005db2:	2a10      	cmp	r2, #16
 8005db4:	d002      	beq.n	8005dbc <MIOS32_MIDI_Receive_Handler+0x178>
 8005db6:	2a30      	cmp	r2, #48	; 0x30
 8005db8:	d113      	bne.n	8005de2 <MIOS32_MIDI_Receive_Handler+0x19e>
 8005dba:	e009      	b.n	8005dd0 <MIOS32_MIDI_Receive_Handler+0x18c>
		  case USB0://..15
		    sysex_timeout_ctr = 0;
 8005dbc:	4a6d      	ldr	r2, [pc, #436]	; (8005f74 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005dbe:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.usb_receives = (1 << (port & 0xf));
 8005dc0:	2201      	movs	r2, #1
 8005dc2:	f004 030f 	and.w	r3, r4, #15
 8005dc6:	fa12 f303 	lsls.w	r3, r2, r3
 8005dca:	4a69      	ldr	r2, [pc, #420]	; (8005f70 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005dcc:	8013      	strh	r3, [r2, #0]
		    break;
 8005dce:	e008      	b.n	8005de2 <MIOS32_MIDI_Receive_Handler+0x19e>
		  case UART0://..15
		    // already done in MIOS32_UART_MIDI_PackageReceive()
		    break;
		  case IIC0://..15
		    sysex_timeout_ctr = 0;
 8005dd0:	4a68      	ldr	r2, [pc, #416]	; (8005f74 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005dd2:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.iic_receives = (1 << (port & 0xf));
 8005dd4:	2201      	movs	r2, #1
 8005dd6:	f004 030f 	and.w	r3, r4, #15
 8005dda:	fa12 f303 	lsls.w	r3, r2, r3
 8005dde:	4a64      	ldr	r2, [pc, #400]	; (8005f70 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005de0:	8053      	strh	r3, [r2, #2]
		    // no timeout protection for remaining interfaces (yet)
		}
	      }
	    }

	    MIOS32_MIDI_SYSEX_Parser(port, package.evnt0); // -> forward to MIOS32 SysEx Parser
 8005de2:	4620      	mov	r0, r4
 8005de4:	f7ff fe9a 	bl	8005b1c <MIOS32_MIDI_SYSEX_Parser>
	    if( package.type != 0x0f ) {
 8005de8:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8005dec:	f003 030f 	and.w	r3, r3, #15
 8005df0:	2b0f      	cmp	r3, #15
 8005df2:	d009      	beq.n	8005e08 <MIOS32_MIDI_Receive_Handler+0x1c4>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
 8005df4:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005df8:	4620      	mov	r0, r4
 8005dfa:	f7ff fe8f 	bl	8005b1c <MIOS32_MIDI_SYSEX_Parser>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
 8005dfe:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005e02:	4620      	mov	r0, r4
 8005e04:	f7ff fe8a 	bl	8005b1c <MIOS32_MIDI_SYSEX_Parser>
	    }

	    if( sysex_callback_func != NULL ) {
 8005e08:	683e      	ldr	r6, [r7, #0]
 8005e0a:	b1de      	cbz	r6, 8005e44 <MIOS32_MIDI_Receive_Handler+0x200>
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005e0c:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005e10:	4620      	mov	r0, r4
 8005e12:	47b0      	blx	r6
	      if( package.type != 0x0f ) {
 8005e14:	f89d 301c 	ldrb.w	r3, [sp, #28]
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005e18:	b2c6      	uxtb	r6, r0
	      if( package.type != 0x0f ) {
 8005e1a:	f003 030f 	and.w	r3, r3, #15
 8005e1e:	2b0f      	cmp	r3, #15
 8005e20:	d010      	beq.n	8005e44 <MIOS32_MIDI_Receive_Handler+0x200>
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005e22:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005e26:	683b      	ldr	r3, [r7, #0]
 8005e28:	4620      	mov	r0, r4
 8005e2a:	4798      	blx	r3
 8005e2c:	4602      	mov	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005e2e:	683b      	ldr	r3, [r7, #0]
 8005e30:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005e34:	9200      	str	r2, [sp, #0]
 8005e36:	4620      	mov	r0, r4
 8005e38:	4798      	blx	r3
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
	      if( package.type != 0x0f ) {
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005e3a:	9a00      	ldr	r2, [sp, #0]
 8005e3c:	4302      	orrs	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005e3e:	ea42 0606 	orr.w	r6, r2, r6
 8005e42:	b2f6      	uxtb	r6, r6
	      }
	    }

	    if( callback_package != NULL && !filter_sysex )
 8005e44:	1e2b      	subs	r3, r5, #0
 8005e46:	bf18      	it	ne
 8005e48:	2301      	movne	r3, #1
 8005e4a:	2e00      	cmp	r6, #0
 8005e4c:	bf14      	ite	ne
 8005e4e:	2600      	movne	r6, #0
 8005e50:	f003 0601 	andeq.w	r6, r3, #1
 8005e54:	2e00      	cmp	r6, #0
 8005e56:	d052      	beq.n	8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005e58:	e04e      	b.n	8005ef8 <MIOS32_MIDI_Receive_Handler+0x2b4>
	      callback_package(port, package);

	    break;

	  case 0x5:   // Single-byte System Common Message or SysEx ends with following single byte. 
	    if( package.evnt0 >= 0xf8 ) {
 8005e5a:	f89d 201d 	ldrb.w	r2, [sp, #29]
 8005e5e:	2af7      	cmp	r2, #247	; 0xf7
 8005e60:	d902      	bls.n	8005e68 <MIOS32_MIDI_Receive_Handler+0x224>
	      if( callback_package != NULL )
 8005e62:	2d00      	cmp	r5, #0
 8005e64:	d148      	bne.n	8005ef8 <MIOS32_MIDI_Receive_Handler+0x2b4>
 8005e66:	e04a      	b.n	8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
	    }
	    // no >= 0xf8 event: continue!

	  case 0x6:   // SysEx ends with following two bytes.
	  case 0x7: { // SysEx ends with following three bytes.
	    u8 num_bytes = package.type - 0x5 + 1;
 8005e68:	3b04      	subs	r3, #4
 8005e6a:	b2db      	uxtb	r3, r3
 8005e6c:	9302      	str	r3, [sp, #8]
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
 8005e6e:	2b00      	cmp	r3, #0
 8005e70:	d079      	beq.n	8005f66 <MIOS32_MIDI_Receive_Handler+0x322>
	      current_byte = package.evnt0;
 8005e72:	f89d 601d 	ldrb.w	r6, [sp, #29]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005e76:	4620      	mov	r0, r4
 8005e78:	4631      	mov	r1, r6
 8005e7a:	f7ff fe4f 	bl	8005b1c <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005e7e:	683b      	ldr	r3, [r7, #0]
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005e80:	461a      	mov	r2, r3
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005e82:	b11b      	cbz	r3, 8005e8c <MIOS32_MIDI_Receive_Handler+0x248>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005e84:	4620      	mov	r0, r4
 8005e86:	4631      	mov	r1, r6
 8005e88:	4798      	blx	r3
 8005e8a:	b2c2      	uxtb	r2, r0
	    }

	    if( num_bytes >= 2 ) {
 8005e8c:	9b02      	ldr	r3, [sp, #8]
 8005e8e:	2b01      	cmp	r3, #1
 8005e90:	d024      	beq.n	8005edc <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt1;
 8005e92:	f89d 601e 	ldrb.w	r6, [sp, #30]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005e96:	4620      	mov	r0, r4
 8005e98:	4631      	mov	r1, r6
 8005e9a:	9200      	str	r2, [sp, #0]
 8005e9c:	f7ff fe3e 	bl	8005b1c <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005ea0:	683b      	ldr	r3, [r7, #0]
 8005ea2:	9a00      	ldr	r2, [sp, #0]
 8005ea4:	b133      	cbz	r3, 8005eb4 <MIOS32_MIDI_Receive_Handler+0x270>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005ea6:	4620      	mov	r0, r4
 8005ea8:	4631      	mov	r1, r6
 8005eaa:	4798      	blx	r3
 8005eac:	9a00      	ldr	r2, [sp, #0]
 8005eae:	ea40 0202 	orr.w	r2, r0, r2
 8005eb2:	b2d2      	uxtb	r2, r2
	    }

	    if( num_bytes >= 3 ) {
 8005eb4:	9902      	ldr	r1, [sp, #8]
 8005eb6:	2902      	cmp	r1, #2
 8005eb8:	d010      	beq.n	8005edc <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt2;
 8005eba:	f89d 601f 	ldrb.w	r6, [sp, #31]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005ebe:	4620      	mov	r0, r4
 8005ec0:	4631      	mov	r1, r6
 8005ec2:	9200      	str	r2, [sp, #0]
 8005ec4:	f7ff fe2a 	bl	8005b1c <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005ec8:	683b      	ldr	r3, [r7, #0]
 8005eca:	9a00      	ldr	r2, [sp, #0]
 8005ecc:	b133      	cbz	r3, 8005edc <MIOS32_MIDI_Receive_Handler+0x298>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005ece:	4620      	mov	r0, r4
 8005ed0:	4631      	mov	r1, r6
 8005ed2:	4798      	blx	r3
 8005ed4:	9a00      	ldr	r2, [sp, #0]
 8005ed6:	ea40 0202 	orr.w	r2, r0, r2
 8005eda:	b2d2      	uxtb	r2, r2
	    }

	    // reset timeout protection if required
	    if( current_byte == 0xf7 )
 8005edc:	2ef7      	cmp	r6, #247	; 0xf7
 8005ede:	d102      	bne.n	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2a2>
	      sysex_timeout_ctr_flags.ALL = 0;
 8005ee0:	4b23      	ldr	r3, [pc, #140]	; (8005f70 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005ee2:	2100      	movs	r1, #0
 8005ee4:	6019      	str	r1, [r3, #0]

	    // forward as package if not filtered
	    if( callback_package != NULL && !filter_sysex )
 8005ee6:	1e2b      	subs	r3, r5, #0
 8005ee8:	bf18      	it	ne
 8005eea:	2301      	movne	r3, #1
 8005eec:	2a00      	cmp	r2, #0
 8005eee:	bf14      	ite	ne
 8005ef0:	2300      	movne	r3, #0
 8005ef2:	f003 0301 	andeq.w	r3, r3, #1
 8005ef6:	b113      	cbz	r3, 8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
	      callback_package(port, package);
 8005ef8:	9907      	ldr	r1, [sp, #28]
 8005efa:	4620      	mov	r0, r4
 8005efc:	47a8      	blx	r5
	}	  
      }
    }

    // timeout detected by this handler?
    if( sysex_timeout_ctr_flags.ALL && sysex_timeout_ctr > 1000 ) {
 8005efe:	4b1c      	ldr	r3, [pc, #112]	; (8005f70 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005f00:	681a      	ldr	r2, [r3, #0]
 8005f02:	b33a      	cbz	r2, 8005f54 <MIOS32_MIDI_Receive_Handler+0x310>
 8005f04:	491b      	ldr	r1, [pc, #108]	; (8005f74 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005f06:	880a      	ldrh	r2, [r1, #0]
 8005f08:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 8005f0c:	d922      	bls.n	8005f54 <MIOS32_MIDI_Receive_Handler+0x310>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
 8005f0e:	8819      	ldrh	r1, [r3, #0]
 8005f10:	b161      	cbz	r1, 8005f2c <MIOS32_MIDI_Receive_Handler+0x2e8>
 8005f12:	2200      	movs	r2, #0
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
 8005f14:	fa51 f302 	asrs.w	r3, r1, r2
 8005f18:	f013 0301 	ands.w	r3, r3, #1
 8005f1c:	d103      	bne.n	8005f26 <MIOS32_MIDI_Receive_Handler+0x2e2>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005f1e:	3201      	adds	r2, #1
 8005f20:	2a10      	cmp	r2, #16
 8005f22:	d1f7      	bne.n	8005f14 <MIOS32_MIDI_Receive_Handler+0x2d0>
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005f24:	461a      	mov	r2, r3
	timeout_port = USB0 + i;
 8005f26:	3210      	adds	r2, #16
 8005f28:	b2d0      	uxtb	r0, r2
 8005f2a:	e00d      	b.n	8005f48 <MIOS32_MIDI_Receive_Handler+0x304>
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
 8005f2c:	8858      	ldrh	r0, [r3, #2]
 8005f2e:	b158      	cbz	r0, 8005f48 <MIOS32_MIDI_Receive_Handler+0x304>
 8005f30:	460b      	mov	r3, r1
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
 8005f32:	fa50 f203 	asrs.w	r2, r0, r3
 8005f36:	f012 0201 	ands.w	r2, r2, #1
 8005f3a:	d103      	bne.n	8005f44 <MIOS32_MIDI_Receive_Handler+0x300>
	if( i >= 16 ) // failsafe
	  i = 0;
	timeout_port = USB0 + i;
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005f3c:	3301      	adds	r3, #1
 8005f3e:	2b10      	cmp	r3, #16
 8005f40:	d1f7      	bne.n	8005f32 <MIOS32_MIDI_Receive_Handler+0x2ee>
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005f42:	4613      	mov	r3, r2
	timeout_port = IIC0 + i;
 8005f44:	3330      	adds	r3, #48	; 0x30
 8005f46:	b2d8      	uxtb	r0, r3
      }

      MIOS32_MIDI_TimeOut(timeout_port);
 8005f48:	f7ff fe56 	bl	8005bf8 <MIOS32_MIDI_TimeOut>
      sysex_timeout_ctr_flags.ALL = 0;
 8005f4c:	4b08      	ldr	r3, [pc, #32]	; (8005f70 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005f4e:	2200      	movs	r2, #0
 8005f50:	601a      	str	r2, [r3, #0]
 8005f52:	e003      	b.n	8005f5c <MIOS32_MIDI_Receive_Handler+0x318>
      again = 0;
    }
  } while( again );
 8005f54:	9a04      	ldr	r2, [sp, #16]
 8005f56:	2a00      	cmp	r2, #0
 8005f58:	f47f ae7f 	bne.w	8005c5a <MIOS32_MIDI_Receive_Handler+0x16>

  return 0;
}
 8005f5c:	2000      	movs	r0, #0
 8005f5e:	b009      	add	sp, #36	; 0x24
 8005f60:	bdf0      	pop	{r4, r5, r6, r7, pc}
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
	} else {
	  again = 0; // no more interfaces to be processed
 8005f62:	9304      	str	r3, [sp, #16]
 8005f64:	e7cb      	b.n	8005efe <MIOS32_MIDI_Receive_Handler+0x2ba>
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005f66:	9a02      	ldr	r2, [sp, #8]
 8005f68:	e7bd      	b.n	8005ee6 <MIOS32_MIDI_Receive_Handler+0x2a2>
 8005f6a:	bf00      	nop
 8005f6c:	200007d4 	.word	0x200007d4
 8005f70:	200007d0 	.word	0x200007d0
 8005f74:	200007be 	.word	0x200007be

08005f78 <MIOS32_MIDI_Periodic_mS>:
//! by a task in the programming model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Periodic_mS(void)
{
 8005f78:	b510      	push	{r4, lr}
  s32 status = 0;

#ifndef MIOS32_DONT_USE_USB_MIDI
  status |= MIOS32_USB_MIDI_Periodic_mS();
 8005f7a:	f002 f881 	bl	8008080 <MIOS32_USB_MIDI_Periodic_mS>
 8005f7e:	4604      	mov	r4, r0
#endif

#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
 8005f80:	f000 f8ca 	bl	8006118 <MIOS32_UART_MIDI_Periodic_mS>
 8005f84:	ea40 0404 	orr.w	r4, r0, r4
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005f88:	f000 fa3f 	bl	800640a <MIOS32_IIC_MIDI_Periodic_mS>
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005f8c:	4b05      	ldr	r3, [pc, #20]	; (8005fa4 <MIOS32_MIDI_Periodic_mS+0x2c>)
 8005f8e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005f92:	881a      	ldrh	r2, [r3, #0]
#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005f94:	ea44 0000 	orr.w	r0, r4, r0
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005f98:	428a      	cmp	r2, r1
 8005f9a:	d001      	beq.n	8005fa0 <MIOS32_MIDI_Periodic_mS+0x28>
    ++sysex_timeout_ctr;
 8005f9c:	3201      	adds	r2, #1
 8005f9e:	801a      	strh	r2, [r3, #0]

  return status;
}
 8005fa0:	bd10      	pop	{r4, pc}
 8005fa2:	bf00      	nop
 8005fa4:	200007be 	.word	0x200007be

08005fa8 <MIOS32_MIDI_SendByteToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_byte received MIDI byte
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendByteToRxCallback(mios32_midi_port_t port, u8 midi_byte)
{
 8005fa8:	b508      	push	{r3, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL )
 8005faa:	4b03      	ldr	r3, [pc, #12]	; (8005fb8 <MIOS32_MIDI_SendByteToRxCallback+0x10>)
 8005fac:	681b      	ldr	r3, [r3, #0]
 8005fae:	b10b      	cbz	r3, 8005fb4 <MIOS32_MIDI_SendByteToRxCallback+0xc>
    return direct_rx_callback_func(port, midi_byte);
 8005fb0:	4798      	blx	r3
 8005fb2:	e000      	b.n	8005fb6 <MIOS32_MIDI_SendByteToRxCallback+0xe>
  return 0; // no error
 8005fb4:	4618      	mov	r0, r3
}
 8005fb6:	bd08      	pop	{r3, pc}
 8005fb8:	200007b8 	.word	0x200007b8

08005fbc <MIOS32_MIDI_SendPackageToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005fbe:	4e13      	ldr	r6, [pc, #76]	; (800600c <MIOS32_MIDI_SendPackageToRxCallback+0x50>)
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005fc0:	b085      	sub	sp, #20
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005fc2:	6834      	ldr	r4, [r6, #0]
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005fc4:	4607      	mov	r7, r0
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005fc6:	b1ec      	cbz	r4, 8006004 <MIOS32_MIDI_SendPackageToRxCallback+0x48>
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005fc8:	f3c1 6307 	ubfx	r3, r1, #24, #8
 8005fcc:	f88d 300e 	strb.w	r3, [sp, #14]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005fd0:	4b0f      	ldr	r3, [pc, #60]	; (8006010 <MIOS32_MIDI_SendPackageToRxCallback+0x54>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005fd2:	f3c1 4207 	ubfx	r2, r1, #16, #8
 8005fd6:	f3c1 2007 	ubfx	r0, r1, #8, #8
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
 8005fda:	2400      	movs	r4, #0
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005fdc:	f001 010f 	and.w	r1, r1, #15
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005fe0:	f88d 200d 	strb.w	r2, [sp, #13]
 8005fe4:	f88d 000c 	strb.w	r0, [sp, #12]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005fe8:	5c5a      	ldrb	r2, [r3, r1]
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005fea:	4625      	mov	r5, r4
 8005fec:	e008      	b.n	8006000 <MIOS32_MIDI_SendPackageToRxCallback+0x44>
      status |= direct_rx_callback_func(port, buffer[i]);
 8005fee:	ab03      	add	r3, sp, #12
 8005ff0:	5d59      	ldrb	r1, [r3, r5]
 8005ff2:	4638      	mov	r0, r7
 8005ff4:	9201      	str	r2, [sp, #4]
 8005ff6:	6833      	ldr	r3, [r6, #0]
 8005ff8:	4798      	blx	r3
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005ffa:	9a01      	ldr	r2, [sp, #4]
      status |= direct_rx_callback_func(port, buffer[i]);
 8005ffc:	4304      	orrs	r4, r0
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005ffe:	3501      	adds	r5, #1
 8006000:	4295      	cmp	r5, r2
 8006002:	dbf4      	blt.n	8005fee <MIOS32_MIDI_SendPackageToRxCallback+0x32>
      status |= direct_rx_callback_func(port, buffer[i]);
    return status;
  }
  return 0; // no error
}
 8006004:	4620      	mov	r0, r4
 8006006:	b005      	add	sp, #20
 8006008:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800600a:	bf00      	nop
 800600c:	200007b8 	.word	0x200007b8
 8006010:	0800af54 	.word	0x0800af54

08006014 <MIOS32_OSC_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_OSC_Init(u32 mode)
{
  if( mode > 0 )
    return -1; // only mode 0 supported yet
 8006014:	2800      	cmp	r0, #0
 8006016:	bf14      	ite	ne
 8006018:	f04f 30ff 	movne.w	r0, #4294967295
 800601c:	2000      	moveq	r0, #0

  return 0; // no error
}
 800601e:	4770      	bx	lr

08006020 <MIOS32_COM_Init>:
s32 MIOS32_COM_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 8006020:	b938      	cbnz	r0, 8006032 <MIOS32_COM_Init+0x12>
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 8006022:	4b05      	ldr	r3, [pc, #20]	; (8006038 <MIOS32_COM_Init+0x18>)

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 8006024:	4a05      	ldr	r2, [pc, #20]	; (800603c <MIOS32_COM_Init+0x1c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 8006026:	6018      	str	r0, [r3, #0]

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 8006028:	2310      	movs	r3, #16
 800602a:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_COM_DEBUG_PORT;
 800602c:	4a04      	ldr	r2, [pc, #16]	; (8006040 <MIOS32_COM_Init+0x20>)
 800602e:	7013      	strb	r3, [r2, #0]
#if MIOS32_UART0_ASSIGNMENT == 2 || MIOS32_UART1_ASSIGNMENT == 2 || MIOS32_UART2_ASSIGNMENT == 2 || MIOS32_UART3_ASSIGNMENT == 2
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
 8006030:	e001      	b.n	8006036 <MIOS32_COM_Init+0x16>
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8006032:	f04f 30ff 	mov.w	r0, #4294967295
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
}
 8006036:	4770      	bx	lr
 8006038:	200007dc 	.word	0x200007dc
 800603c:	20000007 	.word	0x20000007
 8006040:	20000008 	.word	0x20000008

08006044 <MIOS32_COM_SendBuffer>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8006044:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] len buffer length
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
 8006048:	b508      	push	{r3, lr}
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 800604a:	d104      	bne.n	8006056 <MIOS32_COM_SendBuffer+0x12>
    port = (port == COM_DEBUG) ? debug_port : default_port;
 800604c:	2801      	cmp	r0, #1
 800604e:	bf0c      	ite	eq
 8006050:	4b06      	ldreq	r3, [pc, #24]	; (800606c <MIOS32_COM_SendBuffer+0x28>)
 8006052:	4b07      	ldrne	r3, [pc, #28]	; (8006070 <MIOS32_COM_SendBuffer+0x2c>)
 8006054:	7818      	ldrb	r0, [r3, #0]
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 8006056:	0903      	lsrs	r3, r0, #4
 8006058:	2b02      	cmp	r3, #2
    case 1:
#if !defined(MIOS32_DONT_USE_USB) && defined(MIOS32_USE_USB_COM)
      return MIOS32_USB_COM_TxBufferPutMore(port & 0xf, buffer, len);
#else
      return -1; // USB has been disabled
 800605a:	bf18      	it	ne
 800605c:	f04f 30ff 	movne.w	r0, #4294967295
  if( !(port & 0xf0) ) {
    port = (port == COM_DEBUG) ? debug_port : default_port;
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 8006060:	d103      	bne.n	800606a <MIOS32_COM_SendBuffer+0x26>
      return -1; // USB has been disabled
#endif

    case 2:
#if !defined(MIOS32_DONT_USE_UART)
      return MIOS32_UART_TxBufferPutMore(port & 0xf, buffer, len);
 8006062:	f000 000f 	and.w	r0, r0, #15
 8006066:	f002 f9e9 	bl	800843c <MIOS32_UART_TxBufferPutMore>
      
    default:
      // invalid port
      return -1;
  }
}
 800606a:	bd08      	pop	{r3, pc}
 800606c:	20000008 	.word	0x20000008
 8006070:	20000007 	.word	0x20000007

08006074 <MIOS32_COM_SendChar>:
//! \param[in] c character
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendChar(mios32_com_port_t port, char c)
{
 8006074:	b507      	push	{r0, r1, r2, lr}
 8006076:	ab02      	add	r3, sp, #8
 8006078:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return MIOS32_COM_SendBuffer(port, (u8 *)&c, 1);
 800607c:	4619      	mov	r1, r3
 800607e:	2201      	movs	r2, #1
 8006080:	f7ff ffe0 	bl	8006044 <MIOS32_COM_SendBuffer>
}
 8006084:	bd0e      	pop	{r1, r2, r3, pc}

08006086 <MIOS32_COM_Receive_Handler>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_Receive_Handler(void)
{
  u8 port = DEFAULT;

  u8 intf = 0; // interface to be checked
 8006086:	2300      	movs	r3, #0
 8006088:	e000      	b.n	800608c <MIOS32_COM_Receive_Handler+0x6>
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 800608a:	4613      	mov	r3, r2
 800608c:	1c5a      	adds	r2, r3, #1
 800608e:	2b04      	cmp	r3, #4
 8006090:	b2d2      	uxtb	r2, r2
 8006092:	d9fa      	bls.n	800608a <MIOS32_COM_Receive_Handler+0x4>
	receive_callback_func(port, (u8)status);
    }
  } while( again );

  return 0;
}
 8006094:	2000      	movs	r0, #0
 8006096:	4770      	bx	lr

08006098 <MIOS32_UART_MIDI_RS_Reset>:
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 8006098:	2801      	cmp	r0, #1
//! \return -1 if port not available
//! \return < 0 on errors
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
 800609a:	b510      	push	{r4, lr}
 800609c:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
    return -1; // port not available
 800609e:	bf88      	it	hi
 80060a0:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 80060a4:	d80b      	bhi.n	80060be <MIOS32_UART_MIDI_RS_Reset+0x26>
    return -1; // port not available

  MIOS32_IRQ_Disable();
 80060a6:	f000 fb1d 	bl	80066e4 <MIOS32_IRQ_Disable>
  rs_last[uart_port] = 0xff;
 80060aa:	4b05      	ldr	r3, [pc, #20]	; (80060c0 <MIOS32_UART_MIDI_RS_Reset+0x28>)
 80060ac:	22ff      	movs	r2, #255	; 0xff
 80060ae:	551a      	strb	r2, [r3, r4]
  rs_expire_ctr[uart_port] = 0;
 80060b0:	4b04      	ldr	r3, [pc, #16]	; (80060c4 <MIOS32_UART_MIDI_RS_Reset+0x2c>)
 80060b2:	2200      	movs	r2, #0
 80060b4:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
  MIOS32_IRQ_Enable();
 80060b8:	f000 fb2a 	bl	8006710 <MIOS32_IRQ_Enable>

  return 0;
 80060bc:	2000      	movs	r0, #0
#endif
}
 80060be:	bd10      	pop	{r4, pc}
 80060c0:	200007e0 	.word	0x200007e0
 80060c4:	20000800 	.word	0x20000800

080060c8 <MIOS32_UART_MIDI_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Init(u32 mode)
{
 80060c8:	b510      	push	{r4, lr}
 80060ca:	4604      	mov	r4, r0
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80060cc:	f04f 30ff 	mov.w	r0, #4294967295
#else
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
 80060d0:	b9ec      	cbnz	r4, 800610e <MIOS32_UART_MIDI_Init+0x46>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80060d2:	4b0f      	ldr	r3, [pc, #60]	; (8006110 <MIOS32_UART_MIDI_Init+0x48>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060d4:	22ff      	movs	r2, #255	; 0xff
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80060d6:	601c      	str	r4, [r3, #0]
  midix->running_status = 0x00;
 80060d8:	711c      	strb	r4, [r3, #4]
  midix->expected_bytes = 0x00;
 80060da:	715c      	strb	r4, [r3, #5]
  midix->wait_bytes = 0x00;
 80060dc:	719c      	strb	r4, [r3, #6]
  midix->sysex_ctr = 0x00;
 80060de:	71dc      	strb	r4, [r3, #7]
  midix->timeout_ctr = 0;
 80060e0:	811c      	strh	r4, [r3, #8]
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80060e2:	60dc      	str	r4, [r3, #12]
  midix->running_status = 0x00;
 80060e4:	741c      	strb	r4, [r3, #16]
  midix->expected_bytes = 0x00;
 80060e6:	745c      	strb	r4, [r3, #17]
  midix->wait_bytes = 0x00;
 80060e8:	749c      	strb	r4, [r3, #18]
  midix->sysex_ctr = 0x00;
 80060ea:	74dc      	strb	r4, [r3, #19]
  midix->timeout_ctr = 0;
 80060ec:	829c      	strh	r4, [r3, #20]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060ee:	4b09      	ldr	r3, [pc, #36]	; (8006114 <MIOS32_UART_MIDI_Init+0x4c>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 80060f0:	4620      	mov	r0, r4
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 80060f2:	701a      	strb	r2, [r3, #0]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 80060f4:	f7ff ffd0 	bl	8006098 <MIOS32_UART_MIDI_RS_Reset>
 80060f8:	2001      	movs	r0, #1
 80060fa:	f7ff ffcd 	bl	8006098 <MIOS32_UART_MIDI_RS_Reset>

  // if any MIDI assignment:
#if MIOS32_UART0_ASSIGNMENT == 1 || MIOS32_UART1_ASSIGNMENT == 1 || MIOS32_UART2_ASSIGNMENT == 1
  // initialize U(S)ART interface
  if( MIOS32_UART_Init(0) < 0 )
 80060fe:	4620      	mov	r0, r4
 8006100:	f002 f806 	bl	8008110 <MIOS32_UART_Init>
    return -1; // initialisation of U(S)ART Interface failed
 8006104:	2800      	cmp	r0, #0
 8006106:	bfb4      	ite	lt
 8006108:	f04f 30ff 	movlt.w	r0, #4294967295
 800610c:	2000      	movge	r0, #0
#endif

  return 0; // no error
#endif
}
 800610e:	bd10      	pop	{r4, pc}
 8006110:	200007e4 	.word	0x200007e4
 8006114:	200007fc 	.word	0x200007fc

08006118 <MIOS32_UART_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Periodic_mS(void)
{
 8006118:	b508      	push	{r3, lr}
#if MIOS32_UART_NUM
  u8 uart_port;

  MIOS32_IRQ_Disable();
 800611a:	f000 fae3 	bl	80066e4 <MIOS32_IRQ_Disable>
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 800611e:	4b12      	ldr	r3, [pc, #72]	; (8006168 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 8006120:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006124:	881a      	ldrh	r2, [r3, #0]
 8006126:	428a      	cmp	r2, r1
 8006128:	d001      	beq.n	800612e <MIOS32_UART_MIDI_Periodic_mS+0x16>
      ++rs_expire_ctr[uart_port];
 800612a:	3201      	adds	r2, #1
 800612c:	801a      	strh	r2, [r3, #0]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 800612e:	4b0f      	ldr	r3, [pc, #60]	; (800616c <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 8006130:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006134:	891a      	ldrh	r2, [r3, #8]
 8006136:	428a      	cmp	r2, r1
 8006138:	d001      	beq.n	800613e <MIOS32_UART_MIDI_Periodic_mS+0x26>
      ++midi_rec[uart_port].timeout_ctr;
 800613a:	3201      	adds	r2, #1
 800613c:	811a      	strh	r2, [r3, #8]
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 800613e:	4b0a      	ldr	r3, [pc, #40]	; (8006168 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 8006140:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006144:	885a      	ldrh	r2, [r3, #2]
 8006146:	428a      	cmp	r2, r1
 8006148:	d001      	beq.n	800614e <MIOS32_UART_MIDI_Periodic_mS+0x36>
      ++rs_expire_ctr[uart_port];
 800614a:	3201      	adds	r2, #1
 800614c:	805a      	strh	r2, [r3, #2]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 800614e:	4b07      	ldr	r3, [pc, #28]	; (800616c <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 8006150:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006154:	8a9a      	ldrh	r2, [r3, #20]
 8006156:	428a      	cmp	r2, r1
 8006158:	d001      	beq.n	800615e <MIOS32_UART_MIDI_Periodic_mS+0x46>
      ++midi_rec[uart_port].timeout_ctr;
 800615a:	3201      	adds	r2, #1
 800615c:	829a      	strh	r2, [r3, #20]
  }
  MIOS32_IRQ_Enable();
 800615e:	f000 fad7 	bl	8006710 <MIOS32_IRQ_Enable>
  // (atomic operation not required in MIOS32_UART_MIDI_PackageSend_NonBlocking() due to single-byte accesses)
#endif

  return 0; // no error
}
 8006162:	2000      	movs	r0, #0
 8006164:	bd08      	pop	{r3, pc}
 8006166:	bf00      	nop
 8006168:	20000800 	.word	0x20000800
 800616c:	200007e4 	.word	0x200007e4

08006170 <MIOS32_UART_MIDI_PackageSend_NonBlocking>:
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 8006170:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 8006172:	2801      	cmp	r0, #1
 8006174:	f3c1 2607 	ubfx	r6, r1, #8, #8
 8006178:	f001 030f 	and.w	r3, r1, #15
 800617c:	f3c1 4207 	ubfx	r2, r1, #16, #8
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 8006180:	4604      	mov	r4, r0
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 8006182:	b2f7      	uxtb	r7, r6
 8006184:	f3c1 6107 	ubfx	r1, r1, #24, #8
 8006188:	d844      	bhi.n	8006214 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa4>
 800618a:	e046      	b.n	800621a <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xaa>

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};

    if( rs_expire_ctr[uart_port] > 1000 ) {
 800618c:	4826      	ldr	r0, [pc, #152]	; (8006228 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xb8>)
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 800618e:	f88d 6004 	strb.w	r6, [sp, #4]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 8006192:	f830 c014 	ldrh.w	ip, [r0, r4, lsl #1]
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 8006196:	f88d 2005 	strb.w	r2, [sp, #5]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 800619a:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 800619e:	f88d 1006 	strb.w	r1, [sp, #6]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 80061a2:	d903      	bls.n	80061ac <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x3c>
      // the current RS is expired each second to ensure that a status byte will be sent
      // if the MIDI cable is (re)connected during runtime
      MIOS32_UART_MIDI_RS_Reset(uart_port);
 80061a4:	4620      	mov	r0, r4
 80061a6:	f7ff ff77 	bl	8006098 <MIOS32_UART_MIDI_RS_Reset>
 80061aa:	e022      	b.n	80061f2 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
#if 0
      // for optional monitoring of the optimisation
      MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS 0x%02x expired!\n", uart_port);
#endif
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
 80061ac:	f8df c07c 	ldr.w	ip, [pc, #124]	; 800622c <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xbc>
 80061b0:	f89c c000 	ldrb.w	ip, [ip]
 80061b4:	fa4c fc04 	asr.w	ip, ip, r4
 80061b8:	f01c 0f01 	tst.w	ip, #1
 80061bc:	d019      	beq.n	80061f2 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
 80061be:	2b07      	cmp	r3, #7
 80061c0:	dd17      	ble.n	80061f2 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  package.cin >= NoteOff && package.cin <= PitchBend &&
 80061c2:	2b0e      	cmp	r3, #14
 80061c4:	bfcc      	ite	gt
 80061c6:	2300      	movgt	r3, #0
 80061c8:	2301      	movle	r3, #1
 80061ca:	2d01      	cmp	r5, #1
 80061cc:	bf94      	ite	ls
 80061ce:	2300      	movls	r3, #0
 80061d0:	f003 0301 	andhi.w	r3, r3, #1
 80061d4:	b16b      	cbz	r3, 80061f2 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
 80061d6:	4b16      	ldr	r3, [pc, #88]	; (8006230 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)
 80061d8:	5d1b      	ldrb	r3, [r3, r4]
 80061da:	42bb      	cmp	r3, r7
 80061dc:	d106      	bne.n	80061ec <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x7c>
	  buffer[0] = package.evnt1;
	  buffer[1] = package.evnt2;
	  --len;
 80061de:	3d01      	subs	r5, #1
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
	  package.cin >= NoteOff && package.cin <= PitchBend &&
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
	  buffer[0] = package.evnt1;
 80061e0:	f88d 2004 	strb.w	r2, [sp, #4]
	  buffer[1] = package.evnt2;
 80061e4:	f88d 1005 	strb.w	r1, [sp, #5]
	  --len;
 80061e8:	b2ed      	uxtb	r5, r5
 80061ea:	e002      	b.n	80061f2 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  // for optional monitoring of the optimisation
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS optimized (%02x) %02x %02x\n", uart_port, package.evnt0, package.evnt1, package.evnt2);
#endif
	} else {
	  // new running status
	  rs_expire_ctr[uart_port] = 0;
 80061ec:	2300      	movs	r3, #0
 80061ee:	f820 3014 	strh.w	r3, [r0, r4, lsl #1]
      }
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
 80061f2:	2ff7      	cmp	r7, #247	; 0xf7
      rs_last[uart_port] = package.evnt0;
 80061f4:	bf98      	it	ls
 80061f6:	4b0e      	ldrls	r3, [pc, #56]	; (8006230 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80061f8:	4620      	mov	r0, r4
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;
 80061fa:	bf98      	it	ls
 80061fc:	551e      	strbls	r6, [r3, r4]


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80061fe:	a901      	add	r1, sp, #4
 8006200:	462a      	mov	r2, r5
 8006202:	f002 f91b 	bl	800843c <MIOS32_UART_TxBufferPutMore>
 8006206:	3002      	adds	r0, #2
 8006208:	2802      	cmp	r0, #2
 800620a:	bf9c      	itt	ls
 800620c:	4b09      	ldrls	r3, [pc, #36]	; (8006234 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc4>)
 800620e:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
 8006212:	d901      	bls.n	8006218 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 8006214:	f04f 30ff 	mov.w	r0, #4294967295

  } else {
    return 0; // no bytes to send -> no error
  }
#endif
}
 8006218:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
 800621a:	4807      	ldr	r0, [pc, #28]	; (8006238 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc8>)
 800621c:	5cc5      	ldrb	r5, [r0, r3]
      case -2: return -2; // buffer full, request retry
      default: return -1; // UART error
    }

  } else {
    return 0; // no bytes to send -> no error
 800621e:	4628      	mov	r0, r5
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
 8006220:	2d00      	cmp	r5, #0
 8006222:	d1b3      	bne.n	800618c <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x1c>
 8006224:	e7f8      	b.n	8006218 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 8006226:	bf00      	nop
 8006228:	20000800 	.word	0x20000800
 800622c:	200007fc 	.word	0x200007fc
 8006230:	200007e0 	.word	0x200007e0
 8006234:	0800b080 	.word	0x0800b080
 8006238:	0800af54 	.word	0x0800af54

0800623c <MIOS32_UART_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: UART_MIDI device not available
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend(u8 uart_port, mios32_midi_package_t package)
{
 800623c:	b538      	push	{r3, r4, r5, lr}
 800623e:	4605      	mov	r5, r0
 8006240:	460c      	mov	r4, r1
  s32 error;

  while( (error=MIOS32_UART_MIDI_PackageSend_NonBlocking(uart_port, package)) == -2);
 8006242:	4628      	mov	r0, r5
 8006244:	4621      	mov	r1, r4
 8006246:	f7ff ff93 	bl	8006170 <MIOS32_UART_MIDI_PackageSend_NonBlocking>
 800624a:	f110 0f02 	cmn.w	r0, #2
 800624e:	d0f8      	beq.n	8006242 <MIOS32_UART_MIDI_PackageSend+0x6>

  return error;
}
 8006250:	bd38      	pop	{r3, r4, r5, pc}
	...

08006254 <MIOS32_UART_MIDI_PackageReceive>:
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 8006254:	2801      	cmp	r0, #1
//! \return -1: no package in buffer
//! \return -10: incoming MIDI package timed out (incomplete package received)
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageReceive(u8 uart_port, mios32_midi_package_t *package)
{
 8006256:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006258:	4604      	mov	r4, r0
 800625a:	460e      	mov	r6, r1
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled - accordingly no package in buffer
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;
 800625c:	bf88      	it	hi
 800625e:	f04f 30ff 	movhi.w	r0, #4294967295
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 8006262:	f200 80c5 	bhi.w	80063f0 <MIOS32_UART_MIDI_PackageReceive+0x19c>
 8006266:	e09e      	b.n	80063a6 <MIOS32_UART_MIDI_PackageReceive+0x152>
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
    u8 byte = (u8)status;
 8006268:	b2c0      	uxtb	r0, r0

    if( byte & 0x80 ) { // new MIDI status
 800626a:	f010 0f80 	tst.w	r0, #128	; 0x80
 800626e:	d048      	beq.n	8006302 <MIOS32_UART_MIDI_PackageReceive+0xae>
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
 8006270:	28f7      	cmp	r0, #247	; 0xf7
 8006272:	d908      	bls.n	8006286 <MIOS32_UART_MIDI_PackageReceive+0x32>
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
 8006274:	6833      	ldr	r3, [r6, #0]
 8006276:	f043 030f 	orr.w	r3, r3, #15
 800627a:	6033      	str	r3, [r6, #0]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
 800627c:	2300      	movs	r3, #0
    if( byte & 0x80 ) { // new MIDI status
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
	package->evnt0 = byte;
 800627e:	7070      	strb	r0, [r6, #1]
	package->evnt1 = 0x00;
 8006280:	70b3      	strb	r3, [r6, #2]
	package->evnt2 = 0x00;
 8006282:	70f3      	strb	r3, [r6, #3]
 8006284:	e0b5      	b.n	80063f2 <MIOS32_UART_MIDI_PackageReceive+0x19e>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 8006286:	f3c0 1302 	ubfx	r3, r0, #4, #3
 800628a:	5cfb      	ldrb	r3, [r7, r3]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
 800628c:	7128      	strb	r0, [r5, #4]
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 800628e:	716b      	strb	r3, [r5, #5]

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 8006290:	2b00      	cmp	r3, #0
 8006292:	d12e      	bne.n	80062f2 <MIOS32_UART_MIDI_PackageReceive+0x9e>
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 8006294:	4958      	ldr	r1, [pc, #352]	; (80063f8 <MIOS32_UART_MIDI_PackageReceive+0x1a4>)
 8006296:	f000 020f 	and.w	r2, r0, #15
 800629a:	5c8a      	ldrb	r2, [r1, r2]

	  if( byte == 0xf0 ) {
 800629c:	28f0      	cmp	r0, #240	; 0xf0
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 800629e:	716a      	strb	r2, [r5, #5]

	  if( byte == 0xf0 ) {
 80062a0:	d103      	bne.n	80062aa <MIOS32_UART_MIDI_PackageReceive+0x56>
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
	    midix->sysex_ctr = 0x01;
 80062a2:	2201      	movs	r2, #1

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];

	  if( byte == 0xf0 ) {
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
 80062a4:	7068      	strb	r0, [r5, #1]
	    midix->sysex_ctr = 0x01;
 80062a6:	71ea      	strb	r2, [r5, #7]
 80062a8:	e024      	b.n	80062f4 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	  } else if( byte == 0xf7 ) {
 80062aa:	28f7      	cmp	r0, #247	; 0xf7
 80062ac:	d122      	bne.n	80062f4 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	    switch( midix->sysex_ctr ) {
 80062ae:	79ea      	ldrb	r2, [r5, #7]
 80062b0:	b11a      	cbz	r2, 80062ba <MIOS32_UART_MIDI_PackageReceive+0x66>
 80062b2:	2a01      	cmp	r2, #1
 80062b4:	782a      	ldrb	r2, [r5, #0]
 80062b6:	d110      	bne.n	80062da <MIOS32_UART_MIDI_PackageReceive+0x86>
 80062b8:	e008      	b.n	80062cc <MIOS32_UART_MIDI_PackageReceive+0x78>
 	      case 0:
		midix->package.cin = 5; // 5: SysEx ends with single byte
 80062ba:	782b      	ldrb	r3, [r5, #0]
 80062bc:	2105      	movs	r1, #5
 80062be:	f361 0303 	bfi	r3, r1, #0, #4
 80062c2:	702b      	strb	r3, [r5, #0]
		midix->package.evnt0 = 0xf7;
 80062c4:	7068      	strb	r0, [r5, #1]
		midix->package.evnt1 = 0x00;
 80062c6:	70aa      	strb	r2, [r5, #2]
		midix->package.evnt2 = 0x00;
 80062c8:	70ea      	strb	r2, [r5, #3]
		break;
 80062ca:	e00c      	b.n	80062e6 <MIOS32_UART_MIDI_PackageReceive+0x92>
	      case 1:
		midix->package.cin = 6; // 6: SysEx ends with two bytes
 80062cc:	2106      	movs	r1, #6
 80062ce:	f361 0203 	bfi	r2, r1, #0, #4
 80062d2:	702a      	strb	r2, [r5, #0]
		// midix->package.evnt0 = // already stored
		midix->package.evnt1 = 0xf7;
 80062d4:	70a8      	strb	r0, [r5, #2]
		midix->package.evnt2 = 0x00;
 80062d6:	70eb      	strb	r3, [r5, #3]
		break;
 80062d8:	e005      	b.n	80062e6 <MIOS32_UART_MIDI_PackageReceive+0x92>
	      default:
		midix->package.cin = 7; // 7: SysEx ends with three bytes
 80062da:	4613      	mov	r3, r2
 80062dc:	2207      	movs	r2, #7
 80062de:	f362 0303 	bfi	r3, r2, #0, #4
 80062e2:	702b      	strb	r3, [r5, #0]
		// midix->package.evnt0 = // already stored
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
 80062e4:	70e8      	strb	r0, [r5, #3]
		break;
	    }
	    *package = midix->package;
 80062e6:	682b      	ldr	r3, [r5, #0]
 80062e8:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
 80062ea:	2300      	movs	r3, #0
 80062ec:	71eb      	strb	r3, [r5, #7]
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
		break;
	    }
	    *package = midix->package;
	    package_complete = 1; // -> forward to caller
 80062ee:	3301      	adds	r3, #1
 80062f0:	e000      	b.n	80062f4 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 80062f2:	2300      	movs	r3, #0
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
	  }
	}

	midix->wait_bytes = midix->expected_bytes;
 80062f4:	796a      	ldrb	r2, [r5, #5]
 80062f6:	71aa      	strb	r2, [r5, #6]
	midix->timeout_ctr = 0; // reset timeout counter
 80062f8:	2200      	movs	r2, #0
 80062fa:	812a      	strh	r2, [r5, #8]
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80062fc:	2b00      	cmp	r3, #0
 80062fe:	d057      	beq.n	80063b0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
 8006300:	e077      	b.n	80063f2 <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 8006302:	792b      	ldrb	r3, [r5, #4]
 8006304:	2bf0      	cmp	r3, #240	; 0xf0
 8006306:	d117      	bne.n	8006338 <MIOS32_UART_MIDI_PackageReceive+0xe4>
	switch( ++midix->sysex_ctr ) {
 8006308:	79eb      	ldrb	r3, [r5, #7]
 800630a:	3301      	adds	r3, #1
 800630c:	b2db      	uxtb	r3, r3
 800630e:	2b01      	cmp	r3, #1
 8006310:	71eb      	strb	r3, [r5, #7]
 8006312:	d002      	beq.n	800631a <MIOS32_UART_MIDI_PackageReceive+0xc6>
 8006314:	2b02      	cmp	r3, #2
 8006316:	d104      	bne.n	8006322 <MIOS32_UART_MIDI_PackageReceive+0xce>
 8006318:	e001      	b.n	800631e <MIOS32_UART_MIDI_PackageReceive+0xca>
  	  case 1:
	    midix->package.evnt0 = byte; 
 800631a:	7068      	strb	r0, [r5, #1]
	    break;
 800631c:	e048      	b.n	80063b0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  case 2: 
	    midix->package.evnt1 = byte; 
 800631e:	70a8      	strb	r0, [r5, #2]
	    break;
 8006320:	e046      	b.n	80063b0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  default: // 3
	    midix->package.evnt2 = byte;

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 8006322:	782b      	ldrb	r3, [r5, #0]
 8006324:	2204      	movs	r2, #4
 8006326:	f362 0303 	bfi	r3, r2, #0, #4
	    break;
	  case 2: 
	    midix->package.evnt1 = byte; 
	    break;
	  default: // 3
	    midix->package.evnt2 = byte;
 800632a:	70e8      	strb	r0, [r5, #3]

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 800632c:	702b      	strb	r3, [r5, #0]
	    *package = midix->package;
 800632e:	682b      	ldr	r3, [r5, #0]
 8006330:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
 8006332:	2300      	movs	r3, #0
 8006334:	71eb      	strb	r3, [r5, #7]
 8006336:	e05c      	b.n	80063f2 <MIOS32_UART_MIDI_PackageReceive+0x19e>
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
 8006338:	79ab      	ldrb	r3, [r5, #6]
 800633a:	b923      	cbnz	r3, 8006346 <MIOS32_UART_MIDI_PackageReceive+0xf2>
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 800633c:	796a      	ldrb	r2, [r5, #5]
	  midix->timeout_ctr = 0; // reset timeout counter
 800633e:	812b      	strh	r3, [r5, #8]
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 8006340:	3a01      	subs	r2, #1
 8006342:	71aa      	strb	r2, [r5, #6]
 8006344:	e001      	b.n	800634a <MIOS32_UART_MIDI_PackageReceive+0xf6>
	  midix->timeout_ctr = 0; // reset timeout counter
	} else {
	  --midix->wait_bytes;
 8006346:	3b01      	subs	r3, #1
 8006348:	71ab      	strb	r3, [r5, #6]
	}

	if( midix->expected_bytes == 1 ) {
 800634a:	796b      	ldrb	r3, [r5, #5]
 800634c:	2b01      	cmp	r3, #1
 800634e:	d103      	bne.n	8006358 <MIOS32_UART_MIDI_PackageReceive+0x104>
	  midix->package.evnt1 = byte;
	  midix->package.evnt2 = 0x00;
 8006350:	3b01      	subs	r3, #1
	} else {
	  --midix->wait_bytes;
	}

	if( midix->expected_bytes == 1 ) {
	  midix->package.evnt1 = byte;
 8006352:	70a8      	strb	r0, [r5, #2]
	  midix->package.evnt2 = 0x00;
 8006354:	70eb      	strb	r3, [r5, #3]
 8006356:	e004      	b.n	8006362 <MIOS32_UART_MIDI_PackageReceive+0x10e>
	} else {
	  if( midix->wait_bytes )
 8006358:	79ab      	ldrb	r3, [r5, #6]
 800635a:	b10b      	cbz	r3, 8006360 <MIOS32_UART_MIDI_PackageReceive+0x10c>
	    midix->package.evnt1 = byte;
 800635c:	70a8      	strb	r0, [r5, #2]
 800635e:	e000      	b.n	8006362 <MIOS32_UART_MIDI_PackageReceive+0x10e>
	  else
	    midix->package.evnt2 = byte;
 8006360:	70e8      	strb	r0, [r5, #3]
	}
	
	if( !midix->wait_bytes ) {
 8006362:	79ab      	ldrb	r3, [r5, #6]
 8006364:	bb23      	cbnz	r3, 80063b0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  if( (midix->running_status & 0xf0) != 0xf0 ) {
 8006366:	792b      	ldrb	r3, [r5, #4]
 8006368:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800636c:	2af0      	cmp	r2, #240	; 0xf0
 800636e:	d002      	beq.n	8006376 <MIOS32_UART_MIDI_PackageReceive+0x122>
	    midix->package.cin = midix->running_status >> 4; // common MIDI message
 8006370:	091a      	lsrs	r2, r3, #4
 8006372:	782b      	ldrb	r3, [r5, #0]
 8006374:	e00b      	b.n	800638e <MIOS32_UART_MIDI_PackageReceive+0x13a>
	  } else {
	    switch( midix->expected_bytes ) { // MEMO: == 0 comparison was a bug in original MBHP_USB code
 8006376:	796b      	ldrb	r3, [r5, #5]
 8006378:	b11b      	cbz	r3, 8006382 <MIOS32_UART_MIDI_PackageReceive+0x12e>
 800637a:	2b01      	cmp	r3, #1
 800637c:	782b      	ldrb	r3, [r5, #0]
 800637e:	d105      	bne.n	800638c <MIOS32_UART_MIDI_PackageReceive+0x138>
 8006380:	e002      	b.n	8006388 <MIOS32_UART_MIDI_PackageReceive+0x134>
  	      case 0: 
		midix->package.cin = 5; // 5: SysEx common with one byte
 8006382:	782b      	ldrb	r3, [r5, #0]
 8006384:	2205      	movs	r2, #5
 8006386:	e002      	b.n	800638e <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      case 1: 
		midix->package.cin = 2; // 2: SysEx common with two bytes
 8006388:	2202      	movs	r2, #2
 800638a:	e000      	b.n	800638e <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      default: 
		midix->package.cin = 3; // 3: SysEx common with three bytes
 800638c:	2203      	movs	r2, #3
 800638e:	f362 0303 	bfi	r3, r2, #0, #4
 8006392:	702b      	strb	r3, [r5, #0]
		break;
	    }
	  }

	  midix->package.evnt0 = midix->running_status;
 8006394:	230c      	movs	r3, #12
 8006396:	4363      	muls	r3, r4
 8006398:	4a18      	ldr	r2, [pc, #96]	; (80063fc <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 800639a:	18d1      	adds	r1, r2, r3
 800639c:	7908      	ldrb	r0, [r1, #4]
 800639e:	7048      	strb	r0, [r1, #1]
	  // midix->package.evnt1 = // already stored
	  // midix->package.evnt2 = // already stored
	  *package = midix->package;
 80063a0:	58d3      	ldr	r3, [r2, r3]
 80063a2:	6033      	str	r3, [r6, #0]
 80063a4:	e025      	b.n	80063f2 <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 80063a6:	4b15      	ldr	r3, [pc, #84]	; (80063fc <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 80063a8:	250c      	movs	r5, #12
 80063aa:	fb05 3504 	mla	r5, r5, r4, r3
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 80063ae:	4f14      	ldr	r7, [pc, #80]	; (8006400 <MIOS32_UART_MIDI_PackageReceive+0x1ac>)
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80063b0:	4620      	mov	r0, r4
 80063b2:	f001 ff51 	bl	8008258 <MIOS32_UART_RxBufferGet>
 80063b6:	2800      	cmp	r0, #0
 80063b8:	f6bf af56 	bge.w	8006268 <MIOS32_UART_MIDI_PackageReceive+0x14>
 80063bc:	2000      	movs	r0, #0
      }
    }
  }

  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
 80063be:	230c      	movs	r3, #12
 80063c0:	435c      	muls	r4, r3
 80063c2:	490e      	ldr	r1, [pc, #56]	; (80063fc <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 80063c4:	190b      	adds	r3, r1, r4
 80063c6:	799a      	ldrb	r2, [r3, #6]
 80063c8:	b16a      	cbz	r2, 80063e6 <MIOS32_UART_MIDI_PackageReceive+0x192>
 80063ca:	891a      	ldrh	r2, [r3, #8]
 80063cc:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 80063d0:	d909      	bls.n	80063e6 <MIOS32_UART_MIDI_PackageReceive+0x192>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 80063d2:	2200      	movs	r2, #0
 80063d4:	510a      	str	r2, [r1, r4]
  midix->running_status = 0x00;
 80063d6:	711a      	strb	r2, [r3, #4]
  midix->expected_bytes = 0x00;
 80063d8:	715a      	strb	r2, [r3, #5]
  midix->wait_bytes = 0x00;
 80063da:	719a      	strb	r2, [r3, #6]
  midix->sysex_ctr = 0x00;
 80063dc:	71da      	strb	r2, [r3, #7]
  midix->timeout_ctr = 0;
 80063de:	811a      	strh	r2, [r3, #8]
  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
    // stop waiting
    MIOS32_UART_MIDI_RecordReset(uart_port);
    // notify that incomplete package has been received
    return -10;
 80063e0:	f06f 0009 	mvn.w	r0, #9
 80063e4:	e004      	b.n	80063f0 <MIOS32_UART_MIDI_PackageReceive+0x19c>
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 80063e6:	2800      	cmp	r0, #0
 80063e8:	bf0c      	ite	eq
 80063ea:	f04f 30ff 	moveq.w	r0, #4294967295
 80063ee:	2000      	movne	r0, #0
#endif
}
 80063f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80063f2:	2001      	movs	r0, #1
 80063f4:	e7e3      	b.n	80063be <MIOS32_UART_MIDI_PackageReceive+0x16a>
 80063f6:	bf00      	nop
 80063f8:	0800af44 	.word	0x0800af44
 80063fc:	200007e4 	.word	0x200007e4
 8006400:	0800b070 	.word	0x0800b070

08006404 <MIOS32_IIC_MIDI_Init>:
  // TODO: send optimisation flag to IIC_MIDI device once it has been scanned!
#endif

  return 0; // no error
#endif
}
 8006404:	f04f 30ff 	mov.w	r0, #4294967295
 8006408:	4770      	bx	lr

0800640a <MIOS32_IIC_MIDI_Periodic_mS>:
s32 MIOS32_IIC_MIDI_Periodic_mS(void)
{
  // currently only a dummy - RS optimisation handled by IIC_MIDI device

  return 0;
}
 800640a:	2000      	movs	r0, #0
 800640c:	4770      	bx	lr

0800640e <MIOS32_IIC_MIDI_PackageSend>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageSend(u8 iic_port, mios32_midi_package_t package)
{
  return _MIOS32_IIC_MIDI_PackageSend(iic_port, package, 0); // blocking mode
}
 800640e:	f04f 30ff 	mov.w	r0, #4294967295
 8006412:	4770      	bx	lr

08006414 <MIOS32_IIC_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageReceive(u8 iic_port, mios32_midi_package_t *package)
{
  return _MIOS32_IIC_MIDI_PackageReceive(iic_port, package, 0); // blocking
}
 8006414:	f04f 30ff 	mov.w	r0, #4294967295
 8006418:	4770      	bx	lr

0800641a <MIOS32_IIC_BS_Init>:
  if( MIOS32_IIC_BS_ScanBankSticks() < 0 )
    return -2; // we don't expect that any other task accesses the IIC port yet!

  return 0; // no error
#endif
}
 800641a:	f04f 30ff 	mov.w	r0, #4294967295
 800641e:	4770      	bx	lr

08006420 <MIOS32_MF_Init>:
    mf_state[i].config.cfg.pwm_duty_cycle_up = 1;
  }

  return 0;
#endif
}
 8006420:	f04f 30ff 	mov.w	r0, #4294967295
 8006424:	4770      	bx	lr
	...

08006428 <MIOS32_SYS_Reset>:
//!   <LI>reset STM32
//! </UL>
//! \return < 0 if reset failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Reset(void)
{
 8006428:	b508      	push	{r3, lr}
  // disable all RTOS tasks
#ifndef MIOS32_DONT_USE_FREERTOS
  portENTER_CRITICAL(); // port specific FreeRTOS function to disable tasks (nested)
 800642a:	f7fe fd9f 	bl	8004f6c <vPortEnterCritical>

  // print reboot message if LCD enabled
#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 800642e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8006432:	f7ff f8f8 	bl	8005626 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 8006436:	2000      	movs	r0, #0
 8006438:	f7ff f8f9 	bl	800562e <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 800643c:	2000      	movs	r0, #0
 800643e:	f7ff f817 	bl	8005470 <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 8006442:	f7ff f87d 	bl	8005540 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 8006446:	2000      	movs	r0, #0
 8006448:	4601      	mov	r1, r0
 800644a:	f7ff f817 	bl	800547c <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("Bootloader Mode "); // 16 chars
 800644e:	4811      	ldr	r0, [pc, #68]	; (8006494 <MIOS32_SYS_Reset+0x6c>)
 8006450:	f7ff f8a8 	bl	80055a4 <MIOS32_LCD_PrintString>
#endif

  // wait until all MIDI OUT buffers are empty (TODO)

  // disable all interrupts
  MIOS32_IRQ_Disable();
 8006454:	f000 f946 	bl	80066e4 <MIOS32_IRQ_Disable>

  // turn off all board LEDs
  MIOS32_BOARD_LED_Set(0xffffffff, 0x00000000);
 8006458:	2100      	movs	r1, #0
 800645a:	f04f 30ff 	mov.w	r0, #4294967295
 800645e:	f000 fe79 	bl	8007154 <MIOS32_BOARD_LED_Set>
#else
  //  NVIC_GenerateSystemReset();
#ifdef MIOS32_BOARD_STM32_PRIMER
  RCC_APB2PeriphResetCmd(0xfffffff0, ENABLE); // Primer: don't reset GPIOA/AF + GPIOB due to USB detach pin
#else
  RCC_APB2PeriphResetCmd(0xfffffff8, ENABLE); // MBHP_CORE_STM32: don't reset GPIOA/AF due to USB pins
 8006462:	f06f 0007 	mvn.w	r0, #7
 8006466:	2101      	movs	r1, #1
 8006468:	f002 ffd2 	bl	8009410 <RCC_APB2PeriphResetCmd>
#endif
  RCC_APB1PeriphResetCmd(0xff7fffff, ENABLE); // don't reset USB, so that the connection can survive!
 800646c:	f46f 0000 	mvn.w	r0, #8388608	; 0x800000
 8006470:	2101      	movs	r1, #1
 8006472:	f002 ffdb 	bl	800942c <RCC_APB1PeriphResetCmd>
  RCC_APB2PeriphResetCmd(0xffffffff, DISABLE);
 8006476:	f04f 30ff 	mov.w	r0, #4294967295
 800647a:	2100      	movs	r1, #0
 800647c:	f002 ffc8 	bl	8009410 <RCC_APB2PeriphResetCmd>
  RCC_APB1PeriphResetCmd(0xffffffff, DISABLE);
 8006480:	f04f 30ff 	mov.w	r0, #4294967295
 8006484:	2100      	movs	r1, #0
 8006486:	f002 ffd1 	bl	800942c <RCC_APB1PeriphResetCmd>
  // not available in v3.0.0 library anymore? - copy from v2.0.1
  SCB->AIRCR = NVIC_AIRCR_VECTKEY | (1 << NVIC_VECTRESET);
#endif
#if 1
  // and this is the code for v3.3.0
  SCB->AIRCR = (0x5fa << SCB_AIRCR_VECTKEY_Pos) | (1 << SCB_AIRCR_VECTRESET_Pos);
 800648a:	4a03      	ldr	r2, [pc, #12]	; (8006498 <MIOS32_SYS_Reset+0x70>)
 800648c:	4b03      	ldr	r3, [pc, #12]	; (800649c <MIOS32_SYS_Reset+0x74>)
 800648e:	60da      	str	r2, [r3, #12]
 8006490:	e7fe      	b.n	8006490 <MIOS32_SYS_Reset+0x68>
 8006492:	bf00      	nop
 8006494:	0800b08c 	.word	0x0800b08c
 8006498:	05fa0001 	.word	0x05fa0001
 800649c:	e000ed00 	.word	0xe000ed00

080064a0 <MIOS32_SYS_ChipIDGet>:
//! \return the chip ID
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_ChipIDGet(void)
{
  // stored in DBGMCU_IDCODE register
  return MEM32(0xe0042000);
 80064a0:	4b01      	ldr	r3, [pc, #4]	; (80064a8 <MIOS32_SYS_ChipIDGet+0x8>)
 80064a2:	6818      	ldr	r0, [r3, #0]
}
 80064a4:	4770      	bx	lr
 80064a6:	bf00      	nop
 80064a8:	e0042000 	.word	0xe0042000

080064ac <MIOS32_SYS_FlashSizeGet>:
//! \return the Flash size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_FlashSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e0) * 0x400;
 80064ac:	4b02      	ldr	r3, [pc, #8]	; (80064b8 <MIOS32_SYS_FlashSizeGet+0xc>)
 80064ae:	8818      	ldrh	r0, [r3, #0]
 80064b0:	b280      	uxth	r0, r0
 80064b2:	0280      	lsls	r0, r0, #10
}
 80064b4:	4770      	bx	lr
 80064b6:	bf00      	nop
 80064b8:	1ffff7e0 	.word	0x1ffff7e0

080064bc <MIOS32_SYS_RAMSizeGet>:
//! \return the RAM size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_RAMSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e2) * 0x400;
 80064bc:	4b02      	ldr	r3, [pc, #8]	; (80064c8 <MIOS32_SYS_RAMSizeGet+0xc>)
 80064be:	8818      	ldrh	r0, [r3, #0]
 80064c0:	b280      	uxth	r0, r0
 80064c2:	0280      	lsls	r0, r0, #10
}
 80064c4:	4770      	bx	lr
 80064c6:	bf00      	nop
 80064c8:	1ffff7e2 	.word	0x1ffff7e2

080064cc <MIOS32_SYS_SerialNumberGet>:
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 80064cc:	2300      	movs	r3, #0
    u8 b = MEM8(0x1ffff7e8 + (i/2));
 80064ce:	4a0b      	ldr	r2, [pc, #44]	; (80064fc <MIOS32_SYS_SerialNumberGet+0x30>)
 80064d0:	1059      	asrs	r1, r3, #1
 80064d2:	188a      	adds	r2, r1, r2
 80064d4:	7812      	ldrb	r2, [r2, #0]
    if( !(i & 1) )
 80064d6:	f013 0f01 	tst.w	r3, #1
      b >>= 4;
 80064da:	bf08      	it	eq
 80064dc:	0912      	lsreq	r2, r2, #4
    b &= 0x0f;
 80064de:	f002 020f 	and.w	r2, r2, #15

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
 80064e2:	2a09      	cmp	r2, #9
 80064e4:	bf94      	ite	ls
 80064e6:	2130      	movls	r1, #48	; 0x30
 80064e8:	2137      	movhi	r1, #55	; 0x37
 80064ea:	188a      	adds	r2, r1, r2
 80064ec:	54c2      	strb	r2, [r0, r3]
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 80064ee:	3301      	adds	r3, #1
 80064f0:	2b18      	cmp	r3, #24
 80064f2:	d1ec      	bne.n	80064ce <MIOS32_SYS_SerialNumberGet+0x2>
      b >>= 4;
    b &= 0x0f;

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
  }
  str[i] = 0;
 80064f4:	2300      	movs	r3, #0
 80064f6:	7603      	strb	r3, [r0, #24]

  return 0; // no error
}
 80064f8:	4618      	mov	r0, r3
 80064fa:	4770      	bx	lr
 80064fc:	1ffff7e8 	.word	0x1ffff7e8

08006500 <MIOS32_SYS_TimeSet>:
//! Note that this format isn't completely compatible to the NTP timestamp format,
//! as the fraction has only mS accuracy
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_TimeSet(mios32_sys_time_t t)
{
 8006500:	b507      	push	{r0, r1, r2, lr}
 8006502:	466b      	mov	r3, sp
 8006504:	e883 0003 	stmia.w	r3, {r0, r1}
  // taken from STM32 example "RTC/Calendar"
  // adapted to clock RTC via HSE  oscillator

  // Enable PWR and BKP clocks
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 8006508:	2101      	movs	r1, #1
 800650a:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 800650e:	f002 ff71 	bl	80093f4 <RCC_APB1PeriphClockCmd>

  // Allow access to BKP Domain
  PWR_BackupAccessCmd(ENABLE);
 8006512:	2001      	movs	r0, #1
 8006514:	f003 f82a 	bl	800956c <PWR_BackupAccessCmd>

  // Reset Backup Domain
  BKP_DeInit();
 8006518:	f003 f820 	bl	800955c <BKP_DeInit>

  // Select HSE (divided by 128) as RTC Clock Source
  RCC_RTCCLKConfig(RCC_RTCCLKSource_HSE_Div128);
 800651c:	f44f 7040 	mov.w	r0, #768	; 0x300
 8006520:	f002 feea 	bl	80092f8 <RCC_RTCCLKConfig>

  // Enable RTC Clock
  RCC_RTCCLKCmd(ENABLE);
 8006524:	2001      	movs	r0, #1
 8006526:	f002 feef 	bl	8009308 <RCC_RTCCLKCmd>

  // Wait for RTC registers synchronization
  RTC_WaitForSynchro();
 800652a:	f003 f809 	bl	8009540 <RTC_WaitForSynchro>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800652e:	f002 ffff 	bl	8009530 <RTC_WaitForLastTask>

  // Enable the RTC Second
  RTC_ITConfig(RTC_IT_SEC, ENABLE);
 8006532:	2001      	movs	r0, #1
 8006534:	4601      	mov	r1, r0
 8006536:	f002 ffb9 	bl	80094ac <RTC_ITConfig>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800653a:	f002 fff9 	bl	8009530 <RTC_WaitForLastTask>

  // Set RTC prescaler: set RTC period to 1sec
  RTC_SetPrescaler(RTC_PREDIVIDER-1);
 800653e:	4806      	ldr	r0, [pc, #24]	; (8006558 <MIOS32_SYS_TimeSet+0x58>)
 8006540:	f002 ffe6 	bl	8009510 <RTC_SetPrescaler>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 8006544:	f002 fff4 	bl	8009530 <RTC_WaitForLastTask>

  // Change the current time
  // (fraction not taken into account here)
  RTC_SetCounter(t.seconds);
 8006548:	9800      	ldr	r0, [sp, #0]
 800654a:	f002 ffd3 	bl	80094f4 <RTC_SetCounter>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800654e:	f002 ffef 	bl	8009530 <RTC_WaitForLastTask>

  return 0; // no error
}
 8006552:	2000      	movs	r0, #0
 8006554:	bd0e      	pop	{r1, r2, r3, pc}
 8006556:	bf00      	nop
 8006558:	00016e35 	.word	0x00016e35

0800655c <MIOS32_SYS_Init>:
//! </UL>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
 800655c:	b530      	push	{r4, r5, lr}
 800655e:	4605      	mov	r5, r0
 8006560:	b085      	sub	sp, #20
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8006562:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
 8006566:	2d00      	cmp	r5, #0
 8006568:	d177      	bne.n	800665a <MIOS32_SYS_Init+0xfe>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800656a:	ac03      	add	r4, sp, #12
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
 800656c:	2101      	movs	r1, #1
 800656e:	207d      	movs	r0, #125	; 0x7d
 8006570:	f002 ff32 	bl	80093d8 <RCC_APB2PeriphClockCmd>
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8006574:	4620      	mov	r0, r4
 8006576:	f002 fab9 	bl	8008aec <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 800657a:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800657c:	4621      	mov	r1, r4
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 800657e:	f88d 300f 	strb.w	r3, [sp, #15]
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8006582:	4837      	ldr	r0, [pc, #220]	; (8006660 <MIOS32_SYS_Init+0x104>)

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
 8006584:	f24e 73ff 	movw	r3, #59391	; 0xe7ff
 8006588:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800658c:	f002 fa55 	bl	8008a3a <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 8006590:	f04f 33ff 	mov.w	r3, #4294967295
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8006594:	4621      	mov	r1, r4
 8006596:	4833      	ldr	r0, [pc, #204]	; (8006664 <MIOS32_SYS_Init+0x108>)
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 8006598:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800659c:	f002 fa4d 	bl	8008a3a <GPIO_Init>
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 80065a0:	4621      	mov	r1, r4
 80065a2:	4831      	ldr	r0, [pc, #196]	; (8006668 <MIOS32_SYS_Init+0x10c>)
 80065a4:	f002 fa49 	bl	8008a3a <GPIO_Init>
  GPIO_Init(GPIOB, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 80065a8:	4621      	mov	r1, r4
 80065aa:	4830      	ldr	r0, [pc, #192]	; (800666c <MIOS32_SYS_Init+0x110>)
 80065ac:	f002 fa45 	bl	8008a3a <GPIO_Init>
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 80065b0:	f002 fe6c 	bl	800928c <RCC_GetSYSCLKSource>
 80065b4:	2808      	cmp	r0, #8
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;
 80065b6:	bf08      	it	eq
 80065b8:	462c      	moveq	r4, r5
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 80065ba:	d033      	beq.n	8006624 <MIOS32_SYS_Init+0xc8>
    // Start with the clocks in their expected state
    RCC_DeInit();
 80065bc:	f002 fe10 	bl	80091e0 <RCC_DeInit>

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);
 80065c0:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80065c4:	f002 fe2c 	bl	8009220 <RCC_HSEConfig>

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 80065c8:	f002 ff5a 	bl	8009480 <RCC_WaitForHSEStartUp>

    if( HSEStartUpStatus == SUCCESS ) {
 80065cc:	2801      	cmp	r0, #1

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 80065ce:	4604      	mov	r4, r0

    if( HSEStartUpStatus == SUCCESS ) {
 80065d0:	d128      	bne.n	8006624 <MIOS32_SYS_Init+0xc8>
      // Enable Prefetch Buffer
      FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 80065d2:	2010      	movs	r0, #16
 80065d4:	f002 fad6 	bl	8008b84 <FLASH_PrefetchBufferCmd>

      // Flash 2 wait state
      FLASH_SetLatency(FLASH_Latency_2);
 80065d8:	2002      	movs	r0, #2
 80065da:	f002 fac9 	bl	8008b70 <FLASH_SetLatency>

      // HCLK = SYSCLK
      RCC_HCLKConfig(RCC_SYSCLK_Div1);
 80065de:	4628      	mov	r0, r5
 80065e0:	f002 fe5c 	bl	800929c <RCC_HCLKConfig>

      // PCLK2 = HCLK
      RCC_PCLK2Config(RCC_HCLK_Div1);
 80065e4:	4628      	mov	r0, r5
 80065e6:	f002 fe6d 	bl	80092c4 <RCC_PCLK2Config>

      // PCLK1 = HCLK/2
      RCC_PCLK1Config(RCC_HCLK_Div2);
 80065ea:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80065ee:	f002 fe5f 	bl	80092b0 <RCC_PCLK1Config>

      // ADCCLK = PCLK2/6
      RCC_ADCCLKConfig(RCC_PCLK2_Div6);
 80065f2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80065f6:	f002 fe75 	bl	80092e4 <RCC_ADCCLKConfig>
      // PLL configuration: PLLCLK = (PLL2 / 5) * 9 = 72 MHz
      RCC_PREDIV1Config(RCC_PREDIV1_Source_PLL2, RCC_PREDIV1_Div5);
      RCC_PLLConfig(RCC_PLLSource_PREDIV1, RCC_PLLMul_9);
#else
      // PLLCLK = 12MHz * 6 = 72 MHz
      RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_6);
 80065fa:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80065fe:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 8006602:	f002 fe29 	bl	8009258 <RCC_PLLConfig>
#endif

      // Enable PLL
      RCC_PLLCmd(ENABLE);
 8006606:	4620      	mov	r0, r4
 8006608:	f002 fe30 	bl	800926c <RCC_PLLCmd>

      // Wait till PLL is ready
      while( RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET );
 800660c:	2039      	movs	r0, #57	; 0x39
 800660e:	f002 ff21 	bl	8009454 <RCC_GetFlagStatus>
 8006612:	2800      	cmp	r0, #0
 8006614:	d0fa      	beq.n	800660c <MIOS32_SYS_Init+0xb0>

      // Select PLL as system clock source
      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 8006616:	2002      	movs	r0, #2
 8006618:	f002 fe2e 	bl	8009278 <RCC_SYSCLKConfig>

      // Wait till PLL is used as system clock source
      while( RCC_GetSYSCLKSource() != 0x08 );
 800661c:	f002 fe36 	bl	800928c <RCC_GetSYSCLKSource>
 8006620:	2808      	cmp	r0, #8
 8006622:	d1fb      	bne.n	800661c <MIOS32_SYS_Init+0xc0>
    }
  }

  // Set the Vector Table base address as specified in .ld file (-> mios32_sys_isr_vector)
  NVIC_SetVectorTable((u32)&mios32_sys_isr_vector, 0x0);
 8006624:	2100      	movs	r1, #0
 8006626:	4812      	ldr	r0, [pc, #72]	; (8006670 <MIOS32_SYS_Init+0x114>)
 8006628:	f002 ffb0 	bl	800958c <NVIC_SetVectorTable>
  NVIC_PriorityGroupConfig(MIOS32_IRQ_PRIGROUP);
 800662c:	f44f 7040 	mov.w	r0, #768	; 0x300
 8006630:	f002 ffa2 	bl	8009578 <NVIC_PriorityGroupConfig>

  // Configure HCLK clock as SysTick clock source
  SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );
 8006634:	2004      	movs	r0, #4
 8006636:	f002 ffb5 	bl	80095a4 <SysTick_CLKSourceConfig>

  // configure debug control register DBGMCU_CR (we want to stop timers in CPU HALT mode)
  // flags can be overruled in mios32_config.h
  MEM32(0xe0042004) = MIOS32_SYS_STM32_DBGMCU_CR;
 800663a:	4a0e      	ldr	r2, [pc, #56]	; (8006674 <MIOS32_SYS_Init+0x118>)
 800663c:	4b0e      	ldr	r3, [pc, #56]	; (8006678 <MIOS32_SYS_Init+0x11c>)
 800663e:	601a      	str	r2, [r3, #0]

  // initialize system clock
  mios32_sys_time_t t = { .seconds=0, .fraction_ms=0 };
 8006640:	2300      	movs	r3, #0
 8006642:	9301      	str	r3, [sp, #4]
 8006644:	9302      	str	r3, [sp, #8]
  MIOS32_SYS_TimeSet(t);
 8006646:	ab01      	add	r3, sp, #4
 8006648:	e893 0003 	ldmia.w	r3, {r0, r1}
 800664c:	f7ff ff58 	bl	8006500 <MIOS32_SYS_TimeSet>

  // error during clock configuration?
  return HSEStartUpStatus == SUCCESS ? 0 : -1;
 8006650:	2c01      	cmp	r4, #1
 8006652:	bf14      	ite	ne
 8006654:	f04f 30ff 	movne.w	r0, #4294967295
 8006658:	2000      	moveq	r0, #0
}
 800665a:	b005      	add	sp, #20
 800665c:	bd30      	pop	{r4, r5, pc}
 800665e:	bf00      	nop
 8006660:	40010800 	.word	0x40010800
 8006664:	40011000 	.word	0x40011000
 8006668:	40011400 	.word	0x40011400
 800666c:	40010c00 	.word	0x40010c00
 8006670:	08004000 	.word	0x08004000
 8006674:	001fff00 	.word	0x001fff00
 8006678:	e0042004 	.word	0xe0042004

0800667c <MIOS32_SYS_TimeGet>:
//!   int milliseconds = t.fraction_ms;
//! \endcode
//! \return the system time in a mios32_sys_time_t structure
/////////////////////////////////////////////////////////////////////////////
mios32_sys_time_t MIOS32_SYS_TimeGet(void)
{
 800667c:	b570      	push	{r4, r5, r6, lr}
 800667e:	4604      	mov	r4, r0
  // therefore interrupts are disabled
  // Disadvantage: bad for interrupt latency...
  // However, expected execution time is ca. 500 nS for two loops (best case),
  // and 750 nS for three loops (worst case)

  MIOS32_IRQ_Disable();
 8006680:	f000 f830 	bl	80066e4 <MIOS32_IRQ_Disable>
  seconds = divider = 0;
 8006684:	2200      	movs	r2, #0
 8006686:	4611      	mov	r1, r2
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
 8006688:	4b12      	ldr	r3, [pc, #72]	; (80066d4 <MIOS32_SYS_TimeGet+0x58>)
 800668a:	e001      	b.n	8006690 <MIOS32_SYS_TimeGet+0x14>
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 800668c:	462a      	mov	r2, r5
  MIOS32_IRQ_Disable();
  seconds = divider = 0;
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
 800668e:	4631      	mov	r1, r6
 8006690:	8b18      	ldrh	r0, [r3, #24]
 8006692:	8b9e      	ldrh	r6, [r3, #28]
 8006694:	b2b6      	uxth	r6, r6
 8006696:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 800669a:	8a18      	ldrh	r0, [r3, #16]
 800669c:	8a9d      	ldrh	r5, [r3, #20]
  } while( seconds != last_seconds && divider != last_divider );
 800669e:	1a71      	subs	r1, r6, r1
 80066a0:	bf18      	it	ne
 80066a2:	2101      	movne	r1, #1
  seconds = divider = 0;
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 80066a4:	b2ad      	uxth	r5, r5
 80066a6:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
  } while( seconds != last_seconds && divider != last_divider );
 80066aa:	4295      	cmp	r5, r2
 80066ac:	bf0c      	ite	eq
 80066ae:	2200      	moveq	r2, #0
 80066b0:	f001 0201 	andne.w	r2, r1, #1
 80066b4:	2a00      	cmp	r2, #0
 80066b6:	d1e9      	bne.n	800668c <MIOS32_SYS_TimeGet+0x10>
  MIOS32_IRQ_Enable();
 80066b8:	f000 f82a 	bl	8006710 <MIOS32_IRQ_Enable>

  mios32_sys_time_t t = {
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
 80066bc:	4b06      	ldr	r3, [pc, #24]	; (80066d8 <MIOS32_SYS_TimeGet+0x5c>)
 80066be:	4a07      	ldr	r2, [pc, #28]	; (80066dc <MIOS32_SYS_TimeGet+0x60>)
 80066c0:	435d      	muls	r5, r3
 80066c2:	4b07      	ldr	r3, [pc, #28]	; (80066e0 <MIOS32_SYS_TimeGet+0x64>)
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
  } while( seconds != last_seconds && divider != last_divider );
  MIOS32_IRQ_Enable();
 80066c4:	6026      	str	r6, [r4, #0]

  mios32_sys_time_t t = {
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
 80066c6:	18eb      	adds	r3, r5, r3
 80066c8:	fbb3 f3f2 	udiv	r3, r3, r2
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
  } while( seconds != last_seconds && divider != last_divider );
  MIOS32_IRQ_Enable();
 80066cc:	6063      	str	r3, [r4, #4]
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
  };

  return t;
}
 80066ce:	4620      	mov	r0, r4
 80066d0:	bd70      	pop	{r4, r5, r6, pc}
 80066d2:	bf00      	nop
 80066d4:	40002800 	.word	0x40002800
 80066d8:	fffffc18 	.word	0xfffffc18
 80066dc:	00016e36 	.word	0x00016e36
 80066e0:	05967f08 	.word	0x05967f08

080066e4 <MIOS32_IRQ_Disable>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Disable(void)
{
  // get current priority if nested level == 0
  if( !nested_ctr ) {
 80066e4:	4b08      	ldr	r3, [pc, #32]	; (8006708 <MIOS32_IRQ_Disable+0x24>)
 80066e6:	681b      	ldr	r3, [r3, #0]
 80066e8:	b91b      	cbnz	r3, 80066f2 <MIOS32_IRQ_Disable+0xe>
    __asm volatile (			   \
 80066ea:	f3ef 8210 	mrs	r2, PRIMASK
 80066ee:	4b07      	ldr	r3, [pc, #28]	; (800670c <MIOS32_IRQ_Disable+0x28>)
 80066f0:	601a      	str	r2, [r3, #0]
		    : "=r" (prev_primask)  \
		    );
  }

  // disable interrupts
  __asm volatile ( \
 80066f2:	f04f 0001 	mov.w	r0, #1
 80066f6:	f380 8810 	msr	PRIMASK, r0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 80066fa:	4b03      	ldr	r3, [pc, #12]	; (8006708 <MIOS32_IRQ_Disable+0x24>)

  return 0; // no error
}
 80066fc:	2000      	movs	r0, #0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 80066fe:	681a      	ldr	r2, [r3, #0]
 8006700:	3201      	adds	r2, #1
 8006702:	601a      	str	r2, [r3, #0]

  return 0; // no error
}
 8006704:	4770      	bx	lr
 8006706:	bf00      	nop
 8006708:	20000808 	.word	0x20000808
 800670c:	20000804 	.word	0x20000804

08006710 <MIOS32_IRQ_Enable>:
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 8006710:	4a06      	ldr	r2, [pc, #24]	; (800672c <MIOS32_IRQ_Enable+0x1c>)
    return -1; // nesting error
 8006712:	f04f 30ff 	mov.w	r0, #4294967295
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 8006716:	6813      	ldr	r3, [r2, #0]
 8006718:	b13b      	cbz	r3, 800672a <MIOS32_IRQ_Enable+0x1a>
    return -1; // nesting error

  // decrease nesting level
  --nested_ctr;
 800671a:	3b01      	subs	r3, #1
 800671c:	6013      	str	r3, [r2, #0]

  // set back previous priority once nested level reached 0 again
  if( nested_ctr == 0 ) {
 800671e:	b91b      	cbnz	r3, 8006728 <MIOS32_IRQ_Enable+0x18>
    __asm volatile ( \
 8006720:	4b03      	ldr	r3, [pc, #12]	; (8006730 <MIOS32_IRQ_Enable+0x20>)
 8006722:	681b      	ldr	r3, [r3, #0]
 8006724:	f383 8810 	msr	PRIMASK, r3
		    "	msr primask, %0\n" \
		    :: "r" (prev_primask)  \
		    );
  }

  return 0; // no error
 8006728:	2000      	movs	r0, #0
}
 800672a:	4770      	bx	lr
 800672c:	20000808 	.word	0x20000808
 8006730:	20000804 	.word	0x20000804

08006734 <MIOS32_IRQ_Install>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 8006734:	290f      	cmp	r1, #15
    return -1; // invalid priority
 8006736:	bf88      	it	hi
 8006738:	f04f 30ff 	movhi.w	r0, #4294967295
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 800673c:	d818      	bhi.n	8006770 <MIOS32_IRQ_Install+0x3c>
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
 800673e:	4b0d      	ldr	r3, [pc, #52]	; (8006774 <MIOS32_IRQ_Install+0x40>)
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 8006740:	b242      	sxtb	r2, r0
 8006742:	68db      	ldr	r3, [r3, #12]
 8006744:	0952      	lsrs	r2, r2, #5
 8006746:	43db      	mvns	r3, r3
 8006748:	f3c3 2302 	ubfx	r3, r3, #8, #3
  u32 tmppre = (4 - tmppriority);
 800674c:	f1c3 0304 	rsb	r3, r3, #4
  tmppriority = priority << tmppre;
 8006750:	4099      	lsls	r1, r3
  tmppriority = tmppriority << 4;
  NVIC->IP[IRQn] = tmppriority;
 8006752:	4b09      	ldr	r3, [pc, #36]	; (8006778 <MIOS32_IRQ_Install+0x44>)
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
  u32 tmppre = (4 - tmppriority);
  tmppriority = priority << tmppre;
  tmppriority = tmppriority << 4;
 8006754:	0109      	lsls	r1, r1, #4
  NVIC->IP[IRQn] = tmppriority;
 8006756:	18c3      	adds	r3, r0, r3
 8006758:	b2c9      	uxtb	r1, r1
 800675a:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
 800675e:	f000 001f 	and.w	r0, r0, #31
 8006762:	2301      	movs	r3, #1
 8006764:	fa13 f000 	lsls.w	r0, r3, r0
 8006768:	4b03      	ldr	r3, [pc, #12]	; (8006778 <MIOS32_IRQ_Install+0x44>)
 800676a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]

  NVIC_EnableIRQ(IRQn);

  return 0; // no error
 800676e:	2000      	movs	r0, #0
}
 8006770:	4770      	bx	lr
 8006772:	bf00      	nop
 8006774:	e000ed00 	.word	0xe000ed00
 8006778:	e000e100 	.word	0xe000e100

0800677c <MIOS32_SPI_IO_Init>:
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported pin driver mode
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_IO_Init(u8 spi, mios32_spi_pin_driver_t spi_pin_driver)
{
 800677c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800677e:	4604      	mov	r4, r0
 8006780:	460d      	mov	r5, r1
  // init GPIO structure
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8006782:	a801      	add	r0, sp, #4
 8006784:	f002 f9b2 	bl	8008aec <GPIO_StructInit>

  // select pin driver and output mode
  u32 af_mode;
  u32 gp_mode;

  switch( spi_pin_driver ) {
 8006788:	2d03      	cmp	r5, #3
 800678a:	f200 809e 	bhi.w	80068ca <MIOS32_SPI_IO_Init+0x14e>
 800678e:	e8df f005 	tbb	[pc, r5]
 8006792:	0802      	.short	0x0802
 8006794:	140e      	.short	0x140e
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8006796:	2303      	movs	r3, #3
 8006798:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 800679c:	2510      	movs	r5, #16
  u32 gp_mode;

  switch( spi_pin_driver ) {
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_PP;
 800679e:	3315      	adds	r3, #21
      gp_mode = GPIO_Mode_Out_PP;
      break;
 80067a0:	e010      	b.n	80067c4 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80067a2:	2303      	movs	r3, #3
 80067a4:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 80067a8:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_OD;
 80067aa:	3319      	adds	r3, #25
      gp_mode = GPIO_Mode_Out_OD;
      break;
 80067ac:	e00a      	b.n	80067c4 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80067ae:	2302      	movs	r3, #2
 80067b0:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 80067b4:	2510      	movs	r5, #16
      gp_mode = GPIO_Mode_Out_OD;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_PP;
 80067b6:	3316      	adds	r3, #22
      gp_mode = GPIO_Mode_Out_PP;
      break;
 80067b8:	e004      	b.n	80067c4 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80067ba:	2302      	movs	r3, #2
 80067bc:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 80067c0:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_OD;
 80067c2:	331a      	adds	r3, #26

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 80067c4:	2c01      	cmp	r4, #1
 80067c6:	d030      	beq.n	800682a <MIOS32_SPI_IO_Init+0xae>
 80067c8:	d305      	bcc.n	80067d6 <MIOS32_SPI_IO_Init+0x5a>
 80067ca:	2c02      	cmp	r4, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 80067cc:	bf18      	it	ne
 80067ce:	f06f 0001 	mvnne.w	r0, #1

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 80067d2:	d17c      	bne.n	80068ce <MIOS32_SPI_IO_Init+0x152>
 80067d4:	e04c      	b.n	8006870 <MIOS32_SPI_IO_Init+0xf4>
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 80067d6:	ac02      	add	r4, sp, #8
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 80067d8:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 80067dc:	2320      	movs	r3, #32
 80067de:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
 80067e2:	483b      	ldr	r0, [pc, #236]	; (80068d0 <MIOS32_SPI_IO_Init+0x154>)
 80067e4:	4621      	mov	r1, r4
 80067e6:	f002 f928 	bl	8008a3a <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 80067ea:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 80067ec:	4838      	ldr	r0, [pc, #224]	; (80068d0 <MIOS32_SPI_IO_Init+0x154>)
 80067ee:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 80067f0:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 80067f4:	f002 f921 	bl	8008a3a <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 80067f8:	2310      	movs	r3, #16
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 80067fa:	4835      	ldr	r0, [pc, #212]	; (80068d0 <MIOS32_SPI_IO_Init+0x154>)
 80067fc:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 80067fe:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 8006802:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 8006806:	f002 f918 	bl	8008a3a <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 800680a:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 800680e:	4831      	ldr	r0, [pc, #196]	; (80068d4 <MIOS32_SPI_IO_Init+0x158>)
 8006810:	4621      	mov	r1, r4
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 8006812:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 8006816:	f002 f910 	bl	8008a3a <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800681a:	2348      	movs	r3, #72	; 0x48
 800681c:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MISO_PIN;
 8006820:	2340      	movs	r3, #64	; 0x40
 8006822:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
 8006826:	482a      	ldr	r0, [pc, #168]	; (80068d0 <MIOS32_SPI_IO_Init+0x154>)
 8006828:	e04a      	b.n	80068c0 <MIOS32_SPI_IO_Init+0x144>
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 800682a:	ac02      	add	r4, sp, #8
    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 800682c:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 8006830:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006834:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 8006838:	4827      	ldr	r0, [pc, #156]	; (80068d8 <MIOS32_SPI_IO_Init+0x15c>)
 800683a:	4621      	mov	r1, r4
 800683c:	f002 f8fd 	bl	8008a3a <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 8006840:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 8006844:	4824      	ldr	r0, [pc, #144]	; (80068d8 <MIOS32_SPI_IO_Init+0x15c>)
 8006846:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 8006848:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 800684c:	f002 f8f5 	bl	8008a3a <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 8006850:	f44f 5380 	mov.w	r3, #4096	; 0x1000
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 8006854:	4820      	ldr	r0, [pc, #128]	; (80068d8 <MIOS32_SPI_IO_Init+0x15c>)
 8006856:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 8006858:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 800685c:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 8006860:	f002 f8eb 	bl	8008a3a <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
#endif
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8006864:	2348      	movs	r3, #72	; 0x48
 8006866:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MISO_PIN;
 800686a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800686e:	e024      	b.n	80068ba <MIOS32_SPI_IO_Init+0x13e>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
 8006870:	ac02      	add	r4, sp, #8
 8006872:	2340      	movs	r3, #64	; 0x40
 8006874:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 8006878:	4817      	ldr	r0, [pc, #92]	; (80068d8 <MIOS32_SPI_IO_Init+0x15c>)
 800687a:	4621      	mov	r1, r4
    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 800687c:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 8006880:	f002 f8db 	bl	8008a3a <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 8006884:	2320      	movs	r3, #32
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 8006886:	4814      	ldr	r0, [pc, #80]	; (80068d8 <MIOS32_SPI_IO_Init+0x15c>)
 8006888:	4621      	mov	r1, r4
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 800688a:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 800688e:	f002 f8d4 	bl	8008a3a <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 8006892:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 8006896:	480f      	ldr	r0, [pc, #60]	; (80068d4 <MIOS32_SPI_IO_Init+0x158>)
 8006898:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 800689a:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 800689e:	f002 f8cc 	bl	8008a3a <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 80068a2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 80068a6:	480b      	ldr	r0, [pc, #44]	; (80068d4 <MIOS32_SPI_IO_Init+0x158>)
 80068a8:	4621      	mov	r1, r4
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 80068aa:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 80068ae:	f002 f8c4 	bl	8008a3a <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80068b2:	2348      	movs	r3, #72	; 0x48
 80068b4:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 80068b8:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 80068ba:	4807      	ldr	r0, [pc, #28]	; (80068d8 <MIOS32_SPI_IO_Init+0x15c>)
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 80068bc:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 80068c0:	4621      	mov	r1, r4
 80068c2:	f002 f8ba 	bl	8008a3a <GPIO_Init>

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 80068c6:	2000      	movs	r0, #0
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);

      break;
 80068c8:	e001      	b.n	80068ce <MIOS32_SPI_IO_Init+0x152>
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
      break;

    default:
      return -3; // unsupported pin driver mode
 80068ca:	f06f 0002 	mvn.w	r0, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 80068ce:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 80068d0:	40010800 	.word	0x40010800
 80068d4:	40011000 	.word	0x40011000
 80068d8:	40010c00 	.word	0x40010c00

080068dc <MIOS32_SPI_RC_PinSet>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 80068dc:	2801      	cmp	r0, #1
 80068de:	d017      	beq.n	8006910 <MIOS32_SPI_RC_PinSet+0x34>
 80068e0:	d305      	bcc.n	80068ee <MIOS32_SPI_RC_PinSet+0x12>
 80068e2:	2802      	cmp	r0, #2
      }
      break;
#endif

    default:
      return -2; // unsupported SPI port
 80068e4:	bf18      	it	ne
 80068e6:	f06f 0101 	mvnne.w	r1, #1
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 80068ea:	d137      	bne.n	800695c <MIOS32_SPI_RC_PinSet+0x80>
 80068ec:	e01a      	b.n	8006924 <MIOS32_SPI_RC_PinSet+0x48>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 80068ee:	b111      	cbz	r1, 80068f6 <MIOS32_SPI_RC_PinSet+0x1a>
 80068f0:	2901      	cmp	r1, #1
 80068f2:	d131      	bne.n	8006958 <MIOS32_SPI_RC_PinSet+0x7c>
 80068f4:	e006      	b.n	8006904 <MIOS32_SPI_RC_PinSet+0x28>
        case 0:
	  if( pin_value )
 80068f6:	b112      	cbz	r2, 80068fe <MIOS32_SPI_RC_PinSet+0x22>
	    MIOS32_SPI0_RCLK1_PORT->BSRR = MIOS32_SPI0_RCLK1_PIN;
 80068f8:	2210      	movs	r2, #16
 80068fa:	4b19      	ldr	r3, [pc, #100]	; (8006960 <MIOS32_SPI_RC_PinSet+0x84>)
 80068fc:	e01a      	b.n	8006934 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
 80068fe:	2110      	movs	r1, #16
 8006900:	4b17      	ldr	r3, [pc, #92]	; (8006960 <MIOS32_SPI_RC_PinSet+0x84>)
 8006902:	e026      	b.n	8006952 <MIOS32_SPI_RC_PinSet+0x76>

        case 1:
	  if( pin_value )
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
	  else
	    MIOS32_SPI0_RCLK2_PORT->BRR  = MIOS32_SPI0_RCLK2_PIN;
 8006904:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 8006908:	b312      	cbz	r2, 8006950 <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
 800690a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800690e:	e01b      	b.n	8006948 <MIOS32_SPI_RC_PinSet+0x6c>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 8006910:	bb11      	cbnz	r1, 8006958 <MIOS32_SPI_RC_PinSet+0x7c>
        case 0:
	  if( pin_value )
 8006912:	b11a      	cbz	r2, 800691c <MIOS32_SPI_RC_PinSet+0x40>
	    MIOS32_SPI1_RCLK1_PORT->BSRR = MIOS32_SPI1_RCLK1_PIN;
 8006914:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8006918:	4b12      	ldr	r3, [pc, #72]	; (8006964 <MIOS32_SPI_RC_PinSet+0x88>)
 800691a:	e00b      	b.n	8006934 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI1_RCLK1_PORT->BRR  = MIOS32_SPI1_RCLK1_PIN;
 800691c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8006920:	4b10      	ldr	r3, [pc, #64]	; (8006964 <MIOS32_SPI_RC_PinSet+0x88>)
 8006922:	e016      	b.n	8006952 <MIOS32_SPI_RC_PinSet+0x76>

    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 8006924:	b111      	cbz	r1, 800692c <MIOS32_SPI_RC_PinSet+0x50>
 8006926:	2901      	cmp	r1, #1
 8006928:	d116      	bne.n	8006958 <MIOS32_SPI_RC_PinSet+0x7c>
 800692a:	e008      	b.n	800693e <MIOS32_SPI_RC_PinSet+0x62>
        case 0:
	  if( pin_value )
 800692c:	b122      	cbz	r2, 8006938 <MIOS32_SPI_RC_PinSet+0x5c>
	    MIOS32_SPI2_RCLK1_PORT->BSRR = MIOS32_SPI2_RCLK1_PIN;
 800692e:	4b0e      	ldr	r3, [pc, #56]	; (8006968 <MIOS32_SPI_RC_PinSet+0x8c>)
 8006930:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8006934:	611a      	str	r2, [r3, #16]
 8006936:	e011      	b.n	800695c <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
 8006938:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800693c:	e008      	b.n	8006950 <MIOS32_SPI_RC_PinSet+0x74>

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 800693e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 8006942:	b12a      	cbz	r2, 8006950 <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 8006944:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8006948:	4b07      	ldr	r3, [pc, #28]	; (8006968 <MIOS32_SPI_RC_PinSet+0x8c>)

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 800694a:	2100      	movs	r1, #0
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 800694c:	611a      	str	r2, [r3, #16]
 800694e:	e005      	b.n	800695c <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 8006950:	4b05      	ldr	r3, [pc, #20]	; (8006968 <MIOS32_SPI_RC_PinSet+0x8c>)
 8006952:	6159      	str	r1, [r3, #20]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006954:	4611      	mov	r1, r2
 8006956:	e001      	b.n	800695c <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
	  break;

        default:
	  return -3; // unsupported RC pin
 8006958:	f06f 0102 	mvn.w	r1, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 800695c:	4608      	mov	r0, r1
 800695e:	4770      	bx	lr
 8006960:	40010800 	.word	0x40010800
 8006964:	40010c00 	.word	0x40010c00
 8006968:	40011000 	.word	0x40011000

0800696c <MIOS32_SPI_TransferByte>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 800696c:	2801      	cmp	r0, #1
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported SPI mode configured via MIOS32_SPI_TransferModeInit()
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
 800696e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 8006970:	f000 823c 	beq.w	8006dec <MIOS32_SPI_TransferByte+0x480>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI0_PTR;
 8006974:	bf38      	it	cc
 8006976:	f8df 3490 	ldrcc.w	r3, [pc, #1168]	; 8006e08 <MIOS32_SPI_TransferByte+0x49c>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 800697a:	f0c0 8238 	bcc.w	8006dee <MIOS32_SPI_TransferByte+0x482>
 800697e:	2802      	cmp	r0, #2
      return in_data; // END of SW emulation - EXIT here!
#endif
    } break;

    default:
      return -2; // unsupported SPI port
 8006980:	bf18      	it	ne
 8006982:	f06f 0001 	mvnne.w	r0, #1
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 8006986:	f040 823d 	bne.w	8006e04 <MIOS32_SPI_TransferByte+0x498>
#else
    // Software Emulation
    {
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
 800698a:	f8df 3480 	ldr.w	r3, [pc, #1152]	; 8006e0c <MIOS32_SPI_TransferByte+0x4a0>
 800698e:	781b      	ldrb	r3, [r3, #0]
 8006990:	2b03      	cmp	r3, #3
 8006992:	f200 8235 	bhi.w	8006e00 <MIOS32_SPI_TransferByte+0x494>
 8006996:	e8df f013 	tbh	[pc, r3, lsl #1]
 800699a:	0004      	.short	0x0004
 800699c:	01180096 	.word	0x01180096
 80069a0:	01a8      	.short	0x01a8
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 80069a2:	f8df 346c 	ldr.w	r3, [pc, #1132]	; 8006e10 <MIOS32_SPI_TransferByte+0x4a4>
 80069a6:	f011 0f80 	tst.w	r1, #128	; 0x80
 80069aa:	bf0c      	ite	eq
 80069ac:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 80069b0:	2220      	movne	r2, #32
 80069b2:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 80069b4:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 80069b6:	f011 0f40 	tst.w	r1, #64	; 0x40
 80069ba:	bf0c      	ite	eq
 80069bc:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069c0:	2020      	movne	r0, #32
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 80069c2:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069c4:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 80069c6:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069c8:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069ca:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 80069cc:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 80069ce:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069d0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 80069d2:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 80069d6:	bf18      	it	ne
 80069d8:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 80069da:	f011 0f20 	tst.w	r1, #32
 80069de:	bf0c      	ite	eq
 80069e0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069e4:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069e6:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069e8:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069ea:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 80069ec:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 80069ee:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069f0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 80069f2:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 80069f6:	bf18      	it	ne
 80069f8:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 80069fa:	f011 0f10 	tst.w	r1, #16
 80069fe:	bf0c      	ite	eq
 8006a00:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a04:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a06:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a08:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a0a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006a0c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006a0e:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a12:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006a14:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006a18:	bf18      	it	ne
 8006a1a:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006a1e:	f011 0f08 	tst.w	r1, #8
 8006a22:	bf0c      	ite	eq
 8006a24:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a28:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a2a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a2c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a2e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006a30:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a32:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a34:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a38:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006a3c:	bf18      	it	ne
 8006a3e:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006a40:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a44:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006a46:	bf0c      	ite	eq
 8006a48:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a4c:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a4e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a50:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a52:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a54:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006a56:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a58:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a5a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006a5c:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006a60:	bf18      	it	ne
 8006a62:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006a64:	f011 0f02 	tst.w	r1, #2
 8006a68:	bf0c      	ite	eq
 8006a6a:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a6e:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a70:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a72:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a74:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006a76:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006a78:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a7a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006a7c:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006a80:	bf18      	it	ne
 8006a82:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006a84:	f011 0f01 	tst.w	r1, #1
 8006a88:	bf0c      	ite	eq
 8006a8a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006a8e:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006a90:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a92:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a94:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006a96:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006a98:	6899      	ldr	r1, [r3, #8]
 8006a9a:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a9e:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006aa2:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006aa4:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006aa6:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006aaa:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006aae:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006ab2:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006ab6:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_1;
 8006aba:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006abc:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006abe:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006ac0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ac2:	615a      	str	r2, [r3, #20]
	  break;
 8006ac4:	e19e      	b.n	8006e04 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006ac6:	4bd2      	ldr	r3, [pc, #840]	; (8006e10 <MIOS32_SPI_TransferByte+0x4a4>)
 8006ac8:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006aca:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006ace:	bf0c      	ite	eq
 8006ad0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ad4:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006ad6:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  break;

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006ada:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006adc:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ade:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006ae0:	bf0c      	ite	eq
 8006ae2:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ae6:	2020      	movne	r0, #32

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006ae8:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006aea:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006aec:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006aee:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006af0:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006af2:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006af4:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006af8:	bf18      	it	ne
 8006afa:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006afc:	f011 0f20 	tst.w	r1, #32
 8006b00:	bf0c      	ite	eq
 8006b02:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b06:	2020      	movne	r0, #32
 8006b08:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b0a:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b0c:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b0e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b10:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006b14:	bf18      	it	ne
 8006b16:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006b18:	f011 0f10 	tst.w	r1, #16
 8006b1c:	bf0c      	ite	eq
 8006b1e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b22:	2020      	movne	r0, #32
 8006b24:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b26:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006b28:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b2c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006b2e:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006b32:	bf18      	it	ne
 8006b34:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006b38:	f011 0f08 	tst.w	r1, #8
 8006b3c:	bf0c      	ite	eq
 8006b3e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b42:	2020      	movne	r0, #32
 8006b44:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b46:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b48:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b4a:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b4e:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006b52:	bf18      	it	ne
 8006b54:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006b56:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b5a:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006b5c:	bf0c      	ite	eq
 8006b5e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b62:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006b64:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006b66:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b68:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b6a:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b6c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006b6e:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006b72:	bf18      	it	ne
 8006b74:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006b76:	f011 0f02 	tst.w	r1, #2
 8006b7a:	bf0c      	ite	eq
 8006b7c:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b80:	2020      	movne	r0, #32
 8006b82:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b84:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b86:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b88:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006b8a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006b8e:	bf18      	it	ne
 8006b90:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006b92:	f011 0f01 	tst.w	r1, #1
 8006b96:	bf0c      	ite	eq
 8006b98:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006b9c:	2120      	movne	r1, #32
 8006b9e:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ba0:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006ba2:	689b      	ldr	r3, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006ba4:	9a01      	ldr	r2, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006ba6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006baa:	ea43 0606 	orr.w	r6, r3, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006bae:	ea46 0505 	orr.w	r5, r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006bb2:	ea45 0404 	orr.w	r4, r5, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006bb6:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006bba:	ea4c 0c02 	orr.w	ip, ip, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006bbe:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006bc2:	ea47 0000 	orr.w	r0, r7, r0
 8006bc6:	b2c0      	uxtb	r0, r0
	  break;
 8006bc8:	e11c      	b.n	8006e04 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006bca:	4b91      	ldr	r3, [pc, #580]	; (8006e10 <MIOS32_SPI_TransferByte+0x4a4>)
 8006bcc:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006bd0:	bf0c      	ite	eq
 8006bd2:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006bd6:	2220      	movne	r2, #32
 8006bd8:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bda:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006bdc:	f011 0f40 	tst.w	r1, #64	; 0x40
 8006be0:	bf0c      	ite	eq
 8006be2:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006be6:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006be8:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bea:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bec:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bee:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bf0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006bf2:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006bf4:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bf6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006bf8:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006bfc:	bf18      	it	ne
 8006bfe:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006c00:	f011 0f20 	tst.w	r1, #32
 8006c04:	bf0c      	ite	eq
 8006c06:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c0a:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c0c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c0e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c10:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006c12:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006c14:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c16:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006c18:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006c1c:	bf18      	it	ne
 8006c1e:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006c20:	f011 0f10 	tst.w	r1, #16
 8006c24:	bf0c      	ite	eq
 8006c26:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c2a:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c2c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c2e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c30:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006c32:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006c34:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c38:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006c3a:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006c3e:	bf18      	it	ne
 8006c40:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006c44:	f011 0f08 	tst.w	r1, #8
 8006c48:	bf0c      	ite	eq
 8006c4a:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c4e:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c50:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c52:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c54:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006c56:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c58:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c5a:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c5e:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006c62:	bf18      	it	ne
 8006c64:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006c66:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c6a:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006c6c:	bf0c      	ite	eq
 8006c6e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c72:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c74:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c76:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c78:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c7a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006c7c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c7e:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c80:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c82:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006c86:	bf18      	it	ne
 8006c88:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006c8a:	f011 0f02 	tst.w	r1, #2
 8006c8e:	bf0c      	ite	eq
 8006c90:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c94:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c96:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c98:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c9a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006c9c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c9e:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ca0:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006ca2:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006ca6:	bf18      	it	ne
 8006ca8:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006caa:	f011 0f01 	tst.w	r1, #1
 8006cae:	bf0c      	ite	eq
 8006cb0:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006cb4:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006cb6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006cb8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cba:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006cbc:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006cbe:	6899      	ldr	r1, [r3, #8]
 8006cc0:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006cc4:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006cc8:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006cca:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006ccc:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006cd0:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006cd4:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006cd8:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006cdc:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_0;
 8006ce0:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006ce2:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006ce4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006ce6:	615a      	str	r2, [r3, #20]
 8006ce8:	e07e      	b.n	8006de8 <MIOS32_SPI_TransferByte+0x47c>
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006cea:	4b49      	ldr	r3, [pc, #292]	; (8006e10 <MIOS32_SPI_TransferByte+0x4a4>)
 8006cec:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006cf0:	bf0c      	ite	eq
 8006cf2:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006cf6:	2220      	movne	r2, #32
 8006cf8:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006cfa:	2240      	movs	r2, #64	; 0x40
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006cfc:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
 8006d00:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006d02:	bf0c      	ite	eq
 8006d04:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d08:	2020      	movne	r0, #32
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006d0a:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d0c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006d0e:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d10:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006d12:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d14:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006d16:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006d1a:	bf18      	it	ne
 8006d1c:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006d1e:	f011 0f20 	tst.w	r1, #32
 8006d22:	bf0c      	ite	eq
 8006d24:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d28:	2020      	movne	r0, #32
 8006d2a:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d2c:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006d2e:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d30:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006d32:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006d36:	bf18      	it	ne
 8006d38:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006d3a:	f011 0f10 	tst.w	r1, #16
 8006d3e:	bf0c      	ite	eq
 8006d40:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d44:	2020      	movne	r0, #32
 8006d46:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d48:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006d4a:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d4e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006d50:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006d54:	bf18      	it	ne
 8006d56:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006d5a:	f011 0f08 	tst.w	r1, #8
 8006d5e:	bf0c      	ite	eq
 8006d60:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d64:	2020      	movne	r0, #32
 8006d66:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d68:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d6a:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006d6c:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d70:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006d74:	bf18      	it	ne
 8006d76:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006d78:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d7c:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006d7e:	bf0c      	ite	eq
 8006d80:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006d84:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006d86:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006d88:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d8a:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d8c:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006d8e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d90:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006d94:	bf18      	it	ne
 8006d96:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006d98:	f011 0f02 	tst.w	r1, #2
 8006d9c:	bf0c      	ite	eq
 8006d9e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006da2:	2020      	movne	r0, #32
 8006da4:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006da6:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006da8:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006daa:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006dac:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006db0:	bf18      	it	ne
 8006db2:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006db4:	f011 0f01 	tst.w	r1, #1
 8006db8:	bf0c      	ite	eq
 8006dba:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006dbe:	2120      	movne	r1, #32
 8006dc0:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006dc2:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006dc4:	6899      	ldr	r1, [r3, #8]
 8006dc6:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006dca:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006dce:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006dd0:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006dd4:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006dd6:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006dda:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006dde:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006de2:	ea47 0000 	orr.w	r0, r7, r0
 8006de6:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
 8006de8:	611a      	str	r2, [r3, #16]

        default:
	  return -3; // unsupported SPI mode
      }

      return in_data; // END of SW emulation - EXIT here!
 8006dea:	e00b      	b.n	8006e04 <MIOS32_SPI_TransferByte+0x498>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI1_PTR;
 8006dec:	4b09      	ldr	r3, [pc, #36]	; (8006e14 <MIOS32_SPI_TransferByte+0x4a8>)
    default:
      return -2; // unsupported SPI port
  }

  // send byte
  spi_ptr->DR = b;
 8006dee:	8199      	strh	r1, [r3, #12]

  if( spi_ptr->SR ); // dummy read due to undocumented pipelining issue :-/
 8006df0:	891a      	ldrh	r2, [r3, #8]
  // We use a bus access instead of NOPs to avoid any risk for back-to-back transactions
  // over AHB (if SPI1/SPI2 pointers are used, there is still a risk for such a scenario,
  // e.g. if DMA loads the bus!)

  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );
 8006df2:	891a      	ldrh	r2, [r3, #8]
 8006df4:	f012 0f80 	tst.w	r2, #128	; 0x80
 8006df8:	d1fb      	bne.n	8006df2 <MIOS32_SPI_TransferByte+0x486>

  // return received byte
  return spi_ptr->DR;
 8006dfa:	8998      	ldrh	r0, [r3, #12]
 8006dfc:	b280      	uxth	r0, r0
 8006dfe:	e001      	b.n	8006e04 <MIOS32_SPI_TransferByte+0x498>
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        default:
	  return -3; // unsupported SPI mode
 8006e00:	f06f 0002 	mvn.w	r0, #2
  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );

  // return received byte
  return spi_ptr->DR;
}
 8006e04:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8006e06:	bf00      	nop
 8006e08:	40013000 	.word	0x40013000
 8006e0c:	20000818 	.word	0x20000818
 8006e10:	40010c00 	.word	0x40010c00
 8006e14:	40003800 	.word	0x40003800

08006e18 <MIOS32_SPI_TransferModeInit>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006e18:	b530      	push	{r4, r5, lr}
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006e1a:	2300      	movs	r3, #0
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006e1c:	b087      	sub	sp, #28
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006e1e:	f8ad 3004 	strh.w	r3, [sp, #4]
  SPI_InitStructure.SPI_Mode          = SPI_Mode_Master;
 8006e22:	f44f 7382 	mov.w	r3, #260	; 0x104
 8006e26:	f8ad 3006 	strh.w	r3, [sp, #6]
  SPI_InitStructure.SPI_DataSize      = SPI_DataSize_8b;
 8006e2a:	2300      	movs	r3, #0
 8006e2c:	f8ad 3008 	strh.w	r3, [sp, #8]
  SPI_InitStructure.SPI_NSS           = SPI_NSS_Soft;
 8006e30:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006e34:	f8ad 300e 	strh.w	r3, [sp, #14]
  SPI_InitStructure.SPI_FirstBit      = SPI_FirstBit_MSB;
 8006e38:	2300      	movs	r3, #0
 8006e3a:	f8ad 3012 	strh.w	r3, [sp, #18]
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 8006e3e:	2307      	movs	r3, #7
 8006e40:	f8ad 3014 	strh.w	r3, [sp, #20]

  switch( spi_mode ) {
 8006e44:	2903      	cmp	r1, #3
 8006e46:	d85f      	bhi.n	8006f08 <MIOS32_SPI_TransferModeInit+0xf0>
 8006e48:	e8df f001 	tbb	[pc, r1]
 8006e4c:	0d080602 	.word	0x0d080602
    case MIOS32_SPI_MODE_CLK0_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006e50:	2300      	movs	r3, #0
 8006e52:	f8ad 300a 	strh.w	r3, [sp, #10]
 8006e56:	e00a      	b.n	8006e6e <MIOS32_SPI_TransferModeInit+0x56>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK0_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006e58:	2300      	movs	r3, #0
 8006e5a:	e005      	b.n	8006e68 <MIOS32_SPI_TransferModeInit+0x50>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006e5c:	2302      	movs	r3, #2
 8006e5e:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8006e62:	2300      	movs	r3, #0
 8006e64:	e003      	b.n	8006e6e <MIOS32_SPI_TransferModeInit+0x56>
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006e66:	2302      	movs	r3, #2
 8006e68:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006e6c:	2301      	movs	r3, #1
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006e6e:	2a07      	cmp	r2, #7
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006e70:	f8ad 300c 	strh.w	r3, [sp, #12]
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected
 8006e74:	bf88      	it	hi
 8006e76:	f06f 0002 	mvnhi.w	r0, #2
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006e7a:	d847      	bhi.n	8006f0c <MIOS32_SPI_TransferModeInit+0xf4>
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006e7c:	2801      	cmp	r0, #1
 8006e7e:	d019      	beq.n	8006eb4 <MIOS32_SPI_TransferModeInit+0x9c>
 8006e80:	d305      	bcc.n	8006e8e <MIOS32_SPI_TransferModeInit+0x76>
 8006e82:	2802      	cmp	r0, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 8006e84:	bf18      	it	ne
 8006e86:	f06f 0001 	mvnne.w	r0, #1
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006e8a:	d13f      	bne.n	8006f0c <MIOS32_SPI_TransferModeInit+0xf4>
 8006e8c:	e02b      	b.n	8006ee6 <MIOS32_SPI_TransferModeInit+0xce>
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e8e:	4c20      	ldr	r4, [pc, #128]	; (8006f10 <MIOS32_SPI_TransferModeInit+0xf8>)
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e90:	f002 0207 	and.w	r2, r2, #7
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006e94:	8825      	ldrh	r5, [r4, #0]
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e96:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006e98:	4620      	mov	r0, r4
 8006e9a:	a901      	add	r1, sp, #4
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006e9c:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006ea0:	f001 ff38 	bl	8008d14 <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006ea4:	8820      	ldrh	r0, [r4, #0]
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006ea6:	b2ad      	uxth	r5, r5
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006ea8:	4045      	eors	r5, r0
 8006eaa:	f015 0003 	ands.w	r0, r5, #3
 8006eae:	d02d      	beq.n	8006f0c <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006eb0:	2000      	movs	r0, #0
 8006eb2:	e014      	b.n	8006ede <MIOS32_SPI_TransferModeInit+0xc6>

    case 1: {
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006eb4:	4b16      	ldr	r3, [pc, #88]	; (8006f10 <MIOS32_SPI_TransferModeInit+0xf8>)
 8006eb6:	881c      	ldrh	r4, [r3, #0]
 8006eb8:	b2a4      	uxth	r4, r4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
 8006eba:	b11a      	cbz	r2, 8006ec4 <MIOS32_SPI_TransferModeInit+0xac>
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006ebc:	f002 0207 	and.w	r2, r2, #7
 8006ec0:	3a01      	subs	r2, #1
 8006ec2:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006ec4:	4813      	ldr	r0, [pc, #76]	; (8006f14 <MIOS32_SPI_TransferModeInit+0xfc>)
 8006ec6:	a901      	add	r1, sp, #4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006ec8:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006ecc:	f001 ff22 	bl	8008d14 <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006ed0:	4b0f      	ldr	r3, [pc, #60]	; (8006f10 <MIOS32_SPI_TransferModeInit+0xf8>)
 8006ed2:	8818      	ldrh	r0, [r3, #0]
 8006ed4:	4044      	eors	r4, r0
 8006ed6:	f014 0003 	ands.w	r0, r4, #3
 8006eda:	d017      	beq.n	8006f0c <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006edc:	2001      	movs	r0, #1
 8006ede:	21ff      	movs	r1, #255	; 0xff
 8006ee0:	f7ff fd44 	bl	800696c <MIOS32_SPI_TransferByte>
 8006ee4:	e00e      	b.n	8006f04 <MIOS32_SPI_TransferModeInit+0xec>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // no clock prescaler for SW emulated SPI
      // remember mode settings
      sw_spi2_mode = spi_mode;
 8006ee6:	4b0c      	ldr	r3, [pc, #48]	; (8006f18 <MIOS32_SPI_TransferModeInit+0x100>)
 8006ee8:	7019      	strb	r1, [r3, #0]

      // set clock idle level
      switch( sw_spi2_mode ) {
 8006eea:	2903      	cmp	r1, #3
 8006eec:	d80c      	bhi.n	8006f08 <MIOS32_SPI_TransferModeInit+0xf0>
 8006eee:	e8df f001 	tbb	[pc, r1]
 8006ef2:	0202      	.short	0x0202
 8006ef4:	0606      	.short	0x0606
        case MIOS32_SPI_MODE_CLK0_PHASE0:
        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_0;
 8006ef6:	4b09      	ldr	r3, [pc, #36]	; (8006f1c <MIOS32_SPI_TransferModeInit+0x104>)
 8006ef8:	2240      	movs	r2, #64	; 0x40
 8006efa:	615a      	str	r2, [r3, #20]
 8006efc:	e002      	b.n	8006f04 <MIOS32_SPI_TransferModeInit+0xec>
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006efe:	4b07      	ldr	r3, [pc, #28]	; (8006f1c <MIOS32_SPI_TransferModeInit+0x104>)
 8006f00:	2240      	movs	r2, #64	; 0x40
 8006f02:	611a      	str	r2, [r3, #16]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006f04:	2000      	movs	r0, #0
	  MIOS32_SPI2_SET_SCLK_0;
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  break;
 8006f06:	e001      	b.n	8006f0c <MIOS32_SPI_TransferModeInit+0xf4>
        default:
	  return -4; // invalid SPI clock/phase mode
 8006f08:	f06f 0003 	mvn.w	r0, #3
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 8006f0c:	b007      	add	sp, #28
 8006f0e:	bd30      	pop	{r4, r5, pc}
 8006f10:	40013000 	.word	0x40013000
 8006f14:	40003800 	.word	0x40003800
 8006f18:	20000818 	.word	0x20000818
 8006f1c:	40010c00 	.word	0x40010c00

08006f20 <MIOS32_SPI_Init>:
//! Initializes SPI pins
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
 8006f20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006f22:	4604      	mov	r4, r0
 8006f24:	b08f      	sub	sp, #60	; 0x3c
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8006f26:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8006f2a:	2c00      	cmp	r4, #0
 8006f2c:	f040 80bb 	bne.w	80070a6 <MIOS32_SPI_Init+0x186>
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006f30:	ad03      	add	r5, sp, #12
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006f32:	4f5e      	ldr	r7, [pc, #376]	; (80070ac <MIOS32_SPI_Init+0x18c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006f34:	4628      	mov	r0, r5
 8006f36:	f002 f898 	bl	800906a <DMA_StructInit>

  // disable callback function
  spi_callback[0] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006f3a:	2201      	movs	r2, #1
 8006f3c:	4621      	mov	r1, r4
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006f3e:	603c      	str	r4, [r7, #0]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006f40:	4620      	mov	r0, r4
 8006f42:	f7ff fccb 	bl	80068dc <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(0, 1, 1); // spi, rc_pin, pin_value
 8006f46:	2101      	movs	r1, #1
 8006f48:	460a      	mov	r2, r1
 8006f4a:	4620      	mov	r0, r4
 8006f4c:	f7ff fcc6 	bl	80068dc <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(0, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006f50:	2103      	movs	r1, #3
 8006f52:	4620      	mov	r0, r4
 8006f54:	f7ff fc12 	bl	800677c <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB2 == high speed)
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 8006f58:	2101      	movs	r1, #1
 8006f5a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8006f5e:	f002 fa3b 	bl	80093d8 <RCC_APB2PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8006f62:	2001      	movs	r0, #1
 8006f64:	4601      	mov	r1, r0
 8006f66:	f002 fa29 	bl	80093bc <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
 8006f6a:	4851      	ldr	r0, [pc, #324]	; (80070b0 <MIOS32_SPI_Init+0x190>)
 8006f6c:	4621      	mov	r1, r4
 8006f6e:	f002 f889 	bl	8009084 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006f72:	4b50      	ldr	r3, [pc, #320]	; (80070b4 <MIOS32_SPI_Init+0x194>)
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f74:	2680      	movs	r6, #128	; 0x80
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006f76:	9303      	str	r3, [sp, #12]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f78:	484d      	ldr	r0, [pc, #308]	; (80070b0 <MIOS32_SPI_Init+0x190>)
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f7a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f7e:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f80:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f82:	9301      	str	r3, [sp, #4]
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006f84:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8006f86:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006f88:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006f8a:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f8c:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006f8e:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006f90:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8006f92:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8006f94:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006f96:	f002 f83d 	bl	8009014 <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
 8006f9a:	4847      	ldr	r0, [pc, #284]	; (80070b8 <MIOS32_SPI_Init+0x198>)
 8006f9c:	4621      	mov	r1, r4
 8006f9e:	f002 f871 	bl	8009084 <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006fa2:	f04f 0c10 	mov.w	ip, #16
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006fa6:	4844      	ldr	r0, [pc, #272]	; (80070b8 <MIOS32_SPI_Init+0x198>)
 8006fa8:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006faa:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006fae:	f8cd c000 	str.w	ip, [sp]
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006fb2:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006fb4:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006fb6:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006fb8:	f002 f82c 	bl	8009014 <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(0, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8006fbc:	2206      	movs	r2, #6
 8006fbe:	2103      	movs	r1, #3
 8006fc0:	4620      	mov	r0, r4
 8006fc2:	f7ff ff29 	bl	8006e18 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI0_PTR, ENABLE);
 8006fc6:	2101      	movs	r1, #1
 8006fc8:	483c      	ldr	r0, [pc, #240]	; (80070bc <MIOS32_SPI_Init+0x19c>)
 8006fca:	f001 fed0 	bl	8008d6e <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI0_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8006fce:	2201      	movs	r2, #1
 8006fd0:	2103      	movs	r1, #3
 8006fd2:	483a      	ldr	r0, [pc, #232]	; (80070bc <MIOS32_SPI_Init+0x19c>)
 8006fd4:	f001 fed8 	bl	8008d88 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI0_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8006fd8:	2105      	movs	r1, #5
 8006fda:	200c      	movs	r0, #12
 8006fdc:	f7ff fbaa 	bl	8006734 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[1] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006fe0:	2001      	movs	r0, #1
 8006fe2:	4621      	mov	r1, r4
 8006fe4:	4602      	mov	r2, r0
  // SPI1
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI1

  // disable callback function
  spi_callback[1] = NULL;
 8006fe6:	607c      	str	r4, [r7, #4]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006fe8:	f7ff fc78 	bl	80068dc <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(1, 1, 1); // spi, rc_pin, pin_value
 8006fec:	2001      	movs	r0, #1
 8006fee:	4602      	mov	r2, r0
 8006ff0:	4601      	mov	r1, r0
 8006ff2:	f7ff fc73 	bl	80068dc <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(1, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006ff6:	2103      	movs	r1, #3
 8006ff8:	2001      	movs	r0, #1
 8006ffa:	f7ff fbbf 	bl	800677c <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB1 == slow speed)
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8006ffe:	2101      	movs	r1, #1
 8007000:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8007004:	f002 f9f6 	bl	80093f4 <RCC_APB1PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8007008:	2001      	movs	r0, #1
 800700a:	4601      	mov	r1, r0
 800700c:	f002 f9d6 	bl	80093bc <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
 8007010:	482b      	ldr	r0, [pc, #172]	; (80070c0 <MIOS32_SPI_Init+0x1a0>)
 8007012:	4621      	mov	r1, r4
 8007014:	f002 f836 	bl	8009084 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8007018:	9b01      	ldr	r3, [sp, #4]
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 800701a:	4a2a      	ldr	r2, [pc, #168]	; (80070c4 <MIOS32_SPI_Init+0x1a4>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 800701c:	4828      	ldr	r0, [pc, #160]	; (80070c0 <MIOS32_SPI_Init+0x1a0>)
 800701e:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8007020:	930c      	str	r3, [sp, #48]	; 0x30
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8007022:	9203      	str	r2, [sp, #12]
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8007024:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8007026:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8007028:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800702a:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800702c:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 800702e:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8007030:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8007032:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8007034:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8007036:	f001 ffed 	bl	8009014 <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
 800703a:	4823      	ldr	r0, [pc, #140]	; (80070c8 <MIOS32_SPI_Init+0x1a8>)
 800703c:	4621      	mov	r1, r4
 800703e:	f002 f821 	bl	8009084 <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8007042:	f8dd c000 	ldr.w	ip, [sp]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8007046:	4820      	ldr	r0, [pc, #128]	; (80070c8 <MIOS32_SPI_Init+0x1a8>)
 8007048:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 800704a:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 800704e:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8007050:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8007052:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8007054:	f001 ffde 	bl	8009014 <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(1, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8007058:	2206      	movs	r2, #6
 800705a:	2103      	movs	r1, #3
 800705c:	2001      	movs	r0, #1
 800705e:	f7ff fedb 	bl	8006e18 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI1_PTR, ENABLE);
 8007062:	2101      	movs	r1, #1
 8007064:	4819      	ldr	r0, [pc, #100]	; (80070cc <MIOS32_SPI_Init+0x1ac>)
 8007066:	f001 fe82 	bl	8008d6e <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI1_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 800706a:	2201      	movs	r2, #1
 800706c:	2103      	movs	r1, #3
 800706e:	4817      	ldr	r0, [pc, #92]	; (80070cc <MIOS32_SPI_Init+0x1ac>)
 8007070:	f001 fe8a 	bl	8008d88 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI1_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8007074:	2105      	movs	r1, #5
 8007076:	200e      	movs	r0, #14
 8007078:	f7ff fb5c 	bl	8006734 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[2] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 800707c:	2201      	movs	r2, #1
 800707e:	2002      	movs	r0, #2
 8007080:	4621      	mov	r1, r4
  // SPI2 (software emulated)
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI2

  // disable callback function
  spi_callback[2] = NULL;
 8007082:	60bc      	str	r4, [r7, #8]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 8007084:	f7ff fc2a 	bl	80068dc <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(2, 1, 1); // spi, rc_pin, pin_value
 8007088:	2101      	movs	r1, #1
 800708a:	460a      	mov	r2, r1
 800708c:	2002      	movs	r0, #2
 800708e:	f7ff fc25 	bl	80068dc <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(2, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8007092:	2103      	movs	r1, #3
 8007094:	2002      	movs	r0, #2
 8007096:	f7ff fb71 	bl	800677c <MIOS32_SPI_IO_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(2, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 800709a:	2002      	movs	r0, #2
 800709c:	2103      	movs	r1, #3
 800709e:	2206      	movs	r2, #6
 80070a0:	f7ff feba 	bl	8006e18 <MIOS32_SPI_TransferModeInit>

#endif /* MIOS32_DONT_USE_SPI2 */

  return 0; // no error
 80070a4:	4620      	mov	r0, r4
}
 80070a6:	b00f      	add	sp, #60	; 0x3c
 80070a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80070aa:	bf00      	nop
 80070ac:	2000080c 	.word	0x2000080c
 80070b0:	4002001c 	.word	0x4002001c
 80070b4:	4001300c 	.word	0x4001300c
 80070b8:	40020030 	.word	0x40020030
 80070bc:	40013000 	.word	0x40013000
 80070c0:	40020044 	.word	0x40020044
 80070c4:	4000380c 	.word	0x4000380c
 80070c8:	40020058 	.word	0x40020058
 80070cc:	40003800 	.word	0x40003800

080070d0 <DMA1_Channel2_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Called when callback function has been defined and SPI transfer has finished
/////////////////////////////////////////////////////////////////////////////
MIOS32_SPI0_DMA_IRQHANDLER_FUNC
{
 80070d0:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI0_DMA_RX_IRQ_FLAGS);
 80070d2:	20f0      	movs	r0, #240	; 0xf0
 80070d4:	f001 ffea 	bl	80090ac <DMA_ClearFlag>

  if( spi_callback[0] != NULL )
 80070d8:	4b02      	ldr	r3, [pc, #8]	; (80070e4 <DMA1_Channel2_IRQHandler+0x14>)
 80070da:	681b      	ldr	r3, [r3, #0]
 80070dc:	b103      	cbz	r3, 80070e0 <DMA1_Channel2_IRQHandler+0x10>
    spi_callback[0]();
 80070de:	4798      	blx	r3
}
 80070e0:	bd08      	pop	{r3, pc}
 80070e2:	bf00      	nop
 80070e4:	2000080c 	.word	0x2000080c

080070e8 <DMA1_Channel4_IRQHandler>:

MIOS32_SPI1_DMA_IRQHANDLER_FUNC
{
 80070e8:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI1_DMA_RX_IRQ_FLAGS);
 80070ea:	f44f 4070 	mov.w	r0, #61440	; 0xf000
 80070ee:	f001 ffdd 	bl	80090ac <DMA_ClearFlag>

  if( spi_callback[1] != NULL )
 80070f2:	4b02      	ldr	r3, [pc, #8]	; (80070fc <DMA1_Channel4_IRQHandler+0x14>)
 80070f4:	685b      	ldr	r3, [r3, #4]
 80070f6:	b103      	cbz	r3, 80070fa <DMA1_Channel4_IRQHandler+0x12>
    spi_callback[1]();
 80070f8:	4798      	blx	r3
}
 80070fa:	bd08      	pop	{r3, pc}
 80070fc:	2000080c 	.word	0x2000080c

08007100 <MIOS32_BOARD_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8007100:	b910      	cbnz	r0, 8007108 <MIOS32_BOARD_Init+0x8>
    return -1; // unsupported mode

  j5_enable_mask = 0;
 8007102:	4b03      	ldr	r3, [pc, #12]	; (8007110 <MIOS32_BOARD_Init+0x10>)
 8007104:	8018      	strh	r0, [r3, #0]

  return 0; // no error
 8007106:	e001      	b.n	800710c <MIOS32_BOARD_Init+0xc>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007108:	f04f 30ff 	mov.w	r0, #4294967295

  j5_enable_mask = 0;

  return 0; // no error
}
 800710c:	4770      	bx	lr
 800710e:	bf00      	nop
 8007110:	2000081a 	.word	0x2000081a

08007114 <MIOS32_BOARD_LED_Init>:
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 8007114:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8007116:	ad01      	add	r5, sp, #4
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 8007118:	4604      	mov	r4, r0
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800711a:	4628      	mov	r0, r5
 800711c:	f001 fce6 	bl	8008aec <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007120:	2310      	movs	r3, #16
 8007122:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007126:	2303      	movs	r3, #3

  // only one LED, connected to PD2
  if( leds & 1 ) {
 8007128:	f014 0f01 	tst.w	r4, #1
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800712c:	f88d 3006 	strb.w	r3, [sp, #6]

  // only one LED, connected to PD2
  if( leds & 1 ) {
 8007130:	d006      	beq.n	8007140 <MIOS32_BOARD_LED_Init+0x2c>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8007132:	2304      	movs	r3, #4
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 8007134:	4806      	ldr	r0, [pc, #24]	; (8007150 <MIOS32_BOARD_LED_Init+0x3c>)
 8007136:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  // only one LED, connected to PD2
  if( leds & 1 ) {
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8007138:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 800713c:	f001 fc7d 	bl	8008a3a <GPIO_Init>
  }

  if( leds & 0xfffffffe)
 8007140:	f034 0401 	bics.w	r4, r4, #1
    return -2; // LED doesn't exist
 8007144:	bf0c      	ite	eq
 8007146:	4620      	moveq	r0, r4
 8007148:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 800714c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 800714e:	bf00      	nop
 8007150:	40011400 	.word	0x40011400

08007154 <MIOS32_BOARD_LED_Set>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Set(u32 leds, u32 value)
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( leds & 1 ) {
 8007154:	f010 0f01 	tst.w	r0, #1
 8007158:	d007      	beq.n	800716a <MIOS32_BOARD_LED_Set+0x16>
    GPIOD->BSRR = (value&1) ? GPIO_Pin_2 : (GPIO_Pin_2 << 16);
 800715a:	f011 0f01 	tst.w	r1, #1
 800715e:	4b06      	ldr	r3, [pc, #24]	; (8007178 <MIOS32_BOARD_LED_Set+0x24>)
 8007160:	bf0c      	ite	eq
 8007162:	f44f 2280 	moveq.w	r2, #262144	; 0x40000
 8007166:	2204      	movne	r2, #4
 8007168:	611a      	str	r2, [r3, #16]
  }

  if( leds & 0xfffffffe)
 800716a:	f030 0001 	bics.w	r0, r0, #1
    return -2; // LED doesn't exist
 800716e:	bf18      	it	ne
 8007170:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 8007174:	4770      	bx	lr
 8007176:	bf00      	nop
 8007178:	40011400 	.word	0x40011400

0800717c <MIOS32_BOARD_LED_Get>:
{
  u32 values = 0;

#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( GPIOD->ODR & GPIO_Pin_2 )
 800717c:	4b02      	ldr	r3, [pc, #8]	; (8007188 <MIOS32_BOARD_LED_Get+0xc>)
 800717e:	68d8      	ldr	r0, [r3, #12]
//! Returns the status of all LEDs
//! \return status of all LEDs
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_BOARD_LED_Get(void)
{
  u32 values = 0;
 8007180:	f3c0 0080 	ubfx	r0, r0, #2, #1
  if( GPIOB->ODR & GPIO_Pin_9 )
    values |= (1 << 1);
#endif

  return values;
}
 8007184:	4770      	bx	lr
 8007186:	bf00      	nop
 8007188:	40011400 	.word	0x40011400

0800718c <MIOS32_BOARD_J5_PinInit>:
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 800718c:	280b      	cmp	r0, #11
//!     <LI>MIOS32_BOARD_PIN_MODE_OUTPUT_OD: pin is used as output in open drain mode
//!   </UL>
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
 800718e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007190:	4604      	mov	r4, r0
 8007192:	460d      	mov	r5, r1
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported
 8007194:	bf88      	it	hi
 8007196:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 800719a:	d83a      	bhi.n	8007212 <MIOS32_BOARD_J5_PinInit+0x86>
 800719c:	4b1d      	ldr	r3, [pc, #116]	; (8007214 <MIOS32_BOARD_J5_PinInit+0x88>)
    return -1; // pin not supported

  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
 800719e:	b941      	cbnz	r1, 80071b2 <MIOS32_BOARD_J5_PinInit+0x26>
    // don't touch
    j5_enable_mask &= ~(1 << pin);
 80071a0:	2201      	movs	r2, #1
 80071a2:	fa12 f404 	lsls.w	r4, r2, r4
 80071a6:	881a      	ldrh	r2, [r3, #0]

    // init IO mode
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
  }

  return 0; // no error
 80071a8:	4608      	mov	r0, r1
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
    // don't touch
    j5_enable_mask &= ~(1 << pin);
 80071aa:	ea22 0404 	bic.w	r4, r2, r4
 80071ae:	801c      	strh	r4, [r3, #0]
 80071b0:	e02f      	b.n	8007212 <MIOS32_BOARD_J5_PinInit+0x86>
  } else {
    // enable pin
    j5_enable_mask |= (1 << pin);
 80071b2:	2201      	movs	r2, #1
 80071b4:	40a2      	lsls	r2, r4
 80071b6:	8819      	ldrh	r1, [r3, #0]

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
 80071b8:	a801      	add	r0, sp, #4
  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
    // don't touch
    j5_enable_mask &= ~(1 << pin);
  } else {
    // enable pin
    j5_enable_mask |= (1 << pin);
 80071ba:	430a      	orrs	r2, r1
 80071bc:	801a      	strh	r2, [r3, #0]

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
 80071be:	f001 fc95 	bl	8008aec <GPIO_StructInit>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80071c2:	2303      	movs	r3, #3
 80071c4:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_InitStructure.GPIO_Pin = j5_pin[pin].pin_mask;
 80071c8:	4b13      	ldr	r3, [pc, #76]	; (8007218 <MIOS32_BOARD_J5_PinInit+0x8c>)

    switch( mode ) {
 80071ca:	3d01      	subs	r5, #1
    j5_enable_mask |= (1 << pin);

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Pin = j5_pin[pin].pin_mask;
 80071cc:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80071d0:	889b      	ldrh	r3, [r3, #4]
 80071d2:	f8ad 3004 	strh.w	r3, [sp, #4]

    switch( mode ) {
 80071d6:	2d05      	cmp	r5, #5
 80071d8:	d819      	bhi.n	800720e <MIOS32_BOARD_J5_PinInit+0x82>
 80071da:	e8df f005 	tbb	[pc, r5]
 80071de:	0503      	.short	0x0503
 80071e0:	0d0b0907 	.word	0x0d0b0907
      case MIOS32_BOARD_PIN_MODE_ANALOG:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 80071e4:	2300      	movs	r3, #0
 80071e6:	e008      	b.n	80071fa <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 80071e8:	2304      	movs	r3, #4
 80071ea:	e006      	b.n	80071fa <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT_PD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 80071ec:	2328      	movs	r3, #40	; 0x28
 80071ee:	e004      	b.n	80071fa <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT_PU:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80071f0:	2348      	movs	r3, #72	; 0x48
 80071f2:	e002      	b.n	80071fa <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_PP:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80071f4:	2310      	movs	r3, #16
 80071f6:	e000      	b.n	80071fa <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_OD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 80071f8:	2314      	movs	r3, #20
 80071fa:	f88d 3007 	strb.w	r3, [sp, #7]
    // TK: disabled since there are application which have to switch between Input/Output
    // without destroying the current pin value
#endif

    // init IO mode
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
 80071fe:	4b06      	ldr	r3, [pc, #24]	; (8007218 <MIOS32_BOARD_J5_PinInit+0x8c>)
 8007200:	a901      	add	r1, sp, #4
 8007202:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 8007206:	f001 fc18 	bl	8008a3a <GPIO_Init>
  }

  return 0; // no error
 800720a:	2000      	movs	r0, #0
 800720c:	e001      	b.n	8007212 <MIOS32_BOARD_J5_PinInit+0x86>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_OD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	break;
      default:
	return -2; // invalid pin mode
 800720e:	f06f 0001 	mvn.w	r0, #1
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
  }

  return 0; // no error
#endif
}
 8007212:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8007214:	2000081a 	.word	0x2000081a
 8007218:	0800b0a0 	.word	0x0800b0a0

0800721c <MIOS32_BOARD_J5_PinSet>:
s32 MIOS32_BOARD_J5_PinSet(u8 pin, u8 value)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 800721c:	280b      	cmp	r0, #11
    return -1; // pin not supported
 800721e:	bf88      	it	hi
 8007220:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinSet(u8 pin, u8 value)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 8007224:	d818      	bhi.n	8007258 <MIOS32_BOARD_J5_PinSet+0x3c>
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 8007226:	4b0d      	ldr	r3, [pc, #52]	; (800725c <MIOS32_BOARD_J5_PinSet+0x40>)
 8007228:	881b      	ldrh	r3, [r3, #0]
 800722a:	4103      	asrs	r3, r0
 800722c:	f013 0f01 	tst.w	r3, #1
    return -2; // pin disabled
 8007230:	bf08      	it	eq
 8007232:	f06f 0001 	mvneq.w	r0, #1
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 8007236:	d00f      	beq.n	8007258 <MIOS32_BOARD_J5_PinSet+0x3c>
 8007238:	4b09      	ldr	r3, [pc, #36]	; (8007260 <MIOS32_BOARD_J5_PinSet+0x44>)
 800723a:	00c2      	lsls	r2, r0, #3
    return -2; // pin disabled

  if( value )
 800723c:	b131      	cbz	r1, 800724c <MIOS32_BOARD_J5_PinSet+0x30>
    j5_pin[pin].port->BSRR = j5_pin[pin].pin_mask;
 800723e:	f853 1030 	ldr.w	r1, [r3, r0, lsl #3]
 8007242:	189b      	adds	r3, r3, r2
 8007244:	889b      	ldrh	r3, [r3, #4]
  else
    j5_pin[pin].port->BRR = j5_pin[pin].pin_mask;

  return 0; // no error
 8007246:	2000      	movs	r0, #0

  if( !(j5_enable_mask & (1 << pin)) )
    return -2; // pin disabled

  if( value )
    j5_pin[pin].port->BSRR = j5_pin[pin].pin_mask;
 8007248:	610b      	str	r3, [r1, #16]
 800724a:	e005      	b.n	8007258 <MIOS32_BOARD_J5_PinSet+0x3c>
  else
    j5_pin[pin].port->BRR = j5_pin[pin].pin_mask;
 800724c:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
 8007250:	189b      	adds	r3, r3, r2
 8007252:	889b      	ldrh	r3, [r3, #4]
 8007254:	6143      	str	r3, [r0, #20]

  return 0; // no error
 8007256:	4608      	mov	r0, r1
#endif
}
 8007258:	4770      	bx	lr
 800725a:	bf00      	nop
 800725c:	2000081a 	.word	0x2000081a
 8007260:	0800b0a0 	.word	0x0800b0a0

08007264 <MIOS32_BOARD_J5_PinGet>:
s32 MIOS32_BOARD_J5_PinGet(u8 pin)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 8007264:	280b      	cmp	r0, #11
    return -1; // pin not supported
 8007266:	bf88      	it	hi
 8007268:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinGet(u8 pin)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 800726c:	d813      	bhi.n	8007296 <MIOS32_BOARD_J5_PinGet+0x32>
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 800726e:	4b0a      	ldr	r3, [pc, #40]	; (8007298 <MIOS32_BOARD_J5_PinGet+0x34>)
 8007270:	881b      	ldrh	r3, [r3, #0]
 8007272:	4103      	asrs	r3, r0
 8007274:	f013 0f01 	tst.w	r3, #1
    return -2; // pin disabled
 8007278:	bf08      	it	eq
 800727a:	f06f 0001 	mvneq.w	r0, #1
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 800727e:	d00a      	beq.n	8007296 <MIOS32_BOARD_J5_PinGet+0x32>
    return -2; // pin disabled

  return (j5_pin[pin].port->IDR & j5_pin[pin].pin_mask) ? 1 : 0;
 8007280:	4b06      	ldr	r3, [pc, #24]	; (800729c <MIOS32_BOARD_J5_PinGet+0x38>)
 8007282:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
 8007286:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800728a:	8883      	ldrh	r3, [r0, #4]
 800728c:	6892      	ldr	r2, [r2, #8]
 800728e:	4213      	tst	r3, r2
 8007290:	bf0c      	ite	eq
 8007292:	2000      	moveq	r0, #0
 8007294:	2001      	movne	r0, #1
#endif
}
 8007296:	4770      	bx	lr
 8007298:	2000081a 	.word	0x2000081a
 800729c:	0800b0a0 	.word	0x0800b0a0

080072a0 <MIOS32_BOARD_J15_PortInit>:
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 80072a0:	2801      	cmp	r0, #1
//!   <LI>1: J15 pins are configured in Open Drain mode (perfect for 3.3V->5V levelshifting)
//! </UL>
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PortInit(u32 mode)
{
 80072a2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80072a4:	4606      	mov	r6, r0
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
    return -1; // unsupported mode
 80072a6:	bf88      	it	hi
 80072a8:	f04f 30ff 	movhi.w	r0, #4294967295
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 80072ac:	d854      	bhi.n	8007358 <MIOS32_BOARD_J15_PortInit+0xb8>
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80072ae:	ad01      	add	r5, sp, #4
 80072b0:	4628      	mov	r0, r5
 80072b2:	f001 fc1b 	bl	8008aec <GPIO_StructInit>

  J15_PIN_SCLK_0;
  J15_PIN_RCLK_0;
 80072b6:	4c29      	ldr	r4, [pc, #164]	; (800735c <MIOS32_BOARD_J15_PortInit+0xbc>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 80072b8:	4829      	ldr	r0, [pc, #164]	; (8007360 <MIOS32_BOARD_J15_PortInit+0xc0>)
  J15_PIN_RCLK_0;
  J15_PIN_RW(0);
 80072ba:	4a2a      	ldr	r2, [pc, #168]	; (8007364 <MIOS32_BOARD_J15_PortInit+0xc4>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 80072bc:	f44f 7380 	mov.w	r3, #256	; 0x100
  J15_PIN_RCLK_0;
 80072c0:	f44f 7700 	mov.w	r7, #512	; 0x200
  J15_PIN_RW(0);
 80072c4:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 80072c8:	6143      	str	r3, [r0, #20]
  J15_PIN_RCLK_0;
 80072ca:	6167      	str	r7, [r4, #20]
  J15_PIN_RW(0);
 80072cc:	6111      	str	r1, [r2, #16]
  J15_PIN_E1(0);
 80072ce:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 80072d2:	6122      	str	r2, [r4, #16]
  J15_PIN_E2(0);
 80072d4:	f5a2 0280 	sub.w	r2, r2, #4194304	; 0x400000
 80072d8:	6122      	str	r2, [r4, #16]
#ifdef MIOS32_BOARD_LCD_E4_PORT
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80072da:	2210      	movs	r2, #16
 80072dc:	f88d 2007 	strb.w	r2, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80072e0:	4629      	mov	r1, r5
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients
 80072e2:	2202      	movs	r2, #2
 80072e4:	f88d 2006 	strb.w	r2, [sp, #6]

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
 80072e8:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80072ec:	f001 fba5 	bl	8008a3a <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 80072f0:	4620      	mov	r0, r4
 80072f2:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
 80072f4:	f8ad 7004 	strh.w	r7, [sp, #4]
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 80072f8:	f001 fb9f 	bl	8008a3a <GPIO_Init>

  // configure open-drain pins (if OD option enabled)
  if( mode )
 80072fc:	b116      	cbz	r6, 8007304 <MIOS32_BOARD_J15_PortInit+0x64>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 80072fe:	2314      	movs	r3, #20
 8007300:	f88d 3007 	strb.w	r3, [sp, #7]

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
 8007304:	ac02      	add	r4, sp, #8
 8007306:	f44f 7380 	mov.w	r3, #256	; 0x100
 800730a:	f824 3d04 	strh.w	r3, [r4, #-4]!
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);
 800730e:	4813      	ldr	r0, [pc, #76]	; (800735c <MIOS32_BOARD_J15_PortInit+0xbc>)
 8007310:	4621      	mov	r1, r4
 8007312:	f001 fb92 	bl	8008a3a <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 8007316:	2380      	movs	r3, #128	; 0x80
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 8007318:	4810      	ldr	r0, [pc, #64]	; (800735c <MIOS32_BOARD_J15_PortInit+0xbc>)
 800731a:	4621      	mov	r1, r4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 800731c:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 8007320:	f001 fb8b 	bl	8008a3a <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 8007324:	2340      	movs	r3, #64	; 0x40
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 8007326:	480d      	ldr	r0, [pc, #52]	; (800735c <MIOS32_BOARD_J15_PortInit+0xbc>)
 8007328:	4621      	mov	r1, r4
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 800732a:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 800732e:	f001 fb84 	bl	8008a3a <GPIO_Init>
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 8007332:	2304      	movs	r3, #4
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 8007334:	480b      	ldr	r0, [pc, #44]	; (8007364 <MIOS32_BOARD_J15_PortInit+0xc4>)
 8007336:	4621      	mov	r1, r4
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 8007338:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 800733c:	f001 fb7d 	bl	8008a3a <GPIO_Init>

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8007340:	2348      	movs	r3, #72	; 0x48
 8007342:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 8007346:	4805      	ldr	r0, [pc, #20]	; (800735c <MIOS32_BOARD_J15_PortInit+0xbc>)
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 8007348:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 800734c:	4621      	mov	r1, r4
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 800734e:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 8007352:	f001 fb72 	bl	8008a3a <GPIO_Init>

  return 0; // no error
 8007356:	2000      	movs	r0, #0
#endif
}
 8007358:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800735a:	bf00      	nop
 800735c:	40011000 	.word	0x40011000
 8007360:	40010800 	.word	0x40010800
 8007364:	40010c00 	.word	0x40010c00

08007368 <MIOS32_BOARD_J15_DataSet>:
#else
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
 8007368:	492d      	ldr	r1, [pc, #180]	; (8007420 <MIOS32_BOARD_J15_DataSet+0xb8>)
 800736a:	f010 0f80 	tst.w	r0, #128	; 0x80
 800736e:	bf0c      	ite	eq
 8007370:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 8007374:	f44f 7380 	movne.w	r3, #256	; 0x100
 8007378:	610b      	str	r3, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 800737a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800737e:	4b29      	ldr	r3, [pc, #164]	; (8007424 <MIOS32_BOARD_J15_DataSet+0xbc>)
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
 8007380:	f010 0f40 	tst.w	r0, #64	; 0x40
 8007384:	bf0c      	ite	eq
 8007386:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 800738a:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 800738c:	f010 0f20 	tst.w	r0, #32
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
 8007390:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007392:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x40); // D6
 8007394:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 8007398:	bf0c      	ite	eq
 800739a:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 800739e:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 80073a0:	f010 0f10 	tst.w	r0, #16

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
 80073a4:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073a6:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x20); // D5
 80073a8:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 80073ac:	bf0c      	ite	eq
 80073ae:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80073b2:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 80073b4:	f010 0f08 	tst.w	r0, #8
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
 80073b8:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073ba:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x10); // D4
 80073bc:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 80073c0:	bf0c      	ite	eq
 80073c2:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80073c6:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 80073c8:	f010 0f04 	tst.w	r0, #4
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
 80073cc:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073ce:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x08); // D3
 80073d0:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 80073d4:	bf0c      	ite	eq
 80073d6:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80073da:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 80073dc:	f010 0f02 	tst.w	r0, #2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
 80073e0:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073e2:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x04); // D2
 80073e4:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 80073e8:	bf0c      	ite	eq
 80073ea:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80073ee:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x01); // D0
 80073f0:	f010 0f01 	tst.w	r0, #1
 80073f4:	bf0c      	ite	eq
 80073f6:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 80073fa:	4610      	movne	r0, r2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
  J15_PIN_SCLK_0; // setup delay
 80073fc:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80073fe:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x02); // D1
 8007400:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 8007404:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007406:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x01); // D0
 8007408:	6108      	str	r0, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 800740a:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800740c:	611a      	str	r2, [r3, #16]

  // transfer to output register
  J15_PIN_RCLK_1;
 800740e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007412:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_0;

  return 0; // no error
#endif
}
 8007414:	2000      	movs	r0, #0
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;

  // transfer to output register
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_1;
 8007416:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
 8007418:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_0;
 800741a:	614b      	str	r3, [r1, #20]

  return 0; // no error
#endif
}
 800741c:	4770      	bx	lr
 800741e:	bf00      	nop
 8007420:	40011000 	.word	0x40011000
 8007424:	40010800 	.word	0x40010800

08007428 <MIOS32_BOARD_J15_RS_Set>:
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 8007428:	4b04      	ldr	r3, [pc, #16]	; (800743c <MIOS32_BOARD_J15_RS_Set+0x14>)
 800742a:	2800      	cmp	r0, #0
 800742c:	bf0c      	ite	eq
 800742e:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 8007432:	f44f 7080 	movne.w	r0, #256	; 0x100
 8007436:	6118      	str	r0, [r3, #16]
  J15_PIN_SCLK_0;
#endif

  return 0; // no error
#endif
}
 8007438:	2000      	movs	r0, #0
 800743a:	4770      	bx	lr
 800743c:	40011000 	.word	0x40011000

08007440 <MIOS32_BOARD_J15_RW_Set>:
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007440:	4b04      	ldr	r3, [pc, #16]	; (8007454 <MIOS32_BOARD_J15_RW_Set+0x14>)
 8007442:	2800      	cmp	r0, #0
 8007444:	bf0c      	ite	eq
 8007446:	f44f 2080 	moveq.w	r0, #262144	; 0x40000
 800744a:	2004      	movne	r0, #4
 800744c:	6118      	str	r0, [r3, #16]

  return 0; // no error
#endif
}
 800744e:	2000      	movs	r0, #0
 8007450:	4770      	bx	lr
 8007452:	bf00      	nop
 8007454:	40010c00 	.word	0x40010c00

08007458 <MIOS32_BOARD_J15_E_Set>:
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 8007458:	b128      	cbz	r0, 8007466 <MIOS32_BOARD_J15_E_Set+0xe>
 800745a:	2801      	cmp	r0, #1
      return 0; // no error
#endif

  }

  return -1; // pin not available
 800745c:	bf18      	it	ne
 800745e:	f04f 30ff 	movne.w	r0, #4294967295
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 8007462:	d110      	bne.n	8007486 <MIOS32_BOARD_J15_E_Set+0x2e>
 8007464:	e007      	b.n	8007476 <MIOS32_BOARD_J15_E_Set+0x1e>
    case 0: 
      J15_PIN_E1(e);
 8007466:	4b08      	ldr	r3, [pc, #32]	; (8007488 <MIOS32_BOARD_J15_E_Set+0x30>)
 8007468:	2900      	cmp	r1, #0
 800746a:	bf0c      	ite	eq
 800746c:	f44f 0100 	moveq.w	r1, #8388608	; 0x800000
 8007470:	2180      	movne	r1, #128	; 0x80
 8007472:	6119      	str	r1, [r3, #16]
      return 0; // no error
 8007474:	e007      	b.n	8007486 <MIOS32_BOARD_J15_E_Set+0x2e>

    case 1: 
      J15_PIN_E2(e);
 8007476:	4b04      	ldr	r3, [pc, #16]	; (8007488 <MIOS32_BOARD_J15_E_Set+0x30>)
 8007478:	2900      	cmp	r1, #0
 800747a:	bf0c      	ite	eq
 800747c:	f44f 0180 	moveq.w	r1, #4194304	; 0x400000
 8007480:	2140      	movne	r1, #64	; 0x40
 8007482:	6119      	str	r1, [r3, #16]
      return 0; // no error
 8007484:	2000      	movs	r0, #0

  }

  return -1; // pin not available
#endif
}
 8007486:	4770      	bx	lr
 8007488:	40011000 	.word	0x40011000

0800748c <MIOS32_BOARD_J15_PollUnbusy>:
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 800748c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 800748e:	4b1a      	ldr	r3, [pc, #104]	; (80074f8 <MIOS32_BOARD_J15_PollUnbusy+0x6c>)
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007490:	4f1a      	ldr	r7, [pc, #104]	; (80074fc <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 8007492:	2604      	movs	r6, #4
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 8007494:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8007498:	611a      	str	r2, [r3, #16]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 800749a:	460c      	mov	r4, r1
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 800749c:	613e      	str	r6, [r7, #16]

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 800749e:	2101      	movs	r1, #1
 80074a0:	9301      	str	r3, [sp, #4]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 80074a2:	4605      	mov	r5, r0

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 80074a4:	f7ff ffd8 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
 80074a8:	9b01      	ldr	r3, [sp, #4]
 80074aa:	2800      	cmp	r0, #0

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 80074ac:	bfa8      	it	ge
 80074ae:	461e      	movge	r6, r3

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 80074b0:	db1f      	blt.n	80074f2 <MIOS32_BOARD_J15_PollUnbusy+0x66>
 80074b2:	e012      	b.n	80074da <MIOS32_BOARD_J15_PollUnbusy+0x4e>
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);
 80074b4:	2101      	movs	r1, #1
 80074b6:	4628      	mov	r0, r5
 80074b8:	f7ff ffce 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
 80074bc:	210a      	movs	r1, #10
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80074be:	4a0f      	ldr	r2, [pc, #60]	; (80074fc <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 80074c0:	2304      	movs	r3, #4
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 80074c2:	f111 31ff 	adds.w	r1, r1, #4294967295
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80074c6:	6113      	str	r3, [r2, #16]
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 80074c8:	d1f9      	bne.n	80074be <MIOS32_BOARD_J15_PollUnbusy+0x32>
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 80074ca:	68b7      	ldr	r7, [r6, #8]
    MIOS32_BOARD_J15_E_Set(lcd, 0);
 80074cc:	4628      	mov	r0, r5
 80074ce:	f7ff ffc3 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
    if( !busy )
 80074d2:	f417 5f80 	tst.w	r7, #4096	; 0x1000
 80074d6:	d002      	beq.n	80074de <MIOS32_BOARD_J15_PollUnbusy+0x52>
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
 80074d8:	3c01      	subs	r4, #1
 80074da:	2c00      	cmp	r4, #0
 80074dc:	d1ea      	bne.n	80074b4 <MIOS32_BOARD_J15_PollUnbusy+0x28>
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80074de:	4b07      	ldr	r3, [pc, #28]	; (80074fc <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 80074e0:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 80074e4:	2c00      	cmp	r4, #0
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80074e6:	611a      	str	r2, [r3, #16]
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 80074e8:	bf14      	ite	ne
 80074ea:	2000      	movne	r0, #0
 80074ec:	f06f 0001 	mvneq.w	r0, #1
 80074f0:	e001      	b.n	80074f6 <MIOS32_BOARD_J15_PollUnbusy+0x6a>
  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available
 80074f2:	f04f 30ff 	mov.w	r0, #4294967295
  if( poll_ctr == 0 )
    return -2; // timeout error

  return 0; // no error
#endif
}
 80074f6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80074f8:	40011000 	.word	0x40011000
 80074fc:	40010c00 	.word	0x40010c00

08007500 <TIM2_IRQHandler>:
//! Interrupt handlers
//! \note don't call them directly from application
/////////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_ALLOCATE_TIM2_IRQn
TIMER0_IRQ_HANDLER
{
 8007500:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER0_BASE, TIM_IT_Update) != RESET ) {
 8007502:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8007506:	2101      	movs	r1, #1
 8007508:	f001 fe59 	bl	80091be <TIM_GetITStatus>
 800750c:	b138      	cbz	r0, 800751e <TIM2_IRQHandler+0x1e>
    TIM_ClearITPendingBit(TIMER0_BASE, TIM_IT_Update);
 800750e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8007512:	2101      	movs	r1, #1
 8007514:	f001 fe5f 	bl	80091d6 <TIM_ClearITPendingBit>
    timer_callback[0]();
 8007518:	4b01      	ldr	r3, [pc, #4]	; (8007520 <TIM2_IRQHandler+0x20>)
 800751a:	681b      	ldr	r3, [r3, #0]
 800751c:	4798      	blx	r3
  }
}
 800751e:	bd08      	pop	{r3, pc}
 8007520:	2000081c 	.word	0x2000081c

08007524 <TIM3_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM3_IRQn
TIMER1_IRQ_HANDLER
{
 8007524:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER1_BASE, TIM_IT_Update) != RESET ) {
 8007526:	4806      	ldr	r0, [pc, #24]	; (8007540 <TIM3_IRQHandler+0x1c>)
 8007528:	2101      	movs	r1, #1
 800752a:	f001 fe48 	bl	80091be <TIM_GetITStatus>
 800752e:	b130      	cbz	r0, 800753e <TIM3_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER1_BASE, TIM_IT_Update);
 8007530:	4803      	ldr	r0, [pc, #12]	; (8007540 <TIM3_IRQHandler+0x1c>)
 8007532:	2101      	movs	r1, #1
 8007534:	f001 fe4f 	bl	80091d6 <TIM_ClearITPendingBit>
    timer_callback[1]();
 8007538:	4b02      	ldr	r3, [pc, #8]	; (8007544 <TIM3_IRQHandler+0x20>)
 800753a:	685b      	ldr	r3, [r3, #4]
 800753c:	4798      	blx	r3
  }
}
 800753e:	bd08      	pop	{r3, pc}
 8007540:	40000400 	.word	0x40000400
 8007544:	2000081c 	.word	0x2000081c

08007548 <TIM5_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM5_IRQn
TIMER2_IRQ_HANDLER
{
 8007548:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER2_BASE, TIM_IT_Update) != RESET ) {
 800754a:	4806      	ldr	r0, [pc, #24]	; (8007564 <TIM5_IRQHandler+0x1c>)
 800754c:	2101      	movs	r1, #1
 800754e:	f001 fe36 	bl	80091be <TIM_GetITStatus>
 8007552:	b130      	cbz	r0, 8007562 <TIM5_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER2_BASE, TIM_IT_Update);
 8007554:	4803      	ldr	r0, [pc, #12]	; (8007564 <TIM5_IRQHandler+0x1c>)
 8007556:	2101      	movs	r1, #1
 8007558:	f001 fe3d 	bl	80091d6 <TIM_ClearITPendingBit>
    timer_callback[2]();
 800755c:	4b02      	ldr	r3, [pc, #8]	; (8007568 <TIM5_IRQHandler+0x20>)
 800755e:	689b      	ldr	r3, [r3, #8]
 8007560:	4798      	blx	r3
  }
}
 8007562:	bd08      	pop	{r3, pc}
 8007564:	40000c00 	.word	0x40000c00
 8007568:	2000081c 	.word	0x2000081c

0800756c <MIOS32_DELAY_Init>:
//!
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
 800756c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800756e:	4604      	mov	r4, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007570:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8007574:	b9c4      	cbnz	r4, 80075a8 <MIOS32_DELAY_Init+0x3c>
    return -1; // unsupported mode

  // enable timer clock
  if( MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM1 || MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM8 )
    RCC_APB2PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);
 8007576:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800757a:	2101      	movs	r1, #1
 800757c:	f001 ff2c 	bl	80093d8 <RCC_APB2PeriphClockCmd>
  else
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
 8007580:	f04f 33ff 	mov.w	r3, #4294967295
 8007584:	f8ad 3008 	strh.w	r3, [sp, #8]
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007588:	4808      	ldr	r0, [pc, #32]	; (80075ac <MIOS32_DELAY_Init+0x40>)
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 800758a:	2347      	movs	r3, #71	; 0x47
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 800758c:	a901      	add	r1, sp, #4
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 800758e:	f8ad 3004 	strh.w	r3, [sp, #4]
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8007592:	f8ad 400a 	strh.w	r4, [sp, #10]
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8007596:	f8ad 4006 	strh.w	r4, [sp, #6]
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 800759a:	f001 fd93 	bl	80090c4 <TIM_TimeBaseInit>

  // enable counter
  TIM_Cmd(MIOS32_DELAY_TIMER, ENABLE);
 800759e:	4803      	ldr	r0, [pc, #12]	; (80075ac <MIOS32_DELAY_Init+0x40>)
 80075a0:	2101      	movs	r1, #1
 80075a2:	f001 fdff 	bl	80091a4 <TIM_Cmd>

  return 0; // no error
 80075a6:	4620      	mov	r0, r4
}
 80075a8:	b004      	add	sp, #16
 80075aa:	bd10      	pop	{r4, pc}
 80075ac:	40012c00 	.word	0x40012c00

080075b0 <MIOS32_DELAY_Wait_uS>:
//! \param[in] uS delay (1..65535 microseconds)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Wait_uS(u16 uS)
{
  u16 start = MIOS32_DELAY_TIMER->CNT;
 80075b0:	4b04      	ldr	r3, [pc, #16]	; (80075c4 <MIOS32_DELAY_Wait_uS+0x14>)
 80075b2:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80075b4:	b292      	uxth	r2, r2

  // note that this even works on 16bit counter wrap-arounds
  while( (u16)(MIOS32_DELAY_TIMER->CNT - start) <= uS );
 80075b6:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 80075b8:	1a89      	subs	r1, r1, r2
 80075ba:	b289      	uxth	r1, r1
 80075bc:	4281      	cmp	r1, r0
 80075be:	d9fa      	bls.n	80075b6 <MIOS32_DELAY_Wait_uS+0x6>

  return 0; // no error
}
 80075c0:	2000      	movs	r0, #0
 80075c2:	4770      	bx	lr
 80075c4:	40012c00 	.word	0x40012c00

080075c8 <MIOS32_AIN_Init>:
//! Initializes AIN driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
{
 80075c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80075ca:	b095      	sub	sp, #84	; 0x54
  // currently only mode 0 supported
  if( mode != 0 )
 80075cc:	2800      	cmp	r0, #0
 80075ce:	f040 8104 	bne.w	80077da <MIOS32_AIN_Init+0x212>
  return -1; // no AIN pins selected
#else
  int i;

  // disable service prepare callback function
  service_prepare_callback = NULL;
 80075d2:	4b84      	ldr	r3, [pc, #528]	; (80077e4 <MIOS32_AIN_Init+0x21c>)
 80075d4:	4e84      	ldr	r6, [pc, #528]	; (80077e8 <MIOS32_AIN_Init+0x220>)
 80075d6:	6018      	str	r0, [r3, #0]
 80075d8:	4b84      	ldr	r3, [pc, #528]	; (80077ec <MIOS32_AIN_Init+0x224>)
/////////////////////////////////////////////////////////////////////////////
//! Initializes AIN driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
 80075da:	f106 021e 	add.w	r2, r6, #30
  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    adc_conversion_values[i] = 0;
 80075de:	2100      	movs	r1, #0
 80075e0:	f823 1f02 	strh.w	r1, [r3, #2]!

  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80075e4:	4293      	cmp	r3, r2
 80075e6:	d1fa      	bne.n	80075de <MIOS32_AIN_Init+0x16>
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
    ain_pin_values[i] = 0;
 80075e8:	4981      	ldr	r1, [pc, #516]	; (80077f0 <MIOS32_AIN_Init+0x228>)
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
 80075ea:	4a82      	ldr	r2, [pc, #520]	; (80077f4 <MIOS32_AIN_Init+0x22c>)

  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80075ec:	2300      	movs	r3, #0
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
    ain_pin_values[i] = 0;
 80075ee:	2400      	movs	r4, #0
 80075f0:	52cc      	strh	r4, [r1, r3]
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
 80075f2:	52d4      	strh	r4, [r2, r3]
 80075f4:	3302      	adds	r3, #2
    adc_conversion_values[i] = 0;
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
 80075f6:	2b20      	cmp	r3, #32
 80075f8:	d1f9      	bne.n	80075ee <MIOS32_AIN_Init+0x26>
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
 80075fa:	4b7f      	ldr	r3, [pc, #508]	; (80077f8 <MIOS32_AIN_Init+0x230>)
  oversampling_ctr = mux_ctr = 0;


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80075fc:	ad13      	add	r5, sp, #76	; 0x4c
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
 80075fe:	601c      	str	r4, [r3, #0]
  }
  oversampling_ctr = mux_ctr = 0;
 8007600:	4b7e      	ldr	r3, [pc, #504]	; (80077fc <MIOS32_AIN_Init+0x234>)


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8007602:	4628      	mov	r0, r5
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
  }
  oversampling_ctr = mux_ctr = 0;
 8007604:	701c      	strb	r4, [r3, #0]
 8007606:	4b7e      	ldr	r3, [pc, #504]	; (8007800 <MIOS32_AIN_Init+0x238>)

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 8007608:	27f0      	movs	r7, #240	; 0xf0
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
  }
  oversampling_ctr = mux_ctr = 0;
 800760a:	701c      	strb	r4, [r3, #0]


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800760c:	f001 fa6e 	bl	8008aec <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8007610:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AIN;

  // J5A.0..3 -> Channel 10..13 -> Pin C0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x000f) >> 0;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007612:	4629      	mov	r1, r5
 8007614:	487b      	ldr	r0, [pc, #492]	; (8007804 <MIOS32_AIN_Init+0x23c>)


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8007616:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AIN;
 800761a:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f

  // J5A.0..3 -> Channel 10..13 -> Pin C0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x000f) >> 0;
 800761e:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007622:	f001 fa0a 	bl	8008a3a <GPIO_Init>

  // J5B.4..7 -> Channel 0..3 -> Pin A0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x00f0) >> 4;
 8007626:	210f      	movs	r1, #15
 8007628:	f8ad 104c 	strh.w	r1, [sp, #76]	; 0x4c
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800762c:	4876      	ldr	r0, [pc, #472]	; (8007808 <MIOS32_AIN_Init+0x240>)
 800762e:	4629      	mov	r1, r5
 8007630:	f001 fa03 	bl	8008a3a <GPIO_Init>

  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007634:	4629      	mov	r1, r5
 8007636:	4873      	ldr	r0, [pc, #460]	; (8007804 <MIOS32_AIN_Init+0x23c>)
  // J5B.4..7 -> Channel 0..3 -> Pin A0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x00f0) >> 4;
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
 8007638:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800763c:	f001 f9fd 	bl	8008a3a <GPIO_Init>

  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8007640:	4629      	mov	r1, r5
 8007642:	4872      	ldr	r0, [pc, #456]	; (800780c <MIOS32_AIN_Init+0x244>)
  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
 8007644:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8007648:	f001 f9f7 	bl	8008a3a <GPIO_Init>

  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800764c:	4629      	mov	r1, r5
 800764e:	486d      	ldr	r0, [pc, #436]	; (8007804 <MIOS32_AIN_Init+0x23c>)
  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
  GPIO_Init(GPIOB, &GPIO_InitStructure);

  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
 8007650:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007654:	f001 f9f1 	bl	8008a3a <GPIO_Init>

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007658:	4629      	mov	r1, r5
 800765a:	486b      	ldr	r0, [pc, #428]	; (8007808 <MIOS32_AIN_Init+0x240>)
  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
 800765c:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
 8007660:	4d6b      	ldr	r5, [pc, #428]	; (8007810 <MIOS32_AIN_Init+0x248>)
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007662:	f001 f9ea 	bl	8008a3a <GPIO_Init>


  // configure MUX pins if enabled
#if MIOS32_AIN_MUX_PINS >= 0
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007666:	2310      	movs	r3, #16
#endif
#endif


  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 8007668:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 800766c:	2101      	movs	r1, #1
  GPIO_Init(GPIOA, &GPIO_InitStructure);


  // configure MUX pins if enabled
#if MIOS32_AIN_MUX_PINS >= 0
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 800766e:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
#endif
#endif


  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 8007672:	f001 feb1 	bl	80093d8 <RCC_APB2PeriphClockCmd>
  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
      ADC_RegularChannelConfig(
 8007676:	f8df c19c 	ldr.w	ip, [pc, #412]	; 8007814 <MIOS32_AIN_Init+0x24c>
  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
 800767a:	702c      	strb	r4, [r5, #0]
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 800767c:	fa57 f304 	asrs.w	r3, r7, r4
 8007680:	f013 0f01 	tst.w	r3, #1
 8007684:	d013      	beq.n	80076ae <MIOS32_AIN_Init+0xe6>
      ADC_RegularChannelConfig(
        (num_channels & 1) ? ADC2 : ADC1, 
 8007686:	782a      	ldrb	r2, [r5, #0]
  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
      ADC_RegularChannelConfig(
 8007688:	4863      	ldr	r0, [pc, #396]	; (8007818 <MIOS32_AIN_Init+0x250>)
 800768a:	f012 0f01 	tst.w	r2, #1
 800768e:	4b63      	ldr	r3, [pc, #396]	; (800781c <MIOS32_AIN_Init+0x254>)
 8007690:	bf08      	it	eq
 8007692:	4660      	moveq	r0, ip
 8007694:	0852      	lsrs	r2, r2, #1
 8007696:	5d19      	ldrb	r1, [r3, r4]
 8007698:	3201      	adds	r2, #1
 800769a:	2307      	movs	r3, #7
 800769c:	f8cd c004 	str.w	ip, [sp, #4]
 80076a0:	f001 fadb 	bl	8008c5a <ADC_RegularChannelConfig>
        (num_channels & 1) ? ADC2 : ADC1, 
	adc_chn_map[i], 
	(num_channels>>1)+1, 
	ADC_SampleTime_239Cycles5);
      ++num_channels;
 80076a4:	782b      	ldrb	r3, [r5, #0]
 80076a6:	3301      	adds	r3, #1
 80076a8:	702b      	strb	r3, [r5, #0]
 80076aa:	f8dd c004 	ldr.w	ip, [sp, #4]
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80076ae:	3401      	adds	r4, #1
 80076b0:	2c10      	cmp	r4, #16
 80076b2:	d1e3      	bne.n	800767c <MIOS32_AIN_Init+0xb4>
      ++num_channels;
    }
  }

  // ensure that num_used_channels is an even value to keep ADC2 in synch with ADC1
  num_used_channels = num_channels;
 80076b4:	4b56      	ldr	r3, [pc, #344]	; (8007810 <MIOS32_AIN_Init+0x248>)
 80076b6:	4a5a      	ldr	r2, [pc, #360]	; (8007820 <MIOS32_AIN_Init+0x258>)
 80076b8:	781b      	ldrb	r3, [r3, #0]
  if( num_used_channels & 1 )
 80076ba:	f013 0f01 	tst.w	r3, #1
      ++num_channels;
    }
  }

  // ensure that num_used_channels is an even value to keep ADC2 in synch with ADC1
  num_used_channels = num_channels;
 80076be:	7013      	strb	r3, [r2, #0]
  if( num_used_channels & 1 )
 80076c0:	d001      	beq.n	80076c6 <MIOS32_AIN_Init+0xfe>
      ++num_used_channels;
 80076c2:	3301      	adds	r3, #1
 80076c4:	7013      	strb	r3, [r2, #0]

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
 80076c6:	ad0e      	add	r5, sp, #56	; 0x38
 80076c8:	4628      	mov	r0, r5
 80076ca:	f001 fa8d 	bl	8008be8 <ADC_StructInit>
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
 80076ce:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
 80076d2:	930e      	str	r3, [sp, #56]	; 0x38
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 80076d4:	f5a3 23c0 	sub.w	r3, r3, #393216	; 0x60000
 80076d8:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 80076dc:	9311      	str	r3, [sp, #68]	; 0x44
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80076de:	4b50      	ldr	r3, [pc, #320]	; (8007820 <MIOS32_AIN_Init+0x258>)

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 80076e0:	2401      	movs	r4, #1
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80076e2:	781b      	ldrb	r3, [r3, #0]
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 80076e4:	f44f 2260 	mov.w	r2, #917504	; 0xe0000
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80076e8:	40e3      	lsrs	r3, r4
  ADC_Init(ADC1, &ADC_InitStructure);
 80076ea:	484a      	ldr	r0, [pc, #296]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 80076ec:	4629      	mov	r1, r5
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 80076ee:	9210      	str	r2, [sp, #64]	; 0x40
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80076f0:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 80076f4:	f88d 403c 	strb.w	r4, [sp, #60]	; 0x3c
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
  ADC_Init(ADC1, &ADC_InitStructure);
 80076f8:	f001 fa50 	bl	8008b9c <ADC_Init>
  ADC_Init(ADC2, &ADC_InitStructure);
 80076fc:	4846      	ldr	r0, [pc, #280]	; (8007818 <MIOS32_AIN_Init+0x250>)
 80076fe:	4629      	mov	r1, r5
 8007700:	f001 fa4c 	bl	8008b9c <ADC_Init>

  // enable ADC2 external trigger conversion (to synch with ADC1)
  ADC_ExternalTrigConvCmd(ADC2, ENABLE);
 8007704:	4844      	ldr	r0, [pc, #272]	; (8007818 <MIOS32_AIN_Init+0x250>)
 8007706:	4621      	mov	r1, r4
 8007708:	f001 fafa 	bl	8008d00 <ADC_ExternalTrigConvCmd>

  // enable ADC1->DMA request
  ADC_DMACmd(ADC1, ENABLE);
 800770c:	4841      	ldr	r0, [pc, #260]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 800770e:	4621      	mov	r1, r4
 8007710:	f001 fa7d 	bl	8008c0e <ADC_DMACmd>


  // ADC1 calibration
  ADC_Cmd(ADC1, ENABLE);
 8007714:	483f      	ldr	r0, [pc, #252]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 8007716:	4621      	mov	r1, r4
 8007718:	f001 fa6f 	bl	8008bfa <ADC_Cmd>
  ADC_ResetCalibration(ADC1);
 800771c:	483d      	ldr	r0, [pc, #244]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 800771e:	f001 fa80 	bl	8008c22 <ADC_ResetCalibration>
  while( ADC_GetResetCalibrationStatus(ADC1) );
 8007722:	483c      	ldr	r0, [pc, #240]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 8007724:	f001 fa82 	bl	8008c2c <ADC_GetResetCalibrationStatus>
 8007728:	2800      	cmp	r0, #0
 800772a:	d1fa      	bne.n	8007722 <MIOS32_AIN_Init+0x15a>
  ADC_StartCalibration(ADC1);
 800772c:	4839      	ldr	r0, [pc, #228]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 800772e:	f001 fa81 	bl	8008c34 <ADC_StartCalibration>
  while( ADC_GetCalibrationStatus(ADC1) );
 8007732:	4838      	ldr	r0, [pc, #224]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 8007734:	f001 fa83 	bl	8008c3e <ADC_GetCalibrationStatus>
 8007738:	2800      	cmp	r0, #0
 800773a:	d1fa      	bne.n	8007732 <MIOS32_AIN_Init+0x16a>

  // ADC2 calibration
  ADC_Cmd(ADC2, ENABLE);
 800773c:	4836      	ldr	r0, [pc, #216]	; (8007818 <MIOS32_AIN_Init+0x250>)
 800773e:	2101      	movs	r1, #1
 8007740:	f001 fa5b 	bl	8008bfa <ADC_Cmd>
  ADC_ResetCalibration(ADC2);
 8007744:	4834      	ldr	r0, [pc, #208]	; (8007818 <MIOS32_AIN_Init+0x250>)
 8007746:	f001 fa6c 	bl	8008c22 <ADC_ResetCalibration>
  while( ADC_GetResetCalibrationStatus(ADC2) );
 800774a:	4833      	ldr	r0, [pc, #204]	; (8007818 <MIOS32_AIN_Init+0x250>)
 800774c:	f001 fa6e 	bl	8008c2c <ADC_GetResetCalibrationStatus>
 8007750:	2800      	cmp	r0, #0
 8007752:	d1fa      	bne.n	800774a <MIOS32_AIN_Init+0x182>
  ADC_StartCalibration(ADC2);
 8007754:	4830      	ldr	r0, [pc, #192]	; (8007818 <MIOS32_AIN_Init+0x250>)
 8007756:	f001 fa6d 	bl	8008c34 <ADC_StartCalibration>
  while( ADC_GetCalibrationStatus(ADC2) );
 800775a:	482f      	ldr	r0, [pc, #188]	; (8007818 <MIOS32_AIN_Init+0x250>)
 800775c:	f001 fa6f 	bl	8008c3e <ADC_GetCalibrationStatus>
 8007760:	2800      	cmp	r0, #0
 8007762:	d1fa      	bne.n	800775a <MIOS32_AIN_Init+0x192>
 8007764:	4604      	mov	r4, r0


  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8007766:	3001      	adds	r0, #1
 8007768:	4601      	mov	r1, r0

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 800776a:	ad03      	add	r5, sp, #12
  ADC_StartCalibration(ADC2);
  while( ADC_GetCalibrationStatus(ADC2) );


  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 800776c:	f001 fe26 	bl	80093bc <RCC_AHBPeriphClockCmd>

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8007770:	4628      	mov	r0, r5
 8007772:	f001 fc7a 	bl	800906a <DMA_StructInit>
  DMA_DeInit(DMA1_Channel1);
 8007776:	482b      	ldr	r0, [pc, #172]	; (8007824 <MIOS32_AIN_Init+0x25c>)
 8007778:	f001 fbe2 	bl	8008f40 <DMA_DeInit>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
 800777c:	4b2a      	ldr	r3, [pc, #168]	; (8007828 <MIOS32_AIN_Init+0x260>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 800777e:	4829      	ldr	r0, [pc, #164]	; (8007824 <MIOS32_AIN_Init+0x25c>)

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
 8007780:	9303      	str	r3, [sp, #12]
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 8007782:	4b27      	ldr	r3, [pc, #156]	; (8007820 <MIOS32_AIN_Init+0x258>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 8007784:	4629      	mov	r1, r5
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 8007786:	781b      	ldrb	r3, [r3, #0]
  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
 8007788:	9604      	str	r6, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 800778a:	085b      	lsrs	r3, r3, #1
 800778c:	9306      	str	r3, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800778e:	2380      	movs	r3, #128	; 0x80
 8007790:	9308      	str	r3, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
 8007792:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 8007796:	9309      	str	r3, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
 8007798:	f503 63c0 	add.w	r3, r3, #1536	; 0x600
 800779c:	930a      	str	r3, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 800779e:	f5a3 63fc 	sub.w	r3, r3, #2016	; 0x7e0
 80077a2:	930b      	str	r3, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 80077a4:	f503 53ff 	add.w	r3, r3, #8160	; 0x1fe0
 80077a8:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 80077aa:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 80077ac:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 80077ae:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 80077b0:	f001 fc30 	bl	8009014 <DMA_Init>
  DMA_Cmd(DMA1_Channel1, ENABLE);
 80077b4:	481b      	ldr	r0, [pc, #108]	; (8007824 <MIOS32_AIN_Init+0x25c>)
 80077b6:	2101      	movs	r1, #1
 80077b8:	f001 fc64 	bl	8009084 <DMA_Cmd>

  // trigger interrupt when all conversion values have been fetched
  DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);
 80077bc:	2201      	movs	r2, #1
 80077be:	4819      	ldr	r0, [pc, #100]	; (8007824 <MIOS32_AIN_Init+0x25c>)
 80077c0:	2102      	movs	r1, #2
 80077c2:	f001 fc69 	bl	8009098 <DMA_ITConfig>

  // Configure and enable DMA interrupt
  MIOS32_IRQ_Install(DMA1_Channel1_IRQn, MIOS32_IRQ_AIN_DMA_PRIORITY);
 80077c6:	2105      	movs	r1, #5
 80077c8:	200b      	movs	r0, #11
 80077ca:	f7fe ffb3 	bl	8006734 <MIOS32_IRQ_Install>

  // finally start initial conversion
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 80077ce:	4811      	ldr	r0, [pc, #68]	; (8007814 <MIOS32_AIN_Init+0x24c>)
 80077d0:	2101      	movs	r1, #1
 80077d2:	f001 fa38 	bl	8008c46 <ADC_SoftwareStartConvCmd>

  return 0;
 80077d6:	4620      	mov	r0, r4
 80077d8:	e001      	b.n	80077de <MIOS32_AIN_Init+0x216>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80077da:	f04f 30ff 	mov.w	r0, #4294967295
  // finally start initial conversion
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0;
#endif
}
 80077de:	b015      	add	sp, #84	; 0x54
 80077e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80077e2:	bf00      	nop
 80077e4:	20000894 	.word	0x20000894
 80077e8:	2000084c 	.word	0x2000084c
 80077ec:	2000084a 	.word	0x2000084a
 80077f0:	20000828 	.word	0x20000828
 80077f4:	20000870 	.word	0x20000870
 80077f8:	2000089c 	.word	0x2000089c
 80077fc:	2000086c 	.word	0x2000086c
 8007800:	20000848 	.word	0x20000848
 8007804:	40011000 	.word	0x40011000
 8007808:	40010800 	.word	0x40010800
 800780c:	40010c00 	.word	0x40010c00
 8007810:	20000890 	.word	0x20000890
 8007814:	40012400 	.word	0x40012400
 8007818:	40012800 	.word	0x40012800
 800781c:	0800b100 	.word	0x0800b100
 8007820:	20000898 	.word	0x20000898
 8007824:	40020008 	.word	0x40020008
 8007828:	4001244c 	.word	0x4001244c

0800782c <MIOS32_AIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Handler(void *_callback)
{
 800782c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800782e:	4607      	mov	r7, r0
  // no callback function?
  if( _callback == NULL )
    return -1;
 8007830:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Handler(void *_callback)
{
  // no callback function?
  if( _callback == NULL )
 8007834:	2f00      	cmp	r7, #0
 8007836:	d03e      	beq.n	80078b6 <MIOS32_AIN_Handler+0x8a>
#else
  int chn, mux;
  void (*callback)(s32 pin, u16 value) = _callback;

  // exit if scan hasn't been finished yet
  if( mux_ctr || oversampling_ctr )
 8007838:	4b1f      	ldr	r3, [pc, #124]	; (80078b8 <MIOS32_AIN_Handler+0x8c>)
 800783a:	7818      	ldrb	r0, [r3, #0]
 800783c:	2800      	cmp	r0, #0
 800783e:	d139      	bne.n	80078b4 <MIOS32_AIN_Handler+0x88>
 8007840:	4b1e      	ldr	r3, [pc, #120]	; (80078bc <MIOS32_AIN_Handler+0x90>)
 8007842:	781c      	ldrb	r4, [r3, #0]
 8007844:	2c00      	cmp	r4, #0
 8007846:	d136      	bne.n	80078b6 <MIOS32_AIN_Handler+0x8a>
    return 0;

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
 8007848:	4e1d      	ldr	r6, [pc, #116]	; (80078c0 <MIOS32_AIN_Handler+0x94>)
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
 800784a:	4d1e      	ldr	r5, [pc, #120]	; (80078c4 <MIOS32_AIN_Handler+0x98>)
 800784c:	e025      	b.n	800789a <MIOS32_AIN_Handler+0x6e>

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
 800784e:	2001      	movs	r0, #1
 8007850:	f004 021f 	and.w	r2, r4, #31
 8007854:	fa10 f202 	lsls.w	r2, r0, r2
      if( ain_pin_changed[pin >> 5] & mask ) {
 8007858:	0963      	lsrs	r3, r4, #5
 800785a:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 800785e:	420a      	tst	r2, r1
 8007860:	d01a      	beq.n	8007898 <MIOS32_AIN_Handler+0x6c>
	MIOS32_IRQ_Disable();
 8007862:	9201      	str	r2, [sp, #4]
 8007864:	9300      	str	r3, [sp, #0]
 8007866:	f7fe ff3d 	bl	80066e4 <MIOS32_IRQ_Disable>
	u32 pin_value = ain_pin_values[pin];
	ain_pin_changed[pin>>5] &= ~mask;
 800786a:	9b00      	ldr	r3, [sp, #0]
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
 800786c:	4816      	ldr	r0, [pc, #88]	; (80078c8 <MIOS32_AIN_Handler+0x9c>)
	ain_pin_changed[pin>>5] &= ~mask;
 800786e:	9a01      	ldr	r2, [sp, #4]
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
 8007870:	f830 1014 	ldrh.w	r1, [r0, r4, lsl #1]
	ain_pin_changed[pin>>5] &= ~mask;
 8007874:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
	MIOS32_IRQ_Enable();
 8007878:	9101      	str	r1, [sp, #4]
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
	ain_pin_changed[pin>>5] &= ~mask;
 800787a:	ea20 0202 	bic.w	r2, r0, r2
 800787e:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
	MIOS32_IRQ_Enable();
 8007882:	f7fe ff45 	bl	8006710 <MIOS32_IRQ_Enable>

	// call application hook
	// note that due to dual conversion approach, we have to convert the pin number
	// if an uneven number number of channels selected
	u8 app_pin = (num_channels & 1) ? (pin>>1) : pin;
 8007886:	7833      	ldrb	r3, [r6, #0]
 8007888:	9901      	ldr	r1, [sp, #4]
 800788a:	f013 0f01 	tst.w	r3, #1
 800788e:	bf14      	ite	ne
 8007890:	f3c4 0047 	ubfxne	r0, r4, #1, #8
 8007894:	b2e0      	uxtbeq	r0, r4
	callback(app_pin, pin_value);
 8007896:	47b8      	blx	r7
  if( mux_ctr || oversampling_ctr )
    return 0;

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
 8007898:	3401      	adds	r4, #1
 800789a:	7833      	ldrb	r3, [r6, #0]
 800789c:	429c      	cmp	r4, r3
 800789e:	dbd6      	blt.n	800784e <MIOS32_AIN_Handler+0x22>
    }
  }

  // execute optional "service prepare" callback function
  // skip scan if it returns a value >= 1
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
 80078a0:	4b0a      	ldr	r3, [pc, #40]	; (80078cc <MIOS32_AIN_Handler+0xa0>)
 80078a2:	681b      	ldr	r3, [r3, #0]
 80078a4:	b113      	cbz	r3, 80078ac <MIOS32_AIN_Handler+0x80>
 80078a6:	4798      	blx	r3
 80078a8:	2800      	cmp	r0, #0
 80078aa:	dc03      	bgt.n	80078b4 <MIOS32_AIN_Handler+0x88>
    return 0; // scan skipped - no error

  // start next scan
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 80078ac:	4808      	ldr	r0, [pc, #32]	; (80078d0 <MIOS32_AIN_Handler+0xa4>)
 80078ae:	2101      	movs	r1, #1
 80078b0:	f001 f9c9 	bl	8008c46 <ADC_SoftwareStartConvCmd>
  }

  // execute optional "service prepare" callback function
  // skip scan if it returns a value >= 1
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
    return 0; // scan skipped - no error
 80078b4:	2000      	movs	r0, #0
  // start next scan
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0; // no error
#endif
}
 80078b6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80078b8:	2000086c 	.word	0x2000086c
 80078bc:	20000848 	.word	0x20000848
 80078c0:	20000890 	.word	0x20000890
 80078c4:	2000089c 	.word	0x2000089c
 80078c8:	20000828 	.word	0x20000828
 80078cc:	20000894 	.word	0x20000894
 80078d0:	40012400 	.word	0x40012400

080078d4 <DMA1_Channel1_IRQHandler>:
//! DMA channel interrupt is triggered when all ADC channels have been converted
//! \note shouldn't be called directly from application
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_AIN_CHANNEL_MASK
void DMA1_Channel1_IRQHandler(void)
{
 80078d4:	b5f0      	push	{r4, r5, r6, r7, lr}
  int i;
  u16 *src_ptr, *dst_ptr;

  // clear the pending flag(s)
  DMA_ClearFlag(DMA1_FLAG_TC1 | DMA1_FLAG_TE1 | DMA1_FLAG_HT1 | DMA1_FLAG_GL1);
 80078d6:	200f      	movs	r0, #15
//! DMA channel interrupt is triggered when all ADC channels have been converted
//! \note shouldn't be called directly from application
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_AIN_CHANNEL_MASK
void DMA1_Channel1_IRQHandler(void)
{
 80078d8:	b089      	sub	sp, #36	; 0x24
  int i;
  u16 *src_ptr, *dst_ptr;

  // clear the pending flag(s)
  DMA_ClearFlag(DMA1_FLAG_TC1 | DMA1_FLAG_TE1 | DMA1_FLAG_HT1 | DMA1_FLAG_GL1);
 80078da:	f001 fbe7 	bl	80090ac <DMA_ClearFlag>
    oversampling_ctr = 0;
#endif

  // whenever we reached the last sample:
  // copy conversion values to ain_pin_values if difference > deadband
  if( oversampling_ctr == 0 ) {
 80078de:	4b2f      	ldr	r3, [pc, #188]	; (800799c <DMA1_Channel1_IRQHandler+0xc8>)
 80078e0:	7818      	ldrb	r0, [r3, #0]
 80078e2:	2800      	cmp	r0, #0
 80078e4:	d14d      	bne.n	8007982 <DMA1_Channel1_IRQHandler+0xae>
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80078e6:	4b2e      	ldr	r3, [pc, #184]	; (80079a0 <DMA1_Channel1_IRQHandler+0xcc>)
 80078e8:	4a2e      	ldr	r2, [pc, #184]	; (80079a4 <DMA1_Channel1_IRQHandler+0xd0>)
 80078ea:	781b      	ldrb	r3, [r3, #0]
 80078ec:	7812      	ldrb	r2, [r2, #0]

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80078ee:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 80079a8 <DMA1_Channel1_IRQHandler+0xd4>
  if( oversampling_ctr == 0 ) {
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80078f2:	435a      	muls	r2, r3

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80078f4:	f89c c000 	ldrb.w	ip, [ip]
 80078f8:	4c2c      	ldr	r4, [pc, #176]	; (80079ac <DMA1_Channel1_IRQHandler+0xd8>)
  if( oversampling_ctr == 0 ) {
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80078fa:	b2d2      	uxtb	r2, r2

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80078fc:	f8cd c01c 	str.w	ip, [sp, #28]
 8007900:	9405      	str	r4, [sp, #20]
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    src_ptr = (u16 *)adc_conversion_values_sum;
#else
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 8007902:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 80079b0 <DMA1_Channel1_IRQHandler+0xdc>

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 8007906:	4c2b      	ldr	r4, [pc, #172]	; (80079b4 <DMA1_Channel1_IRQHandler+0xe0>)
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
    u8 bit_offset = pin_offset & 0x1f;
 8007908:	f002 031f 	and.w	r3, r2, #31
    u8 word_offset = pin_offset >> 5;
 800790c:	0951      	lsrs	r1, r2, #5
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    src_ptr = (u16 *)adc_conversion_values_sum;
#else
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 800790e:	0052      	lsls	r2, r2, #1
 8007910:	4494      	add	ip, r2
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
#endif
	*dst_ptr = *src_ptr;
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 8007912:	4d29      	ldr	r5, [pc, #164]	; (80079b8 <DMA1_Channel1_IRQHandler+0xe4>)
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 8007914:	18a2      	adds	r2, r4, r2
#endif

    for(i=0; i<num_channels; ++i) {
 8007916:	e031      	b.n	800797c <DMA1_Channel1_IRQHandler+0xa8>
#if MIOS32_AIN_DEADBAND_IDLE
      u16 deadband = *idle_ctr_ptr ? (MIOS32_AIN_DEADBAND) : (MIOS32_AIN_DEADBAND_IDLE);
 8007918:	f832 4b02 	ldrh.w	r4, [r2], #2
 800791c:	2c00      	cmp	r4, #0
 800791e:	bf0c      	ite	eq
 8007920:	267f      	moveq	r6, #127	; 0x7f
 8007922:	261f      	movne	r6, #31
 8007924:	9606      	str	r6, [sp, #24]

      // takeover new value if difference to old value is outside the deadband
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
 8007926:	9e05      	ldr	r6, [sp, #20]
 8007928:	f836 7f02 	ldrh.w	r7, [r6, #2]!
 800792c:	9701      	str	r7, [sp, #4]
 800792e:	9605      	str	r6, [sp, #20]
 8007930:	f83c 7b02 	ldrh.w	r7, [ip], #2
 8007934:	9e01      	ldr	r6, [sp, #4]
 8007936:	1bf7      	subs	r7, r6, r7
 8007938:	ea87 76e7 	eor.w	r6, r7, r7, asr #31
 800793c:	eba6 76e7 	sub.w	r6, r6, r7, asr #31
 8007940:	9f06      	ldr	r7, [sp, #24]
 8007942:	42be      	cmp	r6, r7
 8007944:	dd0e      	ble.n	8007964 <DMA1_Channel1_IRQHandler+0x90>
#endif
	*dst_ptr = *src_ptr;
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 8007946:	2701      	movs	r7, #1
 8007948:	fa17 f603 	lsls.w	r6, r7, r3
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
#endif
	*dst_ptr = *src_ptr;
 800794c:	9c01      	ldr	r4, [sp, #4]
 800794e:	f82c 4c02 	strh.w	r4, [ip, #-2]
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 8007952:	f855 4021 	ldr.w	r4, [r5, r1, lsl #2]
 8007956:	ea46 0404 	orr.w	r4, r6, r4
 800795a:	f845 4021 	str.w	r4, [r5, r1, lsl #2]
#if MIOS32_AIN_DEADBAND_IDLE
	*idle_ctr_ptr = MIOS32_AIN_IDLE_CTR;
 800795e:	f640 34b8 	movw	r4, #3000	; 0xbb8
 8007962:	e001      	b.n	8007968 <DMA1_Channel1_IRQHandler+0x94>
#endif
      } else {
#if MIOS32_AIN_DEADBAND_IDLE
	if( *idle_ctr_ptr )
 8007964:	b114      	cbz	r4, 800796c <DMA1_Channel1_IRQHandler+0x98>
	  *idle_ctr_ptr -= 1;
 8007966:	3c01      	subs	r4, #1
 8007968:	f822 4c02 	strh.w	r4, [r2, #-2]
#if MIOS32_AIN_DEADBAND_IDLE
      ++idle_ctr_ptr;
#endif

      // switch to next bit/word offset for "changed" flags
      if( ++bit_offset >= 32 ) {
 800796c:	3301      	adds	r3, #1
 800796e:	b2db      	uxtb	r3, r3
 8007970:	2b20      	cmp	r3, #32
 8007972:	d102      	bne.n	800797a <DMA1_Channel1_IRQHandler+0xa6>
	bit_offset = 0;
	++word_offset;
 8007974:	3101      	adds	r1, #1
 8007976:	b2c9      	uxtb	r1, r1
      ++idle_ctr_ptr;
#endif

      // switch to next bit/word offset for "changed" flags
      if( ++bit_offset >= 32 ) {
	bit_offset = 0;
 8007978:	2300      	movs	r3, #0

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 800797a:	3001      	adds	r0, #1
 800797c:	9e07      	ldr	r6, [sp, #28]
 800797e:	42b0      	cmp	r0, r6
 8007980:	dbca      	blt.n	8007918 <DMA1_Channel1_IRQHandler+0x44>
    // starting conversion of new selected channels
  }
#endif

  // request next conversion as long as oversampling/mux counter haven't reached the end
  if( mux_ctr || oversampling_ctr )
 8007982:	4b07      	ldr	r3, [pc, #28]	; (80079a0 <DMA1_Channel1_IRQHandler+0xcc>)
 8007984:	781b      	ldrb	r3, [r3, #0]
 8007986:	b913      	cbnz	r3, 800798e <DMA1_Channel1_IRQHandler+0xba>
 8007988:	4b04      	ldr	r3, [pc, #16]	; (800799c <DMA1_Channel1_IRQHandler+0xc8>)
 800798a:	781b      	ldrb	r3, [r3, #0]
 800798c:	b11b      	cbz	r3, 8007996 <DMA1_Channel1_IRQHandler+0xc2>
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 800798e:	480b      	ldr	r0, [pc, #44]	; (80079bc <DMA1_Channel1_IRQHandler+0xe8>)
 8007990:	2101      	movs	r1, #1
 8007992:	f001 f958 	bl	8008c46 <ADC_SoftwareStartConvCmd>
}
 8007996:	b009      	add	sp, #36	; 0x24
 8007998:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800799a:	bf00      	nop
 800799c:	20000848 	.word	0x20000848
 80079a0:	2000086c 	.word	0x2000086c
 80079a4:	20000898 	.word	0x20000898
 80079a8:	20000890 	.word	0x20000890
 80079ac:	2000084a 	.word	0x2000084a
 80079b0:	20000828 	.word	0x20000828
 80079b4:	20000870 	.word	0x20000870
 80079b8:	2000089c 	.word	0x2000089c
 80079bc:	40012400 	.word	0x40012400

080079c0 <MIOS32_USB_CB_SetDeviceAddress>:
}

// update the device state to addressed
static void MIOS32_USB_CB_SetDeviceAddress (void)
{
  bDeviceState = ADDRESSED;
 80079c0:	4b01      	ldr	r3, [pc, #4]	; (80079c8 <MIOS32_USB_CB_SetDeviceAddress+0x8>)
 80079c2:	2204      	movs	r2, #4
 80079c4:	601a      	str	r2, [r3, #0]
}
 80079c6:	4770      	bx	lr
 80079c8:	200008a0 	.word	0x200008a0

080079cc <MIOS32_USB_CB_Status_In>:
static void MIOS32_USB_CB_Status_In(void)
{
#ifdef MIOS32_USE_USB_COM
  MIOS32_USB_COM_CB_StatusIn();
#endif
}
 80079cc:	4770      	bx	lr

080079ce <MIOS32_USB_CB_Status_Out>:

// status OUT routine
static void MIOS32_USB_CB_Status_Out(void)
{
}
 80079ce:	4770      	bx	lr

080079d0 <MIOS32_USB_CB_Data_Setup>:
  RESULT res;
  if( (res=MIOS32_USB_COM_CB_Data_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif
  return USB_UNSUPPORT;
}
 80079d0:	2002      	movs	r0, #2
 80079d2:	4770      	bx	lr

080079d4 <MIOS32_USB_CB_NoData_Setup>:
  if( (res=MIOS32_USB_COM_CB_NoData_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif

  return USB_UNSUPPORT;
}
 80079d4:	2002      	movs	r0, #2
 80079d6:	4770      	bx	lr

080079d8 <MIOS32_USB_CB_Get_Interface_Setting>:
}

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
 80079d8:	b921      	cbnz	r1, 80079e4 <MIOS32_USB_CB_Get_Interface_Setting+0xc>
    return USB_UNSUPPORT;
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
 80079da:	2801      	cmp	r0, #1
 80079dc:	bf8c      	ite	hi
 80079de:	2002      	movhi	r0, #2
 80079e0:	2000      	movls	r0, #0
 80079e2:	e000      	b.n	80079e6 <MIOS32_USB_CB_Get_Interface_Setting+0xe>

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
    return USB_UNSUPPORT;
 80079e4:	2002      	movs	r0, #2
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
  }

  return USB_SUCCESS;
}
 80079e6:	4770      	bx	lr

080079e8 <MIOS32_USB_CB_SetConfiguration>:
  bDeviceState = ATTACHED;
}

// update the device state to configured.
static void MIOS32_USB_CB_SetConfiguration(void)
{
 80079e8:	b508      	push	{r3, lr}
  if (pInformation->Current_Configuration != 0) {
 80079ea:	4b05      	ldr	r3, [pc, #20]	; (8007a00 <MIOS32_USB_CB_SetConfiguration+0x18>)
 80079ec:	681b      	ldr	r3, [r3, #0]
 80079ee:	7a9b      	ldrb	r3, [r3, #10]
 80079f0:	b12b      	cbz	r3, 80079fe <MIOS32_USB_CB_SetConfiguration+0x16>
#ifndef MIOS32_DONT_USE_USB_MIDI
    // propagate connection state to USB MIDI driver
    MIOS32_USB_MIDI_ChangeConnectionState(1); // connected
 80079f2:	2001      	movs	r0, #1
 80079f4:	f000 fa92 	bl	8007f1c <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
    // propagate connection state to USB COM driver
    MIOS32_USB_COM_ChangeConnectionState(1); // connected
#endif

    bDeviceState = CONFIGURED;
 80079f8:	4b02      	ldr	r3, [pc, #8]	; (8007a04 <MIOS32_USB_CB_SetConfiguration+0x1c>)
 80079fa:	2205      	movs	r2, #5
 80079fc:	601a      	str	r2, [r3, #0]
  }
}
 80079fe:	bd08      	pop	{r3, pc}
 8007a00:	2000379c 	.word	0x2000379c
 8007a04:	200008a0 	.word	0x200008a0

08007a08 <MIOS32_USB_CB_GetStringDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 8007a08:	b570      	push	{r4, r5, r6, lr}
 8007a0a:	b0c4      	sub	sp, #272	; 0x110
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 8007a0c:	493f      	ldr	r1, [pc, #252]	; (8007b0c <MIOS32_USB_CB_GetStringDescriptor+0x104>)
 8007a0e:	220c      	movs	r2, #12
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 8007a10:	4604      	mov	r4, r0
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 8007a12:	a83d      	add	r0, sp, #244	; 0xf4
 8007a14:	f002 fd86 	bl	800a524 <memcpy>
  const u8 product_str[] = MIOS32_USB_PRODUCT_STR;
 8007a18:	a842      	add	r0, sp, #264	; 0x108
 8007a1a:	493d      	ldr	r1, [pc, #244]	; (8007b10 <MIOS32_USB_CB_GetStringDescriptor+0x108>)
 8007a1c:	2207      	movs	r2, #7
 8007a1e:	f002 fd81 	bl	800a524 <memcpy>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 8007a22:	4b3c      	ldr	r3, [pc, #240]	; (8007b14 <MIOS32_USB_CB_GetStringDescriptor+0x10c>)
 8007a24:	681b      	ldr	r3, [r3, #0]
 8007a26:	78db      	ldrb	r3, [r3, #3]
 8007a28:	2b03      	cmp	r3, #3
 8007a2a:	d86c      	bhi.n	8007b06 <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 8007a2c:	e8df f003 	tbb	[pc, r3]
 8007a30:	40020a12 	.word	0x40020a12
 8007a34:	a941      	add	r1, sp, #260	; 0x104
 8007a36:	3103      	adds	r1, #3
 8007a38:	f10d 0206 	add.w	r2, sp, #6
 8007a3c:	2302      	movs	r3, #2

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 8007a3e:	f04f 0c00 	mov.w	ip, #0
 8007a42:	e027      	b.n	8007a94 <MIOS32_USB_CB_GetStringDescriptor+0x8c>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 8007a44:	f10d 01f3 	add.w	r1, sp, #243	; 0xf3
 8007a48:	f10d 0206 	add.w	r2, sp, #6
 8007a4c:	2302      	movs	r3, #2

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 8007a4e:	f04f 0c00 	mov.w	ip, #0
 8007a52:	e00b      	b.n	8007a6c <MIOS32_USB_CB_GetStringDescriptor+0x64>
  int i;

  switch( pInformation->USBwValue0 ) {
    case 0: // Language
      // buffer[0] and [1] initialized below
      buffer[2] = 0x09;        // CharSet
 8007a54:	aa01      	add	r2, sp, #4
 8007a56:	2309      	movs	r3, #9
 8007a58:	7093      	strb	r3, [r2, #2]
      buffer[3] = 0x04;        // U.S.
 8007a5a:	2304      	movs	r3, #4
 8007a5c:	70d3      	strb	r3, [r2, #3]
      len = 4;
      break;
 8007a5e:	e046      	b.n	8007aee <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 8007a60:	3302      	adds	r3, #2
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
 8007a62:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 8007a66:	f802 cc01 	strb.w	ip, [r2, #-1]
 8007a6a:	b29b      	uxth	r3, r3
      len = 4;
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
 8007a6c:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007a70:	3202      	adds	r2, #2
 8007a72:	1e05      	subs	r5, r0, #0
 8007a74:	bf18      	it	ne
 8007a76:	2501      	movne	r5, #1
 8007a78:	2bc7      	cmp	r3, #199	; 0xc7
 8007a7a:	bf8c      	ite	hi
 8007a7c:	2500      	movhi	r5, #0
 8007a7e:	f005 0501 	andls.w	r5, r5, #1
 8007a82:	2d00      	cmp	r5, #0
 8007a84:	d1ec      	bne.n	8007a60 <MIOS32_USB_CB_GetStringDescriptor+0x58>
 8007a86:	e032      	b.n	8007aee <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 8007a88:	3302      	adds	r3, #2
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
 8007a8a:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 8007a8e:	f802 cc01 	strb.w	ip, [r2, #-1]
 8007a92:	b29b      	uxth	r3, r3
      }
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
 8007a94:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007a98:	3202      	adds	r2, #2
 8007a9a:	1e05      	subs	r5, r0, #0
 8007a9c:	bf18      	it	ne
 8007a9e:	2501      	movne	r5, #1
 8007aa0:	2bc7      	cmp	r3, #199	; 0xc7
 8007aa2:	bf8c      	ite	hi
 8007aa4:	2500      	movhi	r5, #0
 8007aa6:	f005 0501 	andls.w	r5, r5, #1
 8007aaa:	2d00      	cmp	r5, #0
 8007aac:	d1ec      	bne.n	8007a88 <MIOS32_USB_CB_GetStringDescriptor+0x80>
 8007aae:	e01e      	b.n	8007aee <MIOS32_USB_CB_GetStringDescriptor+0xe6>
      }
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
 8007ab0:	ad33      	add	r5, sp, #204	; 0xcc
 8007ab2:	4628      	mov	r0, r5
 8007ab4:	f7fe fd0a 	bl	80064cc <MIOS32_SYS_SerialNumberGet>
 8007ab8:	2800      	cmp	r0, #0
 8007aba:	db24      	blt.n	8007b06 <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 8007abc:	3d01      	subs	r5, #1
 8007abe:	f10d 0206 	add.w	r2, sp, #6
 8007ac2:	2302      	movs	r3, #2
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
 8007ac4:	2000      	movs	r0, #0
 8007ac6:	e005      	b.n	8007ad4 <MIOS32_USB_CB_GetStringDescriptor+0xcc>
 8007ac8:	3302      	adds	r3, #2

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
 8007aca:	f802 1c02 	strb.w	r1, [r2, #-2]
	    buffer[len++] = 0;
 8007ace:	f802 0c01 	strb.w	r0, [r2, #-1]
 8007ad2:	b29b      	uxth	r3, r3
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
 8007ad4:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007ad8:	3202      	adds	r2, #2
 8007ada:	1e0e      	subs	r6, r1, #0
 8007adc:	bf18      	it	ne
 8007ade:	2601      	movne	r6, #1
 8007ae0:	2bc7      	cmp	r3, #199	; 0xc7
 8007ae2:	bf8c      	ite	hi
 8007ae4:	2600      	movhi	r6, #0
 8007ae6:	f006 0601 	andls.w	r6, r6, #1
 8007aea:	2e00      	cmp	r6, #0
 8007aec:	d1ec      	bne.n	8007ac8 <MIOS32_USB_CB_GetStringDescriptor+0xc0>
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 8007aee:	aa01      	add	r2, sp, #4
  buffer[1] = DSCR_STRING; // Descriptor Type
 8007af0:	2103      	movs	r1, #3
 8007af2:	7051      	strb	r1, [r2, #1]
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 8007af4:	7013      	strb	r3, [r2, #0]
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
 8007af6:	4620      	mov	r0, r4
 8007af8:	a940      	add	r1, sp, #256	; 0x100
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
 8007afa:	9240      	str	r2, [sp, #256]	; 0x100
 8007afc:	f8ad 3104 	strh.w	r3, [sp, #260]	; 0x104
  return Standard_GetDescriptorData(Length, &desc);
 8007b00:	f001 ff6e 	bl	80099e0 <Standard_GetDescriptorData>
 8007b04:	e000      	b.n	8007b08 <MIOS32_USB_CB_GetStringDescriptor+0x100>
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
	  }
	} else
	  return NULL;
 8007b06:	2000      	movs	r0, #0

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
}
 8007b08:	b044      	add	sp, #272	; 0x110
 8007b0a:	bd70      	pop	{r4, r5, r6, pc}
 8007b0c:	0800b178 	.word	0x0800b178
 8007b10:	0800afb7 	.word	0x0800afb7
 8007b14:	2000379c 	.word	0x2000379c

08007b18 <MIOS32_USB_CB_GetConfigDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 8007b18:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 8007b1a:	4905      	ldr	r1, [pc, #20]	; (8007b30 <MIOS32_USB_CB_GetConfigDescriptor+0x18>)
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 8007b1c:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 8007b1e:	466b      	mov	r3, sp
 8007b20:	c903      	ldmia	r1!, {r0, r1}
 8007b22:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 8007b26:	4610      	mov	r0, r2
 8007b28:	4669      	mov	r1, sp
 8007b2a:	f001 ff59 	bl	80099e0 <Standard_GetDescriptorData>
}
 8007b2e:	bd0e      	pop	{r1, r2, r3, pc}
 8007b30:	0800b18c 	.word	0x0800b18c

08007b34 <MIOS32_USB_CB_GetDeviceDescriptor>:
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 8007b34:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 8007b36:	4905      	ldr	r1, [pc, #20]	; (8007b4c <MIOS32_USB_CB_GetDeviceDescriptor+0x18>)
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 8007b38:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 8007b3a:	466b      	mov	r3, sp
 8007b3c:	c903      	ldmia	r1!, {r0, r1}
 8007b3e:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 8007b42:	4610      	mov	r0, r2
 8007b44:	4669      	mov	r1, sp
 8007b46:	f001 ff4b 	bl	80099e0 <Standard_GetDescriptorData>
}
 8007b4a:	bd0e      	pop	{r1, r2, r3, pc}
 8007b4c:	0800b184 	.word	0x0800b184

08007b50 <MIOS32_USB_CB_Reset>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
 8007b50:	b538      	push	{r3, r4, r5, lr}
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 8007b52:	4b27      	ldr	r3, [pc, #156]	; (8007bf0 <MIOS32_USB_CB_Reset+0xa0>)
 8007b54:	2400      	movs	r4, #0
 8007b56:	681b      	ldr	r3, [r3, #0]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007b58:	2580      	movs	r5, #128	; 0x80

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 8007b5a:	729c      	strb	r4, [r3, #10]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007b5c:	725d      	strb	r5, [r3, #9]

  // Set MIOS32 Device with the default Interface
  pInformation->Current_Interface = 0;
 8007b5e:	72dc      	strb	r4, [r3, #11]

#ifdef STM32F10X_CL   
  // EP0 is already configured in DFU_Init() by USB_SIL_Init() function
#else 
  SetBTABLE(MIOS32_USB_BTABLE_ADDRESS);
 8007b60:	4620      	mov	r0, r4
 8007b62:	f002 faab 	bl	800a0bc <SetBTABLE>

  // Initialize Endpoint 0
  SetEPType(ENDP0, EP_CONTROL);
 8007b66:	4620      	mov	r0, r4
 8007b68:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007b6c:	f002 fab0 	bl	800a0d0 <SetEPType>
  SetEPTxStatus(ENDP0, EP_TX_STALL);
 8007b70:	4620      	mov	r0, r4
 8007b72:	2110      	movs	r1, #16
 8007b74:	f002 fac4 	bl	800a100 <SetEPTxStatus>
  SetEPRxAddr(ENDP0, MIOS32_USB_ENDP0_RXADDR);
 8007b78:	4620      	mov	r0, r4
 8007b7a:	2140      	movs	r1, #64	; 0x40
 8007b7c:	f002 fb48 	bl	800a210 <SetEPRxAddr>
  SetEPTxAddr(ENDP0, MIOS32_USB_ENDP0_TXADDR);
 8007b80:	4629      	mov	r1, r5
 8007b82:	4620      	mov	r0, r4
 8007b84:	f002 fb34 	bl	800a1f0 <SetEPTxAddr>
  Clear_Status_Out(ENDP0);
 8007b88:	4620      	mov	r0, r4
 8007b8a:	f002 faf9 	bl	800a180 <Clear_Status_Out>
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 8007b8e:	4b19      	ldr	r3, [pc, #100]	; (8007bf4 <MIOS32_USB_CB_Reset+0xa4>)
 8007b90:	4620      	mov	r0, r4
 8007b92:	681b      	ldr	r3, [r3, #0]
 8007b94:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8007b98:	f002 fb74 	bl	800a284 <SetEPRxCount>
  SetEPRxValid(ENDP0);
 8007b9c:	4620      	mov	r0, r4
 8007b9e:	f002 fadd 	bl	800a15c <SetEPRxValid>
  
  // Init EP1 OUT
  OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
# else
  // Initialize Endpoint 1
  SetEPType(ENDP1, EP_BULK);
 8007ba2:	2001      	movs	r0, #1
 8007ba4:	4621      	mov	r1, r4
 8007ba6:	f002 fa93 	bl	800a0d0 <SetEPType>

  SetEPTxAddr(ENDP1, MIOS32_USB_ENDP1_TXADDR);
 8007baa:	2001      	movs	r0, #1
 8007bac:	21c0      	movs	r1, #192	; 0xc0
 8007bae:	f002 fb1f 	bl	800a1f0 <SetEPTxAddr>
  SetEPTxCount(ENDP1, MIOS32_USB_MIDI_DATA_OUT_SIZE);
 8007bb2:	2001      	movs	r0, #1
 8007bb4:	2140      	movs	r1, #64	; 0x40
 8007bb6:	f002 fb57 	bl	800a268 <SetEPTxCount>
  SetEPTxStatus(ENDP1, EP_TX_NAK);
 8007bba:	2001      	movs	r0, #1
 8007bbc:	2120      	movs	r1, #32
 8007bbe:	f002 fa9f 	bl	800a100 <SetEPTxStatus>

  SetEPRxAddr(ENDP1, MIOS32_USB_ENDP1_RXADDR);
 8007bc2:	2001      	movs	r0, #1
 8007bc4:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007bc8:	f002 fb22 	bl	800a210 <SetEPRxAddr>
  SetEPRxCount(ENDP1, MIOS32_USB_MIDI_DATA_IN_SIZE);
 8007bcc:	2140      	movs	r1, #64	; 0x40
 8007bce:	2001      	movs	r0, #1
 8007bd0:	f002 fb58 	bl	800a284 <SetEPRxCount>
  SetEPRxValid(ENDP1);
 8007bd4:	2001      	movs	r0, #1
 8007bd6:	f002 fac1 	bl	800a15c <SetEPRxValid>
# endif
#endif

  // Set this device to response on default address
#ifndef STM32F10X_CL   
  SetDeviceAddress(0);
 8007bda:	4620      	mov	r0, r4
 8007bdc:	f002 f932 	bl	8009e44 <SetDeviceAddress>
#endif

#ifndef MIOS32_DONT_USE_USB_MIDI
  // propagate connection state to USB MIDI driver
  MIOS32_USB_MIDI_ChangeConnectionState(0); // not connected
 8007be0:	4620      	mov	r0, r4
 8007be2:	f000 f99b 	bl	8007f1c <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
  // propagate connection state to USB COM driver
  MIOS32_USB_COM_ChangeConnectionState(0); // not connected
#endif

  bDeviceState = ATTACHED;
 8007be6:	4b04      	ldr	r3, [pc, #16]	; (8007bf8 <MIOS32_USB_CB_Reset+0xa8>)
 8007be8:	2201      	movs	r2, #1
 8007bea:	601a      	str	r2, [r3, #0]
}
 8007bec:	bd38      	pop	{r3, r4, r5, pc}
 8007bee:	bf00      	nop
 8007bf0:	2000379c 	.word	0x2000379c
 8007bf4:	20003794 	.word	0x20003794
 8007bf8:	200008a0 	.word	0x200008a0

08007bfc <USB_LP_CAN1_RX0_IRQHandler>:
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  u16 wIstr = _GetISTR();
 8007bfc:	4b0d      	ldr	r3, [pc, #52]	; (8007c34 <USB_LP_CAN1_RX0_IRQHandler+0x38>)
  }
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
 8007bfe:	b510      	push	{r4, lr}
  u16 wIstr = _GetISTR();
 8007c00:	681c      	ldr	r4, [r3, #0]
 8007c02:	b2a4      	uxth	r4, r4

  if( wIstr & ISTR_RESET ) {
 8007c04:	f414 6f80 	tst.w	r4, #1024	; 0x400
 8007c08:	d006      	beq.n	8007c18 <USB_LP_CAN1_RX0_IRQHandler+0x1c>
    _SetISTR((u16)CLR_RESET);
 8007c0a:	f64f 32ff 	movw	r2, #64511	; 0xfbff
 8007c0e:	601a      	str	r2, [r3, #0]
    pProperty->Reset();
 8007c10:	4b09      	ldr	r3, [pc, #36]	; (8007c38 <USB_LP_CAN1_RX0_IRQHandler+0x3c>)
 8007c12:	681b      	ldr	r3, [r3, #0]
 8007c14:	685b      	ldr	r3, [r3, #4]
 8007c16:	4798      	blx	r3
  }

  if( wIstr & ISTR_SOF ) {
 8007c18:	f414 7f00 	tst.w	r4, #512	; 0x200
    _SetISTR((u16)CLR_SOF);
 8007c1c:	bf1e      	ittt	ne
 8007c1e:	4b05      	ldrne	r3, [pc, #20]	; (8007c34 <USB_LP_CAN1_RX0_IRQHandler+0x38>)
 8007c20:	f64f 52ff 	movwne	r2, #65023	; 0xfdff
 8007c24:	601a      	strne	r2, [r3, #0]
  }

  if( wIstr & ISTR_CTR ) {
 8007c26:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8007c2a:	d001      	beq.n	8007c30 <USB_LP_CAN1_RX0_IRQHandler+0x34>
    // servicing of the endpoint correct transfer interrupt
    // clear of the CTR flag into the sub
    CTR_LP();
 8007c2c:	f002 f964 	bl	8009ef8 <CTR_LP>
  }
}
 8007c30:	bd10      	pop	{r4, pc}
 8007c32:	bf00      	nop
 8007c34:	40005c44 	.word	0x40005c44
 8007c38:	20003794 	.word	0x20003794

08007c3c <MIOS32_USB_IsInitialized>:
//! This function is used by the bootloader to avoid a reconnection, it isn't
//! relevant for typical applications!
//! \return 1 if USB already initialized, 0 if not initialized
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_IsInitialized(void)
{
 8007c3c:	b508      	push	{r3, lr}
  // we assume that initialisation has been done when B-Session valid flag is set
  __IO USB_OTG_GREGS *GREGS = (USB_OTG_GREGS *)(USB_OTG_FS_BASE_ADDR + USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  return (GREGS->GOTGCTL & (1 << 19));
#else
  // we assume that initialisation has been done when endpoint 0 contains a value
  return GetEPType(ENDP0) ? 1 : 0;
 8007c3e:	2000      	movs	r0, #0
 8007c40:	f002 fa55 	bl	800a0ee <GetEPType>
 8007c44:	3800      	subs	r0, #0
 8007c46:	bf18      	it	ne
 8007c48:	2001      	movne	r0, #1
#endif
}
 8007c4a:	bd08      	pop	{r3, pc}

08007c4c <MIOS32_USB_Init>:
//!   </UL>
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_Init(u32 mode)
{
 8007c4c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007c4e:	4604      	mov	r4, r0
  u32 delay;

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8007c50:	a801      	add	r0, sp, #4
 8007c52:	f000 ff4b 	bl	8008aec <GPIO_StructInit>

  // currently only mode 0..2 supported
  if( mode >= 3 )
 8007c56:	2c02      	cmp	r4, #2
    return -1; // unsupported mode
 8007c58:	bf88      	it	hi
 8007c5a:	f04f 30ff 	movhi.w	r0, #4294967295

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  // currently only mode 0..2 supported
  if( mode >= 3 )
 8007c5e:	d877      	bhi.n	8007d50 <MIOS32_USB_Init+0x104>
    return -1; // unsupported mode

  // clear all USB interrupt requests
#ifdef STM32F10X_CL
#else
  MIOS32_IRQ_Disable();
 8007c60:	f7fe fd40 	bl	80066e4 <MIOS32_IRQ_Disable>
  _SetCNTR(0); // Interrupt Mask
 8007c64:	4b3b      	ldr	r3, [pc, #236]	; (8007d54 <MIOS32_USB_Init+0x108>)
 8007c66:	2200      	movs	r2, #0
 8007c68:	601a      	str	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 8007c6a:	f7fe fd51 	bl	8006710 <MIOS32_IRQ_Enable>
#endif

  // if mode != 2: install MIOS32 hooks
  // a local driver can install it's own hooks and call MIOS32_USB_Init(2) to force re-enumeration
  if( mode != 2 ) {
 8007c6e:	2c02      	cmp	r4, #2
 8007c70:	d013      	beq.n	8007c9a <MIOS32_USB_Init+0x4e>
    pInformation = &My_Device_Info; // Note: usually no need to duplicate this for external drivers
 8007c72:	4a39      	ldr	r2, [pc, #228]	; (8007d58 <MIOS32_USB_Init+0x10c>)
 8007c74:	4b39      	ldr	r3, [pc, #228]	; (8007d5c <MIOS32_USB_Init+0x110>)
 8007c76:	601a      	str	r2, [r3, #0]

    // following hooks/pointers should be replaced by external drivers
    memcpy(&Device_Table, (DEVICE *)&My_Device_Table, sizeof(Device_Table));
 8007c78:	4b39      	ldr	r3, [pc, #228]	; (8007d60 <MIOS32_USB_Init+0x114>)
 8007c7a:	2205      	movs	r2, #5
 8007c7c:	701a      	strb	r2, [r3, #0]
 8007c7e:	2201      	movs	r2, #1
 8007c80:	705a      	strb	r2, [r3, #1]
    pProperty = (DEVICE_PROP *)&My_Device_Property;
 8007c82:	4a38      	ldr	r2, [pc, #224]	; (8007d64 <MIOS32_USB_Init+0x118>)
 8007c84:	4b38      	ldr	r3, [pc, #224]	; (8007d68 <MIOS32_USB_Init+0x11c>)
 8007c86:	601a      	str	r2, [r3, #0]
    pUser_Standard_Requests = (USER_STANDARD_REQUESTS *)&My_User_Standard_Requests;
 8007c88:	4a38      	ldr	r2, [pc, #224]	; (8007d6c <MIOS32_USB_Init+0x120>)
 8007c8a:	4b39      	ldr	r3, [pc, #228]	; (8007d70 <MIOS32_USB_Init+0x124>)
 8007c8c:	601a      	str	r2, [r3, #0]

#ifndef MIOS32_DONT_USE_USB_MIDI
    pEpInt_IN[0]  = MIOS32_USB_MIDI_EP1_IN_Callback;  // IN  EP1
 8007c8e:	4a39      	ldr	r2, [pc, #228]	; (8007d74 <MIOS32_USB_Init+0x128>)
 8007c90:	4b39      	ldr	r3, [pc, #228]	; (8007d78 <MIOS32_USB_Init+0x12c>)
 8007c92:	601a      	str	r2, [r3, #0]
    pEpInt_OUT[0] = MIOS32_USB_MIDI_EP1_OUT_Callback; // OUT EP1
 8007c94:	4a39      	ldr	r2, [pc, #228]	; (8007d7c <MIOS32_USB_Init+0x130>)
 8007c96:	4b3a      	ldr	r3, [pc, #232]	; (8007d80 <MIOS32_USB_Init+0x134>)
 8007c98:	601a      	str	r2, [r3, #0]
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 8007c9a:	4d30      	ldr	r5, [pc, #192]	; (8007d5c <MIOS32_USB_Init+0x110>)
#endif
  }

  // change connection state to disconnected
#ifndef MIOS32_DONT_USE_USB_MIDI
  MIOS32_USB_MIDI_ChangeConnectionState(0);
 8007c9c:	2000      	movs	r0, #0
 8007c9e:	f000 f93d 	bl	8007f1c <MIOS32_USB_MIDI_ChangeConnectionState>
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 8007ca2:	682b      	ldr	r3, [r5, #0]
 8007ca4:	2202      	movs	r2, #2
 8007ca6:	721a      	strb	r2, [r3, #8]
  pInformation->Current_Configuration = 0;
 8007ca8:	2200      	movs	r2, #0
 8007caa:	729a      	strb	r2, [r3, #10]

  // if mode == 0: don't initialize USB if not required (important for BSL)
  if( mode == 0 && MIOS32_USB_IsInitialized() ) {
 8007cac:	b99c      	cbnz	r4, 8007cd6 <MIOS32_USB_Init+0x8a>
 8007cae:	f7ff ffc5 	bl	8007c3c <MIOS32_USB_IsInitialized>
 8007cb2:	b180      	cbz	r0, 8007cd6 <MIOS32_USB_Init+0x8a>
    // Init EP1 OUT again
    OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
#else
#ifndef MIOS32_DONT_USE_USB_MIDI
    // release ENDP1 Rx/Tx
    SetEPTxStatus(ENDP1, EP_TX_NAK);
 8007cb4:	2001      	movs	r0, #1
 8007cb6:	2120      	movs	r1, #32
 8007cb8:	f002 fa22 	bl	800a100 <SetEPTxStatus>
    SetEPRxValid(ENDP1);
 8007cbc:	2001      	movs	r0, #1
 8007cbe:	f002 fa4d 	bl	800a15c <SetEPRxValid>
#endif
#endif

    pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007cc2:	682b      	ldr	r3, [r5, #0]
 8007cc4:	2280      	movs	r2, #128	; 0x80
 8007cc6:	725a      	strb	r2, [r3, #9]
    pInformation->Current_Configuration = 1;
 8007cc8:	2201      	movs	r2, #1
 8007cca:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 8007ccc:	4b28      	ldr	r3, [pc, #160]	; (8007d70 <MIOS32_USB_Init+0x124>)
 8007cce:	681b      	ldr	r3, [r3, #0]
 8007cd0:	685b      	ldr	r3, [r3, #4]
 8007cd2:	4798      	blx	r3
 8007cd4:	e02d      	b.n	8007d32 <MIOS32_USB_Init+0xe6>
    
    // connect device
    USB_DevConnect();
#else
    // force USB reset and power-down (this will also release the USB pins for direct GPIO control)
    _SetCNTR(CNTR_FRES | CNTR_PDWN);
 8007cd6:	4a1f      	ldr	r2, [pc, #124]	; (8007d54 <MIOS32_USB_Init+0x108>)
 8007cd8:	2303      	movs	r3, #3
 8007cda:	6013      	str	r3, [r2, #0]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8007cdc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8007ce0:	f8ad 2004 	strh.w	r2, [sp, #4]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007ce4:	a901      	add	r1, sp, #4
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007ce6:	2210      	movs	r2, #16
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007ce8:	4826      	ldr	r0, [pc, #152]	; (8007d84 <MIOS32_USB_Init+0x138>)
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007cea:	f88d 2007 	strb.w	r2, [sp, #7]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007cee:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007cf2:	f000 fea2 	bl	8008a3a <GPIO_Init>
 8007cf6:	4b24      	ldr	r3, [pc, #144]	; (8007d88 <MIOS32_USB_Init+0x13c>)

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 8007cf8:	4922      	ldr	r1, [pc, #136]	; (8007d84 <MIOS32_USB_Init+0x138>)
 8007cfa:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 8007cfe:	f113 33ff 	adds.w	r3, r3, #4294967295
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 8007d02:	614a      	str	r2, [r1, #20]
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 8007d04:	d1fb      	bne.n	8007cfe <MIOS32_USB_Init+0xb2>
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 8007d06:	4a13      	ldr	r2, [pc, #76]	; (8007d54 <MIOS32_USB_Init+0x108>)
 8007d08:	2102      	movs	r1, #2
 8007d0a:	6011      	str	r1, [r2, #0]

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 8007d0c:	4a1d      	ldr	r2, [pc, #116]	; (8007d84 <MIOS32_USB_Init+0x138>)
    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 8007d0e:	200a      	movs	r0, #10

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 8007d10:	f110 30ff 	adds.w	r0, r0, #4294967295
 8007d14:	6153      	str	r3, [r2, #20]
 8007d16:	d1fb      	bne.n	8007d10 <MIOS32_USB_Init+0xc4>

    // CNTR_FRES = 0
    _SetCNTR(0);
 8007d18:	4b0e      	ldr	r3, [pc, #56]	; (8007d54 <MIOS32_USB_Init+0x108>)
 8007d1a:	6018      	str	r0, [r3, #0]

    // Clear pending interrupts
    _SetISTR(0);
 8007d1c:	3304      	adds	r3, #4
 8007d1e:	6018      	str	r0, [r3, #0]

    // Configure USB clock
    // USBCLK = PLLCLK / 1.5
    RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
 8007d20:	f001 fada 	bl	80092d8 <RCC_USBCLKConfig>
    // Enable USB clock
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
 8007d24:	2101      	movs	r1, #1
 8007d26:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8007d2a:	f001 fb63 	bl	80093f4 <RCC_APB1PeriphClockCmd>
#endif /* STM32F10X_CL */

  }

  // don't set interrupt mask on custom driver installation
  if( mode != 2 ) {
 8007d2e:	2c02      	cmp	r4, #2
 8007d30:	d006      	beq.n	8007d40 <MIOS32_USB_Init+0xf4>
#ifdef STM32F10X_CL
    OTGD_FS_EnableGlobalInt();
#else
    // clear pending interrupts (again)
    _SetISTR(0);
 8007d32:	4b16      	ldr	r3, [pc, #88]	; (8007d8c <MIOS32_USB_Init+0x140>)
 8007d34:	2200      	movs	r2, #0
 8007d36:	601a      	str	r2, [r3, #0]

    // set interrupts mask
    _SetCNTR(IMR_MSK); // Interrupt mask
 8007d38:	f502 4204 	add.w	r2, r2, #33792	; 0x8400
 8007d3c:	3b04      	subs	r3, #4
 8007d3e:	601a      	str	r2, [r3, #0]
#endif
  }

  bDeviceState = UNCONNECTED;
 8007d40:	4b13      	ldr	r3, [pc, #76]	; (8007d90 <MIOS32_USB_Init+0x144>)
 8007d42:	2400      	movs	r4, #0
 8007d44:	601c      	str	r4, [r3, #0]
#ifdef STM32F10X_CL
  // Enable the USB interrupts
  MIOS32_IRQ_Install(OTG_FS_IRQn, MIOS32_IRQ_USB_PRIORITY);
#else
  // enable USB interrupts (unfortunately shared with CAN Rx0, as either CAN or USB can be used, but not at the same time)
  MIOS32_IRQ_Install(USB_LP_CAN1_RX0_IRQn, MIOS32_IRQ_USB_PRIORITY);
 8007d46:	2014      	movs	r0, #20
 8007d48:	2108      	movs	r1, #8
 8007d4a:	f7fe fcf3 	bl	8006734 <MIOS32_IRQ_Install>
#endif

  return 0; // no error
 8007d4e:	4620      	mov	r0, r4
}
 8007d50:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8007d52:	bf00      	nop
 8007d54:	40005c40 	.word	0x40005c40
 8007d58:	200008a4 	.word	0x200008a4
 8007d5c:	2000379c 	.word	0x2000379c
 8007d60:	200037a0 	.word	0x200037a0
 8007d64:	0800b148 	.word	0x0800b148
 8007d68:	20003794 	.word	0x20003794
 8007d6c:	0800b110 	.word	0x0800b110
 8007d70:	20003798 	.word	0x20003798
 8007d74:	08008091 	.word	0x08008091
 8007d78:	2000000c 	.word	0x2000000c
 8007d7c:	080080a5 	.word	0x080080a5
 8007d80:	20000028 	.word	0x20000028
 8007d84:	40010800 	.word	0x40010800
 8007d88:	00030d40 	.word	0x00030d40
 8007d8c:	40005c44 	.word	0x40005c44
 8007d90:	200008a0 	.word	0x200008a0

08007d94 <MIOS32_USB_MIDI_RxBufferHandler>:

/////////////////////////////////////////////////////////////////////////////
// This handler receives new packages if the Tx buffer is not full
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_RxBufferHandler(void)
{
 8007d94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  s16 count;

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 8007d96:	f7fe fca5 	bl	80066e4 <MIOS32_IRQ_Disable>

      OTGD_FS_EPStartXfer(ep);
    }
  }
#else
  if( rx_buffer_new_data && (count=GetEPRxCount(ENDP1)>>2) ) {
 8007d9a:	4b23      	ldr	r3, [pc, #140]	; (8007e28 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 8007d9c:	781b      	ldrb	r3, [r3, #0]
 8007d9e:	2b00      	cmp	r3, #0
 8007da0:	d03f      	beq.n	8007e22 <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007da2:	2001      	movs	r0, #1
 8007da4:	f002 fa8e 	bl	800a2c4 <GetEPRxCount>
 8007da8:	f3c0 058f 	ubfx	r5, r0, #2, #16
 8007dac:	2d00      	cmp	r5, #0
 8007dae:	d038      	beq.n	8007e22 <MIOS32_USB_MIDI_RxBufferHandler+0x8e>

    // check if buffer is free
    if( count < (MIOS32_USB_MIDI_RX_BUFFER_SIZE-rx_buffer_size) ) {
 8007db0:	4b1e      	ldr	r3, [pc, #120]	; (8007e2c <MIOS32_USB_MIDI_RxBufferHandler+0x98>)
 8007db2:	b229      	sxth	r1, r5
 8007db4:	881a      	ldrh	r2, [r3, #0]
 8007db6:	b292      	uxth	r2, r2
 8007db8:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
 8007dbc:	4291      	cmp	r1, r2
 8007dbe:	da30      	bge.n	8007e22 <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007dc0:	4e1b      	ldr	r6, [pc, #108]	; (8007e30 <MIOS32_USB_MIDI_RxBufferHandler+0x9c>)
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007dc2:	4c1c      	ldr	r4, [pc, #112]	; (8007e34 <MIOS32_USB_MIDI_RxBufferHandler+0xa0>)
 8007dc4:	4a1c      	ldr	r2, [pc, #112]	; (8007e38 <MIOS32_USB_MIDI_RxBufferHandler+0xa4>)
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007dc6:	f836 1c08 	ldrh.w	r1, [r6, #-8]
 8007dca:	f836 7c04 	ldrh.w	r7, [r6, #-4]

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8007dce:	9201      	str	r2, [sp, #4]
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007dd0:	ea41 4707 	orr.w	r7, r1, r7, lsl #16

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8007dd4:	f3c7 1003 	ubfx	r0, r7, #4, #4
 8007dd8:	3010      	adds	r0, #16
 8007dda:	4639      	mov	r1, r7
 8007ddc:	9300      	str	r3, [sp, #0]
 8007dde:	f7fe f8ed 	bl	8005fbc <MIOS32_MIDI_SendPackageToRxCallback>
 8007de2:	9a01      	ldr	r2, [sp, #4]
 8007de4:	9b00      	ldr	r3, [sp, #0]
 8007de6:	b980      	cbnz	r0, 8007e0a <MIOS32_USB_MIDI_RxBufferHandler+0x76>
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007de8:	8821      	ldrh	r1, [r4, #0]
 8007dea:	b289      	uxth	r1, r1
 8007dec:	f842 7021 	str.w	r7, [r2, r1, lsl #2]

	  if( ++rx_buffer_head >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8007df0:	8821      	ldrh	r1, [r4, #0]
 8007df2:	3101      	adds	r1, #1
 8007df4:	b289      	uxth	r1, r1
 8007df6:	8021      	strh	r1, [r4, #0]
 8007df8:	8821      	ldrh	r1, [r4, #0]
 8007dfa:	b289      	uxth	r1, r1
 8007dfc:	293f      	cmp	r1, #63	; 0x3f
	    rx_buffer_head = 0;
 8007dfe:	bf88      	it	hi
 8007e00:	8020      	strhhi	r0, [r4, #0]
	  ++rx_buffer_size;
 8007e02:	8819      	ldrh	r1, [r3, #0]
 8007e04:	3101      	adds	r1, #1
 8007e06:	b289      	uxth	r1, r1
 8007e08:	8019      	strh	r1, [r3, #0]
	}
      } while( --count > 0 );
 8007e0a:	3d01      	subs	r5, #1
 8007e0c:	b2ad      	uxth	r5, r5
 8007e0e:	b229      	sxth	r1, r5
 8007e10:	3608      	adds	r6, #8
 8007e12:	2900      	cmp	r1, #0
 8007e14:	dcd7      	bgt.n	8007dc6 <MIOS32_USB_MIDI_RxBufferHandler+0x32>

      // notify, that data has been put into buffer
      rx_buffer_new_data = 0;
 8007e16:	4b04      	ldr	r3, [pc, #16]	; (8007e28 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 8007e18:	2200      	movs	r2, #0
 8007e1a:	701a      	strb	r2, [r3, #0]

      // release OUT pipe
      SetEPRxValid(ENDP1);
 8007e1c:	2001      	movs	r0, #1
 8007e1e:	f002 f99d 	bl	800a15c <SetEPRxValid>
    }
  }
#endif
  MIOS32_IRQ_Enable();
 8007e22:	f7fe fc75 	bl	8006710 <MIOS32_IRQ_Enable>
}
 8007e26:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007e28:	20000ac8 	.word	0x20000ac8
 8007e2c:	200008c0 	.word	0x200008c0
 8007e30:	40006208 	.word	0x40006208
 8007e34:	20000aca 	.word	0x20000aca
 8007e38:	200009c8 	.word	0x200009c8

08007e3c <MIOS32_USB_MIDI_TxBufferHandler>:
/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
{
 8007e3c:	b510      	push	{r4, lr}
  //   - last transfer finished
  //   - new packages are in the buffer
  //   - the device is configured

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 8007e3e:	f7fe fc51 	bl	80066e4 <MIOS32_IRQ_Disable>
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
	tx_buffer_tail = 0;
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
 8007e42:	4b2c      	ldr	r3, [pc, #176]	; (8007ef4 <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
 8007e44:	781b      	ldrb	r3, [r3, #0]
 8007e46:	2b00      	cmp	r3, #0
 8007e48:	d150      	bne.n	8007eec <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 8007e4a:	4b2b      	ldr	r3, [pc, #172]	; (8007ef8 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)
 8007e4c:	881a      	ldrh	r2, [r3, #0]
 8007e4e:	b292      	uxth	r2, r2
 8007e50:	2a00      	cmp	r2, #0
 8007e52:	d04b      	beq.n	8007eec <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 8007e54:	4a29      	ldr	r2, [pc, #164]	; (8007efc <MIOS32_USB_MIDI_TxBufferHandler+0xc0>)
 8007e56:	7812      	ldrb	r2, [r2, #0]
 8007e58:	2a00      	cmp	r2, #0
 8007e5a:	d047      	beq.n	8007eec <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8007e5c:	881a      	ldrh	r2, [r3, #0]
 8007e5e:	b292      	uxth	r2, r2
 8007e60:	2a10      	cmp	r2, #16
 8007e62:	bf98      	it	ls
 8007e64:	881c      	ldrhls	r4, [r3, #0]

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007e66:	4b23      	ldr	r3, [pc, #140]	; (8007ef4 <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8007e68:	bf94      	ite	ls
 8007e6a:	b2a4      	uxthls	r4, r4
 8007e6c:	2410      	movhi	r4, #16

    // notify that new package is sent
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007e6e:	b2a4      	uxth	r4, r4
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007e70:	2001      	movs	r0, #1

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007e72:	00a1      	lsls	r1, r4, #2
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007e74:	7018      	strb	r0, [r3, #0]

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007e76:	b289      	uxth	r1, r1
 8007e78:	f002 f9f6 	bl	800a268 <SetEPTxCount>

    tx_buffer_size -= count;
 8007e7c:	4b1e      	ldr	r3, [pc, #120]	; (8007ef8 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007e7e:	4920      	ldr	r1, [pc, #128]	; (8007f00 <MIOS32_USB_MIDI_TxBufferHandler+0xc4>)
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);

    tx_buffer_size -= count;
 8007e80:	881a      	ldrh	r2, [r3, #0]
 8007e82:	1b12      	subs	r2, r2, r4
 8007e84:	b292      	uxth	r2, r2
 8007e86:	801a      	strh	r2, [r3, #0]

/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
 8007e88:	3c01      	subs	r4, #1
 8007e8a:	4b1e      	ldr	r3, [pc, #120]	; (8007f04 <MIOS32_USB_MIDI_TxBufferHandler+0xc8>)
 8007e8c:	b2a4      	uxth	r4, r4
 8007e8e:	18e3      	adds	r3, r4, r3
 8007e90:	00d8      	lsls	r0, r3, #3
 8007e92:	4a1d      	ldr	r2, [pc, #116]	; (8007f08 <MIOS32_USB_MIDI_TxBufferHandler+0xcc>)

    tx_buffer_size -= count;

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007e94:	4b1d      	ldr	r3, [pc, #116]	; (8007f0c <MIOS32_USB_MIDI_TxBufferHandler+0xd0>)
 8007e96:	f8b3 c000 	ldrh.w	ip, [r3]
 8007e9a:	fa1f fc8c 	uxth.w	ip, ip
 8007e9e:	f831 c02c 	ldrh.w	ip, [r1, ip, lsl #2]
 8007ea2:	f842 cc08 	str.w	ip, [r2, #-8]
      *pma_addr++ = (tx_buffer[tx_buffer_tail]>>16) & 0xffff;
 8007ea6:	f8b3 c000 	ldrh.w	ip, [r3]
 8007eaa:	fa1f fc8c 	uxth.w	ip, ip
 8007eae:	f851 c02c 	ldr.w	ip, [r1, ip, lsl #2]
 8007eb2:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8007eb6:	f842 cc04 	str.w	ip, [r2, #-4]
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007eba:	f8b3 c000 	ldrh.w	ip, [r3]
 8007ebe:	f10c 0c01 	add.w	ip, ip, #1
 8007ec2:	fa1f fc8c 	uxth.w	ip, ip
 8007ec6:	f8a3 c000 	strh.w	ip, [r3]
 8007eca:	f8b3 c000 	ldrh.w	ip, [r3]
 8007ece:	fa1f fc8c 	uxth.w	ip, ip
 8007ed2:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
	tx_buffer_tail = 0;
 8007ed6:	bf84      	itt	hi
 8007ed8:	f04f 0c00 	movhi.w	ip, #0
 8007edc:	f8a3 c000 	strhhi.w	ip, [r3]
 8007ee0:	3208      	adds	r2, #8
    } while( --count );
 8007ee2:	4282      	cmp	r2, r0
 8007ee4:	d1d7      	bne.n	8007e96 <MIOS32_USB_MIDI_TxBufferHandler+0x5a>

    // send buffer
    SetEPTxValid(ENDP1);
 8007ee6:	2001      	movs	r0, #1
 8007ee8:	f002 f926 	bl	800a138 <SetEPTxValid>
  }
#endif
  MIOS32_IRQ_Enable();
 8007eec:	f7fe fc10 	bl	8006710 <MIOS32_IRQ_Enable>
}
 8007ef0:	bd10      	pop	{r4, pc}
 8007ef2:	bf00      	nop
 8007ef4:	200009c4 	.word	0x200009c4
 8007ef8:	20000acc 	.word	0x20000acc
 8007efc:	20000ad2 	.word	0x20000ad2
 8007f00:	200008c4 	.word	0x200008c4
 8007f04:	08000c32 	.word	0x08000c32
 8007f08:	40006188 	.word	0x40006188
 8007f0c:	20000ace 	.word	0x20000ace

08007f10 <MIOS32_USB_MIDI_Init>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007f10:	2800      	cmp	r0, #0
 8007f12:	bf14      	ite	ne
 8007f14:	f04f 30ff 	movne.w	r0, #4294967295
 8007f18:	2000      	moveq	r0, #0

  return 0; // no error
}
 8007f1a:	4770      	bx	lr

08007f1c <MIOS32_USB_MIDI_ChangeConnectionState>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_ChangeConnectionState(u8 connected)
{
  // in all cases: re-initialize USB MIDI driver
  // clear buffer counters and busy/wait signals again (e.g., so that no invalid data will be sent out)
  rx_buffer_tail = rx_buffer_head = rx_buffer_size = 0;
 8007f1c:	4a10      	ldr	r2, [pc, #64]	; (8007f60 <MIOS32_USB_MIDI_ChangeConnectionState+0x44>)
 8007f1e:	2300      	movs	r3, #0
 8007f20:	8013      	strh	r3, [r2, #0]
 8007f22:	8811      	ldrh	r1, [r2, #0]
 8007f24:	4a0f      	ldr	r2, [pc, #60]	; (8007f64 <MIOS32_USB_MIDI_ChangeConnectionState+0x48>)
 8007f26:	b289      	uxth	r1, r1
 8007f28:	8011      	strh	r1, [r2, #0]
 8007f2a:	8811      	ldrh	r1, [r2, #0]
 8007f2c:	4a0e      	ldr	r2, [pc, #56]	; (8007f68 <MIOS32_USB_MIDI_ChangeConnectionState+0x4c>)
 8007f2e:	b289      	uxth	r1, r1
 8007f30:	8011      	strh	r1, [r2, #0]
  rx_buffer_new_data = 0; // no data received yet
 8007f32:	4a0e      	ldr	r2, [pc, #56]	; (8007f6c <MIOS32_USB_MIDI_ChangeConnectionState+0x50>)
 8007f34:	7013      	strb	r3, [r2, #0]
  tx_buffer_tail = tx_buffer_head = tx_buffer_size = 0;
 8007f36:	4a0e      	ldr	r2, [pc, #56]	; (8007f70 <MIOS32_USB_MIDI_ChangeConnectionState+0x54>)
 8007f38:	8013      	strh	r3, [r2, #0]
 8007f3a:	8811      	ldrh	r1, [r2, #0]
 8007f3c:	4a0d      	ldr	r2, [pc, #52]	; (8007f74 <MIOS32_USB_MIDI_ChangeConnectionState+0x58>)
 8007f3e:	b289      	uxth	r1, r1
 8007f40:	8011      	strh	r1, [r2, #0]
 8007f42:	8811      	ldrh	r1, [r2, #0]
 8007f44:	4a0c      	ldr	r2, [pc, #48]	; (8007f78 <MIOS32_USB_MIDI_ChangeConnectionState+0x5c>)
 8007f46:	b289      	uxth	r1, r1
 8007f48:	8011      	strh	r1, [r2, #0]
 8007f4a:	490c      	ldr	r1, [pc, #48]	; (8007f7c <MIOS32_USB_MIDI_ChangeConnectionState+0x60>)
 8007f4c:	4a0c      	ldr	r2, [pc, #48]	; (8007f80 <MIOS32_USB_MIDI_ChangeConnectionState+0x64>)

  if( connected ) {
 8007f4e:	b110      	cbz	r0, 8007f56 <MIOS32_USB_MIDI_ChangeConnectionState+0x3a>
    transfer_possible = 1;
 8007f50:	2001      	movs	r0, #1
 8007f52:	7008      	strb	r0, [r1, #0]
 8007f54:	e001      	b.n	8007f5a <MIOS32_USB_MIDI_ChangeConnectionState+0x3e>
    tx_buffer_busy = 0; // buffer not busy anymore
  } else {
    // cable disconnected: disable transfers
    transfer_possible = 0;
 8007f56:	700b      	strb	r3, [r1, #0]
    tx_buffer_busy = 1; // buffer busy
 8007f58:	2301      	movs	r3, #1
 8007f5a:	7013      	strb	r3, [r2, #0]
  }

  return 0; // no error
}
 8007f5c:	2000      	movs	r0, #0
 8007f5e:	4770      	bx	lr
 8007f60:	200008c0 	.word	0x200008c0
 8007f64:	20000aca 	.word	0x20000aca
 8007f68:	200008c2 	.word	0x200008c2
 8007f6c:	20000ac8 	.word	0x20000ac8
 8007f70:	20000acc 	.word	0x20000acc
 8007f74:	20000ad4 	.word	0x20000ad4
 8007f78:	20000ace 	.word	0x20000ace
 8007f7c:	20000ad2 	.word	0x20000ad2
 8007f80:	200009c4 	.word	0x200009c4

08007f84 <MIOS32_USB_MIDI_PackageSend_NonBlocking>:
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007f84:	b538      	push	{r3, r4, r5, lr}
  // device available?
  if( !transfer_possible )
 8007f86:	4d17      	ldr	r5, [pc, #92]	; (8007fe4 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x60>)
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007f88:	4604      	mov	r4, r0
  // device available?
  if( !transfer_possible )
 8007f8a:	782b      	ldrb	r3, [r5, #0]
    return -1;
 8007f8c:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
  // device available?
  if( !transfer_possible )
 8007f90:	b33b      	cbz	r3, 8007fe2 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    return -1;

  // buffer full?
  if( tx_buffer_size >= (MIOS32_USB_MIDI_TX_BUFFER_SIZE-1) ) {
 8007f92:	4b15      	ldr	r3, [pc, #84]	; (8007fe8 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007f94:	881b      	ldrh	r3, [r3, #0]
 8007f96:	b29b      	uxth	r3, r3
 8007f98:	2b3e      	cmp	r3, #62	; 0x3e
 8007f9a:	d909      	bls.n	8007fb0 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x2c>
    // call USB handler, so that we are able to get the buffer free again on next execution
    // (this call simplifies polling loops!)
    MIOS32_USB_MIDI_TxBufferHandler();
 8007f9c:	f7ff ff4e 	bl	8007e3c <MIOS32_USB_MIDI_TxBufferHandler>

    // device still available?
    // (ensures that polling loop terminates if cable has been disconnected)
    if( !transfer_possible )
 8007fa0:	782b      	ldrb	r3, [r5, #0]
 8007fa2:	2b00      	cmp	r3, #0
      return -1;
 8007fa4:	bf14      	ite	ne
 8007fa6:	f06f 0001 	mvnne.w	r0, #1
 8007faa:	f04f 30ff 	moveq.w	r0, #4294967295
 8007fae:	e018      	b.n	8007fe2 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    // notify that buffer was full (request retry)
    return -2;
  }

  // put package into buffer - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007fb0:	f7fe fb98 	bl	80066e4 <MIOS32_IRQ_Disable>
  tx_buffer[tx_buffer_head++] = package.ALL;
 8007fb4:	4b0d      	ldr	r3, [pc, #52]	; (8007fec <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x68>)
 8007fb6:	490e      	ldr	r1, [pc, #56]	; (8007ff0 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x6c>)
 8007fb8:	881a      	ldrh	r2, [r3, #0]
 8007fba:	b292      	uxth	r2, r2
 8007fbc:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
 8007fc0:	3201      	adds	r2, #1
 8007fc2:	b292      	uxth	r2, r2
 8007fc4:	801a      	strh	r2, [r3, #0]
  if( tx_buffer_head >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007fc6:	881a      	ldrh	r2, [r3, #0]
 8007fc8:	b292      	uxth	r2, r2
 8007fca:	2a3f      	cmp	r2, #63	; 0x3f
 8007fcc:	d901      	bls.n	8007fd2 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x4e>
    tx_buffer_head = 0;
 8007fce:	2200      	movs	r2, #0
 8007fd0:	801a      	strh	r2, [r3, #0]
  ++tx_buffer_size;
 8007fd2:	4b05      	ldr	r3, [pc, #20]	; (8007fe8 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007fd4:	881a      	ldrh	r2, [r3, #0]
 8007fd6:	3201      	adds	r2, #1
 8007fd8:	b292      	uxth	r2, r2
 8007fda:	801a      	strh	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 8007fdc:	f7fe fb98 	bl	8006710 <MIOS32_IRQ_Enable>

  return 0;
 8007fe0:	2000      	movs	r0, #0
}
 8007fe2:	bd38      	pop	{r3, r4, r5, pc}
 8007fe4:	20000ad2 	.word	0x20000ad2
 8007fe8:	20000acc 	.word	0x20000acc
 8007fec:	20000ad4 	.word	0x20000ad4
 8007ff0:	200008c4 	.word	0x200008c4

08007ff4 <MIOS32_USB_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: USB not connected
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend(mios32_midi_package_t package)
{
 8007ff4:	b570      	push	{r4, r5, r6, lr}
 8007ff6:	4606      	mov	r6, r0
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
    if( timeout_ctr >= 10000 )
 8007ff8:	4c0a      	ldr	r4, [pc, #40]	; (8008024 <MIOS32_USB_MIDI_PackageSend+0x30>)
 8007ffa:	f242 750f 	movw	r5, #9999	; 0x270f
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8007ffe:	e004      	b.n	800800a <MIOS32_USB_MIDI_PackageSend+0x16>
    if( timeout_ctr >= 10000 )
 8008000:	8823      	ldrh	r3, [r4, #0]
 8008002:	42ab      	cmp	r3, r5
 8008004:	d80c      	bhi.n	8008020 <MIOS32_USB_MIDI_PackageSend+0x2c>
      break;
    ++timeout_ctr;
 8008006:	3301      	adds	r3, #1
 8008008:	8023      	strh	r3, [r4, #0]
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 800800a:	4630      	mov	r0, r6
 800800c:	f7ff ffba 	bl	8007f84 <MIOS32_USB_MIDI_PackageSend_NonBlocking>
 8008010:	f110 0f02 	cmn.w	r0, #2
 8008014:	d0f4      	beq.n	8008000 <MIOS32_USB_MIDI_PackageSend+0xc>
    if( timeout_ctr >= 10000 )
      break;
    ++timeout_ctr;
  }

  if( error >= 0 ) // no error: reset timeout counter
 8008016:	2800      	cmp	r0, #0
 8008018:	db02      	blt.n	8008020 <MIOS32_USB_MIDI_PackageSend+0x2c>
    timeout_ctr = 0;
 800801a:	4b02      	ldr	r3, [pc, #8]	; (8008024 <MIOS32_USB_MIDI_PackageSend+0x30>)
 800801c:	2200      	movs	r2, #0
 800801e:	801a      	strh	r2, [r3, #0]

  return error;
}
 8008020:	bd70      	pop	{r4, r5, r6, pc}
 8008022:	bf00      	nop
 8008024:	20000ad0 	.word	0x20000ad0

08008028 <MIOS32_USB_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8008028:	4b12      	ldr	r3, [pc, #72]	; (8008074 <MIOS32_USB_MIDI_PackageReceive+0x4c>)
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 800802a:	b510      	push	{r4, lr}
  // package received?
  if( !rx_buffer_size )
 800802c:	881b      	ldrh	r3, [r3, #0]
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 800802e:	4604      	mov	r4, r0
  // package received?
  if( !rx_buffer_size )
 8008030:	b29b      	uxth	r3, r3
    return -1;
 8008032:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8008036:	b1db      	cbz	r3, 8008070 <MIOS32_USB_MIDI_PackageReceive+0x48>
    return -1;

  // get package - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8008038:	f7fe fb54 	bl	80066e4 <MIOS32_IRQ_Disable>
  package->ALL = rx_buffer[rx_buffer_tail];
 800803c:	4b0e      	ldr	r3, [pc, #56]	; (8008078 <MIOS32_USB_MIDI_PackageReceive+0x50>)
 800803e:	4a0f      	ldr	r2, [pc, #60]	; (800807c <MIOS32_USB_MIDI_PackageReceive+0x54>)
 8008040:	8819      	ldrh	r1, [r3, #0]
 8008042:	b289      	uxth	r1, r1
 8008044:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8008048:	6022      	str	r2, [r4, #0]
  if( ++rx_buffer_tail >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 800804a:	881a      	ldrh	r2, [r3, #0]
 800804c:	3201      	adds	r2, #1
 800804e:	b292      	uxth	r2, r2
 8008050:	801a      	strh	r2, [r3, #0]
 8008052:	881a      	ldrh	r2, [r3, #0]
 8008054:	b292      	uxth	r2, r2
 8008056:	2a3f      	cmp	r2, #63	; 0x3f
 8008058:	d901      	bls.n	800805e <MIOS32_USB_MIDI_PackageReceive+0x36>
    rx_buffer_tail = 0;
 800805a:	2200      	movs	r2, #0
 800805c:	801a      	strh	r2, [r3, #0]
  --rx_buffer_size;
 800805e:	4c05      	ldr	r4, [pc, #20]	; (8008074 <MIOS32_USB_MIDI_PackageReceive+0x4c>)
 8008060:	8823      	ldrh	r3, [r4, #0]
 8008062:	3b01      	subs	r3, #1
 8008064:	b29b      	uxth	r3, r3
 8008066:	8023      	strh	r3, [r4, #0]
  MIOS32_IRQ_Enable();
 8008068:	f7fe fb52 	bl	8006710 <MIOS32_IRQ_Enable>

  return rx_buffer_size;
 800806c:	8820      	ldrh	r0, [r4, #0]
 800806e:	b280      	uxth	r0, r0
}
 8008070:	bd10      	pop	{r4, pc}
 8008072:	bf00      	nop
 8008074:	200008c0 	.word	0x200008c0
 8008078:	200008c2 	.word	0x200008c2
 800807c:	200009c8 	.word	0x200009c8

08008080 <MIOS32_USB_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Periodic_mS(void)
{
 8008080:	b508      	push	{r3, lr}
  // check for received packages
  MIOS32_USB_MIDI_RxBufferHandler();
 8008082:	f7ff fe87 	bl	8007d94 <MIOS32_USB_MIDI_RxBufferHandler>

  // check for packages which should be transmitted
  MIOS32_USB_MIDI_TxBufferHandler();
 8008086:	f7ff fed9 	bl	8007e3c <MIOS32_USB_MIDI_TxBufferHandler>

  return 0;
}
 800808a:	2000      	movs	r0, #0
 800808c:	bd08      	pop	{r3, pc}
	...

08008090 <MIOS32_USB_MIDI_EP1_IN_Callback>:
//! Called by STM32 USB driver to check for IN streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_IN_Callback(u8 bEP, u8 bEPStatus)
{
 8008090:	b508      	push	{r3, lr}
  // package has been sent
  tx_buffer_busy = 0;
 8008092:	4b03      	ldr	r3, [pc, #12]	; (80080a0 <MIOS32_USB_MIDI_EP1_IN_Callback+0x10>)
 8008094:	2200      	movs	r2, #0
 8008096:	701a      	strb	r2, [r3, #0]
  
  // check for next package
  MIOS32_USB_MIDI_TxBufferHandler();
 8008098:	f7ff fed0 	bl	8007e3c <MIOS32_USB_MIDI_TxBufferHandler>
}
 800809c:	bd08      	pop	{r3, pc}
 800809e:	bf00      	nop
 80080a0:	200009c4 	.word	0x200009c4

080080a4 <MIOS32_USB_MIDI_EP1_OUT_Callback>:
//! Called by STM32 USB driver to check for OUT streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_OUT_Callback(u8 bEP, u8 bEPStatus)
{
 80080a4:	b508      	push	{r3, lr}
  // put package into buffer
  rx_buffer_new_data = 1;
 80080a6:	4b03      	ldr	r3, [pc, #12]	; (80080b4 <MIOS32_USB_MIDI_EP1_OUT_Callback+0x10>)
 80080a8:	2201      	movs	r2, #1
 80080aa:	701a      	strb	r2, [r3, #0]
  MIOS32_USB_MIDI_RxBufferHandler();
 80080ac:	f7ff fe72 	bl	8007d94 <MIOS32_USB_MIDI_RxBufferHandler>
}
 80080b0:	bd08      	pop	{r3, pc}
 80080b2:	bf00      	nop
 80080b4:	20000ac8 	.word	0x20000ac8

080080b8 <MIOS32_UART_BaudrateSet>:
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 80080b8:	b530      	push	{r4, r5, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80080ba:	2801      	cmp	r0, #1
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 80080bc:	4604      	mov	r4, r0
 80080be:	b085      	sub	sp, #20
 80080c0:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1;
 80080c2:	bf88      	it	hi
 80080c4:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80080c8:	d81a      	bhi.n	8008100 <MIOS32_UART_BaudrateSet+0x48>
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 80080ca:	f04f 0300 	mov.w	r3, #0
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 80080ce:	a904      	add	r1, sp, #16
  if( uart >= MIOS32_UART_NUM )
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 80080d0:	f8ad 3004 	strh.w	r3, [sp, #4]
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
 80080d4:	f8ad 3006 	strh.w	r3, [sp, #6]
  USART_InitStructure.USART_Parity = USART_Parity_No;
 80080d8:	f8ad 3008 	strh.w	r3, [sp, #8]
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 80080dc:	f8ad 300c 	strh.w	r3, [sp, #12]
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 80080e0:	f841 5d10 	str.w	r5, [r1, #-16]!
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80080e4:	f04f 030c 	mov.w	r3, #12

  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
 80080e8:	bf14      	ite	ne
 80080ea:	4806      	ldrne	r0, [pc, #24]	; (8008104 <MIOS32_UART_BaudrateSet+0x4c>)
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 80080ec:	4806      	ldreq	r0, [pc, #24]	; (8008108 <MIOS32_UART_BaudrateSet+0x50>)
 80080ee:	4669      	mov	r1, sp
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80080f0:	f8ad 300a 	strh.w	r3, [sp, #10]
  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 80080f4:	f000 fe54 	bl	8008da0 <USART_Init>
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 80080f8:	4b04      	ldr	r3, [pc, #16]	; (800810c <MIOS32_UART_BaudrateSet+0x54>)

  return 0;
 80080fa:	2000      	movs	r0, #0
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 80080fc:	f843 5024 	str.w	r5, [r3, r4, lsl #2]

  return 0;
#endif
}
 8008100:	b005      	add	sp, #20
 8008102:	bd30      	pop	{r4, r5, pc}
 8008104:	40013800 	.word	0x40013800
 8008108:	40004800 	.word	0x40004800
 800810c:	20000bec 	.word	0x20000bec

08008110 <MIOS32_UART_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_Init(u32 mode)
{
 8008110:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8008112:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8008114:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_UART_Init(u32 mode)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
 8008118:	2c00      	cmp	r4, #0
 800811a:	f040 8086 	bne.w	800822a <MIOS32_UART_Init+0x11a>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 800811e:	ad01      	add	r5, sp, #4
#else

  // map UART pins
  MIOS32_UART0_REMAP_FUNC;
#if MIOS32_UART_NUM >= 2
  MIOS32_UART1_REMAP_FUNC;
 8008120:	2101      	movs	r1, #1
 8008122:	4842      	ldr	r0, [pc, #264]	; (800822c <MIOS32_UART_Init+0x11c>)
 8008124:	f000 fcea 	bl	8008afc <GPIO_PinRemapConfig>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 8008128:	4628      	mov	r0, r5
 800812a:	f000 fcdf 	bl	8008aec <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800812e:	2302      	movs	r3, #2
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8008130:	4629      	mov	r1, r5
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8008132:	f88d 3006 	strb.w	r3, [sp, #6]

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8008136:	261c      	movs	r6, #28
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 8008138:	f44f 7300 	mov.w	r3, #512	; 0x200
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 800813c:	483c      	ldr	r0, [pc, #240]	; (8008230 <MIOS32_UART_Init+0x120>)
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 800813e:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8008142:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8008146:	f000 fc78 	bl	8008a3a <GPIO_Init>

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 800814a:	f44f 6380 	mov.w	r3, #1024	; 0x400
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 800814e:	4629      	mov	r1, r5
 8008150:	4838      	ldr	r0, [pc, #224]	; (8008234 <MIOS32_UART_Init+0x124>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 8008152:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8008156:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 800815a:	f000 fc6e 	bl	8008a3a <GPIO_Init>
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800815e:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8008160:	4629      	mov	r1, r5
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8008162:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8008166:	4832      	ldr	r0, [pc, #200]	; (8008230 <MIOS32_UART_Init+0x120>)
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
 8008168:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800816c:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8008170:	f000 fc63 	bl	8008a3a <GPIO_Init>
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 8008174:	f44f 6300 	mov.w	r3, #2048	; 0x800
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 8008178:	4629      	mov	r1, r5
 800817a:	482e      	ldr	r0, [pc, #184]	; (8008234 <MIOS32_UART_Init+0x124>)
  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 800817c:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 8008180:	f000 fc5b 	bl	8008a3a <GPIO_Init>
  GPIO_Init(MIOS32_UART2_RX_PORT, &GPIO_InitStructure);
#endif

  // enable all USART clocks
  // TODO: more generic approach for different UART selections
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 8008184:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8008188:	2101      	movs	r1, #1
 800818a:	f001 f925 	bl	80093d8 <RCC_APB2PeriphClockCmd>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 | RCC_APB1Periph_USART3, ENABLE);
 800818e:	f44f 20c0 	mov.w	r0, #393216	; 0x60000
 8008192:	2101      	movs	r1, #1
 8008194:	f001 f92e 	bl	80093f4 <RCC_APB1PeriphClockCmd>

  // USART configuration
  MIOS32_UART_BaudrateSet(0, MIOS32_UART0_BAUDRATE);
 8008198:	f647 2112 	movw	r1, #31250	; 0x7a12
 800819c:	4620      	mov	r0, r4
 800819e:	f7ff ff8b 	bl	80080b8 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=2
  MIOS32_UART_BaudrateSet(1, MIOS32_UART1_BAUDRATE);
 80081a2:	f647 2112 	movw	r1, #31250	; 0x7a12
 80081a6:	2001      	movs	r0, #1
 80081a8:	f7ff ff86 	bl	80080b8 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=3
  MIOS32_UART_BaudrateSet(2, MIOS32_UART2_BAUDRATE);
#endif

  // configure and enable UART interrupts
  MIOS32_IRQ_Install(MIOS32_UART0_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 80081ac:	2104      	movs	r1, #4
 80081ae:	2025      	movs	r0, #37	; 0x25
 80081b0:	f7fe fac0 	bl	8006734 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART0, USART_IT_RXNE, ENABLE);
 80081b4:	2201      	movs	r2, #1
 80081b6:	4820      	ldr	r0, [pc, #128]	; (8008238 <MIOS32_UART_Init+0x128>)
 80081b8:	f240 5125 	movw	r1, #1317	; 0x525
 80081bc:	f000 fe59 	bl	8008e72 <USART_ITConfig>

#if MIOS32_UART_NUM >= 2
  MIOS32_IRQ_Install(MIOS32_UART1_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 80081c0:	2104      	movs	r1, #4
 80081c2:	2027      	movs	r0, #39	; 0x27
 80081c4:	f7fe fab6 	bl	8006734 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART1, USART_IT_RXNE, ENABLE);
 80081c8:	481c      	ldr	r0, [pc, #112]	; (800823c <MIOS32_UART_Init+0x12c>)
 80081ca:	f240 5125 	movw	r1, #1317	; 0x525
 80081ce:	2201      	movs	r2, #1
 80081d0:	f000 fe4f 	bl	8008e72 <USART_ITConfig>
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80081d4:	481a      	ldr	r0, [pc, #104]	; (8008240 <MIOS32_UART_Init+0x130>)
 80081d6:	491b      	ldr	r1, [pc, #108]	; (8008244 <MIOS32_UART_Init+0x134>)
 80081d8:	7004      	strb	r4, [r0, #0]
 80081da:	7803      	ldrb	r3, [r0, #0]
 80081dc:	f8df e068 	ldr.w	lr, [pc, #104]	; 8008248 <MIOS32_UART_Init+0x138>
 80081e0:	700b      	strb	r3, [r1, #0]
 80081e2:	780b      	ldrb	r3, [r1, #0]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80081e4:	4a19      	ldr	r2, [pc, #100]	; (800824c <MIOS32_UART_Init+0x13c>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80081e6:	f88e 3000 	strb.w	r3, [lr]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80081ea:	7014      	strb	r4, [r2, #0]
 80081ec:	f892 c000 	ldrb.w	ip, [r2]
 80081f0:	4b17      	ldr	r3, [pc, #92]	; (8008250 <MIOS32_UART_Init+0x140>)
 80081f2:	f883 c000 	strb.w	ip, [r3]
 80081f6:	781d      	ldrb	r5, [r3, #0]
 80081f8:	f8df c058 	ldr.w	ip, [pc, #88]	; 8008254 <MIOS32_UART_Init+0x144>
 80081fc:	f88c 5000 	strb.w	r5, [ip]
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 8008200:	7044      	strb	r4, [r0, #1]
 8008202:	7840      	ldrb	r0, [r0, #1]
 8008204:	7048      	strb	r0, [r1, #1]
 8008206:	7849      	ldrb	r1, [r1, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 8008208:	480b      	ldr	r0, [pc, #44]	; (8008238 <MIOS32_UART_Init+0x128>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 800820a:	f88e 1001 	strb.w	r1, [lr, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 800820e:	7054      	strb	r4, [r2, #1]
 8008210:	7852      	ldrb	r2, [r2, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 8008212:	2101      	movs	r1, #1

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 8008214:	705a      	strb	r2, [r3, #1]
 8008216:	785b      	ldrb	r3, [r3, #1]
 8008218:	f88c 3001 	strb.w	r3, [ip, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 800821c:	f000 fe1c 	bl	8008e58 <USART_Cmd>
#if MIOS32_UART_NUM >= 2
  USART_Cmd(MIOS32_UART1, ENABLE);
 8008220:	4806      	ldr	r0, [pc, #24]	; (800823c <MIOS32_UART_Init+0x12c>)
 8008222:	2101      	movs	r1, #1
 8008224:	f000 fe18 	bl	8008e58 <USART_Cmd>
#endif
#if MIOS32_UART_NUM >= 3
  USART_Cmd(MIOS32_UART2, ENABLE);
#endif

  return 0; // no error
 8008228:	4620      	mov	r0, r4
#endif
}
 800822a:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 800822c:	00140010 	.word	0x00140010
 8008230:	40010800 	.word	0x40010800
 8008234:	40011000 	.word	0x40011000
 8008238:	40013800 	.word	0x40013800
 800823c:	40004800 	.word	0x40004800
 8008240:	20000adc 	.word	0x20000adc
 8008244:	20000be4 	.word	0x20000be4
 8008248:	20000ae0 	.word	0x20000ae0
 800824c:	20000be8 	.word	0x20000be8
 8008250:	20000bf4 	.word	0x20000bf4
 8008254:	20000ad8 	.word	0x20000ad8

08008258 <MIOS32_UART_RxBufferGet>:
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008258:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: number of received bytes
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
 800825a:	b538      	push	{r3, r4, r5, lr}
 800825c:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 800825e:	bf88      	it	hi
 8008260:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008264:	d81d      	bhi.n	80082a2 <MIOS32_UART_RxBufferGet+0x4a>
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 8008266:	4b0f      	ldr	r3, [pc, #60]	; (80082a4 <MIOS32_UART_RxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 8008268:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 800826c:	5d1b      	ldrb	r3, [r3, r4]
 800826e:	b1c3      	cbz	r3, 80082a2 <MIOS32_UART_RxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8008270:	f7fe fa38 	bl	80066e4 <MIOS32_IRQ_Disable>
  u8 b = rx_buffer[uart][rx_buffer_tail[uart]];
 8008274:	4b0c      	ldr	r3, [pc, #48]	; (80082a8 <MIOS32_UART_RxBufferGet+0x50>)
 8008276:	490d      	ldr	r1, [pc, #52]	; (80082ac <MIOS32_UART_RxBufferGet+0x54>)
 8008278:	5d1a      	ldrb	r2, [r3, r4]
 800827a:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 800827e:	5c8d      	ldrb	r5, [r1, r2]
  if( ++rx_buffer_tail[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8008280:	5d1a      	ldrb	r2, [r3, r4]
 8008282:	3201      	adds	r2, #1
 8008284:	b2d2      	uxtb	r2, r2
 8008286:	551a      	strb	r2, [r3, r4]
 8008288:	5d1a      	ldrb	r2, [r3, r4]
 800828a:	2a3f      	cmp	r2, #63	; 0x3f
 800828c:	d901      	bls.n	8008292 <MIOS32_UART_RxBufferGet+0x3a>
    rx_buffer_tail[uart] = 0;
 800828e:	2200      	movs	r2, #0
 8008290:	551a      	strb	r2, [r3, r4]
  --rx_buffer_size[uart];
 8008292:	4b04      	ldr	r3, [pc, #16]	; (80082a4 <MIOS32_UART_RxBufferGet+0x4c>)
 8008294:	5d1a      	ldrb	r2, [r3, r4]
 8008296:	3a01      	subs	r2, #1
 8008298:	b2d2      	uxtb	r2, r2
 800829a:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 800829c:	f7fe fa38 	bl	8006710 <MIOS32_IRQ_Enable>

  return b; // return received byte
 80082a0:	4628      	mov	r0, r5
#endif
}
 80082a2:	bd38      	pop	{r3, r4, r5, pc}
 80082a4:	20000adc 	.word	0x20000adc
 80082a8:	20000ae0 	.word	0x20000ae0
 80082ac:	20000b64 	.word	0x20000b64

080082b0 <MIOS32_UART_RxBufferPut>:
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80082b0:	2801      	cmp	r0, #1
//! \return -1 if UART not available
//! \return -2 if buffer full (retry)
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
 80082b2:	b538      	push	{r3, r4, r5, lr}
 80082b4:	4604      	mov	r4, r0
 80082b6:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 80082b8:	bf88      	it	hi
 80082ba:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80082be:	d81f      	bhi.n	8008300 <MIOS32_UART_RxBufferPut+0x50>
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 80082c0:	4b10      	ldr	r3, [pc, #64]	; (8008304 <MIOS32_UART_RxBufferPut+0x54>)
 80082c2:	5d1b      	ldrb	r3, [r3, r4]
 80082c4:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full (retry)
 80082c6:	bf88      	it	hi
 80082c8:	f06f 0001 	mvnhi.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 80082cc:	d818      	bhi.n	8008300 <MIOS32_UART_RxBufferPut+0x50>
    return -2; // buffer full (retry)

  // copy received byte into receive buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 80082ce:	f7fe fa09 	bl	80066e4 <MIOS32_IRQ_Disable>
  rx_buffer[uart][rx_buffer_head[uart]] = b;
 80082d2:	4b0d      	ldr	r3, [pc, #52]	; (8008308 <MIOS32_UART_RxBufferPut+0x58>)
 80082d4:	490d      	ldr	r1, [pc, #52]	; (800830c <MIOS32_UART_RxBufferPut+0x5c>)
 80082d6:	5d1a      	ldrb	r2, [r3, r4]
 80082d8:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 80082dc:	548d      	strb	r5, [r1, r2]
  if( ++rx_buffer_head[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 80082de:	5d1a      	ldrb	r2, [r3, r4]
 80082e0:	3201      	adds	r2, #1
 80082e2:	b2d2      	uxtb	r2, r2
 80082e4:	551a      	strb	r2, [r3, r4]
 80082e6:	5d1a      	ldrb	r2, [r3, r4]
 80082e8:	2a3f      	cmp	r2, #63	; 0x3f
 80082ea:	d901      	bls.n	80082f0 <MIOS32_UART_RxBufferPut+0x40>
    rx_buffer_head[uart] = 0;
 80082ec:	2200      	movs	r2, #0
 80082ee:	551a      	strb	r2, [r3, r4]
  ++rx_buffer_size[uart];
 80082f0:	4b04      	ldr	r3, [pc, #16]	; (8008304 <MIOS32_UART_RxBufferPut+0x54>)
 80082f2:	5d1a      	ldrb	r2, [r3, r4]
 80082f4:	3201      	adds	r2, #1
 80082f6:	b2d2      	uxtb	r2, r2
 80082f8:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 80082fa:	f7fe fa09 	bl	8006710 <MIOS32_IRQ_Enable>

  return 0; // no error
 80082fe:	2000      	movs	r0, #0
#endif
}
 8008300:	bd38      	pop	{r3, r4, r5, pc}
 8008302:	bf00      	nop
 8008304:	20000adc 	.word	0x20000adc
 8008308:	20000be4 	.word	0x20000be4
 800830c:	20000b64 	.word	0x20000b64

08008310 <MIOS32_UART_TxBufferGet>:
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008310:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: transmitted byte
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
 8008312:	b538      	push	{r3, r4, r5, lr}
 8008314:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8008316:	bf88      	it	hi
 8008318:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 800831c:	d81d      	bhi.n	800835a <MIOS32_UART_TxBufferGet+0x4a>
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 800831e:	4b0f      	ldr	r3, [pc, #60]	; (800835c <MIOS32_UART_TxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 8008320:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 8008324:	5d1b      	ldrb	r3, [r3, r4]
 8008326:	b1c3      	cbz	r3, 800835a <MIOS32_UART_TxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8008328:	f7fe f9dc 	bl	80066e4 <MIOS32_IRQ_Disable>
  u8 b = tx_buffer[uart][tx_buffer_tail[uart]];
 800832c:	4b0c      	ldr	r3, [pc, #48]	; (8008360 <MIOS32_UART_TxBufferGet+0x50>)
 800832e:	490d      	ldr	r1, [pc, #52]	; (8008364 <MIOS32_UART_TxBufferGet+0x54>)
 8008330:	5d1a      	ldrb	r2, [r3, r4]
 8008332:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 8008336:	5c8d      	ldrb	r5, [r1, r2]
  if( ++tx_buffer_tail[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 8008338:	5d1a      	ldrb	r2, [r3, r4]
 800833a:	3201      	adds	r2, #1
 800833c:	b2d2      	uxtb	r2, r2
 800833e:	551a      	strb	r2, [r3, r4]
 8008340:	5d1a      	ldrb	r2, [r3, r4]
 8008342:	2a3f      	cmp	r2, #63	; 0x3f
 8008344:	d901      	bls.n	800834a <MIOS32_UART_TxBufferGet+0x3a>
    tx_buffer_tail[uart] = 0;
 8008346:	2200      	movs	r2, #0
 8008348:	551a      	strb	r2, [r3, r4]
  --tx_buffer_size[uart];
 800834a:	4b04      	ldr	r3, [pc, #16]	; (800835c <MIOS32_UART_TxBufferGet+0x4c>)
 800834c:	5d1a      	ldrb	r2, [r3, r4]
 800834e:	3a01      	subs	r2, #1
 8008350:	b2d2      	uxtb	r2, r2
 8008352:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 8008354:	f7fe f9dc 	bl	8006710 <MIOS32_IRQ_Enable>

  return b; // return transmitted byte
 8008358:	4628      	mov	r0, r5
#endif
}
 800835a:	bd38      	pop	{r3, r4, r5, pc}
 800835c:	20000be8 	.word	0x20000be8
 8008360:	20000ad8 	.word	0x20000ad8
 8008364:	20000ae4 	.word	0x20000ae4

08008368 <MIOS32_UART_TxBufferPutMore_NonBlocking>:
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 8008368:	b5f0      	push	{r4, r5, r6, r7, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 800836a:	2801      	cmp	r0, #1
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 800836c:	4604      	mov	r4, r0
 800836e:	b087      	sub	sp, #28
 8008370:	460d      	mov	r5, r1
 8008372:	4617      	mov	r7, r2
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8008374:	bf88      	it	hi
 8008376:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 800837a:	d852      	bhi.n	8008422 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 800837c:	4e2a      	ldr	r6, [pc, #168]	; (8008428 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc0>)
 800837e:	5d33      	ldrb	r3, [r6, r4]
 8008380:	18d3      	adds	r3, r2, r3
 8008382:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full or cannot get all requested bytes (retry)
 8008384:	bfc8      	it	gt
 8008386:	f06f 0001 	mvngt.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 800838a:	dc4a      	bgt.n	8008422 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -2; // buffer full or cannot get all requested bytes (retry)

  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 800838c:	f7fe f9aa 	bl	80066e4 <MIOS32_IRQ_Disable>

  u16 i;
  for(i=0; i<len; ++i) {
 8008390:	2200      	movs	r2, #0
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 8008392:	4b26      	ldr	r3, [pc, #152]	; (800842c <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc4>)

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008394:	4826      	ldr	r0, [pc, #152]	; (8008430 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc8>)
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008396:	4927      	ldr	r1, [pc, #156]	; (8008434 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xcc>)
 8008398:	9701      	str	r7, [sp, #4]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 800839a:	e03c      	b.n	8008416 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xae>
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 800839c:	f813 c004 	ldrb.w	ip, [r3, r4]
 80083a0:	f815 7b01 	ldrb.w	r7, [r5], #1
 80083a4:	f8df e090 	ldr.w	lr, [pc, #144]	; 8008438 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xd0>
 80083a8:	eb0c 1c84 	add.w	ip, ip, r4, lsl #6
 80083ac:	f80e 700c 	strb.w	r7, [lr, ip]

    if( ++tx_buffer_head[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 80083b0:	f813 c004 	ldrb.w	ip, [r3, r4]
 80083b4:	f10c 0c01 	add.w	ip, ip, #1
 80083b8:	fa5f fc8c 	uxtb.w	ip, ip
 80083bc:	f803 c004 	strb.w	ip, [r3, r4]
 80083c0:	f813 c004 	ldrb.w	ip, [r3, r4]
 80083c4:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
      tx_buffer_head[uart] = 0;
 80083c8:	bf84      	itt	hi
 80083ca:	f04f 0c00 	movhi.w	ip, #0
 80083ce:	f803 c004 	strbhi.w	ip, [r3, r4]

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
 80083d2:	f816 c004 	ldrb.w	ip, [r6, r4]
 80083d6:	f10c 0c01 	add.w	ip, ip, #1
 80083da:	fa5f fc8c 	uxtb.w	ip, ip
 80083de:	f806 c004 	strb.w	ip, [r6, r4]
 80083e2:	f816 c004 	ldrb.w	ip, [r6, r4]
 80083e6:	f1bc 0f01 	cmp.w	ip, #1
 80083ea:	d112      	bne.n	8008412 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xaa>
      switch( uart ) {
 80083ec:	2c01      	cmp	r4, #1
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083ee:	bf15      	itete	ne
 80083f0:	f8b1 c00c 	ldrhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083f4:	f8b0 c00c 	ldrheq.w	ip, [r0, #12]
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083f8:	fa1f fc8c 	uxthne.w	ip, ip
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80083fc:	fa1f fc8c 	uxtheq.w	ip, ip
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008400:	bf15      	itete	ne
 8008402:	f04c 0c80 	orrne.w	ip, ip, #128	; 0x80
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008406:	f04c 0c80 	orreq.w	ip, ip, #128	; 0x80
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 800840a:	f8a1 c00c 	strhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 800840e:	f8a0 c00c 	strheq.w	ip, [r0, #12]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 8008412:	3201      	adds	r2, #1
 8008414:	b292      	uxth	r2, r2
 8008416:	9f01      	ldr	r7, [sp, #4]
 8008418:	42ba      	cmp	r2, r7
 800841a:	d3bf      	bcc.n	800839c <MIOS32_UART_TxBufferPutMore_NonBlocking+0x34>
        default: MIOS32_IRQ_Enable(); return -3; // uart not supported by routine (yet)
      }
    }
  }

  MIOS32_IRQ_Enable();
 800841c:	f7fe f978 	bl	8006710 <MIOS32_IRQ_Enable>

  return 0; // no error
 8008420:	2000      	movs	r0, #0
#endif
}
 8008422:	b007      	add	sp, #28
 8008424:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008426:	bf00      	nop
 8008428:	20000be8 	.word	0x20000be8
 800842c:	20000bf4 	.word	0x20000bf4
 8008430:	40004800 	.word	0x40004800
 8008434:	40013800 	.word	0x40013800
 8008438:	20000ae4 	.word	0x20000ae4

0800843c <MIOS32_UART_TxBufferPutMore>:
//! \return -1 if UART not available
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore(u8 uart, u8 *buffer, u16 len)
{
 800843c:	b570      	push	{r4, r5, r6, lr}
 800843e:	4605      	mov	r5, r0
 8008440:	460c      	mov	r4, r1
 8008442:	4616      	mov	r6, r2
  s32 error;

  while( (error=MIOS32_UART_TxBufferPutMore_NonBlocking(uart, buffer, len)) == -2 );
 8008444:	4628      	mov	r0, r5
 8008446:	4621      	mov	r1, r4
 8008448:	4632      	mov	r2, r6
 800844a:	f7ff ff8d 	bl	8008368 <MIOS32_UART_TxBufferPutMore_NonBlocking>
 800844e:	f110 0f02 	cmn.w	r0, #2
 8008452:	d0f7      	beq.n	8008444 <MIOS32_UART_TxBufferPutMore+0x8>

  return error;
}
 8008454:	bd70      	pop	{r4, r5, r6, pc}
	...

08008458 <USART1_IRQHandler>:
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8008458:	4b14      	ldr	r3, [pc, #80]	; (80084ac <USART1_IRQHandler+0x54>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
 800845a:	b510      	push	{r4, lr}
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 800845c:	881a      	ldrh	r2, [r3, #0]
 800845e:	f012 0f20 	tst.w	r2, #32
 8008462:	d009      	beq.n	8008478 <USART1_IRQHandler+0x20>
    u8 b = MIOS32_UART0->DR;
 8008464:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 8008466:	2020      	movs	r0, #32
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART0->DR;
 8008468:	b2e4      	uxtb	r4, r4

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 800846a:	4621      	mov	r1, r4
 800846c:	f7fd fd9c 	bl	8005fa8 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(0, b) < 0 ) {
 8008470:	b910      	cbnz	r0, 8008478 <USART1_IRQHandler+0x20>
 8008472:	4621      	mov	r1, r4
 8008474:	f7ff ff1c 	bl	80082b0 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
 8008478:	4c0c      	ldr	r4, [pc, #48]	; (80084ac <USART1_IRQHandler+0x54>)
 800847a:	8823      	ldrh	r3, [r4, #0]
 800847c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008480:	d013      	beq.n	80084aa <USART1_IRQHandler+0x52>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 8008482:	4b0b      	ldr	r3, [pc, #44]	; (80084b0 <USART1_IRQHandler+0x58>)
 8008484:	781b      	ldrb	r3, [r3, #0]
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
 8008486:	b153      	cbz	r3, 800849e <USART1_IRQHandler+0x46>
      s32 b = MIOS32_UART_TxBufferGet(0);
 8008488:	2000      	movs	r0, #0
 800848a:	f7ff ff41 	bl	8008310 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 800848e:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
      } else {
	MIOS32_UART0->DR = b;
 8008490:	bfa4      	itt	ge
 8008492:	b280      	uxthge	r0, r0
 8008494:	80a0      	strhge	r0, [r4, #4]
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(0);
      if( b < 0 ) {
 8008496:	da08      	bge.n	80084aa <USART1_IRQHandler+0x52>
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
 8008498:	23ff      	movs	r3, #255	; 0xff
 800849a:	80a3      	strh	r3, [r4, #4]
 800849c:	e005      	b.n	80084aa <USART1_IRQHandler+0x52>
      } else {
	MIOS32_UART0->DR = b;
      }
    } else {
      MIOS32_UART0->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 800849e:	89a3      	ldrh	r3, [r4, #12]
 80084a0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80084a4:	041b      	lsls	r3, r3, #16
 80084a6:	0c1b      	lsrs	r3, r3, #16
 80084a8:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 80084aa:	bd10      	pop	{r4, pc}
 80084ac:	40013800 	.word	0x40013800
 80084b0:	20000be8 	.word	0x20000be8

080084b4 <USART3_IRQHandler>:
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 80084b4:	4b15      	ldr	r3, [pc, #84]	; (800850c <USART3_IRQHandler+0x58>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
 80084b6:	b510      	push	{r4, lr}
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 80084b8:	881a      	ldrh	r2, [r3, #0]
 80084ba:	f012 0f20 	tst.w	r2, #32
 80084be:	d00a      	beq.n	80084d6 <USART3_IRQHandler+0x22>
    u8 b = MIOS32_UART1->DR;
 80084c0:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 80084c2:	2021      	movs	r0, #33	; 0x21
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART1->DR;
 80084c4:	b2e4      	uxtb	r4, r4

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 80084c6:	4621      	mov	r1, r4
 80084c8:	f7fd fd6e 	bl	8005fa8 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(1, b) < 0 ) {
 80084cc:	b918      	cbnz	r0, 80084d6 <USART3_IRQHandler+0x22>
 80084ce:	3001      	adds	r0, #1
 80084d0:	4621      	mov	r1, r4
 80084d2:	f7ff feed 	bl	80082b0 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
 80084d6:	4c0d      	ldr	r4, [pc, #52]	; (800850c <USART3_IRQHandler+0x58>)
 80084d8:	8823      	ldrh	r3, [r4, #0]
 80084da:	f013 0f80 	tst.w	r3, #128	; 0x80
 80084de:	d013      	beq.n	8008508 <USART3_IRQHandler+0x54>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 80084e0:	4b0b      	ldr	r3, [pc, #44]	; (8008510 <USART3_IRQHandler+0x5c>)
 80084e2:	785b      	ldrb	r3, [r3, #1]
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
 80084e4:	b153      	cbz	r3, 80084fc <USART3_IRQHandler+0x48>
      s32 b = MIOS32_UART_TxBufferGet(1);
 80084e6:	2001      	movs	r0, #1
 80084e8:	f7ff ff12 	bl	8008310 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 80084ec:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
      } else {
	MIOS32_UART1->DR = b;
 80084ee:	bfa4      	itt	ge
 80084f0:	b280      	uxthge	r0, r0
 80084f2:	80a0      	strhge	r0, [r4, #4]
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(1);
      if( b < 0 ) {
 80084f4:	da08      	bge.n	8008508 <USART3_IRQHandler+0x54>
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
 80084f6:	23ff      	movs	r3, #255	; 0xff
 80084f8:	80a3      	strh	r3, [r4, #4]
 80084fa:	e005      	b.n	8008508 <USART3_IRQHandler+0x54>
      } else {
	MIOS32_UART1->DR = b;
      }
    } else {
      MIOS32_UART1->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 80084fc:	89a3      	ldrh	r3, [r4, #12]
 80084fe:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008502:	041b      	lsls	r3, r3, #16
 8008504:	0c1b      	lsrs	r3, r3, #16
 8008506:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 8008508:	bd10      	pop	{r4, pc}
 800850a:	bf00      	nop
 800850c:	40004800 	.word	0x40004800
 8008510:	20000be8 	.word	0x20000be8

08008514 <USART2_IRQHandler>:
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 8008514:	4b0e      	ldr	r3, [pc, #56]	; (8008550 <USART2_IRQHandler+0x3c>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
 8008516:	b510      	push	{r4, lr}
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 8008518:	881a      	ldrh	r2, [r3, #0]
 800851a:	f012 0f20 	tst.w	r2, #32
 800851e:	d00a      	beq.n	8008536 <USART2_IRQHandler+0x22>
    u8 b = MIOS32_UART2->DR;
 8008520:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 8008522:	2022      	movs	r0, #34	; 0x22
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART2->DR;
 8008524:	b2e4      	uxtb	r4, r4

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 8008526:	4621      	mov	r1, r4
 8008528:	f7fd fd3e 	bl	8005fa8 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(2, b) < 0 ) {
 800852c:	b918      	cbnz	r0, 8008536 <USART2_IRQHandler+0x22>
 800852e:	3002      	adds	r0, #2
 8008530:	4621      	mov	r1, r4
 8008532:	f7ff febd 	bl	80082b0 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART2->SR & (1 << 7) ) { // check if TXE flag is set
 8008536:	4a06      	ldr	r2, [pc, #24]	; (8008550 <USART2_IRQHandler+0x3c>)
 8008538:	8813      	ldrh	r3, [r2, #0]
 800853a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800853e:	d005      	beq.n	800854c <USART2_IRQHandler+0x38>
	MIOS32_UART2->DR = 0xff;
      } else {
	MIOS32_UART2->DR = b;
      }
    } else {
      MIOS32_UART2->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 8008540:	8993      	ldrh	r3, [r2, #12]
 8008542:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008546:	041b      	lsls	r3, r3, #16
 8008548:	0c1b      	lsrs	r3, r3, #16
 800854a:	8193      	strh	r3, [r2, #12]
    }
  }
}
 800854c:	bd10      	pop	{r4, pc}
 800854e:	bf00      	nop
 8008550:	40004400 	.word	0x40004400

08008554 <I2C2_EV_IRQHandler>:
/////////////////////////////////////////////////////////////////////////////
// interrupt vectors
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
 8008554:	b570      	push	{r4, r5, r6, lr}
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8008556:	4c68      	ldr	r4, [pc, #416]	; (80086f8 <I2C2_EV_IRQHandler+0x1a4>)
 8008558:	6820      	ldr	r0, [r4, #0]
 800855a:	f000 fce4 	bl	8008f26 <I2C_GetLastEvent>
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 800855e:	4b67      	ldr	r3, [pc, #412]	; (80086fc <I2C2_EV_IRQHandler+0x1a8>)
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8008560:	4605      	mov	r5, r0
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 8008562:	ea00 0303 	and.w	r3, r0, r3
 8008566:	2b00      	cmp	r3, #0
 8008568:	d033      	beq.n	80085d2 <I2C2_EV_IRQHandler+0x7e>
 800856a:	68e3      	ldr	r3, [r4, #12]
 800856c:	2b00      	cmp	r3, #0
 800856e:	d030      	beq.n	80085d2 <I2C2_EV_IRQHandler+0x7e>
    // get received data
    b = I2C_ReceiveData(iicx->base);
 8008570:	6820      	ldr	r0, [r4, #0]
 8008572:	f000 fccd 	bl	8008f10 <I2C_ReceiveData>

    // failsave: still place in buffer?
    if( iicx->buffer_ix < iicx->buffer_len )
 8008576:	8a62      	ldrh	r2, [r4, #18]
 8008578:	8a23      	ldrh	r3, [r4, #16]
 800857a:	b292      	uxth	r2, r2
 800857c:	b29b      	uxth	r3, r3
 800857e:	429a      	cmp	r2, r3
 8008580:	d206      	bcs.n	8008590 <I2C2_EV_IRQHandler+0x3c>
      iicx->rx_buffer_ptr[iicx->buffer_ix++] = b;
 8008582:	8a63      	ldrh	r3, [r4, #18]
 8008584:	68e2      	ldr	r2, [r4, #12]
 8008586:	b29b      	uxth	r3, r3
 8008588:	54d0      	strb	r0, [r2, r3]
 800858a:	3301      	adds	r3, #1
 800858c:	b29b      	uxth	r3, r3
 800858e:	8263      	strh	r3, [r4, #18]

    // last byte received, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8008590:	4b59      	ldr	r3, [pc, #356]	; (80086f8 <I2C2_EV_IRQHandler+0x1a4>)
 8008592:	695a      	ldr	r2, [r3, #20]
 8008594:	f012 0f02 	tst.w	r2, #2
 8008598:	d13e      	bne.n	8008618 <I2C2_EV_IRQHandler+0xc4>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    }
 
    // request NAK and stop condition before receiving last data
    if( (iicx->buffer_ix >= iicx->buffer_len-1) || (iicx->transfer_state.ABORT_IF_FIRST_BYTE_0 && iicx->buffer_ix == 1 && b == 0x00) ) {
 800859a:	8a59      	ldrh	r1, [r3, #18]
 800859c:	8a1a      	ldrh	r2, [r3, #16]
 800859e:	b289      	uxth	r1, r1
 80085a0:	b292      	uxth	r2, r2
 80085a2:	3a01      	subs	r2, #1
 80085a4:	4291      	cmp	r1, r2
 80085a6:	da0c      	bge.n	80085c2 <I2C2_EV_IRQHandler+0x6e>
 80085a8:	695a      	ldr	r2, [r3, #20]
 80085aa:	f012 0f04 	tst.w	r2, #4
 80085ae:	f000 80a1 	beq.w	80086f4 <I2C2_EV_IRQHandler+0x1a0>
 80085b2:	8a5b      	ldrh	r3, [r3, #18]
 80085b4:	b29b      	uxth	r3, r3
 80085b6:	2b01      	cmp	r3, #1
 80085b8:	f040 809c 	bne.w	80086f4 <I2C2_EV_IRQHandler+0x1a0>
 80085bc:	2800      	cmp	r0, #0
 80085be:	f040 8099 	bne.w	80086f4 <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80085c2:	4c4d      	ldr	r4, [pc, #308]	; (80086f8 <I2C2_EV_IRQHandler+0x1a4>)
 80085c4:	2100      	movs	r1, #0
 80085c6:	6820      	ldr	r0, [r4, #0]
 80085c8:	f000 fc88 	bl	8008edc <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80085cc:	6820      	ldr	r0, [r4, #0]
 80085ce:	2101      	movs	r1, #1
 80085d0:	e011      	b.n	80085f6 <I2C2_EV_IRQHandler+0xa2>
  }

  // ADDR set, TRA flag not set (indicates transmitter/receiver mode).
  // ADDR will be cleared by a read of SR1 followed by a read of SR2 (done by I2C_GetLastEvent)
  // If transmitter mode is selected (TRA set), we go on, TXE will be catched to send the first byte
  if( (event & I2C_FLAG_ADDR) && !(event & I2C_FLAG_TRA) ){
 80085d2:	4b4b      	ldr	r3, [pc, #300]	; (8008700 <I2C2_EV_IRQHandler+0x1ac>)
 80085d4:	ea05 0303 	and.w	r3, r5, r3
 80085d8:	b1a3      	cbz	r3, 8008604 <I2C2_EV_IRQHandler+0xb0>
 80085da:	f415 2180 	ands.w	r1, r5, #262144	; 0x40000
 80085de:	d111      	bne.n	8008604 <I2C2_EV_IRQHandler+0xb0>
    // address sent (receiver mode), receiving first byte - check if we already have to request NAK/Stop
    if( iicx->buffer_len == 1 ) {
 80085e0:	4c45      	ldr	r4, [pc, #276]	; (80086f8 <I2C2_EV_IRQHandler+0x1a4>)
 80085e2:	8a25      	ldrh	r5, [r4, #16]
 80085e4:	b2ad      	uxth	r5, r5
 80085e6:	2d01      	cmp	r5, #1
 80085e8:	f040 8084 	bne.w	80086f4 <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80085ec:	6820      	ldr	r0, [r4, #0]
 80085ee:	f000 fc75 	bl	8008edc <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80085f2:	6820      	ldr	r0, [r4, #0]
 80085f4:	4629      	mov	r1, r5
 80085f6:	f000 fc64 	bl	8008ec2 <I2C_GenerateSTOP>
      iicx->transfer_state.STOP_REQUESTED = 1;
 80085fa:	6963      	ldr	r3, [r4, #20]
 80085fc:	f043 0302 	orr.w	r3, r3, #2
 8008600:	6163      	str	r3, [r4, #20]
 8008602:	e077      	b.n	80086f4 <I2C2_EV_IRQHandler+0x1a0>

  // TxE set, will be cleared by writing DR, or after START or STOP was generated
  // This handling also applies for BTF, as TXE will alway be set if BTF is.
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  if( event & I2C_FLAG_TXE ){
 8008604:	4a3f      	ldr	r2, [pc, #252]	; (8008704 <I2C2_EV_IRQHandler+0x1b0>)
 8008606:	ea05 0202 	and.w	r2, r5, r2
 800860a:	2a00      	cmp	r2, #0
 800860c:	d03e      	beq.n	800868c <I2C2_EV_IRQHandler+0x138>

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 800860e:	4b3a      	ldr	r3, [pc, #232]	; (80086f8 <I2C2_EV_IRQHandler+0x1a4>)
 8008610:	695a      	ldr	r2, [r3, #20]
 8008612:	f012 0f02 	tst.w	r2, #2
 8008616:	d007      	beq.n	8008628 <I2C2_EV_IRQHandler+0xd4>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008618:	695a      	ldr	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 800861a:	6818      	ldr	r0, [r3, #0]
  if( event & I2C_FLAG_TXE ){

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800861c:	f36f 0200 	bfc	r2, #0, #1
 8008620:	615a      	str	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008622:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8008626:	e02f      	b.n	8008688 <I2C2_EV_IRQHandler+0x134>
      return;
    }

    if( iicx->buffer_ix < iicx->buffer_len ) {
 8008628:	8a59      	ldrh	r1, [r3, #18]
 800862a:	8a1a      	ldrh	r2, [r3, #16]
 800862c:	b289      	uxth	r1, r1
 800862e:	b292      	uxth	r2, r2
 8008630:	4291      	cmp	r1, r2
 8008632:	d20b      	bcs.n	800864c <I2C2_EV_IRQHandler+0xf8>
      // checking tx_buffer_ptr for NULL is a failsafe measure.
      I2C_SendData(iicx->base, (iicx->tx_buffer_ptr == NULL) ? 0 : iicx->tx_buffer_ptr[iicx->buffer_ix++]);
 8008634:	6899      	ldr	r1, [r3, #8]
 8008636:	6818      	ldr	r0, [r3, #0]
 8008638:	b129      	cbz	r1, 8008646 <I2C2_EV_IRQHandler+0xf2>
 800863a:	8a5a      	ldrh	r2, [r3, #18]
 800863c:	b292      	uxth	r2, r2
 800863e:	5c89      	ldrb	r1, [r1, r2]
 8008640:	3201      	adds	r2, #1
 8008642:	b292      	uxth	r2, r2
 8008644:	825a      	strh	r2, [r3, #18]
 8008646:	f000 fc61 	bl	8008f0c <I2C_SendData>
 800864a:	e053      	b.n	80086f4 <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 

    // peripheral is transfering last byte, request stop condition /
    // on write-without-stop transfer-type, request start condition instead
    if( !iicx->transfer_state.WRITE_WITHOUT_STOP )
 800864c:	695a      	ldr	r2, [r3, #20]
 800864e:	f012 0f08 	tst.w	r2, #8
 8008652:	d104      	bne.n	800865e <I2C2_EV_IRQHandler+0x10a>
      I2C_GenerateSTOP(iicx->base, ENABLE);
 8008654:	6818      	ldr	r0, [r3, #0]
 8008656:	2101      	movs	r1, #1
 8008658:	f000 fc33 	bl	8008ec2 <I2C_GenerateSTOP>
 800865c:	e003      	b.n	8008666 <I2C2_EV_IRQHandler+0x112>
    else
      I2C_GenerateSTART(iicx->base, ENABLE);
 800865e:	6818      	ldr	r0, [r3, #0]
 8008660:	2101      	movs	r1, #1
 8008662:	f000 fc21 	bl	8008ea8 <I2C_GenerateSTART>
    iicx->transfer_state.STOP_REQUESTED = 1;
 8008666:	4b24      	ldr	r3, [pc, #144]	; (80086f8 <I2C2_EV_IRQHandler+0x1a4>)
 8008668:	695a      	ldr	r2, [r3, #20]
 800866a:	f042 0202 	orr.w	r2, r2, #2
 800866e:	615a      	str	r2, [r3, #20]

    if( iicx->buffer_len == 0 ) {
 8008670:	8a1a      	ldrh	r2, [r3, #16]
 8008672:	b292      	uxth	r2, r2
 8008674:	b92a      	cbnz	r2, 8008682 <I2C2_EV_IRQHandler+0x12e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008676:	6959      	ldr	r1, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008678:	6818      	ldr	r0, [r3, #0]
      I2C_GenerateSTART(iicx->base, ENABLE);
    iicx->transfer_state.STOP_REQUESTED = 1;

    if( iicx->buffer_len == 0 ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800867a:	f362 0100 	bfi	r1, r2, #0, #1
 800867e:	6159      	str	r1, [r3, #20]
 8008680:	e012      	b.n	80086a8 <I2C2_EV_IRQHandler+0x154>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
    } else {
      // Disable the I2C_IT_BUF interrupt after sending the last buffer data 
      // (last EV8) to not allow a new interrupt just with TxE - only BTF will generate it
      // if this is not done, BUSY will be cleared before the transfer is finished
      I2C_ITConfig(iicx->base, I2C_IT_BUF, DISABLE);
 8008682:	6818      	ldr	r0, [r3, #0]
 8008684:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008688:	2200      	movs	r2, #0
 800868a:	e00f      	b.n	80086ac <I2C2_EV_IRQHandler+0x158>
    }
  return;
  }

  // SB set, cleared by reading SR1 (done by I2C_GetLastEvent) followed by writing DR register
  if( event & I2C_FLAG_SB ){
 800868c:	4e1e      	ldr	r6, [pc, #120]	; (8008708 <I2C2_EV_IRQHandler+0x1b4>)
 800868e:	4c1a      	ldr	r4, [pc, #104]	; (80086f8 <I2C2_EV_IRQHandler+0x1a4>)
 8008690:	ea05 0606 	and.w	r6, r5, r6
 8008694:	b1a6      	cbz	r6, 80086c0 <I2C2_EV_IRQHandler+0x16c>
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8008696:	6963      	ldr	r3, [r4, #20]
 8008698:	f013 0f02 	tst.w	r3, #2
 800869c:	d009      	beq.n	80086b2 <I2C2_EV_IRQHandler+0x15e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800869e:	6963      	ldr	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80086a0:	6820      	ldr	r0, [r4, #0]
  if( event & I2C_FLAG_SB ){
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 80086a2:	f362 0300 	bfi	r3, r2, #0, #1
 80086a6:	6163      	str	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80086a8:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 80086ac:	f000 fc23 	bl	8008ef6 <I2C_ITConfig>
 80086b0:	e020      	b.n	80086f4 <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
      (iicx->iic_address & 1)
 80086b2:	7921      	ldrb	r1, [r4, #4]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
 80086b4:	6820      	ldr	r0, [r4, #0]
 80086b6:	f001 0201 	and.w	r2, r1, #1
 80086ba:	f000 fc2c 	bl	8008f16 <I2C_Send7bitAddress>
 80086be:	e019      	b.n	80086f4 <I2C2_EV_IRQHandler+0x1a0>
  }

  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80086c0:	4632      	mov	r2, r6
 80086c2:	6820      	ldr	r0, [r4, #0]
 80086c4:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 80086c8:	f000 fc15 	bl	8008ef6 <I2C_ITConfig>
  // notify error
  MIOS32_IIC_unexpected_event = event;
 80086cc:	4b0f      	ldr	r3, [pc, #60]	; (800870c <I2C2_EV_IRQHandler+0x1b8>)
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80086ce:	4631      	mov	r1, r6
  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
 80086d0:	601d      	str	r5, [r3, #0]
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
 80086d2:	f06f 0307 	mvn.w	r3, #7
 80086d6:	61a3      	str	r3, [r4, #24]
  iicx->transfer_state.BUSY = 0;
 80086d8:	6963      	ldr	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80086da:	6820      	ldr	r0, [r4, #0]
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
 80086dc:	f366 0300 	bfi	r3, r6, #0, #1
 80086e0:	6163      	str	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80086e2:	f000 fbfb 	bl	8008edc <I2C_AcknowledgeConfig>
  b = I2C_ReceiveData(iicx->base);
 80086e6:	6820      	ldr	r0, [r4, #0]
 80086e8:	f000 fc12 	bl	8008f10 <I2C_ReceiveData>
  I2C_GenerateSTOP(iicx->base, ENABLE);
 80086ec:	6820      	ldr	r0, [r4, #0]
 80086ee:	2101      	movs	r1, #1
 80086f0:	f000 fbe7 	bl	8008ec2 <I2C_GenerateSTOP>
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
  EV_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 80086f4:	bd70      	pop	{r4, r5, r6, pc}
 80086f6:	bf00      	nop
 80086f8:	20000bf8 	.word	0x20000bf8
 80086fc:	10000040 	.word	0x10000040
 8008700:	10000002 	.word	0x10000002
 8008704:	10000080 	.word	0x10000080
 8008708:	10000001 	.word	0x10000001
 800870c:	200037a4 	.word	0x200037a4

08008710 <I2C2_ER_IRQHandler>:

void I2C2_ER_IRQHandler(void)
{
 8008710:	b538      	push	{r3, r4, r5, lr}
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8008712:	4d1c      	ldr	r5, [pc, #112]	; (8008784 <I2C2_ER_IRQHandler+0x74>)
 8008714:	6828      	ldr	r0, [r5, #0]
 8008716:	f000 fc06 	bl	8008f26 <I2C_GetLastEvent>
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 800871a:	4b1b      	ldr	r3, [pc, #108]	; (8008788 <I2C2_ER_IRQHandler+0x78>)
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 800871c:	4604      	mov	r4, r0
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 800871e:	ea00 0303 	and.w	r3, r0, r3
 8008722:	b133      	cbz	r3, 8008732 <I2C2_ER_IRQHandler+0x22>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_BERR);
 8008724:	6828      	ldr	r0, [r5, #0]
 8008726:	4919      	ldr	r1, [pc, #100]	; (800878c <I2C2_ER_IRQHandler+0x7c>)
 8008728:	f000 fc05 	bl	8008f36 <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_BUS;
 800872c:	f06f 0305 	mvn.w	r3, #5
 8008730:	61ab      	str	r3, [r5, #24]
  }

  // arbitration lost
  if( event & I2C_FLAG_ARLO ) {
 8008732:	4b17      	ldr	r3, [pc, #92]	; (8008790 <I2C2_ER_IRQHandler+0x80>)
 8008734:	ea04 0303 	and.w	r3, r4, r3
 8008738:	b13b      	cbz	r3, 800874a <I2C2_ER_IRQHandler+0x3a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_ARLO);
 800873a:	4d12      	ldr	r5, [pc, #72]	; (8008784 <I2C2_ER_IRQHandler+0x74>)
 800873c:	4915      	ldr	r1, [pc, #84]	; (8008794 <I2C2_ER_IRQHandler+0x84>)
 800873e:	6828      	ldr	r0, [r5, #0]
 8008740:	f000 fbf9 	bl	8008f36 <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_ARBITRATION_LOST;
 8008744:	f06f 0304 	mvn.w	r3, #4
 8008748:	61ab      	str	r3, [r5, #24]
  }

  // no acknowledge received from slave (e.g. slave not connected)
  if( event & I2C_FLAG_AF ) {
 800874a:	4b13      	ldr	r3, [pc, #76]	; (8008798 <I2C2_ER_IRQHandler+0x88>)
 800874c:	ea04 0303 	and.w	r3, r4, r3
 8008750:	b15b      	cbz	r3, 800876a <I2C2_ER_IRQHandler+0x5a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_AF);
 8008752:	4c0c      	ldr	r4, [pc, #48]	; (8008784 <I2C2_ER_IRQHandler+0x74>)
 8008754:	4911      	ldr	r1, [pc, #68]	; (800879c <I2C2_ER_IRQHandler+0x8c>)
 8008756:	6820      	ldr	r0, [r4, #0]
 8008758:	f000 fbed 	bl	8008f36 <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_SLAVE_NOT_CONNECTED;
 800875c:	f06f 0306 	mvn.w	r3, #6
 8008760:	61a3      	str	r3, [r4, #24]
    // send stop condition to release bus
    I2C_GenerateSTOP(iicx->base, ENABLE);
 8008762:	6820      	ldr	r0, [r4, #0]
 8008764:	2101      	movs	r1, #1
 8008766:	f000 fbac 	bl	8008ec2 <I2C_GenerateSTOP>
  }

  // disable interrupts
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 800876a:	4c06      	ldr	r4, [pc, #24]	; (8008784 <I2C2_ER_IRQHandler+0x74>)
 800876c:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8008770:	6820      	ldr	r0, [r4, #0]
 8008772:	2200      	movs	r2, #0
 8008774:	f000 fbbf 	bl	8008ef6 <I2C_ITConfig>

  // notify that transfer has finished (due to the error)
  iicx->transfer_state.BUSY = 0;
 8008778:	6963      	ldr	r3, [r4, #20]
 800877a:	f36f 0300 	bfc	r3, #0, #1
 800877e:	6163      	str	r3, [r4, #20]
}

void I2C2_ER_IRQHandler(void)
{
  ER_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 8008780:	bd38      	pop	{r3, r4, r5, pc}
 8008782:	bf00      	nop
 8008784:	20000bf8 	.word	0x20000bf8
 8008788:	10000100 	.word	0x10000100
 800878c:	01000100 	.word	0x01000100
 8008790:	10000200 	.word	0x10000200
 8008794:	01000200 	.word	0x01000200
 8008798:	10000400 	.word	0x10000400
 800879c:	01000400 	.word	0x01000400

080087a0 <printchar>:

#include <stdarg.h>
#include <mios32.h>

static void printchar(char **str, int c)
{
 80087a0:	b508      	push	{r3, lr}
  //	extern int putchar(int c);
	
	if (str) {
 80087a2:	b128      	cbz	r0, 80087b0 <printchar+0x10>
		**str = c;
 80087a4:	6803      	ldr	r3, [r0, #0]
 80087a6:	7019      	strb	r1, [r3, #0]
		++(*str);
 80087a8:	6803      	ldr	r3, [r0, #0]
 80087aa:	3301      	adds	r3, #1
 80087ac:	6003      	str	r3, [r0, #0]
 80087ae:	e003      	b.n	80087b8 <printchar+0x18>
	}
#ifndef MIOS32_DONT_USE_COM
	else MIOS32_COM_SendChar(1, c); // (void)putchar(c);
 80087b0:	b2c9      	uxtb	r1, r1
 80087b2:	2001      	movs	r0, #1
 80087b4:	f7fd fc5e 	bl	8006074 <MIOS32_COM_SendChar>
#endif
}
 80087b8:	bd08      	pop	{r3, pc}

080087ba <prints>:

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 80087ba:	2a00      	cmp	r2, #0

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 80087bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80087be:	468c      	mov	ip, r1
 80087c0:	4604      	mov	r4, r0
 80087c2:	4615      	mov	r5, r2
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 80087c4:	dd10      	ble.n	80087e8 <prints+0x2e>
 80087c6:	2200      	movs	r2, #0
 80087c8:	e000      	b.n	80087cc <prints+0x12>
		register int len = 0;
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
 80087ca:	3201      	adds	r2, #1
 80087cc:	f81c 1002 	ldrb.w	r1, [ip, r2]
 80087d0:	2900      	cmp	r1, #0
 80087d2:	d1fa      	bne.n	80087ca <prints+0x10>
		if (len >= width) width = 0;
 80087d4:	42aa      	cmp	r2, r5
 80087d6:	bfac      	ite	ge
 80087d8:	460d      	movge	r5, r1
		else width -= len;
 80087da:	1aad      	sublt	r5, r5, r2
		if (pad & PAD_ZERO) padchar = '0';
 80087dc:	f013 0f02 	tst.w	r3, #2
 80087e0:	bf0c      	ite	eq
 80087e2:	2720      	moveq	r7, #32
 80087e4:	2730      	movne	r7, #48	; 0x30
 80087e6:	e000      	b.n	80087ea <prints+0x30>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 80087e8:	2720      	movs	r7, #32
		for (ptr = string; *ptr; ++ptr) ++len;
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
 80087ea:	f013 0601 	ands.w	r6, r3, #1
 80087ee:	d10d      	bne.n	800880c <prints+0x52>
 80087f0:	e009      	b.n	8008806 <prints+0x4c>
		for ( ; width > 0; --width) {
			printchar (out, padchar);
 80087f2:	4620      	mov	r0, r4
 80087f4:	4639      	mov	r1, r7
 80087f6:	f8cd c004 	str.w	ip, [sp, #4]
 80087fa:	f7ff ffd1 	bl	80087a0 <printchar>
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80087fe:	f8dd c004 	ldr.w	ip, [sp, #4]
			printchar (out, padchar);
			++pc;
 8008802:	3601      	adds	r6, #1
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 8008804:	3d01      	subs	r5, #1
 8008806:	2d00      	cmp	r5, #0
 8008808:	dcf3      	bgt.n	80087f2 <prints+0x38>
 800880a:	e000      	b.n	800880e <prints+0x54>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 800880c:	2600      	movs	r6, #0
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 800880e:	4663      	mov	r3, ip
 8008810:	e005      	b.n	800881e <prints+0x64>
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
 8008812:	4620      	mov	r0, r4
 8008814:	9301      	str	r3, [sp, #4]
 8008816:	f7ff ffc3 	bl	80087a0 <printchar>
		++pc;
 800881a:	9b01      	ldr	r3, [sp, #4]
 800881c:	3601      	adds	r6, #1
		for ( ; width > 0; --width) {
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
 800881e:	f813 1b01 	ldrb.w	r1, [r3], #1
 8008822:	2900      	cmp	r1, #0
 8008824:	d1f5      	bne.n	8008812 <prints+0x58>
 8008826:	e005      	b.n	8008834 <prints+0x7a>
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
		printchar (out, padchar);
 8008828:	4620      	mov	r0, r4
 800882a:	4639      	mov	r1, r7
 800882c:	f7ff ffb8 	bl	80087a0 <printchar>
		++pc;
 8008830:	3601      	adds	r6, #1
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
 8008832:	3d01      	subs	r5, #1
 8008834:	2d00      	cmp	r5, #0
 8008836:	dcf7      	bgt.n	8008828 <prints+0x6e>
		printchar (out, padchar);
		++pc;
	}

	return pc;
}
 8008838:	4630      	mov	r0, r6
 800883a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800883c <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 800883c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800883e:	b087      	sub	sp, #28
 8008840:	4604      	mov	r4, r0
 8008842:	461d      	mov	r5, r3
 8008844:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008846:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
	register unsigned int u = i;
 8008848:	4608      	mov	r0, r1

	if (i == 0) {
 800884a:	b951      	cbnz	r1, 8008862 <printi+0x26>
		print_buf[0] = '0';
 800884c:	2230      	movs	r2, #48	; 0x30
 800884e:	f88d 200c 	strb.w	r2, [sp, #12]
		print_buf[1] = '\0';
 8008852:	f88d 100d 	strb.w	r1, [sp, #13]
		return prints (out, print_buf, width, pad);
 8008856:	4620      	mov	r0, r4
 8008858:	a903      	add	r1, sp, #12
 800885a:	4632      	mov	r2, r6
 800885c:	f7ff ffad 	bl	80087ba <prints>
 8008860:	e043      	b.n	80088ea <printi+0xae>
	}

	if (sg && b == 10 && i < 0) {
 8008862:	2a0a      	cmp	r2, #10
 8008864:	bf14      	ite	ne
 8008866:	2100      	movne	r1, #0
 8008868:	2101      	moveq	r1, #1
 800886a:	2d00      	cmp	r5, #0
 800886c:	bf0c      	ite	eq
 800886e:	2500      	moveq	r5, #0
 8008870:	f001 0501 	andne.w	r5, r1, #1
 8008874:	b12d      	cbz	r5, 8008882 <printi+0x46>
 8008876:	2800      	cmp	r0, #0
 8008878:	da02      	bge.n	8008880 <printi+0x44>
		neg = 1;
		u = -i;
 800887a:	4240      	negs	r0, r0
		print_buf[1] = '\0';
		return prints (out, print_buf, width, pad);
	}

	if (sg && b == 10 && i < 0) {
		neg = 1;
 800887c:	2501      	movs	r5, #1
 800887e:	e000      	b.n	8008882 <printi+0x46>

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 8008880:	2500      	movs	r5, #0
	*s = '\0';

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 8008882:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
		neg = 1;
		u = -i;
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';
 8008886:	a906      	add	r1, sp, #24
 8008888:	f04f 0c00 	mov.w	ip, #0
 800888c:	f801 cd01 	strb.w	ip, [r1, #-1]!

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 8008890:	f1ae 0e3a 	sub.w	lr, lr, #58	; 0x3a
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 8008894:	e00d      	b.n	80088b2 <printi+0x76>
		t = u % b;
 8008896:	fbb0 fcf2 	udiv	ip, r0, r2
 800889a:	fb02 0c1c 	mls	ip, r2, ip, r0
		if( t >= 10 )
 800889e:	f1bc 0f09 	cmp.w	ip, #9
			t += letbase - '0' - 10;
 80088a2:	bfc8      	it	gt
 80088a4:	44f4      	addgt	ip, lr
		*--s = t + '0';
 80088a6:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80088aa:	f801 cd01 	strb.w	ip, [r1, #-1]!
		u /= b;
 80088ae:	fbb0 f0f2 	udiv	r0, r0, r2
 80088b2:	460f      	mov	r7, r1
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 80088b4:	2800      	cmp	r0, #0
 80088b6:	d1ee      	bne.n	8008896 <printi+0x5a>
			t += letbase - '0' - 10;
		*--s = t + '0';
		u /= b;
	}

	if (neg) {
 80088b8:	b18d      	cbz	r5, 80088de <printi+0xa2>
		if( width && (pad & PAD_ZERO) ) {
 80088ba:	b15e      	cbz	r6, 80088d4 <printi+0x98>
 80088bc:	f013 0f02 	tst.w	r3, #2
 80088c0:	d008      	beq.n	80088d4 <printi+0x98>
			printchar (out, '-');
 80088c2:	4620      	mov	r0, r4
 80088c4:	212d      	movs	r1, #45	; 0x2d
 80088c6:	9301      	str	r3, [sp, #4]
			++pc;
			--width;
 80088c8:	3e01      	subs	r6, #1
		u /= b;
	}

	if (neg) {
		if( width && (pad & PAD_ZERO) ) {
			printchar (out, '-');
 80088ca:	f7ff ff69 	bl	80087a0 <printchar>
			++pc;
 80088ce:	2501      	movs	r5, #1
			--width;
 80088d0:	9b01      	ldr	r3, [sp, #4]
 80088d2:	e004      	b.n	80088de <printi+0xa2>
		}
		else {
			*--s = '-';
 80088d4:	222d      	movs	r2, #45	; 0x2d
 80088d6:	1e4f      	subs	r7, r1, #1
 80088d8:	f801 2c01 	strb.w	r2, [r1, #-1]

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 80088dc:	2500      	movs	r5, #0
		else {
			*--s = '-';
		}
	}

	return pc + prints (out, s, width, pad);
 80088de:	4620      	mov	r0, r4
 80088e0:	4639      	mov	r1, r7
 80088e2:	4632      	mov	r2, r6
 80088e4:	f7ff ff69 	bl	80087ba <prints>
 80088e8:	1940      	adds	r0, r0, r5
}
 80088ea:	b007      	add	sp, #28
 80088ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080088f0 <print>:

static int print( char **out, const char *format, va_list args )
{
 80088f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80088f2:	b089      	sub	sp, #36	; 0x24
 80088f4:	4606      	mov	r6, r0
 80088f6:	460d      	mov	r5, r1
 80088f8:	9205      	str	r2, [sp, #20]
	register int width, pad;
	register int pc = 0;
 80088fa:	2400      	movs	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
 80088fc:	e07a      	b.n	80089f4 <print+0x104>
		if (*format == '%') {
 80088fe:	2b25      	cmp	r3, #37	; 0x25
 8008900:	d172      	bne.n	80089e8 <print+0xf8>
			++format;
			width = pad = 0;
			if (*format == '\0') break;
 8008902:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8008906:	2b00      	cmp	r3, #0
 8008908:	d077      	beq.n	80089fa <print+0x10a>
			if (*format == '%') goto out;
 800890a:	2b25      	cmp	r3, #37	; 0x25
 800890c:	d06c      	beq.n	80089e8 <print+0xf8>
			if (*format == '-') {
 800890e:	2b2d      	cmp	r3, #45	; 0x2d
 8008910:	d102      	bne.n	8008918 <print+0x28>
				++format;
 8008912:	3501      	adds	r5, #1
				pad = PAD_RIGHT;
 8008914:	2301      	movs	r3, #1
 8008916:	e003      	b.n	8008920 <print+0x30>
	char scr[2];

	for (; *format != 0; ++format) {
		if (*format == '%') {
			++format;
			width = pad = 0;
 8008918:	2300      	movs	r3, #0
 800891a:	e001      	b.n	8008920 <print+0x30>
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
 800891c:	f043 0302 	orr.w	r3, r3, #2
 8008920:	462f      	mov	r7, r5
			if (*format == '%') goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
 8008922:	f815 2b01 	ldrb.w	r2, [r5], #1
 8008926:	2a30      	cmp	r2, #48	; 0x30
 8008928:	d0f8      	beq.n	800891c <print+0x2c>
 800892a:	2200      	movs	r2, #0
 800892c:	e002      	b.n	8008934 <print+0x44>
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
				width *= 10;
				width += *format - '0';
 800892e:	200a      	movs	r0, #10
 8008930:	fb00 c202 	mla	r2, r0, r2, ip
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 8008934:	7839      	ldrb	r1, [r7, #0]
				width *= 10;
				width += *format - '0';
 8008936:	463d      	mov	r5, r7
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 8008938:	f1a1 0c30 	sub.w	ip, r1, #48	; 0x30
 800893c:	fa5f f08c 	uxtb.w	r0, ip
 8008940:	3701      	adds	r7, #1
 8008942:	2809      	cmp	r0, #9
 8008944:	d9f3      	bls.n	800892e <print+0x3e>
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
 8008946:	2973      	cmp	r1, #115	; 0x73
 8008948:	d109      	bne.n	800895e <print+0x6e>
				register char *s = (char *)va_arg( args, int );
 800894a:	9905      	ldr	r1, [sp, #20]
 800894c:	1d08      	adds	r0, r1, #4
 800894e:	9005      	str	r0, [sp, #20]
 8008950:	6809      	ldr	r1, [r1, #0]
				pc += prints (out, s?s:"(null)", width, pad);
 8008952:	482d      	ldr	r0, [pc, #180]	; (8008a08 <print+0x118>)
 8008954:	2900      	cmp	r1, #0
 8008956:	bf08      	it	eq
 8008958:	4601      	moveq	r1, r0
 800895a:	4630      	mov	r0, r6
 800895c:	e041      	b.n	80089e2 <print+0xf2>
				continue;
			}
			if( *format == 'd' ) {
 800895e:	2964      	cmp	r1, #100	; 0x64
 8008960:	d10e      	bne.n	8008980 <print+0x90>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 8008962:	9905      	ldr	r1, [sp, #20]
 8008964:	9301      	str	r3, [sp, #4]
 8008966:	2361      	movs	r3, #97	; 0x61
 8008968:	9200      	str	r2, [sp, #0]
 800896a:	9302      	str	r3, [sp, #8]
 800896c:	1d08      	adds	r0, r1, #4
 800896e:	6809      	ldr	r1, [r1, #0]
 8008970:	9005      	str	r0, [sp, #20]
 8008972:	220a      	movs	r2, #10
 8008974:	4630      	mov	r0, r6
 8008976:	2301      	movs	r3, #1
 8008978:	f7ff ff60 	bl	800883c <printi>
 800897c:	1824      	adds	r4, r4, r0
				continue;
 800897e:	e038      	b.n	80089f2 <print+0x102>
			}
			if( *format == 'x' ) {
 8008980:	2978      	cmp	r1, #120	; 0x78
 8008982:	d106      	bne.n	8008992 <print+0xa2>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 8008984:	9905      	ldr	r1, [sp, #20]
 8008986:	9301      	str	r3, [sp, #4]
 8008988:	1d08      	adds	r0, r1, #4
 800898a:	9005      	str	r0, [sp, #20]
 800898c:	9200      	str	r2, [sp, #0]
 800898e:	2361      	movs	r3, #97	; 0x61
 8008990:	e007      	b.n	80089a2 <print+0xb2>
				continue;
			}
			if( *format == 'X' ) {
 8008992:	2958      	cmp	r1, #88	; 0x58
 8008994:	d10a      	bne.n	80089ac <print+0xbc>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 8008996:	9905      	ldr	r1, [sp, #20]
 8008998:	9301      	str	r3, [sp, #4]
 800899a:	1d08      	adds	r0, r1, #4
 800899c:	9005      	str	r0, [sp, #20]
 800899e:	9200      	str	r2, [sp, #0]
 80089a0:	2341      	movs	r3, #65	; 0x41
 80089a2:	9302      	str	r3, [sp, #8]
 80089a4:	4630      	mov	r0, r6
 80089a6:	6809      	ldr	r1, [r1, #0]
 80089a8:	2210      	movs	r2, #16
 80089aa:	e00b      	b.n	80089c4 <print+0xd4>
				continue;
			}
			if( *format == 'u' ) {
 80089ac:	2975      	cmp	r1, #117	; 0x75
 80089ae:	d10b      	bne.n	80089c8 <print+0xd8>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 80089b0:	9905      	ldr	r1, [sp, #20]
 80089b2:	9301      	str	r3, [sp, #4]
 80089b4:	2361      	movs	r3, #97	; 0x61
 80089b6:	9200      	str	r2, [sp, #0]
 80089b8:	9302      	str	r3, [sp, #8]
 80089ba:	1d08      	adds	r0, r1, #4
 80089bc:	6809      	ldr	r1, [r1, #0]
 80089be:	9005      	str	r0, [sp, #20]
 80089c0:	220a      	movs	r2, #10
 80089c2:	4630      	mov	r0, r6
 80089c4:	2300      	movs	r3, #0
 80089c6:	e7d7      	b.n	8008978 <print+0x88>
				continue;
			}
			if( *format == 'c' ) {
 80089c8:	2963      	cmp	r1, #99	; 0x63
 80089ca:	d112      	bne.n	80089f2 <print+0x102>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
 80089cc:	9905      	ldr	r1, [sp, #20]
 80089ce:	1d08      	adds	r0, r1, #4
 80089d0:	6809      	ldr	r1, [r1, #0]
 80089d2:	9005      	str	r0, [sp, #20]
 80089d4:	f88d 101c 	strb.w	r1, [sp, #28]
				scr[1] = '\0';
 80089d8:	2100      	movs	r1, #0
 80089da:	f88d 101d 	strb.w	r1, [sp, #29]
				pc += prints (out, scr, width, pad);
 80089de:	4630      	mov	r0, r6
 80089e0:	a907      	add	r1, sp, #28
 80089e2:	f7ff feea 	bl	80087ba <prints>
 80089e6:	e7c9      	b.n	800897c <print+0x8c>
				continue;
			}
		}
		else {
		out:
			printchar (out, *format);
 80089e8:	7829      	ldrb	r1, [r5, #0]
 80089ea:	4630      	mov	r0, r6
 80089ec:	f7ff fed8 	bl	80087a0 <printchar>
			++pc;
 80089f0:	3401      	adds	r4, #1
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
 80089f2:	3501      	adds	r5, #1
 80089f4:	782b      	ldrb	r3, [r5, #0]
 80089f6:	2b00      	cmp	r3, #0
 80089f8:	d181      	bne.n	80088fe <print+0xe>
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
 80089fa:	b116      	cbz	r6, 8008a02 <print+0x112>
 80089fc:	6833      	ldr	r3, [r6, #0]
 80089fe:	2200      	movs	r2, #0
 8008a00:	701a      	strb	r2, [r3, #0]
	va_end( args );
	return pc;
}
 8008a02:	4620      	mov	r0, r4
 8008a04:	b009      	add	sp, #36	; 0x24
 8008a06:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008a08:	0800b1fc 	.word	0x0800b1fc

08008a0c <sprintf>:
{
  return print( 0, format, args );
}

int sprintf(char *out, const char *format, ...)
{
 8008a0c:	b40e      	push	{r1, r2, r3}
 8008a0e:	b50f      	push	{r0, r1, r2, r3, lr}
 8008a10:	aa05      	add	r2, sp, #20
 8008a12:	f852 1b04 	ldr.w	r1, [r2], #4
 8008a16:	9001      	str	r0, [sp, #4]
        va_list args;
        
        va_start( args, format );
        return print( &out, format, args );
 8008a18:	a801      	add	r0, sp, #4

int sprintf(char *out, const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
 8008a1a:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 8008a1c:	f7ff ff68 	bl	80088f0 <print>
}
 8008a20:	b004      	add	sp, #16
 8008a22:	f85d eb04 	ldr.w	lr, [sp], #4
 8008a26:	b003      	add	sp, #12
 8008a28:	4770      	bx	lr

08008a2a <vsprintf>:

// TK: added for alternative parameter passing
int vsprintf(char *out, const char *format, va_list args)
{
 8008a2a:	b507      	push	{r0, r1, r2, lr}
 8008a2c:	4603      	mov	r3, r0
  char *_out;
  _out = out;
 8008a2e:	a802      	add	r0, sp, #8
 8008a30:	f840 3d04 	str.w	r3, [r0, #-4]!
  return print( &_out, format, args );
 8008a34:	f7ff ff5c 	bl	80088f0 <print>
}
 8008a38:	bd0e      	pop	{r1, r2, r3, pc}

08008a3a <GPIO_Init>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8008a3a:	78cb      	ldrb	r3, [r1, #3]
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8008a3c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8008a3e:	f013 0f10 	tst.w	r3, #16
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8008a42:	f003 020f 	and.w	r2, r3, #15
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8008a46:	880f      	ldrh	r7, [r1, #0]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8008a48:	bf1c      	itt	ne
 8008a4a:	788b      	ldrbne	r3, [r1, #2]
 8008a4c:	431a      	orrne	r2, r3
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8008a4e:	f017 0fff 	tst.w	r7, #255	; 0xff
 8008a52:	d022      	beq.n	8008a9a <GPIO_Init+0x60>
  {
    tmpreg = GPIOx->CRL;
 8008a54:	f8d0 c000 	ldr.w	ip, [r0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008a58:	2300      	movs	r3, #0
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008a5a:	9701      	str	r7, [sp, #4]
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
 8008a5c:	2401      	movs	r4, #1
 8008a5e:	fa14 f503 	lsls.w	r5, r4, r3
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8008a62:	9e01      	ldr	r6, [sp, #4]
 8008a64:	ea05 0406 	and.w	r4, r5, r6
      if (currentpin == pos)
 8008a68:	42ac      	cmp	r4, r5
 8008a6a:	d111      	bne.n	8008a90 <GPIO_Init+0x56>
      {
        pos = pinpos << 2;
 8008a6c:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008a6e:	270f      	movs	r7, #15
 8008a70:	fa17 f506 	lsls.w	r5, r7, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008a74:	fa12 f606 	lsls.w	r6, r2, r6
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8008a78:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a7c:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008a7e:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a82:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8008a84:	bf08      	it	eq
 8008a86:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008a88:	d002      	beq.n	8008a90 <GPIO_Init+0x56>
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8008a8a:	2d48      	cmp	r5, #72	; 0x48
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8008a8c:	bf08      	it	eq
 8008a8e:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008a90:	3301      	adds	r3, #1
 8008a92:	2b08      	cmp	r3, #8
 8008a94:	d1e2      	bne.n	8008a5c <GPIO_Init+0x22>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8008a96:	f8c0 c000 	str.w	ip, [r0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8008a9a:	880f      	ldrh	r7, [r1, #0]
 8008a9c:	2fff      	cmp	r7, #255	; 0xff
 8008a9e:	d924      	bls.n	8008aea <GPIO_Init+0xb0>
  {
    tmpreg = GPIOx->CRH;
 8008aa0:	f8d0 c004 	ldr.w	ip, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008aa4:	2300      	movs	r3, #0
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008aa6:	9201      	str	r2, [sp, #4]
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8008aa8:	2201      	movs	r2, #1
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
 8008aaa:	f103 0508 	add.w	r5, r3, #8
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8008aae:	fa12 f505 	lsls.w	r5, r2, r5
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8008ab2:	ea05 0407 	and.w	r4, r5, r7
      if (currentpin == pos)
 8008ab6:	42ac      	cmp	r4, r5
 8008ab8:	d112      	bne.n	8008ae0 <GPIO_Init+0xa6>
      {
        pos = pinpos << 2;
 8008aba:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008abc:	320e      	adds	r2, #14
 8008abe:	fa12 f506 	lsls.w	r5, r2, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008ac2:	9a01      	ldr	r2, [sp, #4]
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8008ac4:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008ac8:	fa12 f606 	lsls.w	r6, r2, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008acc:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008ace:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008ad2:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8008ad4:	bf08      	it	eq
 8008ad6:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008ad8:	d002      	beq.n	8008ae0 <GPIO_Init+0xa6>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8008ada:	2d48      	cmp	r5, #72	; 0x48
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8008adc:	bf08      	it	eq
 8008ade:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008ae0:	3301      	adds	r3, #1
 8008ae2:	2b08      	cmp	r3, #8
 8008ae4:	d1e0      	bne.n	8008aa8 <GPIO_Init+0x6e>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8008ae6:	f8c0 c004 	str.w	ip, [r0, #4]
  }
}
 8008aea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08008aec <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8008aec:	f04f 33ff 	mov.w	r3, #4294967295
 8008af0:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8008af2:	2302      	movs	r3, #2
 8008af4:	7083      	strb	r3, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8008af6:	18db      	adds	r3, r3, r3
 8008af8:	70c3      	strb	r3, [r0, #3]
}
 8008afa:	4770      	bx	lr

08008afc <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8008afc:	2800      	cmp	r0, #0
  {
    tmpreg = AFIO->MAPR2;
 8008afe:	bfb4      	ite	lt
 8008b00:	4b1a      	ldrlt	r3, [pc, #104]	; (8008b6c <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    tmpreg = AFIO->MAPR;
 8008b02:	4b1a      	ldrge	r3, [pc, #104]	; (8008b6c <GPIO_PinRemapConfig+0x70>)
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008b04:	f400 1c40 	and.w	ip, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 8008b08:	bfb4      	ite	lt
 8008b0a:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 8008b0c:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008b0e:	f5bc 1f40 	cmp.w	ip, #3145728	; 0x300000
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 8008b12:	b510      	push	{r4, lr}
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 8008b14:	b282      	uxth	r2, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008b16:	d10a      	bne.n	8008b2e <GPIO_PinRemapConfig+0x32>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8008b18:	f8df c050 	ldr.w	ip, [pc, #80]	; 8008b6c <GPIO_PinRemapConfig+0x70>
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8008b1c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8008b20:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8008b24:	f024 6470 	bic.w	r4, r4, #251658240	; 0xf000000
 8008b28:	f8cc 4004 	str.w	r4, [ip, #4]
 8008b2c:	e012      	b.n	8008b54 <GPIO_PinRemapConfig+0x58>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8008b2e:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008b32:	bf02      	ittt	eq
 8008b34:	ea4f 5c50 	moveq.w	ip, r0, lsr #21
 8008b38:	ea4f 1c0c 	moveq.w	ip, ip, lsl #4
 8008b3c:	fa02 fc0c 	lsleq.w	ip, r2, ip
  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8008b40:	d004      	beq.n	8008b4c <GPIO_PinRemapConfig+0x50>
  else
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 8008b42:	f3c0 4c03 	ubfx	ip, r0, #16, #4
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 8008b46:	2403      	movs	r4, #3
 8008b48:	fa04 fc0c 	lsl.w	ip, r4, ip
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008b4c:	ea23 030c 	bic.w	r3, r3, ip
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8008b50:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  }

  if (NewState != DISABLE)
 8008b54:	b119      	cbz	r1, 8008b5e <GPIO_PinRemapConfig+0x62>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008b56:	0d41      	lsrs	r1, r0, #21
 8008b58:	0109      	lsls	r1, r1, #4
 8008b5a:	408a      	lsls	r2, r1
 8008b5c:	4313      	orrs	r3, r2
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8008b5e:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 8008b60:	bfb5      	itete	lt
 8008b62:	4a02      	ldrlt	r2, [pc, #8]	; (8008b6c <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008b64:	4a01      	ldrge	r2, [pc, #4]	; (8008b6c <GPIO_PinRemapConfig+0x70>)
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    AFIO->MAPR2 = tmpreg;
 8008b66:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008b68:	6053      	strge	r3, [r2, #4]
  }  
}
 8008b6a:	bd10      	pop	{r4, pc}
 8008b6c:	40010000 	.word	0x40010000

08008b70 <FLASH_SetLatency>:
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 8008b70:	4b03      	ldr	r3, [pc, #12]	; (8008b80 <FLASH_SetLatency+0x10>)
 8008b72:	681a      	ldr	r2, [r3, #0]
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8008b74:	f002 0238 	and.w	r2, r2, #56	; 0x38
  tmpreg |= FLASH_Latency;
 8008b78:	4310      	orrs	r0, r2
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8008b7a:	6018      	str	r0, [r3, #0]
}
 8008b7c:	4770      	bx	lr
 8008b7e:	bf00      	nop
 8008b80:	40022000 	.word	0x40022000

08008b84 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 8008b84:	4b04      	ldr	r3, [pc, #16]	; (8008b98 <FLASH_PrefetchBufferCmd+0x14>)
 8008b86:	681a      	ldr	r2, [r3, #0]
 8008b88:	f022 0210 	bic.w	r2, r2, #16
 8008b8c:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 8008b8e:	681a      	ldr	r2, [r3, #0]
 8008b90:	4310      	orrs	r0, r2
 8008b92:	6018      	str	r0, [r3, #0]
}
 8008b94:	4770      	bx	lr
 8008b96:	bf00      	nop
 8008b98:	40022000 	.word	0x40022000

08008b9c <ADC_Init>:
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8008b9c:	6843      	ldr	r3, [r0, #4]
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
 8008b9e:	680a      	ldr	r2, [r1, #0]

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
 8008ba0:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8008ba4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
 8008ba8:	4313      	orrs	r3, r2
 8008baa:	790a      	ldrb	r2, [r1, #4]
 8008bac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8008bb0:	6043      	str	r3, [r0, #4]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008bb2:	688a      	ldr	r2, [r1, #8]
 8008bb4:	68cb      	ldr	r3, [r1, #12]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8008bb6:	f8d0 c008 	ldr.w	ip, [r0, #8]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008bba:	431a      	orrs	r2, r3

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  /* Clear CONT, ALIGN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_Mask;
 8008bbc:	4b09      	ldr	r3, [pc, #36]	; (8008be4 <ADC_Init+0x48>)
 8008bbe:	ea0c 0303 	and.w	r3, ip, r3
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008bc2:	ea42 0303 	orr.w	r3, r2, r3
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8008bc6:	794a      	ldrb	r2, [r1, #5]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008bc8:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8008bcc:	6083      	str	r3, [r0, #8]
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 8008bce:	7c0b      	ldrb	r3, [r1, #16]
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8008bd0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 8008bd2:	3b01      	subs	r3, #1

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
 8008bd4:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
 8008bd8:	b2db      	uxtb	r3, r3
 8008bda:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8008bde:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8008be0:	4770      	bx	lr
 8008be2:	bf00      	nop
 8008be4:	fff1f7fd 	.word	0xfff1f7fd

08008be8 <ADC_StructInit>:
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
 8008be8:	2300      	movs	r3, #0
 8008bea:	6003      	str	r3, [r0, #0]
  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8008bec:	7103      	strb	r3, [r0, #4]
  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8008bee:	7143      	strb	r3, [r0, #5]
  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 8008bf0:	6083      	str	r3, [r0, #8]
  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8008bf2:	60c3      	str	r3, [r0, #12]
  /* Initialize the ADC_NbrOfChannel member */
  ADC_InitStruct->ADC_NbrOfChannel = 1;
 8008bf4:	3301      	adds	r3, #1
 8008bf6:	7403      	strb	r3, [r0, #16]
}
 8008bf8:	4770      	bx	lr

08008bfa <ADC_Cmd>:
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008bfa:	b119      	cbz	r1, 8008c04 <ADC_Cmd+0xa>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
 8008bfc:	6883      	ldr	r3, [r0, #8]
 8008bfe:	f043 0301 	orr.w	r3, r3, #1
 8008c02:	e002      	b.n	8008c0a <ADC_Cmd+0x10>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
 8008c04:	6883      	ldr	r3, [r0, #8]
 8008c06:	f023 0301 	bic.w	r3, r3, #1
 8008c0a:	6083      	str	r3, [r0, #8]
  }
}
 8008c0c:	4770      	bx	lr

08008c0e <ADC_DMACmd>:
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008c0e:	b119      	cbz	r1, 8008c18 <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
 8008c10:	6883      	ldr	r3, [r0, #8]
 8008c12:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008c16:	e002      	b.n	8008c1e <ADC_DMACmd+0x10>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
 8008c18:	6883      	ldr	r3, [r0, #8]
 8008c1a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008c1e:	6083      	str	r3, [r0, #8]
  }
}
 8008c20:	4770      	bx	lr

08008c22 <ADC_ResetCalibration>:
void ADC_ResetCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
 8008c22:	6883      	ldr	r3, [r0, #8]
 8008c24:	f043 0308 	orr.w	r3, r3, #8
 8008c28:	6083      	str	r3, [r0, #8]
}
 8008c2a:	4770      	bx	lr

08008c2c <ADC_GetResetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
 8008c2c:	6880      	ldr	r0, [r0, #8]
 8008c2e:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    /* RSTCAL bit is reset */
    bitstatus = RESET;
  }
  /* Return the RSTCAL bit status */
  return  bitstatus;
}
 8008c32:	4770      	bx	lr

08008c34 <ADC_StartCalibration>:
void ADC_StartCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
 8008c34:	6883      	ldr	r3, [r0, #8]
 8008c36:	f043 0304 	orr.w	r3, r3, #4
 8008c3a:	6083      	str	r3, [r0, #8]
}
 8008c3c:	4770      	bx	lr

08008c3e <ADC_GetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
 8008c3e:	6880      	ldr	r0, [r0, #8]
 8008c40:	f3c0 0080 	ubfx	r0, r0, #2, #1
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
 8008c44:	4770      	bx	lr

08008c46 <ADC_SoftwareStartConvCmd>:
void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008c46:	b119      	cbz	r1, 8008c50 <ADC_SoftwareStartConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
 8008c48:	6883      	ldr	r3, [r0, #8]
 8008c4a:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 8008c4e:	e002      	b.n	8008c56 <ADC_SoftwareStartConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
 8008c50:	6883      	ldr	r3, [r0, #8]
 8008c52:	f423 03a0 	bic.w	r3, r3, #5242880	; 0x500000
 8008c56:	6083      	str	r3, [r0, #8]
  }
}
 8008c58:	4770      	bx	lr

08008c5a <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8008c5a:	2909      	cmp	r1, #9
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8008c5c:	b530      	push	{r4, r5, lr}
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8008c5e:	d912      	bls.n	8008c86 <ADC_RegularChannelConfig+0x2c>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
 8008c60:	f04f 0c03 	mov.w	ip, #3
 8008c64:	fb0c fc01 	mul.w	ip, ip, r1
 8008c68:	2407      	movs	r4, #7
 8008c6a:	f1ac 0c1e 	sub.w	ip, ip, #30
 8008c6e:	fa04 f40c 	lsl.w	r4, r4, ip
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8008c72:	fa03 f30c 	lsl.w	r3, r3, ip
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8008c76:	68c5      	ldr	r5, [r0, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 8008c78:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 8008c7c:	ea44 0c03 	orr.w	ip, r4, r3
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8008c80:	f8c0 c00c 	str.w	ip, [r0, #12]
 8008c84:	e00e      	b.n	8008ca4 <ADC_RegularChannelConfig+0x4a>
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 8008c86:	f04f 0c03 	mov.w	ip, #3
 8008c8a:	fb0c fc01 	mul.w	ip, ip, r1
 8008c8e:	2407      	movs	r4, #7
 8008c90:	fa04 f40c 	lsl.w	r4, r4, ip
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8008c94:	fa03 fc0c 	lsl.w	ip, r3, ip
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8008c98:	6905      	ldr	r5, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 8008c9a:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 8008c9e:	ea44 030c 	orr.w	r3, r4, ip
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8008ca2:	6103      	str	r3, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8008ca4:	2a06      	cmp	r2, #6
 8008ca6:	d80d      	bhi.n	8008cc4 <ADC_RegularChannelConfig+0x6a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
 8008ca8:	2305      	movs	r3, #5
 8008caa:	3a01      	subs	r2, #1
 8008cac:	435a      	muls	r2, r3
 8008cae:	331a      	adds	r3, #26
 8008cb0:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8008cb2:	4091      	lsls	r1, r2
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8008cb4:	f8d0 c034 	ldr.w	ip, [r0, #52]	; 0x34
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008cb8:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008cbc:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8008cc0:	6342      	str	r2, [r0, #52]	; 0x34
 8008cc2:	e01c      	b.n	8008cfe <ADC_RegularChannelConfig+0xa4>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 8008cc4:	2a0c      	cmp	r2, #12
 8008cc6:	d80d      	bhi.n	8008ce4 <ADC_RegularChannelConfig+0x8a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
 8008cc8:	2305      	movs	r3, #5
 8008cca:	435a      	muls	r2, r3
 8008ccc:	331a      	adds	r3, #26
 8008cce:	3a23      	subs	r2, #35	; 0x23
 8008cd0:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8008cd2:	4091      	lsls	r1, r2
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8008cd4:	f8d0 c030 	ldr.w	ip, [r0, #48]	; 0x30
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008cd8:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008cdc:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8008ce0:	6302      	str	r2, [r0, #48]	; 0x30
 8008ce2:	e00c      	b.n	8008cfe <ADC_RegularChannelConfig+0xa4>
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
 8008ce4:	2305      	movs	r3, #5
 8008ce6:	435a      	muls	r2, r3
 8008ce8:	331a      	adds	r3, #26
 8008cea:	3a41      	subs	r2, #65	; 0x41
 8008cec:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8008cee:	4091      	lsls	r1, r2
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8008cf0:	f8d0 c02c 	ldr.w	ip, [r0, #44]	; 0x2c
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008cf4:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008cf8:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8008cfc:	62c2      	str	r2, [r0, #44]	; 0x2c
  }
}
 8008cfe:	bd30      	pop	{r4, r5, pc}

08008d00 <ADC_ExternalTrigConvCmd>:
void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008d00:	b119      	cbz	r1, 8008d0a <ADC_ExternalTrigConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event */
    ADCx->CR2 |= CR2_EXTTRIG_Set;
 8008d02:	6883      	ldr	r3, [r0, #8]
 8008d04:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008d08:	e002      	b.n	8008d10 <ADC_ExternalTrigConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event */
    ADCx->CR2 &= CR2_EXTTRIG_Reset;
 8008d0a:	6883      	ldr	r3, [r0, #8]
 8008d0c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8008d10:	6083      	str	r3, [r0, #8]
  }
}
 8008d12:	4770      	bx	lr

08008d14 <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008d14:	f8b1 c002 	ldrh.w	ip, [r1, #2]
 8008d18:	880b      	ldrh	r3, [r1, #0]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8008d1a:	8802      	ldrh	r2, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008d1c:	ea4c 0303 	orr.w	r3, ip, r3
 8008d20:	f8b1 c004 	ldrh.w	ip, [r1, #4]

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008d24:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008d28:	ea43 030c 	orr.w	r3, r3, ip
 8008d2c:	f8b1 c006 	ldrh.w	ip, [r1, #6]
 8008d30:	ea43 030c 	orr.w	r3, r3, ip
 8008d34:	f8b1 c008 	ldrh.w	ip, [r1, #8]
 8008d38:	ea43 030c 	orr.w	r3, r3, ip
 8008d3c:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 8008d40:	ea43 030c 	orr.w	r3, r3, ip
 8008d44:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
 8008d48:	ea43 030c 	orr.w	r3, r3, ip
 8008d4c:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
 8008d50:	ea43 030c 	orr.w	r3, r3, ip
 8008d54:	ea42 0303 	orr.w	r3, r2, r3
 8008d58:	b29b      	uxth	r3, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8008d5a:	8003      	strh	r3, [r0, #0]
  
  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= SPI_Mode_Select;		
 8008d5c:	8b83      	ldrh	r3, [r0, #28]
 8008d5e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8008d62:	041b      	lsls	r3, r3, #16
 8008d64:	0c1b      	lsrs	r3, r3, #16
 8008d66:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8008d68:	8a0b      	ldrh	r3, [r1, #16]
 8008d6a:	8203      	strh	r3, [r0, #16]
}
 8008d6c:	4770      	bx	lr

08008d6e <SPI_Cmd>:
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008d6e:	b121      	cbz	r1, 8008d7a <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 8008d70:	8803      	ldrh	r3, [r0, #0]
 8008d72:	b29b      	uxth	r3, r3
 8008d74:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008d78:	e004      	b.n	8008d84 <SPI_Cmd+0x16>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= CR1_SPE_Reset;
 8008d7a:	8803      	ldrh	r3, [r0, #0]
 8008d7c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8008d80:	041b      	lsls	r3, r3, #16
 8008d82:	0c1b      	lsrs	r3, r3, #16
 8008d84:	8003      	strh	r3, [r0, #0]
  }
}
 8008d86:	4770      	bx	lr

08008d88 <SPI_I2S_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
 8008d88:	b11a      	cbz	r2, 8008d92 <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8008d8a:	8883      	ldrh	r3, [r0, #4]
 8008d8c:	b29b      	uxth	r3, r3
 8008d8e:	4319      	orrs	r1, r3
 8008d90:	e003      	b.n	8008d9a <SPI_I2S_DMACmd+0x12>
  }
  else
  {
    /* Disable the selected SPI/I2S DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8008d92:	8883      	ldrh	r3, [r0, #4]
 8008d94:	b29b      	uxth	r3, r3
 8008d96:	ea23 0101 	bic.w	r1, r3, r1
 8008d9a:	8081      	strh	r1, [r0, #4]
  }
}
 8008d9c:	4770      	bx	lr
	...

08008da0 <USART_Init>:
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8008da0:	8a03      	ldrh	r3, [r0, #16]
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8008da2:	88ca      	ldrh	r2, [r1, #6]
  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 8008da4:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8008da8:	041b      	lsls	r3, r3, #16
 8008daa:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8008dac:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008dae:	b530      	push	{r4, r5, lr}
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8008db0:	8203      	strh	r3, [r0, #16]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008db2:	460d      	mov	r5, r1
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8008db4:	8983      	ldrh	r3, [r0, #12]
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008db6:	8909      	ldrh	r1, [r1, #8]
 8008db8:	88aa      	ldrh	r2, [r5, #4]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008dba:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008dbe:	ea41 0202 	orr.w	r2, r1, r2
 8008dc2:	8969      	ldrh	r1, [r5, #10]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008dc4:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008dc8:	430a      	orrs	r2, r1
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008dca:	041b      	lsls	r3, r3, #16
 8008dcc:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008dce:	b292      	uxth	r2, r2
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8008dd0:	ea42 0303 	orr.w	r3, r2, r3
 8008dd4:	8183      	strh	r3, [r0, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8008dd6:	8a83      	ldrh	r3, [r0, #20]
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8008dd8:	89aa      	ldrh	r2, [r5, #12]
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8008dda:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008dde:	041b      	lsls	r3, r3, #16
 8008de0:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8008de2:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008de4:	b087      	sub	sp, #28
 8008de6:	4604      	mov	r4, r0
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8008de8:	8283      	strh	r3, [r0, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8008dea:	a801      	add	r0, sp, #4
 8008dec:	f000 fa92 	bl	8009314 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 8008df0:	4b18      	ldr	r3, [pc, #96]	; (8008e54 <USART_Init+0xb4>)
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008df2:	89a2      	ldrh	r2, [r4, #12]
  USARTx->CR3 = (uint16_t)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
 8008df4:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008df6:	b212      	sxth	r2, r2
/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8008df8:	bf0c      	ite	eq
 8008dfa:	9b04      	ldreq	r3, [sp, #16]
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8008dfc:	9b03      	ldrne	r3, [sp, #12]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008dfe:	2a00      	cmp	r2, #0
 8008e00:	682a      	ldr	r2, [r5, #0]
 8008e02:	da03      	bge.n	8008e0c <USART_Init+0x6c>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8008e04:	2119      	movs	r1, #25
 8008e06:	4359      	muls	r1, r3
 8008e08:	0052      	lsls	r2, r2, #1
 8008e0a:	e002      	b.n	8008e12 <USART_Init+0x72>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8008e0c:	2119      	movs	r1, #25
 8008e0e:	4359      	muls	r1, r3
 8008e10:	0092      	lsls	r2, r2, #2
  }
  tmpreg = (integerdivider / 100) << 4;
 8008e12:	2364      	movs	r3, #100	; 0x64
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8008e14:	fbb1 f1f2 	udiv	r1, r1, r2
  }
  tmpreg = (integerdivider / 100) << 4;
 8008e18:	fbb1 f2f3 	udiv	r2, r1, r3
 8008e1c:	0112      	lsls	r2, r2, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8008e1e:	0910      	lsrs	r0, r2, #4
 8008e20:	fb03 1110 	mls	r1, r3, r0, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008e24:	89a0      	ldrh	r0, [r4, #12]
 8008e26:	b200      	sxth	r0, r0
 8008e28:	2800      	cmp	r0, #0
 8008e2a:	da06      	bge.n	8008e3a <USART_Init+0x9a>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8008e2c:	00c9      	lsls	r1, r1, #3
 8008e2e:	3132      	adds	r1, #50	; 0x32
 8008e30:	fbb1 f3f3 	udiv	r3, r1, r3
 8008e34:	f003 0307 	and.w	r3, r3, #7
 8008e38:	e005      	b.n	8008e46 <USART_Init+0xa6>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8008e3a:	0109      	lsls	r1, r1, #4
 8008e3c:	3132      	adds	r1, #50	; 0x32
 8008e3e:	fbb1 f3f3 	udiv	r3, r1, r3
 8008e42:	f003 030f 	and.w	r3, r3, #15
 8008e46:	ea43 0202 	orr.w	r2, r3, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 8008e4a:	b292      	uxth	r2, r2
 8008e4c:	8122      	strh	r2, [r4, #8]
}
 8008e4e:	b007      	add	sp, #28
 8008e50:	bd30      	pop	{r4, r5, pc}
 8008e52:	bf00      	nop
 8008e54:	40013800 	.word	0x40013800

08008e58 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008e58:	b121      	cbz	r1, 8008e64 <USART_Cmd+0xc>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8008e5a:	8983      	ldrh	r3, [r0, #12]
 8008e5c:	b29b      	uxth	r3, r3
 8008e5e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8008e62:	e004      	b.n	8008e6e <USART_Cmd+0x16>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 8008e64:	8983      	ldrh	r3, [r0, #12]
 8008e66:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008e6a:	041b      	lsls	r3, r3, #16
 8008e6c:	0c1b      	lsrs	r3, r3, #16
 8008e6e:	8183      	strh	r3, [r0, #12]
  }
}
 8008e70:	4770      	bx	lr

08008e72 <USART_ITConfig>:
  }   
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8008e72:	f3c1 1342 	ubfx	r3, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8008e76:	f04f 0c01 	mov.w	ip, #1

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
 8008e7a:	f001 011f 	and.w	r1, r1, #31
  itmask = (((uint32_t)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8008e7e:	4563      	cmp	r3, ip
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8008e80:	fa0c f101 	lsl.w	r1, ip, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8008e84:	d101      	bne.n	8008e8a <USART_ITConfig+0x18>
  {
    usartxbase += 0x0C;
 8008e86:	300c      	adds	r0, #12
 8008e88:	e004      	b.n	8008e94 <USART_ITConfig+0x22>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8008e8a:	2b02      	cmp	r3, #2
 8008e8c:	d101      	bne.n	8008e92 <USART_ITConfig+0x20>
  {
    usartxbase += 0x10;
 8008e8e:	3010      	adds	r0, #16
 8008e90:	e000      	b.n	8008e94 <USART_ITConfig+0x22>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8008e92:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
 8008e94:	b11a      	cbz	r2, 8008e9e <USART_ITConfig+0x2c>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8008e96:	6803      	ldr	r3, [r0, #0]
 8008e98:	ea43 0101 	orr.w	r1, r3, r1
 8008e9c:	e002      	b.n	8008ea4 <USART_ITConfig+0x32>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8008e9e:	6803      	ldr	r3, [r0, #0]
 8008ea0:	ea23 0101 	bic.w	r1, r3, r1
 8008ea4:	6001      	str	r1, [r0, #0]
  }
}
 8008ea6:	4770      	bx	lr

08008ea8 <I2C_GenerateSTART>:
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008ea8:	b121      	cbz	r1, 8008eb4 <I2C_GenerateSTART+0xc>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 8008eaa:	8803      	ldrh	r3, [r0, #0]
 8008eac:	b29b      	uxth	r3, r3
 8008eae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008eb2:	e004      	b.n	8008ebe <I2C_GenerateSTART+0x16>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
 8008eb4:	8803      	ldrh	r3, [r0, #0]
 8008eb6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008eba:	041b      	lsls	r3, r3, #16
 8008ebc:	0c1b      	lsrs	r3, r3, #16
 8008ebe:	8003      	strh	r3, [r0, #0]
  }
}
 8008ec0:	4770      	bx	lr

08008ec2 <I2C_GenerateSTOP>:
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008ec2:	b121      	cbz	r1, 8008ece <I2C_GenerateSTOP+0xc>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 8008ec4:	8803      	ldrh	r3, [r0, #0]
 8008ec6:	b29b      	uxth	r3, r3
 8008ec8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008ecc:	e004      	b.n	8008ed8 <I2C_GenerateSTOP+0x16>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
 8008ece:	8803      	ldrh	r3, [r0, #0]
 8008ed0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8008ed4:	041b      	lsls	r3, r3, #16
 8008ed6:	0c1b      	lsrs	r3, r3, #16
 8008ed8:	8003      	strh	r3, [r0, #0]
  }
}
 8008eda:	4770      	bx	lr

08008edc <I2C_AcknowledgeConfig>:
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008edc:	b121      	cbz	r1, 8008ee8 <I2C_AcknowledgeConfig+0xc>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8008ede:	8803      	ldrh	r3, [r0, #0]
 8008ee0:	b29b      	uxth	r3, r3
 8008ee2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008ee6:	e004      	b.n	8008ef2 <I2C_AcknowledgeConfig+0x16>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
 8008ee8:	8803      	ldrh	r3, [r0, #0]
 8008eea:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008eee:	041b      	lsls	r3, r3, #16
 8008ef0:	0c1b      	lsrs	r3, r3, #16
 8008ef2:	8003      	strh	r3, [r0, #0]
  }
}
 8008ef4:	4770      	bx	lr

08008ef6 <I2C_ITConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8008ef6:	b11a      	cbz	r2, 8008f00 <I2C_ITConfig+0xa>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8008ef8:	8883      	ldrh	r3, [r0, #4]
 8008efa:	b29b      	uxth	r3, r3
 8008efc:	4319      	orrs	r1, r3
 8008efe:	e003      	b.n	8008f08 <I2C_ITConfig+0x12>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8008f00:	8883      	ldrh	r3, [r0, #4]
 8008f02:	b29b      	uxth	r3, r3
 8008f04:	ea23 0101 	bic.w	r1, r3, r1
 8008f08:	8081      	strh	r1, [r0, #4]
  }
}
 8008f0a:	4770      	bx	lr

08008f0c <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8008f0c:	8201      	strh	r1, [r0, #16]
}
 8008f0e:	4770      	bx	lr

08008f10 <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8008f10:	8a00      	ldrh	r0, [r0, #16]
 8008f12:	b2c0      	uxtb	r0, r0
}
 8008f14:	4770      	bx	lr

08008f16 <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 8008f16:	b112      	cbz	r2, 8008f1e <I2C_Send7bitAddress+0x8>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 8008f18:	f041 0101 	orr.w	r1, r1, #1
 8008f1c:	e001      	b.n	8008f22 <I2C_Send7bitAddress+0xc>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 8008f1e:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 8008f22:	8201      	strh	r1, [r0, #16]
}
 8008f24:	4770      	bx	lr

08008f26 <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8008f26:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 8008f28:	8b00      	ldrh	r0, [r0, #24]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8008f2a:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 8008f2c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8008f30:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

  /* Return status */
  return lastevent;
}
 8008f34:	4770      	bx	lr

08008f36 <I2C_ClearITPendingBit>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_Mask;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8008f36:	43c9      	mvns	r1, r1
 8008f38:	b289      	uxth	r1, r1
 8008f3a:	8281      	strh	r1, [r0, #20]
}
 8008f3c:	4770      	bx	lr
	...

08008f40 <DMA_DeInit>:
void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 8008f40:	6803      	ldr	r3, [r0, #0]
 8008f42:	f023 0301 	bic.w	r3, r3, #1
 8008f46:	6003      	str	r3, [r0, #0]
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8008f48:	2300      	movs	r3, #0
 8008f4a:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8008f4c:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8008f4e:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 8008f50:	60c3      	str	r3, [r0, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8008f52:	4b24      	ldr	r3, [pc, #144]	; (8008fe4 <DMA_DeInit+0xa4>)
 8008f54:	4298      	cmp	r0, r3
 8008f56:	d01e      	beq.n	8008f96 <DMA_DeInit+0x56>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8008f58:	4b23      	ldr	r3, [pc, #140]	; (8008fe8 <DMA_DeInit+0xa8>)
 8008f5a:	4298      	cmp	r0, r3
 8008f5c:	d023      	beq.n	8008fa6 <DMA_DeInit+0x66>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8008f5e:	4b23      	ldr	r3, [pc, #140]	; (8008fec <DMA_DeInit+0xac>)
 8008f60:	4298      	cmp	r0, r3
 8008f62:	d028      	beq.n	8008fb6 <DMA_DeInit+0x76>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8008f64:	4b22      	ldr	r3, [pc, #136]	; (8008ff0 <DMA_DeInit+0xb0>)
 8008f66:	4298      	cmp	r0, r3
 8008f68:	d02d      	beq.n	8008fc6 <DMA_DeInit+0x86>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8008f6a:	4b22      	ldr	r3, [pc, #136]	; (8008ff4 <DMA_DeInit+0xb4>)
 8008f6c:	4298      	cmp	r0, r3
 8008f6e:	d032      	beq.n	8008fd6 <DMA_DeInit+0x96>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8008f70:	4b21      	ldr	r3, [pc, #132]	; (8008ff8 <DMA_DeInit+0xb8>)
 8008f72:	4298      	cmp	r0, r3
 8008f74:	d104      	bne.n	8008f80 <DMA_DeInit+0x40>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 8008f76:	3b6c      	subs	r3, #108	; 0x6c
 8008f78:	685a      	ldr	r2, [r3, #4]
 8008f7a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8008f7e:	e02e      	b.n	8008fde <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8008f80:	4b1e      	ldr	r3, [pc, #120]	; (8008ffc <DMA_DeInit+0xbc>)
 8008f82:	4298      	cmp	r0, r3
 8008f84:	d104      	bne.n	8008f90 <DMA_DeInit+0x50>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8008f86:	3b80      	subs	r3, #128	; 0x80
 8008f88:	685a      	ldr	r2, [r3, #4]
 8008f8a:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 8008f8e:	e026      	b.n	8008fde <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8008f90:	4b1b      	ldr	r3, [pc, #108]	; (8009000 <DMA_DeInit+0xc0>)
 8008f92:	4298      	cmp	r0, r3
 8008f94:	d104      	bne.n	8008fa0 <DMA_DeInit+0x60>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8008f96:	3b08      	subs	r3, #8
 8008f98:	685a      	ldr	r2, [r3, #4]
 8008f9a:	f042 020f 	orr.w	r2, r2, #15
 8008f9e:	e01e      	b.n	8008fde <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8008fa0:	4b18      	ldr	r3, [pc, #96]	; (8009004 <DMA_DeInit+0xc4>)
 8008fa2:	4298      	cmp	r0, r3
 8008fa4:	d104      	bne.n	8008fb0 <DMA_DeInit+0x70>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 8008fa6:	3b1c      	subs	r3, #28
 8008fa8:	685a      	ldr	r2, [r3, #4]
 8008faa:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 8008fae:	e016      	b.n	8008fde <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 8008fb0:	4b15      	ldr	r3, [pc, #84]	; (8009008 <DMA_DeInit+0xc8>)
 8008fb2:	4298      	cmp	r0, r3
 8008fb4:	d104      	bne.n	8008fc0 <DMA_DeInit+0x80>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 8008fb6:	3b30      	subs	r3, #48	; 0x30
 8008fb8:	685a      	ldr	r2, [r3, #4]
 8008fba:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 8008fbe:	e00e      	b.n	8008fde <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 8008fc0:	4b12      	ldr	r3, [pc, #72]	; (800900c <DMA_DeInit+0xcc>)
 8008fc2:	4298      	cmp	r0, r3
 8008fc4:	d104      	bne.n	8008fd0 <DMA_DeInit+0x90>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8008fc6:	3b44      	subs	r3, #68	; 0x44
 8008fc8:	685a      	ldr	r2, [r3, #4]
 8008fca:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 8008fce:	e006      	b.n	8008fde <DMA_DeInit+0x9e>
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8008fd0:	4b0f      	ldr	r3, [pc, #60]	; (8009010 <DMA_DeInit+0xd0>)
 8008fd2:	4298      	cmp	r0, r3
 8008fd4:	d104      	bne.n	8008fe0 <DMA_DeInit+0xa0>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 8008fd6:	3b58      	subs	r3, #88	; 0x58
 8008fd8:	685a      	ldr	r2, [r3, #4]
 8008fda:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 8008fde:	605a      	str	r2, [r3, #4]
    }
  }
}
 8008fe0:	4770      	bx	lr
 8008fe2:	bf00      	nop
 8008fe4:	40020008 	.word	0x40020008
 8008fe8:	4002001c 	.word	0x4002001c
 8008fec:	40020030 	.word	0x40020030
 8008ff0:	40020044 	.word	0x40020044
 8008ff4:	40020058 	.word	0x40020058
 8008ff8:	4002006c 	.word	0x4002006c
 8008ffc:	40020080 	.word	0x40020080
 8009000:	40020408 	.word	0x40020408
 8009004:	4002041c 	.word	0x4002041c
 8009008:	40020430 	.word	0x40020430
 800900c:	40020444 	.word	0x40020444
 8009010:	40020458 	.word	0x40020458

08009014 <DMA_Init>:
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8009014:	f8d1 c020 	ldr.w	ip, [r1, #32]
 8009018:	688b      	ldr	r3, [r1, #8]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 800901a:	6802      	ldr	r2, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800901c:	ea4c 0303 	orr.w	r3, ip, r3
 8009020:	f8d1 c010 	ldr.w	ip, [r1, #16]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8009024:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8009028:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800902c:	f8d1 c014 	ldr.w	ip, [r1, #20]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8009030:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8009034:	ea43 030c 	orr.w	r3, r3, ip
 8009038:	f8d1 c018 	ldr.w	ip, [r1, #24]
 800903c:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8009040:	f8d1 c01c 	ldr.w	ip, [r1, #28]
 8009044:	ea43 030c 	orr.w	r3, r3, ip
 8009048:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
 800904c:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8009050:	f8d1 c028 	ldr.w	ip, [r1, #40]	; 0x28
 8009054:	ea43 030c 	orr.w	r3, r3, ip
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8009058:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 800905a:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 800905c:	68cb      	ldr	r3, [r1, #12]
 800905e:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8009060:	680b      	ldr	r3, [r1, #0]
 8009062:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8009064:	684b      	ldr	r3, [r1, #4]
 8009066:	60c3      	str	r3, [r0, #12]
}
 8009068:	4770      	bx	lr

0800906a <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 800906a:	2300      	movs	r3, #0
 800906c:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 800906e:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 8009070:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8009072:	60c3      	str	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8009074:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8009076:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8009078:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800907a:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 800907c:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 800907e:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 8009080:	6283      	str	r3, [r0, #40]	; 0x28
}
 8009082:	4770      	bx	lr

08009084 <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8009084:	b119      	cbz	r1, 800908e <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= CCR_ENABLE_Set;
 8009086:	6803      	ldr	r3, [r0, #0]
 8009088:	f043 0301 	orr.w	r3, r3, #1
 800908c:	e002      	b.n	8009094 <DMA_Cmd+0x10>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 800908e:	6803      	ldr	r3, [r0, #0]
 8009090:	f023 0301 	bic.w	r3, r3, #1
 8009094:	6003      	str	r3, [r0, #0]
  }
}
 8009096:	4770      	bx	lr

08009098 <DMA_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009098:	b112      	cbz	r2, 80090a0 <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 800909a:	6803      	ldr	r3, [r0, #0]
 800909c:	4319      	orrs	r1, r3
 800909e:	e002      	b.n	80090a6 <DMA_ITConfig+0xe>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 80090a0:	6803      	ldr	r3, [r0, #0]
 80090a2:	ea23 0101 	bic.w	r1, r3, r1
 80090a6:	6001      	str	r1, [r0, #0]
  }
}
 80090a8:	4770      	bx	lr
	...

080090ac <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
  /* Calculate the used DMA */

  if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
 80090ac:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
  {
    /* Clear the selected DMA flags */
    DMA2->IFCR = DMA_FLAG;
 80090b0:	bf14      	ite	ne
 80090b2:	4b02      	ldrne	r3, [pc, #8]	; (80090bc <DMA_ClearFlag+0x10>)
  }
  else
  {
    /* Clear the selected DMA flags */
    DMA1->IFCR = DMA_FLAG;
 80090b4:	4b02      	ldreq	r3, [pc, #8]	; (80090c0 <DMA_ClearFlag+0x14>)
 80090b6:	6058      	str	r0, [r3, #4]
  }
}
 80090b8:	4770      	bx	lr
 80090ba:	bf00      	nop
 80090bc:	40020400 	.word	0x40020400
 80090c0:	40020000 	.word	0x40020000

080090c4 <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 80090c4:	4a2d      	ldr	r2, [pc, #180]	; (800917c <TIM_TimeBaseInit+0xb8>)
 80090c6:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 8009180 <TIM_TimeBaseInit+0xbc>
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80090ca:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 80090cc:	4290      	cmp	r0, r2
 80090ce:	bf14      	ite	ne
 80090d0:	2200      	movne	r2, #0
 80090d2:	2201      	moveq	r2, #1
 80090d4:	4560      	cmp	r0, ip
 80090d6:	bf08      	it	eq
 80090d8:	f042 0201 	orreq.w	r2, r2, #1
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
  *   structure that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 80090dc:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80090de:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 80090e0:	b9ca      	cbnz	r2, 8009116 <TIM_TimeBaseInit+0x52>
 80090e2:	4c28      	ldr	r4, [pc, #160]	; (8009184 <TIM_TimeBaseInit+0xc0>)
 80090e4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80090e8:	bf14      	ite	ne
 80090ea:	f04f 0c00 	movne.w	ip, #0
 80090ee:	f04f 0c01 	moveq.w	ip, #1
 80090f2:	42a0      	cmp	r0, r4
 80090f4:	bf14      	ite	ne
 80090f6:	4664      	movne	r4, ip
 80090f8:	f04c 0401 	orreq.w	r4, ip, #1
 80090fc:	b95c      	cbnz	r4, 8009116 <TIM_TimeBaseInit+0x52>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 80090fe:	4c22      	ldr	r4, [pc, #136]	; (8009188 <TIM_TimeBaseInit+0xc4>)
 8009100:	f8df c088 	ldr.w	ip, [pc, #136]	; 800918c <TIM_TimeBaseInit+0xc8>
 8009104:	42a0      	cmp	r0, r4
 8009106:	bf14      	ite	ne
 8009108:	2400      	movne	r4, #0
 800910a:	2401      	moveq	r4, #1
 800910c:	4560      	cmp	r0, ip
 800910e:	bf08      	it	eq
 8009110:	f044 0401 	orreq.w	r4, r4, #1
 8009114:	b12c      	cbz	r4, 8009122 <TIM_TimeBaseInit+0x5e>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8009116:	f8b1 c002 	ldrh.w	ip, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 800911a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800911e:	ea43 030c 	orr.w	r3, r3, ip
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8009122:	4c1b      	ldr	r4, [pc, #108]	; (8009190 <TIM_TimeBaseInit+0xcc>)
 8009124:	f8df c06c 	ldr.w	ip, [pc, #108]	; 8009194 <TIM_TimeBaseInit+0xd0>
 8009128:	1b04      	subs	r4, r0, r4
 800912a:	bf18      	it	ne
 800912c:	2401      	movne	r4, #1
 800912e:	4560      	cmp	r0, ip
 8009130:	bf0c      	ite	eq
 8009132:	2400      	moveq	r4, #0
 8009134:	f004 0401 	andne.w	r4, r4, #1
 8009138:	b134      	cbz	r4, 8009148 <TIM_TimeBaseInit+0x84>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 800913a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800913e:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 8009142:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8009144:	ea43 030c 	orr.w	r3, r3, ip
  }

  TIMx->CR1 = tmpcr1;
 8009148:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800914a:	888b      	ldrh	r3, [r1, #4]
 800914c:	8583      	strh	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800914e:	880b      	ldrh	r3, [r1, #0]
 8009150:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8009152:	b96a      	cbnz	r2, 8009170 <TIM_TimeBaseInit+0xac>
 8009154:	4b10      	ldr	r3, [pc, #64]	; (8009198 <TIM_TimeBaseInit+0xd4>)
 8009156:	4a11      	ldr	r2, [pc, #68]	; (800919c <TIM_TimeBaseInit+0xd8>)
 8009158:	4298      	cmp	r0, r3
 800915a:	bf14      	ite	ne
 800915c:	2300      	movne	r3, #0
 800915e:	2301      	moveq	r3, #1
 8009160:	4290      	cmp	r0, r2
 8009162:	bf08      	it	eq
 8009164:	f043 0301 	orreq.w	r3, r3, #1
 8009168:	b913      	cbnz	r3, 8009170 <TIM_TimeBaseInit+0xac>
 800916a:	4b0d      	ldr	r3, [pc, #52]	; (80091a0 <TIM_TimeBaseInit+0xdc>)
 800916c:	4298      	cmp	r0, r3
 800916e:	d101      	bne.n	8009174 <TIM_TimeBaseInit+0xb0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8009170:	7a0b      	ldrb	r3, [r1, #8]
 8009172:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 8009174:	2301      	movs	r3, #1
 8009176:	8283      	strh	r3, [r0, #20]
}
 8009178:	bd10      	pop	{r4, pc}
 800917a:	bf00      	nop
 800917c:	40012c00 	.word	0x40012c00
 8009180:	40013400 	.word	0x40013400
 8009184:	40000400 	.word	0x40000400
 8009188:	40000800 	.word	0x40000800
 800918c:	40000c00 	.word	0x40000c00
 8009190:	40001000 	.word	0x40001000
 8009194:	40001400 	.word	0x40001400
 8009198:	40014000 	.word	0x40014000
 800919c:	40014400 	.word	0x40014400
 80091a0:	40014800 	.word	0x40014800

080091a4 <TIM_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80091a4:	b121      	cbz	r1, 80091b0 <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80091a6:	8803      	ldrh	r3, [r0, #0]
 80091a8:	b29b      	uxth	r3, r3
 80091aa:	f043 0301 	orr.w	r3, r3, #1
 80091ae:	e004      	b.n	80091ba <TIM_Cmd+0x16>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 80091b0:	8803      	ldrh	r3, [r0, #0]
 80091b2:	f023 0301 	bic.w	r3, r3, #1
 80091b6:	041b      	lsls	r3, r3, #16
 80091b8:	0c1b      	lsrs	r3, r3, #16
 80091ba:	8003      	strh	r3, [r0, #0]
  }
}
 80091bc:	4770      	bx	lr

080091be <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 80091be:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 80091c0:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80091c2:	4211      	tst	r1, r2
 80091c4:	bf0c      	ite	eq
 80091c6:	2000      	moveq	r0, #0
 80091c8:	2001      	movne	r0, #1
 80091ca:	4219      	tst	r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 80091cc:	bf0c      	ite	eq
 80091ce:	2000      	moveq	r0, #0
 80091d0:	f000 0001 	andne.w	r0, r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80091d4:	4770      	bx	lr

080091d6 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 80091d6:	43c9      	mvns	r1, r1
 80091d8:	b289      	uxth	r1, r1
 80091da:	8201      	strh	r1, [r0, #16]
}
 80091dc:	4770      	bx	lr
	...

080091e0 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80091e0:	4b0d      	ldr	r3, [pc, #52]	; (8009218 <RCC_DeInit+0x38>)
 80091e2:	681a      	ldr	r2, [r3, #0]
 80091e4:	f042 0201 	orr.w	r2, r2, #1
 80091e8:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 80091ea:	6859      	ldr	r1, [r3, #4]
 80091ec:	4a0b      	ldr	r2, [pc, #44]	; (800921c <RCC_DeInit+0x3c>)
 80091ee:	ea01 0202 	and.w	r2, r1, r2
 80091f2:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80091f4:	681a      	ldr	r2, [r3, #0]
 80091f6:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80091fa:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80091fe:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8009200:	681a      	ldr	r2, [r3, #0]
 8009202:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8009206:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8009208:	685a      	ldr	r2, [r3, #4]
 800920a:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 800920e:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8009210:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8009214:	609a      	str	r2, [r3, #8]
#endif /* STM32F10X_CL */

}
 8009216:	4770      	bx	lr
 8009218:	40021000 	.word	0x40021000
 800921c:	f8ff0000 	.word	0xf8ff0000

08009220 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8009220:	4b0c      	ldr	r3, [pc, #48]	; (8009254 <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8009222:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8009226:	681a      	ldr	r2, [r3, #0]
 8009228:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800922c:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 800922e:	681a      	ldr	r2, [r3, #0]
 8009230:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8009234:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8009236:	d003      	beq.n	8009240 <RCC_HSEConfig+0x20>
 8009238:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 800923c:	d108      	bne.n	8009250 <RCC_HSEConfig+0x30>
 800923e:	e003      	b.n	8009248 <RCC_HSEConfig+0x28>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 8009240:	681a      	ldr	r2, [r3, #0]
 8009242:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009246:	e002      	b.n	800924e <RCC_HSEConfig+0x2e>
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 8009248:	681a      	ldr	r2, [r3, #0]
 800924a:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 800924e:	601a      	str	r2, [r3, #0]
      break;
      
    default:
      break;
  }
}
 8009250:	4770      	bx	lr
 8009252:	bf00      	nop
 8009254:	40021000 	.word	0x40021000

08009258 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8009258:	4b03      	ldr	r3, [pc, #12]	; (8009268 <RCC_PLLConfig+0x10>)
 800925a:	685a      	ldr	r2, [r3, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 800925c:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8009260:	4310      	orrs	r0, r2
 8009262:	4308      	orrs	r0, r1
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8009264:	6058      	str	r0, [r3, #4]
}
 8009266:	4770      	bx	lr
 8009268:	40021000 	.word	0x40021000

0800926c <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 800926c:	4b01      	ldr	r3, [pc, #4]	; (8009274 <RCC_PLLCmd+0x8>)
 800926e:	6018      	str	r0, [r3, #0]
}
 8009270:	4770      	bx	lr
 8009272:	bf00      	nop
 8009274:	42420060 	.word	0x42420060

08009278 <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8009278:	4b03      	ldr	r3, [pc, #12]	; (8009288 <RCC_SYSCLKConfig+0x10>)
 800927a:	685a      	ldr	r2, [r3, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 800927c:	f022 0203 	bic.w	r2, r2, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8009280:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8009282:	6058      	str	r0, [r3, #4]
}
 8009284:	4770      	bx	lr
 8009286:	bf00      	nop
 8009288:	40021000 	.word	0x40021000

0800928c <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 800928c:	4b02      	ldr	r3, [pc, #8]	; (8009298 <RCC_GetSYSCLKSource+0xc>)
 800928e:	6858      	ldr	r0, [r3, #4]
 8009290:	f000 000c 	and.w	r0, r0, #12
}
 8009294:	4770      	bx	lr
 8009296:	bf00      	nop
 8009298:	40021000 	.word	0x40021000

0800929c <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 800929c:	4b03      	ldr	r3, [pc, #12]	; (80092ac <RCC_HCLKConfig+0x10>)
 800929e:	685a      	ldr	r2, [r3, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 80092a0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 80092a4:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80092a6:	6058      	str	r0, [r3, #4]
}
 80092a8:	4770      	bx	lr
 80092aa:	bf00      	nop
 80092ac:	40021000 	.word	0x40021000

080092b0 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80092b0:	4b03      	ldr	r3, [pc, #12]	; (80092c0 <RCC_PCLK1Config+0x10>)
 80092b2:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 80092b4:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80092b8:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80092ba:	6058      	str	r0, [r3, #4]
}
 80092bc:	4770      	bx	lr
 80092be:	bf00      	nop
 80092c0:	40021000 	.word	0x40021000

080092c4 <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80092c4:	4b03      	ldr	r3, [pc, #12]	; (80092d4 <RCC_PCLK2Config+0x10>)
 80092c6:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 80092c8:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80092cc:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80092d0:	6058      	str	r0, [r3, #4]
}
 80092d2:	4770      	bx	lr
 80092d4:	40021000 	.word	0x40021000

080092d8 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 80092d8:	4b01      	ldr	r3, [pc, #4]	; (80092e0 <RCC_USBCLKConfig+0x8>)
 80092da:	6018      	str	r0, [r3, #0]
}
 80092dc:	4770      	bx	lr
 80092de:	bf00      	nop
 80092e0:	424200d8 	.word	0x424200d8

080092e4 <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 80092e4:	4b03      	ldr	r3, [pc, #12]	; (80092f4 <RCC_ADCCLKConfig+0x10>)
 80092e6:	685a      	ldr	r2, [r3, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 80092e8:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 80092ec:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80092ee:	6058      	str	r0, [r3, #4]
}
 80092f0:	4770      	bx	lr
 80092f2:	bf00      	nop
 80092f4:	40021000 	.word	0x40021000

080092f8 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 80092f8:	4b02      	ldr	r3, [pc, #8]	; (8009304 <RCC_RTCCLKConfig+0xc>)
 80092fa:	6a1a      	ldr	r2, [r3, #32]
 80092fc:	4310      	orrs	r0, r2
 80092fe:	6218      	str	r0, [r3, #32]
}
 8009300:	4770      	bx	lr
 8009302:	bf00      	nop
 8009304:	40021000 	.word	0x40021000

08009308 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8009308:	4b01      	ldr	r3, [pc, #4]	; (8009310 <RCC_RTCCLKCmd+0x8>)
 800930a:	6018      	str	r0, [r3, #0]
}
 800930c:	4770      	bx	lr
 800930e:	bf00      	nop
 8009310:	4242043c 	.word	0x4242043c

08009314 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8009314:	4b22      	ldr	r3, [pc, #136]	; (80093a0 <RCC_GetClocksFreq+0x8c>)
 8009316:	685a      	ldr	r2, [r3, #4]
 8009318:	f002 020c 	and.w	r2, r2, #12
  
  switch (tmp)
 800931c:	2a04      	cmp	r2, #4
 800931e:	d002      	beq.n	8009326 <RCC_GetClocksFreq+0x12>
 8009320:	2a08      	cmp	r2, #8
 8009322:	d115      	bne.n	8009350 <RCC_GetClocksFreq+0x3c>
 8009324:	e001      	b.n	800932a <RCC_GetClocksFreq+0x16>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
 8009326:	4b1f      	ldr	r3, [pc, #124]	; (80093a4 <RCC_GetClocksFreq+0x90>)
 8009328:	e013      	b.n	8009352 <RCC_GetClocksFreq+0x3e>
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 800932a:	685a      	ldr	r2, [r3, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 800932c:	6859      	ldr	r1, [r3, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 800932e:	f3c2 4283 	ubfx	r2, r2, #18, #4
 8009332:	3202      	adds	r2, #2
      
      if (pllsource == 0x00)
 8009334:	f411 3f80 	tst.w	r1, #65536	; 0x10000
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
 8009338:	bf08      	it	eq
 800933a:	4b1b      	ldreq	r3, [pc, #108]	; (80093a8 <RCC_GetClocksFreq+0x94>)
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
      
      if (pllsource == 0x00)
 800933c:	d005      	beq.n	800934a <RCC_GetClocksFreq+0x36>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 800933e:	685b      	ldr	r3, [r3, #4]
 8009340:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 8009344:	bf14      	ite	ne
 8009346:	4b19      	ldrne	r3, [pc, #100]	; (80093ac <RCC_GetClocksFreq+0x98>)
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 8009348:	4b16      	ldreq	r3, [pc, #88]	; (80093a4 <RCC_GetClocksFreq+0x90>)
 800934a:	435a      	muls	r2, r3
 800934c:	6002      	str	r2, [r0, #0]
 800934e:	e001      	b.n	8009354 <RCC_GetClocksFreq+0x40>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 8009350:	4b17      	ldr	r3, [pc, #92]	; (80093b0 <RCC_GetClocksFreq+0x9c>)
 8009352:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8009354:	4b12      	ldr	r3, [pc, #72]	; (80093a0 <RCC_GetClocksFreq+0x8c>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8009356:	4917      	ldr	r1, [pc, #92]	; (80093b4 <RCC_GetClocksFreq+0xa0>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8009358:	685a      	ldr	r2, [r3, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800935a:	f8d0 c000 	ldr.w	ip, [r0]
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
  tmp = tmp >> 4;
 800935e:	f3c2 1203 	ubfx	r2, r2, #4, #4
  presc = APBAHBPrescTable[tmp];
 8009362:	5c8a      	ldrb	r2, [r1, r2]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8009364:	fa2c f202 	lsr.w	r2, ip, r2
 8009368:	6042      	str	r2, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 800936a:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 8;
 800936e:	f3cc 2c02 	ubfx	ip, ip, #8, #3
  presc = APBAHBPrescTable[tmp];
 8009372:	f811 c00c 	ldrb.w	ip, [r1, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8009376:	fa22 fc0c 	lsr.w	ip, r2, ip
 800937a:	f8c0 c008 	str.w	ip, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 800937e:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 11;
 8009382:	f3cc 2cc2 	ubfx	ip, ip, #11, #3
  presc = APBAHBPrescTable[tmp];
 8009386:	f811 100c 	ldrb.w	r1, [r1, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800938a:	40ca      	lsrs	r2, r1
 800938c:	60c2      	str	r2, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 800938e:	685b      	ldr	r3, [r3, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
 8009390:	4909      	ldr	r1, [pc, #36]	; (80093b8 <RCC_GetClocksFreq+0xa4>)
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
 8009392:	f3c3 3381 	ubfx	r3, r3, #14, #2
  presc = ADCPrescTable[tmp];
 8009396:	5ccb      	ldrb	r3, [r1, r3]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8009398:	fbb2 f2f3 	udiv	r2, r2, r3
 800939c:	6102      	str	r2, [r0, #16]
}
 800939e:	4770      	bx	lr
 80093a0:	40021000 	.word	0x40021000
 80093a4:	00b71b00 	.word	0x00b71b00
 80093a8:	003d0900 	.word	0x003d0900
 80093ac:	005b8d80 	.word	0x005b8d80
 80093b0:	007a1200 	.word	0x007a1200
 80093b4:	20000048 	.word	0x20000048
 80093b8:	20000044 	.word	0x20000044

080093bc <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80093bc:	b119      	cbz	r1, 80093c6 <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80093be:	4b05      	ldr	r3, [pc, #20]	; (80093d4 <RCC_AHBPeriphClockCmd+0x18>)
 80093c0:	695a      	ldr	r2, [r3, #20]
 80093c2:	4310      	orrs	r0, r2
 80093c4:	e003      	b.n	80093ce <RCC_AHBPeriphClockCmd+0x12>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80093c6:	4b03      	ldr	r3, [pc, #12]	; (80093d4 <RCC_AHBPeriphClockCmd+0x18>)
 80093c8:	695a      	ldr	r2, [r3, #20]
 80093ca:	ea22 0000 	bic.w	r0, r2, r0
 80093ce:	6158      	str	r0, [r3, #20]
  }
}
 80093d0:	4770      	bx	lr
 80093d2:	bf00      	nop
 80093d4:	40021000 	.word	0x40021000

080093d8 <RCC_APB2PeriphClockCmd>:
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80093d8:	b119      	cbz	r1, 80093e2 <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80093da:	4b05      	ldr	r3, [pc, #20]	; (80093f0 <RCC_APB2PeriphClockCmd+0x18>)
 80093dc:	699a      	ldr	r2, [r3, #24]
 80093de:	4310      	orrs	r0, r2
 80093e0:	e003      	b.n	80093ea <RCC_APB2PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80093e2:	4b03      	ldr	r3, [pc, #12]	; (80093f0 <RCC_APB2PeriphClockCmd+0x18>)
 80093e4:	699a      	ldr	r2, [r3, #24]
 80093e6:	ea22 0000 	bic.w	r0, r2, r0
 80093ea:	6198      	str	r0, [r3, #24]
  }
}
 80093ec:	4770      	bx	lr
 80093ee:	bf00      	nop
 80093f0:	40021000 	.word	0x40021000

080093f4 <RCC_APB1PeriphClockCmd>:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80093f4:	b119      	cbz	r1, 80093fe <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80093f6:	4b05      	ldr	r3, [pc, #20]	; (800940c <RCC_APB1PeriphClockCmd+0x18>)
 80093f8:	69da      	ldr	r2, [r3, #28]
 80093fa:	4310      	orrs	r0, r2
 80093fc:	e003      	b.n	8009406 <RCC_APB1PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80093fe:	4b03      	ldr	r3, [pc, #12]	; (800940c <RCC_APB1PeriphClockCmd+0x18>)
 8009400:	69da      	ldr	r2, [r3, #28]
 8009402:	ea22 0000 	bic.w	r0, r2, r0
 8009406:	61d8      	str	r0, [r3, #28]
  }
}
 8009408:	4770      	bx	lr
 800940a:	bf00      	nop
 800940c:	40021000 	.word	0x40021000

08009410 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009410:	b119      	cbz	r1, 800941a <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8009412:	4b05      	ldr	r3, [pc, #20]	; (8009428 <RCC_APB2PeriphResetCmd+0x18>)
 8009414:	68da      	ldr	r2, [r3, #12]
 8009416:	4310      	orrs	r0, r2
 8009418:	e003      	b.n	8009422 <RCC_APB2PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 800941a:	4b03      	ldr	r3, [pc, #12]	; (8009428 <RCC_APB2PeriphResetCmd+0x18>)
 800941c:	68da      	ldr	r2, [r3, #12]
 800941e:	ea22 0000 	bic.w	r0, r2, r0
 8009422:	60d8      	str	r0, [r3, #12]
  }
}
 8009424:	4770      	bx	lr
 8009426:	bf00      	nop
 8009428:	40021000 	.word	0x40021000

0800942c <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800942c:	b119      	cbz	r1, 8009436 <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 800942e:	4b05      	ldr	r3, [pc, #20]	; (8009444 <RCC_APB1PeriphResetCmd+0x18>)
 8009430:	691a      	ldr	r2, [r3, #16]
 8009432:	4310      	orrs	r0, r2
 8009434:	e003      	b.n	800943e <RCC_APB1PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8009436:	4b03      	ldr	r3, [pc, #12]	; (8009444 <RCC_APB1PeriphResetCmd+0x18>)
 8009438:	691a      	ldr	r2, [r3, #16]
 800943a:	ea22 0000 	bic.w	r0, r2, r0
 800943e:	6118      	str	r0, [r3, #16]
  }
}
 8009440:	4770      	bx	lr
 8009442:	bf00      	nop
 8009444:	40021000 	.word	0x40021000

08009448 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8009448:	4b01      	ldr	r3, [pc, #4]	; (8009450 <RCC_BackupResetCmd+0x8>)
 800944a:	6018      	str	r0, [r3, #0]
}
 800944c:	4770      	bx	lr
 800944e:	bf00      	nop
 8009450:	42420440 	.word	0x42420440

08009454 <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8009454:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8009456:	2b01      	cmp	r3, #1
  {
    statusreg = RCC->CR;
 8009458:	bf04      	itt	eq
 800945a:	4b08      	ldreq	r3, [pc, #32]	; (800947c <RCC_GetFlagStatus+0x28>)
 800945c:	681b      	ldreq	r3, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
 800945e:	d005      	beq.n	800946c <RCC_GetFlagStatus+0x18>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8009460:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8009462:	bf0b      	itete	eq
 8009464:	4b05      	ldreq	r3, [pc, #20]	; (800947c <RCC_GetFlagStatus+0x28>)
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8009466:	4b05      	ldrne	r3, [pc, #20]	; (800947c <RCC_GetFlagStatus+0x28>)
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 8009468:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800946a:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 800946c:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8009470:	fa33 f000 	lsrs.w	r0, r3, r0
  {
    statusreg = RCC->BDCR;
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8009474:	f000 0001 	and.w	r0, r0, #1
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8009478:	4770      	bx	lr
 800947a:	bf00      	nop
 800947c:	40021000 	.word	0x40021000

08009480 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8009480:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 8009482:	2300      	movs	r3, #0
 8009484:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8009486:	2031      	movs	r0, #49	; 0x31
 8009488:	f7ff ffe4 	bl	8009454 <RCC_GetFlagStatus>
    StartUpCounter++;  
 800948c:	9b01      	ldr	r3, [sp, #4]
 800948e:	3301      	adds	r3, #1
 8009490:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
 8009492:	9b01      	ldr	r3, [sp, #4]
 8009494:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8009498:	d001      	beq.n	800949e <RCC_WaitForHSEStartUp+0x1e>
 800949a:	2800      	cmp	r0, #0
 800949c:	d0f3      	beq.n	8009486 <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 800949e:	2031      	movs	r0, #49	; 0x31
 80094a0:	f7ff ffd8 	bl	8009454 <RCC_GetFlagStatus>
 80094a4:	3800      	subs	r0, #0
 80094a6:	bf18      	it	ne
 80094a8:	2001      	movne	r0, #1
  else
  {
    status = ERROR;
  }  
  return (status);
}
 80094aa:	bd0e      	pop	{r1, r2, r3, pc}

080094ac <RTC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80094ac:	b121      	cbz	r1, 80094b8 <RTC_ITConfig+0xc>
  {
    RTC->CRH |= RTC_IT;
 80094ae:	4b06      	ldr	r3, [pc, #24]	; (80094c8 <RTC_ITConfig+0x1c>)
 80094b0:	881a      	ldrh	r2, [r3, #0]
 80094b2:	b292      	uxth	r2, r2
 80094b4:	4310      	orrs	r0, r2
 80094b6:	e004      	b.n	80094c2 <RTC_ITConfig+0x16>
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
 80094b8:	4b03      	ldr	r3, [pc, #12]	; (80094c8 <RTC_ITConfig+0x1c>)
 80094ba:	881a      	ldrh	r2, [r3, #0]
 80094bc:	b292      	uxth	r2, r2
 80094be:	ea22 0000 	bic.w	r0, r2, r0
 80094c2:	8018      	strh	r0, [r3, #0]
  }
}
 80094c4:	4770      	bx	lr
 80094c6:	bf00      	nop
 80094c8:	40002800 	.word	0x40002800

080094cc <RTC_EnterConfigMode>:
  * @retval None
  */
void RTC_EnterConfigMode(void)
{
  /* Set the CNF flag to enter in the Configuration Mode */
  RTC->CRL |= CRL_CNF_Set;
 80094cc:	4b03      	ldr	r3, [pc, #12]	; (80094dc <RTC_EnterConfigMode+0x10>)
 80094ce:	889a      	ldrh	r2, [r3, #4]
 80094d0:	b292      	uxth	r2, r2
 80094d2:	f042 0210 	orr.w	r2, r2, #16
 80094d6:	809a      	strh	r2, [r3, #4]
}
 80094d8:	4770      	bx	lr
 80094da:	bf00      	nop
 80094dc:	40002800 	.word	0x40002800

080094e0 <RTC_ExitConfigMode>:
  * @retval None
  */
void RTC_ExitConfigMode(void)
{
  /* Reset the CNF flag to exit from the Configuration Mode */
  RTC->CRL &= CRL_CNF_Reset;
 80094e0:	4a03      	ldr	r2, [pc, #12]	; (80094f0 <RTC_ExitConfigMode+0x10>)
 80094e2:	8893      	ldrh	r3, [r2, #4]
 80094e4:	f023 0310 	bic.w	r3, r3, #16
 80094e8:	041b      	lsls	r3, r3, #16
 80094ea:	0c1b      	lsrs	r3, r3, #16
 80094ec:	8093      	strh	r3, [r2, #4]
}
 80094ee:	4770      	bx	lr
 80094f0:	40002800 	.word	0x40002800

080094f4 <RTC_SetCounter>:
  * @brief  Sets the RTC counter value.
  * @param  CounterValue: RTC counter new value.
  * @retval None
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
 80094f4:	b510      	push	{r4, lr}
 80094f6:	4604      	mov	r4, r0
  RTC_EnterConfigMode();
 80094f8:	f7ff ffe8 	bl	80094cc <RTC_EnterConfigMode>
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 80094fc:	4b03      	ldr	r3, [pc, #12]	; (800950c <RTC_SetCounter+0x18>)
 80094fe:	0c22      	lsrs	r2, r4, #16
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 8009500:	b2a4      	uxth	r4, r4
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
  RTC_EnterConfigMode();
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 8009502:	831a      	strh	r2, [r3, #24]
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 8009504:	839c      	strh	r4, [r3, #28]
  RTC_ExitConfigMode();
 8009506:	f7ff ffeb 	bl	80094e0 <RTC_ExitConfigMode>
}
 800950a:	bd10      	pop	{r4, pc}
 800950c:	40002800 	.word	0x40002800

08009510 <RTC_SetPrescaler>:
  * @brief  Sets the RTC prescaler value.
  * @param  PrescalerValue: RTC prescaler new value.
  * @retval None
  */
void RTC_SetPrescaler(uint32_t PrescalerValue)
{
 8009510:	b510      	push	{r4, lr}
 8009512:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
 8009514:	f7ff ffda 	bl	80094cc <RTC_EnterConfigMode>
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 8009518:	4b04      	ldr	r3, [pc, #16]	; (800952c <RTC_SetPrescaler+0x1c>)
 800951a:	f3c4 4203 	ubfx	r2, r4, #16, #4
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 800951e:	b2a4      	uxth	r4, r4
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 8009520:	811a      	strh	r2, [r3, #8]
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 8009522:	819c      	strh	r4, [r3, #12]
  RTC_ExitConfigMode();
 8009524:	f7ff ffdc 	bl	80094e0 <RTC_ExitConfigMode>
}
 8009528:	bd10      	pop	{r4, pc}
 800952a:	bf00      	nop
 800952c:	40002800 	.word	0x40002800

08009530 <RTC_WaitForLastTask>:
  * @retval None
  */
void RTC_WaitForLastTask(void)
{
  /* Loop until RTOFF flag is set */
  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
 8009530:	4b02      	ldr	r3, [pc, #8]	; (800953c <RTC_WaitForLastTask+0xc>)
 8009532:	889a      	ldrh	r2, [r3, #4]
 8009534:	f012 0f20 	tst.w	r2, #32
 8009538:	d0fb      	beq.n	8009532 <RTC_WaitForLastTask+0x2>
  {
  }
}
 800953a:	4770      	bx	lr
 800953c:	40002800 	.word	0x40002800

08009540 <RTC_WaitForSynchro>:
  * @retval None
  */
void RTC_WaitForSynchro(void)
{
  /* Clear RSF flag */
  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
 8009540:	4a05      	ldr	r2, [pc, #20]	; (8009558 <RTC_WaitForSynchro+0x18>)
 8009542:	8893      	ldrh	r3, [r2, #4]
 8009544:	f023 0308 	bic.w	r3, r3, #8
 8009548:	041b      	lsls	r3, r3, #16
 800954a:	0c1b      	lsrs	r3, r3, #16
 800954c:	8093      	strh	r3, [r2, #4]
  /* Loop until RSF flag is set */
  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
 800954e:	8893      	ldrh	r3, [r2, #4]
 8009550:	f013 0f08 	tst.w	r3, #8
 8009554:	d0fb      	beq.n	800954e <RTC_WaitForSynchro+0xe>
  {
  }
}
 8009556:	4770      	bx	lr
 8009558:	40002800 	.word	0x40002800

0800955c <BKP_DeInit>:
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
  RCC_BackupResetCmd(ENABLE);
 800955c:	2001      	movs	r0, #1
  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
 800955e:	b508      	push	{r3, lr}
  RCC_BackupResetCmd(ENABLE);
 8009560:	f7ff ff72 	bl	8009448 <RCC_BackupResetCmd>
  RCC_BackupResetCmd(DISABLE);
 8009564:	2000      	movs	r0, #0
 8009566:	f7ff ff6f 	bl	8009448 <RCC_BackupResetCmd>
}
 800956a:	bd08      	pop	{r3, pc}

0800956c <PWR_BackupAccessCmd>:
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 800956c:	4b01      	ldr	r3, [pc, #4]	; (8009574 <PWR_BackupAccessCmd+0x8>)
 800956e:	6018      	str	r0, [r3, #0]
}
 8009570:	4770      	bx	lr
 8009572:	bf00      	nop
 8009574:	420e0020 	.word	0x420e0020

08009578 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8009578:	f040 60be 	orr.w	r0, r0, #99614720	; 0x5f00000
 800957c:	4b02      	ldr	r3, [pc, #8]	; (8009588 <NVIC_PriorityGroupConfig+0x10>)
 800957e:	f440 2020 	orr.w	r0, r0, #655360	; 0xa0000
 8009582:	60d8      	str	r0, [r3, #12]
}
 8009584:	4770      	bx	lr
 8009586:	bf00      	nop
 8009588:	e000ed00 	.word	0xe000ed00

0800958c <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 800958c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8009590:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8009594:	4b02      	ldr	r3, [pc, #8]	; (80095a0 <NVIC_SetVectorTable+0x14>)
 8009596:	ea41 0000 	orr.w	r0, r1, r0
 800959a:	6098      	str	r0, [r3, #8]
}
 800959c:	4770      	bx	lr
 800959e:	bf00      	nop
 80095a0:	e000ed00 	.word	0xe000ed00

080095a4 <SysTick_CLKSourceConfig>:
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 80095a4:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80095a6:	bf0b      	itete	eq
 80095a8:	4b05      	ldreq	r3, [pc, #20]	; (80095c0 <SysTick_CLKSourceConfig+0x1c>)
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80095aa:	4b05      	ldrne	r3, [pc, #20]	; (80095c0 <SysTick_CLKSourceConfig+0x1c>)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80095ac:	681a      	ldreq	r2, [r3, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80095ae:	681a      	ldrne	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80095b0:	bf0c      	ite	eq
 80095b2:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80095b6:	f022 0204 	bicne.w	r2, r2, #4
 80095ba:	601a      	str	r2, [r3, #0]
  }
}
 80095bc:	4770      	bx	lr
 80095be:	bf00      	nop
 80095c0:	e000e010 	.word	0xe000e010

080095c4 <Standard_GetConfiguration>:
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetConfiguration(uint16_t Length)
{
 80095c4:	b510      	push	{r4, lr}
 80095c6:	4c06      	ldr	r4, [pc, #24]	; (80095e0 <Standard_GetConfiguration+0x1c>)
  if (Length == 0)
 80095c8:	b918      	cbnz	r0, 80095d2 <Standard_GetConfiguration+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 80095ca:	6823      	ldr	r3, [r4, #0]
 80095cc:	2201      	movs	r2, #1
 80095ce:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_Configuration);
    return 0;
 80095d0:	e005      	b.n	80095de <Standard_GetConfiguration+0x1a>
  }
  pUser_Standard_Requests->User_GetConfiguration();
 80095d2:	4b04      	ldr	r3, [pc, #16]	; (80095e4 <Standard_GetConfiguration+0x20>)
 80095d4:	681b      	ldr	r3, [r3, #0]
 80095d6:	681b      	ldr	r3, [r3, #0]
 80095d8:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_Configuration;
 80095da:	6820      	ldr	r0, [r4, #0]
 80095dc:	300a      	adds	r0, #10
}
 80095de:	bd10      	pop	{r4, pc}
 80095e0:	2000379c 	.word	0x2000379c
 80095e4:	20003798 	.word	0x20003798

080095e8 <Standard_GetInterface>:
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetInterface(uint16_t Length)
{
 80095e8:	b510      	push	{r4, lr}
 80095ea:	4c06      	ldr	r4, [pc, #24]	; (8009604 <Standard_GetInterface+0x1c>)
  if (Length == 0)
 80095ec:	b918      	cbnz	r0, 80095f6 <Standard_GetInterface+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 80095ee:	6823      	ldr	r3, [r4, #0]
 80095f0:	2201      	movs	r2, #1
 80095f2:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
 80095f4:	e005      	b.n	8009602 <Standard_GetInterface+0x1a>
  }
  pUser_Standard_Requests->User_GetInterface();
 80095f6:	4b04      	ldr	r3, [pc, #16]	; (8009608 <Standard_GetInterface+0x20>)
 80095f8:	681b      	ldr	r3, [r3, #0]
 80095fa:	689b      	ldr	r3, [r3, #8]
 80095fc:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_AlternateSetting;
 80095fe:	6820      	ldr	r0, [r4, #0]
 8009600:	300c      	adds	r0, #12
}
 8009602:	bd10      	pop	{r4, pc}
 8009604:	2000379c 	.word	0x2000379c
 8009608:	20003798 	.word	0x20003798

0800960c <Standard_GetStatus>:
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
uint8_t *Standard_GetStatus(uint16_t Length)
{
 800960c:	b508      	push	{r3, lr}
 800960e:	4b27      	ldr	r3, [pc, #156]	; (80096ac <Standard_GetStatus+0xa0>)
  if (Length == 0)
 8009610:	b918      	cbnz	r0, 800961a <Standard_GetStatus+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
 8009612:	681b      	ldr	r3, [r3, #0]
 8009614:	2202      	movs	r2, #2
 8009616:	821a      	strh	r2, [r3, #16]
    return 0;
 8009618:	e047      	b.n	80096aa <Standard_GetStatus+0x9e>
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 800961a:	4825      	ldr	r0, [pc, #148]	; (80096b0 <Standard_GetStatus+0xa4>)
 800961c:	2200      	movs	r2, #0

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 800961e:	681b      	ldr	r3, [r3, #0]
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 8009620:	8002      	strh	r2, [r0, #0]

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009622:	781a      	ldrb	r2, [r3, #0]
 8009624:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009628:	d115      	bne.n	8009656 <Standard_GetStatus+0x4a>
  {
    /*Get Device Status */
    uint8_t Feature = pInformation->Current_Feature;

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
 800962a:	7a5b      	ldrb	r3, [r3, #9]
 800962c:	7802      	ldrb	r2, [r0, #0]
 800962e:	f013 0f20 	tst.w	r3, #32
    {
      SetBit(StatusInfo0, 1);
 8009632:	bf14      	ite	ne
 8009634:	f042 0202 	orrne.w	r2, r2, #2
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 8009638:	f022 0202 	biceq.w	r2, r2, #2
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
 800963c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009640:	4b1b      	ldr	r3, [pc, #108]	; (80096b0 <Standard_GetStatus+0xa4>)
    {
      SetBit(StatusInfo0, 1);
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 8009642:	7002      	strb	r2, [r0, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 8009644:	bf15      	itete	ne
 8009646:	781a      	ldrbne	r2, [r3, #0]
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 8009648:	781a      	ldrbeq	r2, [r3, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 800964a:	f042 0201 	orrne.w	r2, r2, #1
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 800964e:	f022 0201 	biceq.w	r2, r2, #1
 8009652:	701a      	strb	r2, [r3, #0]
 8009654:	e022      	b.n	800969c <Standard_GetStatus+0x90>
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009656:	2a01      	cmp	r2, #1
 8009658:	d027      	beq.n	80096aa <Standard_GetStatus+0x9e>
  {
    return (uint8_t *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 800965a:	2a02      	cmp	r2, #2
 800965c:	d124      	bne.n	80096a8 <Standard_GetStatus+0x9c>
  {
    uint8_t Related_Endpoint;
    uint8_t wIndex0 = pInformation->USBwIndex0;
 800965e:	795a      	ldrb	r2, [r3, #5]

    Related_Endpoint = (wIndex0 & 0x0f);
 8009660:	f002 030f 	and.w	r3, r2, #15
    if (ValBit(wIndex0, 7))
 8009664:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009668:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800966c:	d008      	beq.n	8009680 <Standard_GetStatus+0x74>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
 800966e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009672:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009676:	681b      	ldr	r3, [r3, #0]
 8009678:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800967c:	2b10      	cmp	r3, #16
 800967e:	e008      	b.n	8009692 <Standard_GetStatus+0x86>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 8009680:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009684:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009688:	681b      	ldr	r3, [r3, #0]
 800968a:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800968e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
      {
        SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
 8009692:	bf02      	ittt	eq
 8009694:	7803      	ldrbeq	r3, [r0, #0]
 8009696:	f043 0301 	orreq.w	r3, r3, #1
 800969a:	7003      	strbeq	r3, [r0, #0]
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
 800969c:	4b05      	ldr	r3, [pc, #20]	; (80096b4 <Standard_GetStatus+0xa8>)
 800969e:	681b      	ldr	r3, [r3, #0]
 80096a0:	691b      	ldr	r3, [r3, #16]
 80096a2:	4798      	blx	r3
  return (uint8_t *)&StatusInfo;
 80096a4:	4802      	ldr	r0, [pc, #8]	; (80096b0 <Standard_GetStatus+0xa4>)
 80096a6:	e000      	b.n	80096aa <Standard_GetStatus+0x9e>
    }

  }
  else
  {
    return NULL;
 80096a8:	2000      	movs	r0, #0
  }
  pUser_Standard_Requests->User_GetStatus();
  return (uint8_t *)&StatusInfo;
}
 80096aa:	bd08      	pop	{r3, pc}
 80096ac:	2000379c 	.word	0x2000379c
 80096b0:	200037a8 	.word	0x200037a8
 80096b4:	20003798 	.word	0x20003798

080096b8 <DataStageIn>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
 80096b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 80096ba:	4b27      	ldr	r3, [pc, #156]	; (8009758 <DataStageIn+0xa0>)
 80096bc:	681c      	ldr	r4, [r3, #0]
  uint32_t save_wLength = pEPinfo->Usb_wLength;
 80096be:	8a23      	ldrh	r3, [r4, #16]
  uint32_t ControlState = pInformation->ControlState;
 80096c0:	7a26      	ldrb	r6, [r4, #8]

  uint8_t *DataBuffer;
  uint32_t Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
 80096c2:	f1d3 0201 	rsbs	r2, r3, #1
 80096c6:	bf38      	it	cc
 80096c8:	2200      	movcc	r2, #0
 80096ca:	2e04      	cmp	r6, #4
 80096cc:	bf14      	ite	ne
 80096ce:	2600      	movne	r6, #0
 80096d0:	f002 0601 	andeq.w	r6, r2, #1
 80096d4:	b1ae      	cbz	r6, 8009702 <DataStageIn+0x4a>
  {
    if(Data_Mul_MaxPacketSize == TRUE)
 80096d6:	4921      	ldr	r1, [pc, #132]	; (800975c <DataStageIn+0xa4>)
 80096d8:	4a21      	ldr	r2, [pc, #132]	; (8009760 <DataStageIn+0xa8>)
 80096da:	780b      	ldrb	r3, [r1, #0]
 80096dc:	2b01      	cmp	r3, #1
 80096de:	d10c      	bne.n	80096fa <DataStageIn+0x42>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 80096e0:	4b20      	ldr	r3, [pc, #128]	; (8009764 <DataStageIn+0xac>)
      ControlState = LAST_IN_DATA;
 80096e2:	2704      	movs	r7, #4
  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 80096e4:	6818      	ldr	r0, [r3, #0]
 80096e6:	4b20      	ldr	r3, [pc, #128]	; (8009768 <DataStageIn+0xb0>)
 80096e8:	b280      	uxth	r0, r0
 80096ea:	18c3      	adds	r3, r0, r3
 80096ec:	005b      	lsls	r3, r3, #1
 80096ee:	2000      	movs	r0, #0
 80096f0:	6018      	str	r0, [r3, #0]
 80096f2:	2330      	movs	r3, #48	; 0x30
 80096f4:	8013      	strh	r3, [r2, #0]
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
 80096f6:	7008      	strb	r0, [r1, #0]
 80096f8:	e02a      	b.n	8009750 <DataStageIn+0x98>
    #ifdef STM32F10X_CL      
      PCD_EP_Read (ENDP0, 0, 0);
    #endif  /* STM32F10X_CL */ 
    
    #ifndef STM32F10X_CL 
      vSetEPTxStatus(EP_TX_STALL);
 80096fa:	2310      	movs	r3, #16
 80096fc:	8013      	strh	r3, [r2, #0]
      Data_Mul_MaxPacketSize = FALSE;
    }
    else 
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
 80096fe:	2707      	movs	r7, #7
 8009700:	e026      	b.n	8009750 <DataStageIn+0x98>
    }
    
    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
 8009702:	8aa5      	ldrh	r5, [r4, #20]
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
 8009704:	42ab      	cmp	r3, r5
 8009706:	bf8c      	ite	hi
 8009708:	2702      	movhi	r7, #2
 800970a:	2704      	movls	r7, #4
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
 800970c:	429d      	cmp	r5, r3
 800970e:	bf28      	it	cs
 8009710:	461d      	movcs	r5, r3
 8009712:	4628      	mov	r0, r5
 8009714:	69a3      	ldr	r3, [r4, #24]
 8009716:	4798      	blx	r3
 8009718:	4603      	mov	r3, r0

#ifdef STM32F10X_CL
  PCD_EP_Write (ENDP0, DataBuffer, Length);
#else   
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
 800971a:	4630      	mov	r0, r6
 800971c:	9301      	str	r3, [sp, #4]
 800971e:	f000 fd87 	bl	800a230 <GetEPTxAddr>
 8009722:	9b01      	ldr	r3, [sp, #4]
 8009724:	462a      	mov	r2, r5
 8009726:	4601      	mov	r1, r0
 8009728:	4618      	mov	r0, r3
 800972a:	f000 fca1 	bl	800a070 <UserToPMABufferCopy>
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);
 800972e:	4629      	mov	r1, r5
 8009730:	4630      	mov	r0, r6
 8009732:	f000 fd99 	bl	800a268 <SetEPTxCount>

  pEPinfo->Usb_wLength -= Length;
 8009736:	8a23      	ldrh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);
 8009738:	2230      	movs	r2, #48	; 0x30
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
 800973a:	1b5b      	subs	r3, r3, r5
 800973c:	8223      	strh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
 800973e:	8a63      	ldrh	r3, [r4, #18]
 8009740:	18ed      	adds	r5, r5, r3
  vSetEPTxStatus(EP_TX_VALID);
 8009742:	4b07      	ldr	r3, [pc, #28]	; (8009760 <DataStageIn+0xa8>)
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
 8009744:	8265      	strh	r5, [r4, #18]
  vSetEPTxStatus(EP_TX_VALID);
 8009746:	801a      	strh	r2, [r3, #0]

  USB_StatusOut();/* Expect the host to abort the data IN stage */
 8009748:	4b08      	ldr	r3, [pc, #32]	; (800976c <DataStageIn+0xb4>)
 800974a:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 800974e:	801a      	strh	r2, [r3, #0]

Expect_Status_Out:
  pInformation->ControlState = ControlState;
 8009750:	4b01      	ldr	r3, [pc, #4]	; (8009758 <DataStageIn+0xa0>)
 8009752:	681b      	ldr	r3, [r3, #0]
 8009754:	721f      	strb	r7, [r3, #8]
}
 8009756:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009758:	2000379c 	.word	0x2000379c
 800975c:	20000c1c 	.word	0x20000c1c
 8009760:	200037ac 	.word	0x200037ac
 8009764:	40005c50 	.word	0x40005c50
 8009768:	20003002 	.word	0x20003002
 800976c:	200037aa 	.word	0x200037aa

08009770 <Standard_SetConfiguration>:
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
 8009770:	b510      	push	{r4, lr}

  if ((pInformation->USBwValue0 <=
 8009772:	4b0a      	ldr	r3, [pc, #40]	; (800979c <Standard_SetConfiguration+0x2c>)
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 8009774:	490a      	ldr	r1, [pc, #40]	; (80097a0 <Standard_SetConfiguration+0x30>)
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
 8009776:	681b      	ldr	r3, [r3, #0]
 8009778:	7849      	ldrb	r1, [r1, #1]
 800977a:	78da      	ldrb	r2, [r3, #3]
 800977c:	4291      	cmp	r1, r2
 800977e:	d30a      	bcc.n	8009796 <Standard_SetConfiguration+0x26>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 8009780:	7899      	ldrb	r1, [r3, #2]
 8009782:	b941      	cbnz	r1, 8009796 <Standard_SetConfiguration+0x26>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
 8009784:	889c      	ldrh	r4, [r3, #4]
 8009786:	b934      	cbnz	r4, 8009796 <Standard_SetConfiguration+0x26>
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
 8009788:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 800978a:	4b06      	ldr	r3, [pc, #24]	; (80097a4 <Standard_SetConfiguration+0x34>)
 800978c:	681b      	ldr	r3, [r3, #0]
 800978e:	685b      	ldr	r3, [r3, #4]
 8009790:	4798      	blx	r3
    return USB_SUCCESS;
 8009792:	4620      	mov	r0, r4
 8009794:	e000      	b.n	8009798 <Standard_SetConfiguration+0x28>
  }
  else
  {
    return USB_UNSUPPORT;
 8009796:	2002      	movs	r0, #2
  }
}
 8009798:	bd10      	pop	{r4, pc}
 800979a:	bf00      	nop
 800979c:	2000379c 	.word	0x2000379c
 80097a0:	200037a0 	.word	0x200037a0
 80097a4:	20003798 	.word	0x20003798

080097a8 <Standard_SetInterface>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
 80097a8:	b538      	push	{r3, r4, r5, lr}
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
 80097aa:	4a0e      	ldr	r2, [pc, #56]	; (80097e4 <Standard_SetInterface+0x3c>)
 80097ac:	4c0e      	ldr	r4, [pc, #56]	; (80097e8 <Standard_SetInterface+0x40>)
 80097ae:	6812      	ldr	r2, [r2, #0]
 80097b0:	6823      	ldr	r3, [r4, #0]
 80097b2:	7958      	ldrb	r0, [r3, #5]
 80097b4:	78d9      	ldrb	r1, [r3, #3]
 80097b6:	6993      	ldr	r3, [r2, #24]
 80097b8:	4798      	blx	r3

  if (pInformation->Current_Configuration != 0)
 80097ba:	6823      	ldr	r3, [r4, #0]
 80097bc:	7a9a      	ldrb	r2, [r3, #10]
 80097be:	b17a      	cbz	r2, 80097e0 <Standard_SetInterface+0x38>
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
 80097c0:	b970      	cbnz	r0, 80097e0 <Standard_SetInterface+0x38>
 80097c2:	791a      	ldrb	r2, [r3, #4]
 80097c4:	b962      	cbnz	r2, 80097e0 <Standard_SetInterface+0x38>
        || (pInformation->USBwValue1 != 0))
 80097c6:	789d      	ldrb	r5, [r3, #2]
 80097c8:	b955      	cbnz	r5, 80097e0 <Standard_SetInterface+0x38>
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
 80097ca:	4b08      	ldr	r3, [pc, #32]	; (80097ec <Standard_SetInterface+0x44>)
 80097cc:	681b      	ldr	r3, [r3, #0]
 80097ce:	68db      	ldr	r3, [r3, #12]
 80097d0:	4798      	blx	r3
      pInformation->Current_Interface = pInformation->USBwIndex0;
 80097d2:	6823      	ldr	r3, [r4, #0]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
 80097d4:	4628      	mov	r0, r5
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
 80097d6:	795a      	ldrb	r2, [r3, #5]
 80097d8:	72da      	strb	r2, [r3, #11]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
 80097da:	78da      	ldrb	r2, [r3, #3]
 80097dc:	731a      	strb	r2, [r3, #12]
      return USB_SUCCESS;
 80097de:	e000      	b.n	80097e2 <Standard_SetInterface+0x3a>
  if (pInformation->Current_Configuration != 0)
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
        || (pInformation->USBwValue1 != 0))
    {
      return  USB_UNSUPPORT;
 80097e0:	2002      	movs	r0, #2
    }

  }

  return USB_UNSUPPORT;
}
 80097e2:	bd38      	pop	{r3, r4, r5, pc}
 80097e4:	20003794 	.word	0x20003794
 80097e8:	2000379c 	.word	0x2000379c
 80097ec:	20003798 	.word	0x20003798

080097f0 <Standard_ClearFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
 80097f0:	b510      	push	{r4, lr}
  uint32_t     Type_Rec = Type_Recipient;
 80097f2:	4b3f      	ldr	r3, [pc, #252]	; (80098f0 <Standard_ClearFeature+0x100>)
 80097f4:	681b      	ldr	r3, [r3, #0]
 80097f6:	7818      	ldrb	r0, [r3, #0]
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80097f8:	f010 007f 	ands.w	r0, r0, #127	; 0x7f
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
 80097fc:	bf02      	ittt	eq
 80097fe:	7a5a      	ldrbeq	r2, [r3, #9]
 8009800:	f022 0220 	biceq.w	r2, r2, #32
 8009804:	725a      	strbeq	r2, [r3, #9]
{
  uint32_t     Type_Rec = Type_Recipient;
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009806:	d072      	beq.n	80098ee <Standard_ClearFeature+0xfe>
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009808:	2802      	cmp	r0, #2
 800980a:	d16f      	bne.n	80098ec <Standard_ClearFeature+0xfc>
    DEVICE* pDev;
    uint32_t Related_Endpoint;
    uint32_t wIndex0;
    uint32_t rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
 800980c:	885a      	ldrh	r2, [r3, #2]
 800980e:	2a00      	cmp	r2, #0
 8009810:	d16d      	bne.n	80098ee <Standard_ClearFeature+0xfe>
        || (pInformation->USBwIndex1 != 0))
 8009812:	791a      	ldrb	r2, [r3, #4]
 8009814:	2a00      	cmp	r2, #0
 8009816:	d16a      	bne.n	80098ee <Standard_ClearFeature+0xfe>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
 8009818:	795a      	ldrb	r2, [r3, #5]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 800981a:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 80098f4 <Standard_ClearFeature+0x104>
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
 800981e:	f022 0080 	bic.w	r0, r2, #128	; 0x80
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
 8009822:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009826:	ea4f 0480 	mov.w	r4, r0, lsl #2
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 800982a:	bf15      	itete	ne
 800982c:	f104 4480 	addne.w	r4, r4, #1073741824	; 0x40000000
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009830:	f104 4480 	addeq.w	r4, r4, #1073741824	; 0x40000000

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8009834:	f504 44b8 	addne.w	r4, r4, #23552	; 0x5c00
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009838:	f504 44b8 	addeq.w	r4, r4, #23552	; 0x5c00

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 800983c:	bf14      	ite	ne
 800983e:	6821      	ldrne	r1, [r4, #0]
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009840:	6821      	ldreq	r1, [r4, #0]
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 8009842:	f89c c000 	ldrb.w	ip, [ip]

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8009846:	bf14      	ite	ne
 8009848:	f001 0130 	andne.w	r1, r1, #48	; 0x30
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 800984c:	f401 5140 	andeq.w	r1, r1, #12288	; 0x3000
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 8009850:	4560      	cmp	r0, ip
 8009852:	bf34      	ite	cc
 8009854:	f04f 0c00 	movcc.w	ip, #0
 8009858:	f04f 0c01 	movcs.w	ip, #1
 800985c:	2900      	cmp	r1, #0
 800985e:	bf14      	ite	ne
 8009860:	4661      	movne	r1, ip
 8009862:	f04c 0101 	orreq.w	r1, ip, #1
 8009866:	2900      	cmp	r1, #0
 8009868:	d140      	bne.n	80098ec <Standard_ClearFeature+0xfc>
        || (pInformation->Current_Configuration == 0))
 800986a:	7a9b      	ldrb	r3, [r3, #10]
 800986c:	2b00      	cmp	r3, #0
 800986e:	d03d      	beq.n	80098ec <Standard_ClearFeature+0xfc>
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
 8009870:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009874:	ea4f 0480 	mov.w	r4, r0, lsl #2
 8009878:	d011      	beq.n	800989e <Standard_ClearFeature+0xae>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
 800987a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 800987e:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 8009882:	6823      	ldr	r3, [r4, #0]
 8009884:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8009888:	2b10      	cmp	r3, #16
 800988a:	d129      	bne.n	80098e0 <Standard_ClearFeature+0xf0>
      {
      #ifndef STM32F10X_CL
        ClearDTOG_TX(Related_Endpoint);
 800988c:	b2c4      	uxtb	r4, r0
 800988e:	4620      	mov	r0, r4
 8009890:	f000 fc9a 	bl	800a1c8 <ClearDTOG_TX>
      #endif /* STM32F10X_CL */
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
 8009894:	4620      	mov	r0, r4
 8009896:	2130      	movs	r1, #48	; 0x30
 8009898:	f000 fc32 	bl	800a100 <SetEPTxStatus>
 800989c:	e020      	b.n	80098e0 <Standard_ClearFeature+0xf0>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 800989e:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80098a2:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 80098a6:	6823      	ldr	r3, [r4, #0]
 80098a8:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80098ac:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80098b0:	d116      	bne.n	80098e0 <Standard_ClearFeature+0xf0>
      {
        if (Related_Endpoint == ENDP0)
 80098b2:	b930      	cbnz	r0, 80098c2 <Standard_ClearFeature+0xd2>
        {
          /* After clear the STALL, enable the default endpoint receiver */
//          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
          SetEPRxCount(Related_Endpoint, pProperty->MaxPacketSize);
 80098b4:	4b10      	ldr	r3, [pc, #64]	; (80098f8 <Standard_ClearFeature+0x108>)
 80098b6:	681b      	ldr	r3, [r3, #0]
 80098b8:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 80098bc:	f000 fce2 	bl	800a284 <SetEPRxCount>
 80098c0:	e002      	b.n	80098c8 <Standard_ClearFeature+0xd8>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
        #ifndef STM32F10X_CL
          ClearDTOG_RX(Related_Endpoint);
 80098c2:	b2c0      	uxtb	r0, r0
 80098c4:	f000 fc6c 	bl	800a1a0 <ClearDTOG_RX>
        #endif /* STM32F10X_CL */
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 80098c8:	6822      	ldr	r2, [r4, #0]
 80098ca:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 80098ce:	ea02 0303 	and.w	r3, r2, r3
 80098d2:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 80098d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80098da:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80098de:	6023      	str	r3, [r4, #0]
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
 80098e0:	4b06      	ldr	r3, [pc, #24]	; (80098fc <Standard_ClearFeature+0x10c>)
 80098e2:	681b      	ldr	r3, [r3, #0]
 80098e4:	695b      	ldr	r3, [r3, #20]
 80098e6:	4798      	blx	r3
    return USB_SUCCESS;
 80098e8:	2000      	movs	r0, #0
 80098ea:	e000      	b.n	80098ee <Standard_ClearFeature+0xfe>
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
        || (pInformation->Current_Configuration == 0))
    {
      return USB_UNSUPPORT;
 80098ec:	2002      	movs	r0, #2
    pUser_Standard_Requests->User_ClearFeature();
    return USB_SUCCESS;
  }

  return USB_UNSUPPORT;
}
 80098ee:	bd10      	pop	{r4, pc}
 80098f0:	2000379c 	.word	0x2000379c
 80098f4:	200037a0 	.word	0x200037a0
 80098f8:	20003794 	.word	0x20003794
 80098fc:	20003798 	.word	0x20003798

08009900 <Standard_SetEndPointFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
 8009900:	b508      	push	{r3, lr}
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 8009902:	4b2b      	ldr	r3, [pc, #172]	; (80099b0 <Standard_SetEndPointFeature+0xb0>)
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 8009904:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 80099b4 <Standard_SetEndPointFeature+0xb4>
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 8009908:	6818      	ldr	r0, [r3, #0]
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 800990a:	f89c c000 	ldrb.w	ip, [ip]
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 800990e:	7941      	ldrb	r1, [r0, #5]
  rEP = wIndex0 & ~0x80;
 8009910:	f021 0280 	bic.w	r2, r1, #128	; 0x80
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
 8009914:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009918:	ea4f 0382 	mov.w	r3, r2, lsl #2
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 800991c:	bf15      	itete	ne
 800991e:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009922:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 8009926:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 800992a:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 800992e:	bf15      	itete	ne
 8009930:	681b      	ldrne	r3, [r3, #0]
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009932:	681b      	ldreq	r3, [r3, #0]

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 8009934:	f003 0330 	andne.w	r3, r3, #48	; 0x30
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009938:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 800993c:	4562      	cmp	r2, ip
 800993e:	d235      	bcs.n	80099ac <Standard_SetEndPointFeature+0xac>
      || pInformation->USBwValue != 0 || Status == 0
 8009940:	f8b0 c002 	ldrh.w	ip, [r0, #2]
 8009944:	f1bc 0c00 	subs.w	ip, ip, #0
 8009948:	bf18      	it	ne
 800994a:	f04f 0c01 	movne.w	ip, #1
 800994e:	2b00      	cmp	r3, #0
 8009950:	bf14      	ite	ne
 8009952:	4663      	movne	r3, ip
 8009954:	f04c 0301 	orreq.w	r3, ip, #1
 8009958:	bb43      	cbnz	r3, 80099ac <Standard_SetEndPointFeature+0xac>
      || pInformation->Current_Configuration == 0)
 800995a:	7a83      	ldrb	r3, [r0, #10]
 800995c:	b333      	cbz	r3, 80099ac <Standard_SetEndPointFeature+0xac>
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
 800995e:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009962:	ea4f 0382 	mov.w	r3, r2, lsl #2
 8009966:	d00b      	beq.n	8009980 <Standard_SetEndPointFeature+0x80>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
 8009968:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800996c:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009970:	6819      	ldr	r1, [r3, #0]
 8009972:	f648 72bf 	movw	r2, #36799	; 0x8fbf
 8009976:	ea01 0202 	and.w	r2, r1, r2
 800997a:	f082 0210 	eor.w	r2, r2, #16
 800997e:	e00a      	b.n	8009996 <Standard_SetEndPointFeature+0x96>
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
 8009980:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009984:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009988:	6819      	ldr	r1, [r3, #0]
 800998a:	f64b 728f 	movw	r2, #49039	; 0xbf8f
 800998e:	ea01 0202 	and.w	r2, r1, r2
 8009992:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 8009996:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800999a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800999e:	601a      	str	r2, [r3, #0]
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
 80099a0:	4b05      	ldr	r3, [pc, #20]	; (80099b8 <Standard_SetEndPointFeature+0xb8>)
 80099a2:	681b      	ldr	r3, [r3, #0]
 80099a4:	699b      	ldr	r3, [r3, #24]
 80099a6:	4798      	blx	r3
  return USB_SUCCESS;
 80099a8:	2000      	movs	r0, #0
 80099aa:	e000      	b.n	80099ae <Standard_SetEndPointFeature+0xae>

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
 80099ac:	2002      	movs	r0, #2
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
 80099ae:	bd08      	pop	{r3, pc}
 80099b0:	2000379c 	.word	0x2000379c
 80099b4:	200037a0 	.word	0x200037a0
 80099b8:	20003798 	.word	0x20003798

080099bc <Standard_SetDeviceFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
 80099bc:	b508      	push	{r3, lr}
  SetBit(pInformation->Current_Feature, 5);
 80099be:	4b06      	ldr	r3, [pc, #24]	; (80099d8 <Standard_SetDeviceFeature+0x1c>)
 80099c0:	681b      	ldr	r3, [r3, #0]
 80099c2:	7a5a      	ldrb	r2, [r3, #9]
 80099c4:	f042 0220 	orr.w	r2, r2, #32
 80099c8:	725a      	strb	r2, [r3, #9]
  pUser_Standard_Requests->User_SetDeviceFeature();
 80099ca:	4b04      	ldr	r3, [pc, #16]	; (80099dc <Standard_SetDeviceFeature+0x20>)
 80099cc:	681b      	ldr	r3, [r3, #0]
 80099ce:	69db      	ldr	r3, [r3, #28]
 80099d0:	4798      	blx	r3
  return USB_SUCCESS;
}
 80099d2:	2000      	movs	r0, #0
 80099d4:	bd08      	pop	{r3, pc}
 80099d6:	bf00      	nop
 80099d8:	2000379c 	.word	0x2000379c
 80099dc:	20003798 	.word	0x20003798

080099e0 <Standard_GetDescriptorData>:
*******************************************************************************/
uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
{
  uint32_t  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
 80099e0:	4b05      	ldr	r3, [pc, #20]	; (80099f8 <Standard_GetDescriptorData+0x18>)
 80099e2:	681a      	ldr	r2, [r3, #0]
 80099e4:	8a53      	ldrh	r3, [r2, #18]
  if (Length == 0)
 80099e6:	b918      	cbnz	r0, 80099f0 <Standard_GetDescriptorData+0x10>
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
 80099e8:	8889      	ldrh	r1, [r1, #4]
 80099ea:	1acb      	subs	r3, r1, r3
 80099ec:	8213      	strh	r3, [r2, #16]
    return 0;
 80099ee:	e001      	b.n	80099f4 <Standard_GetDescriptorData+0x14>
  }

  return pDesc->Descriptor + wOffset;
 80099f0:	6808      	ldr	r0, [r1, #0]
 80099f2:	18c0      	adds	r0, r0, r3
}
 80099f4:	4770      	bx	lr
 80099f6:	bf00      	nop
 80099f8:	2000379c 	.word	0x2000379c

080099fc <Post0_Process>:
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
uint8_t Post0_Process(void)
{
 80099fc:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
#endif /* STM32F10X_CL */
      
//  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 80099fe:	4b0c      	ldr	r3, [pc, #48]	; (8009a30 <Post0_Process+0x34>)
 8009a00:	2000      	movs	r0, #0
 8009a02:	681b      	ldr	r3, [r3, #0]
 8009a04:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8009a08:	f000 fc3c 	bl	800a284 <SetEPRxCount>

  if (pInformation->ControlState == STALLED)
 8009a0c:	4b09      	ldr	r3, [pc, #36]	; (8009a34 <Post0_Process+0x38>)
 8009a0e:	681b      	ldr	r3, [r3, #0]
 8009a10:	7a18      	ldrb	r0, [r3, #8]
 8009a12:	2808      	cmp	r0, #8
 8009a14:	d106      	bne.n	8009a24 <Post0_Process+0x28>
  {
    vSetEPRxStatus(EP_RX_STALL);
 8009a16:	4b08      	ldr	r3, [pc, #32]	; (8009a38 <Post0_Process+0x3c>)
 8009a18:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009a1c:	801a      	strh	r2, [r3, #0]
    vSetEPTxStatus(EP_TX_STALL);
 8009a1e:	4b07      	ldr	r3, [pc, #28]	; (8009a3c <Post0_Process+0x40>)
 8009a20:	2210      	movs	r2, #16
 8009a22:	801a      	strh	r2, [r3, #0]
 8009a24:	2809      	cmp	r0, #9
 8009a26:	bf14      	ite	ne
 8009a28:	2000      	movne	r0, #0
 8009a2a:	2001      	moveq	r0, #1
    OTGD_FS_EP0StartXfer(ep);    
  }  
#endif /* STM32F10X_CL */

  return (pInformation->ControlState == PAUSE);
}
 8009a2c:	bd08      	pop	{r3, pc}
 8009a2e:	bf00      	nop
 8009a30:	20003794 	.word	0x20003794
 8009a34:	2000379c 	.word	0x2000379c
 8009a38:	200037aa 	.word	0x200037aa
 8009a3c:	200037ac 	.word	0x200037ac

08009a40 <Out0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Out0_Process(void)
{
 8009a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t ControlState = pInformation->ControlState;
 8009a42:	4b38      	ldr	r3, [pc, #224]	; (8009b24 <Out0_Process+0xe4>)
 8009a44:	681c      	ldr	r4, [r3, #0]
 8009a46:	7a23      	ldrb	r3, [r4, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8009a48:	2b02      	cmp	r3, #2
 8009a4a:	bf14      	ite	ne
 8009a4c:	2600      	movne	r6, #0
 8009a4e:	2601      	moveq	r6, #1
 8009a50:	2b04      	cmp	r3, #4
 8009a52:	bf08      	it	eq
 8009a54:	f046 0601 	orreq.w	r6, r6, #1
 8009a58:	2e00      	cmp	r6, #0
 8009a5a:	d15b      	bne.n	8009b14 <Out0_Process+0xd4>
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
 8009a5c:	2b03      	cmp	r3, #3
 8009a5e:	bf14      	ite	ne
 8009a60:	2200      	movne	r2, #0
 8009a62:	2201      	moveq	r2, #1
 8009a64:	2b05      	cmp	r3, #5
 8009a66:	bf08      	it	eq
 8009a68:	f042 0201 	orreq.w	r2, r2, #1
 8009a6c:	2a00      	cmp	r2, #0
 8009a6e:	d04b      	beq.n	8009b08 <Out0_Process+0xc8>
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
 8009a70:	69a3      	ldr	r3, [r4, #24]
void DataStageOut(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;
 8009a72:	8a22      	ldrh	r2, [r4, #16]

  if (pEPinfo->CopyData && save_rLength)
 8009a74:	1e19      	subs	r1, r3, #0
 8009a76:	bf18      	it	ne
 8009a78:	2101      	movne	r1, #1
 8009a7a:	2a00      	cmp	r2, #0
 8009a7c:	bf0c      	ite	eq
 8009a7e:	2100      	moveq	r1, #0
 8009a80:	f001 0101 	andne.w	r1, r1, #1
 8009a84:	b1a1      	cbz	r1, 8009ab0 <Out0_Process+0x70>
  {
    uint8_t *Buffer;
    uint32_t Length;

    Length = pEPinfo->PacketSize;
 8009a86:	8aa5      	ldrh	r5, [r4, #20]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 8009a88:	4295      	cmp	r5, r2
 8009a8a:	bf28      	it	cs
 8009a8c:	4615      	movcs	r5, r2
 8009a8e:	4628      	mov	r0, r5
 8009a90:	4798      	blx	r3
    pEPinfo->Usb_rLength -= Length;
 8009a92:	8a23      	ldrh	r3, [r4, #16]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 8009a94:	4607      	mov	r7, r0
    pEPinfo->Usb_rLength -= Length;
 8009a96:	1b5b      	subs	r3, r3, r5
 8009a98:	8223      	strh	r3, [r4, #16]
    pEPinfo->Usb_rOffset += Length;
 8009a9a:	8a63      	ldrh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 8009a9c:	4630      	mov	r0, r6
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    pEPinfo->Usb_rLength -= Length;
    pEPinfo->Usb_rOffset += Length;
 8009a9e:	18eb      	adds	r3, r5, r3
 8009aa0:	8263      	strh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 8009aa2:	f000 fbd3 	bl	800a24c <GetEPRxAddr>
 8009aa6:	462a      	mov	r2, r5
 8009aa8:	4601      	mov	r1, r0
 8009aaa:	4638      	mov	r0, r7
 8009aac:	f000 faf6 	bl	800a09c <PMAToUserBufferCopy>
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
 8009ab0:	8a23      	ldrh	r3, [r4, #16]
 8009ab2:	b153      	cbz	r3, 8009aca <Out0_Process+0x8a>
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 8009ab4:	4b1c      	ldr	r3, [pc, #112]	; (8009b28 <Out0_Process+0xe8>)
 8009ab6:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    SetEPTxCount(ENDP0, 0);
 8009aba:	2000      	movs	r0, #0
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 8009abc:	801a      	strh	r2, [r3, #0]
    SetEPTxCount(ENDP0, 0);
 8009abe:	4601      	mov	r1, r0
 8009ac0:	f000 fbd2 	bl	800a268 <SetEPTxCount>
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 8009ac4:	4b19      	ldr	r3, [pc, #100]	; (8009b2c <Out0_Process+0xec>)
 8009ac6:	2230      	movs	r2, #48	; 0x30
 8009ac8:	801a      	strh	r2, [r3, #0]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
 8009aca:	8a23      	ldrh	r3, [r4, #16]
 8009acc:	8aa2      	ldrh	r2, [r4, #20]
 8009ace:	429a      	cmp	r2, r3
 8009ad0:	d803      	bhi.n	8009ada <Out0_Process+0x9a>
  {
    pInformation->ControlState = OUT_DATA;
 8009ad2:	4b14      	ldr	r3, [pc, #80]	; (8009b24 <Out0_Process+0xe4>)
 8009ad4:	2203      	movs	r2, #3
 8009ad6:	681b      	ldr	r3, [r3, #0]
 8009ad8:	e003      	b.n	8009ae2 <Out0_Process+0xa2>
 8009ada:	4a12      	ldr	r2, [pc, #72]	; (8009b24 <Out0_Process+0xe4>)
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
 8009adc:	b11b      	cbz	r3, 8009ae6 <Out0_Process+0xa6>
    {
      pInformation->ControlState = LAST_OUT_DATA;
 8009ade:	6813      	ldr	r3, [r2, #0]
 8009ae0:	2205      	movs	r2, #5
 8009ae2:	721a      	strb	r2, [r3, #8]
 8009ae4:	e00c      	b.n	8009b00 <Out0_Process+0xc0>
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
 8009ae6:	6812      	ldr	r2, [r2, #0]
 8009ae8:	2106      	movs	r1, #6
 8009aea:	7211      	strb	r1, [r2, #8]
      USB_StatusIn();
 8009aec:	4a10      	ldr	r2, [pc, #64]	; (8009b30 <Out0_Process+0xf0>)
 8009aee:	6811      	ldr	r1, [r2, #0]
 8009af0:	4a10      	ldr	r2, [pc, #64]	; (8009b34 <Out0_Process+0xf4>)
 8009af2:	b289      	uxth	r1, r1
 8009af4:	188a      	adds	r2, r1, r2
 8009af6:	0052      	lsls	r2, r2, #1
 8009af8:	6013      	str	r3, [r2, #0]
 8009afa:	4b0c      	ldr	r3, [pc, #48]	; (8009b2c <Out0_Process+0xec>)
 8009afc:	2230      	movs	r2, #48	; 0x30
 8009afe:	801a      	strh	r2, [r3, #0]
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
 8009b00:	4b08      	ldr	r3, [pc, #32]	; (8009b24 <Out0_Process+0xe4>)
 8009b02:	681b      	ldr	r3, [r3, #0]
 8009b04:	7a1b      	ldrb	r3, [r3, #8]
 8009b06:	e006      	b.n	8009b16 <Out0_Process+0xd6>
  }

  else if (ControlState == WAIT_STATUS_OUT)
 8009b08:	2b07      	cmp	r3, #7
 8009b0a:	d103      	bne.n	8009b14 <Out0_Process+0xd4>
  {
    (*pProperty->Process_Status_OUT)();
 8009b0c:	4b0a      	ldr	r3, [pc, #40]	; (8009b38 <Out0_Process+0xf8>)
 8009b0e:	681b      	ldr	r3, [r3, #0]
 8009b10:	68db      	ldr	r3, [r3, #12]
 8009b12:	4798      	blx	r3


  /* Unexpect state, STALL the endpoint */
  else
  {
    ControlState = STALLED;
 8009b14:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 8009b16:	4a03      	ldr	r2, [pc, #12]	; (8009b24 <Out0_Process+0xe4>)
 8009b18:	6812      	ldr	r2, [r2, #0]
 8009b1a:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 8009b1c:	f7ff ff6e 	bl	80099fc <Post0_Process>
}
 8009b20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009b22:	bf00      	nop
 8009b24:	2000379c 	.word	0x2000379c
 8009b28:	200037aa 	.word	0x200037aa
 8009b2c:	200037ac 	.word	0x200037ac
 8009b30:	40005c50 	.word	0x40005c50
 8009b34:	20003002 	.word	0x20003002
 8009b38:	20003794 	.word	0x20003794

08009b3c <Setup0_Process>:
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b3c:	4bb5      	ldr	r3, [pc, #724]	; (8009e14 <Setup0_Process+0x2d8>)
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Setup0_Process(void)
{
 8009b3e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b40:	681a      	ldr	r2, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009b42:	4eb5      	ldr	r6, [pc, #724]	; (8009e18 <Setup0_Process+0x2dc>)
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b44:	4bb5      	ldr	r3, [pc, #724]	; (8009e1c <Setup0_Process+0x2e0>)
 8009b46:	b292      	uxth	r2, r2
 8009b48:	18d3      	adds	r3, r2, r3
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009b4a:	6835      	ldr	r5, [r6, #0]
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b4c:	005b      	lsls	r3, r3, #1
 8009b4e:	681f      	ldr	r7, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009b50:	7a2b      	ldrb	r3, [r5, #8]
 8009b52:	2b09      	cmp	r3, #9
 8009b54:	d01a      	beq.n	8009b8c <Setup0_Process+0x50>
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009b56:	b2bf      	uxth	r7, r7
 8009b58:	f107 5700 	add.w	r7, r7, #536870912	; 0x20000000
 8009b5c:	f507 5740 	add.w	r7, r7, #12288	; 0x3000
 8009b60:	007f      	lsls	r7, r7, #1
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
 8009b62:	463c      	mov	r4, r7
 8009b64:	f814 3b01 	ldrb.w	r3, [r4], #1
 8009b68:	702b      	strb	r3, [r5, #0]
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 8009b6a:	787b      	ldrb	r3, [r7, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 8009b6c:	370a      	adds	r7, #10
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 8009b6e:	706b      	strb	r3, [r5, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
 8009b70:	f8b4 0003 	ldrh.w	r0, [r4, #3]
 8009b74:	f000 fbb6 	bl	800a2e4 <ByteSwap>
 8009b78:	8068      	strh	r0, [r5, #2]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 8009b7a:	f8b4 0007 	ldrh.w	r0, [r4, #7]
 8009b7e:	6835      	ldr	r5, [r6, #0]
 8009b80:	f000 fbb0 	bl	800a2e4 <ByteSwap>
 8009b84:	80a8      	strh	r0, [r5, #4]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength */
 8009b86:	6833      	ldr	r3, [r6, #0]
 8009b88:	887f      	ldrh	r7, [r7, #2]
 8009b8a:	80df      	strh	r7, [r3, #6]
  }

  pInformation->ControlState = SETTING_UP;
 8009b8c:	4ca2      	ldr	r4, [pc, #648]	; (8009e18 <Setup0_Process+0x2dc>)
 8009b8e:	2201      	movs	r2, #1
 8009b90:	6823      	ldr	r3, [r4, #0]
 8009b92:	721a      	strb	r2, [r3, #8]
  if (pInformation->USBwLength == 0)
 8009b94:	88da      	ldrh	r2, [r3, #6]
 8009b96:	785d      	ldrb	r5, [r3, #1]
 8009b98:	2a00      	cmp	r2, #0
 8009b9a:	d161      	bne.n	8009c60 <Setup0_Process+0x124>
{
  RESULT Result = USB_UNSUPPORT;
  uint32_t RequestNo = pInformation->USBbRequest;
  uint32_t ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009b9c:	781a      	ldrb	r2, [r3, #0]
 8009b9e:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009ba2:	d12e      	bne.n	8009c02 <Setup0_Process+0xc6>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
 8009ba4:	2d09      	cmp	r5, #9
 8009ba6:	d102      	bne.n	8009bae <Setup0_Process+0x72>
    {
      Result = Standard_SetConfiguration();
 8009ba8:	f7ff fde2 	bl	8009770 <Standard_SetConfiguration>
 8009bac:	e03b      	b.n	8009c26 <Setup0_Process+0xea>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
 8009bae:	2d05      	cmp	r5, #5
 8009bb0:	d10d      	bne.n	8009bce <Setup0_Process+0x92>
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
 8009bb2:	f993 2003 	ldrsb.w	r2, [r3, #3]
 8009bb6:	2a00      	cmp	r2, #0
 8009bb8:	db4d      	blt.n	8009c56 <Setup0_Process+0x11a>
 8009bba:	789a      	ldrb	r2, [r3, #2]
 8009bbc:	2a00      	cmp	r2, #0
 8009bbe:	d14a      	bne.n	8009c56 <Setup0_Process+0x11a>
          || (pInformation->USBwIndex != 0)
 8009bc0:	889a      	ldrh	r2, [r3, #4]
 8009bc2:	2a00      	cmp	r2, #0
 8009bc4:	d147      	bne.n	8009c56 <Setup0_Process+0x11a>
          || (pInformation->Current_Configuration != 0))
 8009bc6:	7a9b      	ldrb	r3, [r3, #10]
 8009bc8:	2b00      	cmp	r3, #0
 8009bca:	d035      	beq.n	8009c38 <Setup0_Process+0xfc>
 8009bcc:	e043      	b.n	8009c56 <Setup0_Process+0x11a>
         SetDeviceAddress(pInformation->USBwValue0);
      #endif  /* STM32F10X_CL */
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
 8009bce:	2d03      	cmp	r5, #3
 8009bd0:	d10b      	bne.n	8009bea <Setup0_Process+0xae>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
 8009bd2:	78da      	ldrb	r2, [r3, #3]
 8009bd4:	2a01      	cmp	r2, #1
 8009bd6:	d127      	bne.n	8009c28 <Setup0_Process+0xec>
          && (pInformation->USBwIndex == 0)
 8009bd8:	889a      	ldrh	r2, [r3, #4]
 8009bda:	bb2a      	cbnz	r2, 8009c28 <Setup0_Process+0xec>
          && (ValBit(pInformation->Current_Feature, 5)))
 8009bdc:	7a5b      	ldrb	r3, [r3, #9]
 8009bde:	f013 0f20 	tst.w	r3, #32
 8009be2:	d021      	beq.n	8009c28 <Setup0_Process+0xec>
      {
        Result = Standard_SetDeviceFeature();
 8009be4:	f7ff feea 	bl	80099bc <Standard_SetDeviceFeature>
 8009be8:	e01d      	b.n	8009c26 <Setup0_Process+0xea>
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
 8009bea:	2d01      	cmp	r5, #1
 8009bec:	d11c      	bne.n	8009c28 <Setup0_Process+0xec>
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
 8009bee:	78da      	ldrb	r2, [r3, #3]
 8009bf0:	2a01      	cmp	r2, #1
 8009bf2:	d119      	bne.n	8009c28 <Setup0_Process+0xec>
          && pInformation->USBwIndex == 0
 8009bf4:	889a      	ldrh	r2, [r3, #4]
 8009bf6:	b9ba      	cbnz	r2, 8009c28 <Setup0_Process+0xec>
          && ValBit(pInformation->Current_Feature, 5))
 8009bf8:	7a5b      	ldrb	r3, [r3, #9]
 8009bfa:	f013 0f20 	tst.w	r3, #32
 8009bfe:	d013      	beq.n	8009c28 <Setup0_Process+0xec>
 8009c00:	e00a      	b.n	8009c18 <Setup0_Process+0xdc>
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009c02:	2a01      	cmp	r2, #1
 8009c04:	d104      	bne.n	8009c10 <Setup0_Process+0xd4>
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
 8009c06:	2d0b      	cmp	r5, #11
 8009c08:	d10e      	bne.n	8009c28 <Setup0_Process+0xec>
    {
      Result = Standard_SetInterface();
 8009c0a:	f7ff fdcd 	bl	80097a8 <Standard_SetInterface>
 8009c0e:	e00a      	b.n	8009c26 <Setup0_Process+0xea>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009c10:	2a02      	cmp	r2, #2
 8009c12:	d109      	bne.n	8009c28 <Setup0_Process+0xec>
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
 8009c14:	2d01      	cmp	r5, #1
 8009c16:	d102      	bne.n	8009c1e <Setup0_Process+0xe2>
    {
      Result = Standard_ClearFeature();
 8009c18:	f7ff fdea 	bl	80097f0 <Standard_ClearFeature>
 8009c1c:	e003      	b.n	8009c26 <Setup0_Process+0xea>
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
 8009c1e:	2d03      	cmp	r5, #3
 8009c20:	d102      	bne.n	8009c28 <Setup0_Process+0xec>
    {
      Result = Standard_SetEndPointFeature();
 8009c22:	f7ff fe6d 	bl	8009900 <Standard_SetEndPointFeature>
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
 8009c26:	b138      	cbz	r0, 8009c38 <Setup0_Process+0xfc>
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
 8009c28:	4b7d      	ldr	r3, [pc, #500]	; (8009e20 <Setup0_Process+0x2e4>)
 8009c2a:	4628      	mov	r0, r5
 8009c2c:	681b      	ldr	r3, [r3, #0]
 8009c2e:	695b      	ldr	r3, [r3, #20]
 8009c30:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 8009c32:	2803      	cmp	r0, #3
 8009c34:	d00d      	beq.n	8009c52 <Setup0_Process+0x116>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
 8009c36:	b970      	cbnz	r0, 8009c56 <Setup0_Process+0x11a>
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
 8009c38:	4b76      	ldr	r3, [pc, #472]	; (8009e14 <Setup0_Process+0x2d8>)
 8009c3a:	2130      	movs	r1, #48	; 0x30
 8009c3c:	681a      	ldr	r2, [r3, #0]
 8009c3e:	4b79      	ldr	r3, [pc, #484]	; (8009e24 <Setup0_Process+0x2e8>)
 8009c40:	b292      	uxth	r2, r2
 8009c42:	18d3      	adds	r3, r2, r3
 8009c44:	005b      	lsls	r3, r3, #1
 8009c46:	2200      	movs	r2, #0
 8009c48:	601a      	str	r2, [r3, #0]
 8009c4a:	4b77      	ldr	r3, [pc, #476]	; (8009e28 <Setup0_Process+0x2ec>)
 8009c4c:	8019      	strh	r1, [r3, #0]
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
 8009c4e:	2306      	movs	r3, #6
 8009c50:	e002      	b.n	8009c58 <Setup0_Process+0x11c>
  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    if (Result == USB_NOT_READY)
    {
      ControlState = PAUSE;
 8009c52:	2309      	movs	r3, #9
 8009c54:	e000      	b.n	8009c58 <Setup0_Process+0x11c>
    }
  }

  if (Result != USB_SUCCESS)
  {
    ControlState = STALLED;
 8009c56:	2308      	movs	r3, #8
  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
 8009c58:	4a6f      	ldr	r2, [pc, #444]	; (8009e18 <Setup0_Process+0x2dc>)
 8009c5a:	6812      	ldr	r2, [r2, #0]
 8009c5c:	7213      	strb	r3, [r2, #8]
 8009c5e:	e0d6      	b.n	8009e0e <Setup0_Process+0x2d2>

  CopyRoutine = NULL;
  wOffset = 0;

  /*GET DESCRIPTOR*/
  if (Request_No == GET_DESCRIPTOR)
 8009c60:	2d06      	cmp	r5, #6
 8009c62:	d117      	bne.n	8009c94 <Setup0_Process+0x158>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009c64:	781a      	ldrb	r2, [r3, #0]
 8009c66:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 8009c6a:	f040 808a 	bne.w	8009d82 <Setup0_Process+0x246>
    {
      uint8_t wValue1 = pInformation->USBwValue1;
 8009c6e:	789b      	ldrb	r3, [r3, #2]
      if (wValue1 == DEVICE_DESCRIPTOR)
 8009c70:	2b01      	cmp	r3, #1
 8009c72:	d103      	bne.n	8009c7c <Setup0_Process+0x140>
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
 8009c74:	4b6a      	ldr	r3, [pc, #424]	; (8009e20 <Setup0_Process+0x2e4>)
 8009c76:	681b      	ldr	r3, [r3, #0]
 8009c78:	69db      	ldr	r3, [r3, #28]
 8009c7a:	e079      	b.n	8009d70 <Setup0_Process+0x234>
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
 8009c7c:	2b02      	cmp	r3, #2
 8009c7e:	d103      	bne.n	8009c88 <Setup0_Process+0x14c>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
 8009c80:	4b67      	ldr	r3, [pc, #412]	; (8009e20 <Setup0_Process+0x2e4>)
 8009c82:	681b      	ldr	r3, [r3, #0]
 8009c84:	6a1b      	ldr	r3, [r3, #32]
 8009c86:	e073      	b.n	8009d70 <Setup0_Process+0x234>
      }
      else if (wValue1 == STRING_DESCRIPTOR)
 8009c88:	2b03      	cmp	r3, #3
 8009c8a:	d17a      	bne.n	8009d82 <Setup0_Process+0x246>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
 8009c8c:	4b64      	ldr	r3, [pc, #400]	; (8009e20 <Setup0_Process+0x2e4>)
 8009c8e:	681b      	ldr	r3, [r3, #0]
 8009c90:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009c92:	e06d      	b.n	8009d70 <Setup0_Process+0x234>
      }  /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
 8009c94:	2d00      	cmp	r5, #0
 8009c96:	d147      	bne.n	8009d28 <Setup0_Process+0x1ec>
 8009c98:	8859      	ldrh	r1, [r3, #2]
 8009c9a:	2900      	cmp	r1, #0
 8009c9c:	d171      	bne.n	8009d82 <Setup0_Process+0x246>
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
 8009c9e:	685a      	ldr	r2, [r3, #4]
 8009ca0:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8009ca4:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 8009ca8:	d16b      	bne.n	8009d82 <Setup0_Process+0x246>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009caa:	781a      	ldrb	r2, [r3, #0]
 8009cac:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009cb0:	d103      	bne.n	8009cba <Setup0_Process+0x17e>
        && (pInformation->USBwIndex == 0))
 8009cb2:	889b      	ldrh	r3, [r3, #4]
 8009cb4:	2b00      	cmp	r3, #0
 8009cb6:	d059      	beq.n	8009d6c <Setup0_Process+0x230>
 8009cb8:	e063      	b.n	8009d82 <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009cba:	2a01      	cmp	r2, #1
 8009cbc:	d109      	bne.n	8009cd2 <Setup0_Process+0x196>
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
 8009cbe:	4a58      	ldr	r2, [pc, #352]	; (8009e20 <Setup0_Process+0x2e4>)
 8009cc0:	7958      	ldrb	r0, [r3, #5]
 8009cc2:	6812      	ldr	r2, [r2, #0]
 8009cc4:	6993      	ldr	r3, [r2, #24]
 8009cc6:	4798      	blx	r3
 8009cc8:	2800      	cmp	r0, #0
 8009cca:	d15a      	bne.n	8009d82 <Setup0_Process+0x246>
          && (pInformation->Current_Configuration != 0))
 8009ccc:	6823      	ldr	r3, [r4, #0]
 8009cce:	7a9b      	ldrb	r3, [r3, #10]
 8009cd0:	e028      	b.n	8009d24 <Setup0_Process+0x1e8>
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009cd2:	2a02      	cmp	r2, #2
 8009cd4:	d155      	bne.n	8009d82 <Setup0_Process+0x246>
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 8009cd6:	795b      	ldrb	r3, [r3, #5]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009cd8:	4854      	ldr	r0, [pc, #336]	; (8009e2c <Setup0_Process+0x2f0>)
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 8009cda:	f003 020f 	and.w	r2, r3, #15
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
 8009cde:	f013 0f80 	tst.w	r3, #128	; 0x80

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;
 8009ce2:	f003 0170 	and.w	r1, r3, #112	; 0x70
 8009ce6:	ea4f 0382 	mov.w	r3, r2, lsl #2

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009cea:	bf15      	itete	ne
 8009cec:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009cf0:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009cf4:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009cf8:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009cfc:	bf14      	ite	ne
 8009cfe:	681b      	ldrne	r3, [r3, #0]
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009d00:	681b      	ldreq	r3, [r3, #0]
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009d02:	7800      	ldrb	r0, [r0, #0]

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009d04:	bf14      	ite	ne
 8009d06:	f003 0330 	andne.w	r3, r3, #48	; 0x30
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009d0a:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009d0e:	4282      	cmp	r2, r0
 8009d10:	bf2c      	ite	cs
 8009d12:	2200      	movcs	r2, #0
 8009d14:	2201      	movcc	r2, #1
 8009d16:	2900      	cmp	r1, #0
 8009d18:	bf14      	ite	ne
 8009d1a:	2200      	movne	r2, #0
 8009d1c:	f002 0201 	andeq.w	r2, r2, #1
 8009d20:	2a00      	cmp	r2, #0
 8009d22:	d02e      	beq.n	8009d82 <Setup0_Process+0x246>
          && (Status != 0))
 8009d24:	bb13      	cbnz	r3, 8009d6c <Setup0_Process+0x230>
 8009d26:	e02c      	b.n	8009d82 <Setup0_Process+0x246>
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
 8009d28:	2d08      	cmp	r5, #8
 8009d2a:	d106      	bne.n	8009d3a <Setup0_Process+0x1fe>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009d2c:	781b      	ldrb	r3, [r3, #0]
 8009d2e:	f013 0f7f 	tst.w	r3, #127	; 0x7f
    {
      CopyRoutine = Standard_GetConfiguration;
 8009d32:	bf08      	it	eq
 8009d34:	4b3e      	ldreq	r3, [pc, #248]	; (8009e30 <Setup0_Process+0x2f4>)
  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009d36:	d01c      	beq.n	8009d72 <Setup0_Process+0x236>
 8009d38:	e023      	b.n	8009d82 <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
 8009d3a:	2d0a      	cmp	r5, #10
 8009d3c:	d121      	bne.n	8009d82 <Setup0_Process+0x246>
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009d3e:	781a      	ldrb	r2, [r3, #0]
 8009d40:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8009d44:	2a01      	cmp	r2, #1
 8009d46:	d11c      	bne.n	8009d82 <Setup0_Process+0x246>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
 8009d48:	7a9a      	ldrb	r2, [r3, #10]
 8009d4a:	b1d2      	cbz	r2, 8009d82 <Setup0_Process+0x246>
 8009d4c:	8859      	ldrh	r1, [r3, #2]
 8009d4e:	b9c1      	cbnz	r1, 8009d82 <Setup0_Process+0x246>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
 8009d50:	685a      	ldr	r2, [r3, #4]
 8009d52:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8009d56:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8009d5a:	d112      	bne.n	8009d82 <Setup0_Process+0x246>
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 8009d5c:	4a30      	ldr	r2, [pc, #192]	; (8009e20 <Setup0_Process+0x2e4>)
 8009d5e:	7958      	ldrb	r0, [r3, #5]
 8009d60:	6812      	ldr	r2, [r2, #0]
 8009d62:	6993      	ldr	r3, [r2, #24]
 8009d64:	4798      	blx	r3
    {
      CopyRoutine = Standard_GetInterface;
 8009d66:	4b33      	ldr	r3, [pc, #204]	; (8009e34 <Setup0_Process+0x2f8>)
  else if (Request_No == GET_INTERFACE)
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 8009d68:	b118      	cbz	r0, 8009d72 <Setup0_Process+0x236>
 8009d6a:	e00a      	b.n	8009d82 <Setup0_Process+0x246>
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
          && (Status != 0))
      {
        CopyRoutine = Standard_GetStatus;
 8009d6c:	4b32      	ldr	r3, [pc, #200]	; (8009e38 <Setup0_Process+0x2fc>)
 8009d6e:	e000      	b.n	8009d72 <Setup0_Process+0x236>
      CopyRoutine = Standard_GetInterface;
    }

  }
  
  if (CopyRoutine)
 8009d70:	b13b      	cbz	r3, 8009d82 <Setup0_Process+0x246>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
 8009d72:	6822      	ldr	r2, [r4, #0]
 8009d74:	2100      	movs	r1, #0
 8009d76:	8251      	strh	r1, [r2, #18]
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
 8009d78:	6193      	str	r3, [r2, #24]
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
 8009d7a:	2000      	movs	r0, #0
 8009d7c:	4798      	blx	r3
    Result = USB_SUCCESS;
 8009d7e:	2000      	movs	r0, #0
 8009d80:	e00a      	b.n	8009d98 <Setup0_Process+0x25c>
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
 8009d82:	4b27      	ldr	r3, [pc, #156]	; (8009e20 <Setup0_Process+0x2e4>)
 8009d84:	6822      	ldr	r2, [r4, #0]
 8009d86:	681b      	ldr	r3, [r3, #0]
 8009d88:	7850      	ldrb	r0, [r2, #1]
 8009d8a:	691b      	ldr	r3, [r3, #16]
 8009d8c:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 8009d8e:	2803      	cmp	r0, #3
    {
      pInformation->ControlState = PAUSE;
 8009d90:	bf04      	itt	eq
 8009d92:	4b21      	ldreq	r3, [pc, #132]	; (8009e18 <Setup0_Process+0x2dc>)
 8009d94:	681b      	ldreq	r3, [r3, #0]
    Result = USB_SUCCESS;
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    if (Result == USB_NOT_READY)
 8009d96:	d006      	beq.n	8009da6 <Setup0_Process+0x26a>
      pInformation->ControlState = PAUSE;
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
 8009d98:	4b1f      	ldr	r3, [pc, #124]	; (8009e18 <Setup0_Process+0x2dc>)
 8009d9a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009d9e:	681b      	ldr	r3, [r3, #0]
 8009da0:	8a1a      	ldrh	r2, [r3, #16]
 8009da2:	428a      	cmp	r2, r1
 8009da4:	d101      	bne.n	8009daa <Setup0_Process+0x26e>
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
 8009da6:	2209      	movs	r2, #9
 8009da8:	e003      	b.n	8009db2 <Setup0_Process+0x276>
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
 8009daa:	2802      	cmp	r0, #2
 8009dac:	d000      	beq.n	8009db0 <Setup0_Process+0x274>
 8009dae:	b912      	cbnz	r2, 8009db6 <Setup0_Process+0x27a>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
 8009db0:	2208      	movs	r2, #8
 8009db2:	721a      	strb	r2, [r3, #8]
 8009db4:	e02b      	b.n	8009e0e <Setup0_Process+0x2d2>
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
 8009db6:	f993 1000 	ldrsb.w	r1, [r3]
 8009dba:	2900      	cmp	r1, #0
 8009dbc:	da21      	bge.n	8009e02 <Setup0_Process+0x2c6>
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
 8009dbe:	88d9      	ldrh	r1, [r3, #6]
 8009dc0:	9101      	str	r1, [sp, #4]
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8009dc2:	9801      	ldr	r0, [sp, #4]
 8009dc4:	4282      	cmp	r2, r0
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
 8009dc6:	bf84      	itt	hi
 8009dc8:	9a01      	ldrhi	r2, [sp, #4]
 8009dca:	821a      	strhhi	r2, [r3, #16]
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8009dcc:	d811      	bhi.n	8009df2 <Setup0_Process+0x2b6>
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    }
    
    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
 8009dce:	428a      	cmp	r2, r1
 8009dd0:	d20f      	bcs.n	8009df2 <Setup0_Process+0x2b6>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
 8009dd2:	4913      	ldr	r1, [pc, #76]	; (8009e20 <Setup0_Process+0x2e4>)
 8009dd4:	6809      	ldr	r1, [r1, #0]
 8009dd6:	f891 102c 	ldrb.w	r1, [r1, #44]	; 0x2c
 8009dda:	428a      	cmp	r2, r1
 8009ddc:	d201      	bcs.n	8009de2 <Setup0_Process+0x2a6>
      {
        Data_Mul_MaxPacketSize = FALSE;
 8009dde:	2100      	movs	r1, #0
 8009de0:	e005      	b.n	8009dee <Setup0_Process+0x2b2>
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
 8009de2:	fb92 f0f1 	sdiv	r0, r2, r1
 8009de6:	fb01 2210 	mls	r2, r1, r0, r2
 8009dea:	b912      	cbnz	r2, 8009df2 <Setup0_Process+0x2b6>
      {
        Data_Mul_MaxPacketSize = TRUE;
 8009dec:	2101      	movs	r1, #1
 8009dee:	4a13      	ldr	r2, [pc, #76]	; (8009e3c <Setup0_Process+0x300>)
 8009df0:	7011      	strb	r1, [r2, #0]
      }
    }   

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
 8009df2:	4a0b      	ldr	r2, [pc, #44]	; (8009e20 <Setup0_Process+0x2e4>)
 8009df4:	6812      	ldr	r2, [r2, #0]
 8009df6:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8009dfa:	829a      	strh	r2, [r3, #20]
    DataStageIn();
 8009dfc:	f7ff fc5c 	bl	80096b8 <DataStageIn>
 8009e00:	e005      	b.n	8009e0e <Setup0_Process+0x2d2>
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
 8009e02:	2203      	movs	r2, #3
 8009e04:	721a      	strb	r2, [r3, #8]
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
 8009e06:	4b0e      	ldr	r3, [pc, #56]	; (8009e40 <Setup0_Process+0x304>)
 8009e08:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8009e0c:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
 8009e0e:	f7ff fdf5 	bl	80099fc <Post0_Process>
}
 8009e12:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009e14:	40005c50 	.word	0x40005c50
 8009e18:	2000379c 	.word	0x2000379c
 8009e1c:	20003004 	.word	0x20003004
 8009e20:	20003794 	.word	0x20003794
 8009e24:	20003002 	.word	0x20003002
 8009e28:	200037ac 	.word	0x200037ac
 8009e2c:	200037a0 	.word	0x200037a0
 8009e30:	080095c5 	.word	0x080095c5
 8009e34:	080095e9 	.word	0x080095e9
 8009e38:	0800960d 	.word	0x0800960d
 8009e3c:	20000c1c 	.word	0x20000c1c
 8009e40:	200037aa 	.word	0x200037aa

08009e44 <SetDeviceAddress>:
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(uint8_t Val)
{
 8009e44:	b530      	push	{r4, r5, lr}
#ifdef STM32F10X_CL 
  PCD_EP_SetAddress ((uint8_t)Val);
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;
 8009e46:	4b0f      	ldr	r3, [pc, #60]	; (8009e84 <SetDeviceAddress+0x40>)
 8009e48:	f893 c000 	ldrb.w	ip, [r3]

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 8009e4c:	2300      	movs	r3, #0
 8009e4e:	e012      	b.n	8009e76 <SetDeviceAddress+0x32>
 8009e50:	b2da      	uxtb	r2, r3
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
 8009e52:	0091      	lsls	r1, r2, #2
 8009e54:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8009e58:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 8009e5c:	680d      	ldr	r5, [r1, #0]
 8009e5e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009e62:	f042 0480 	orr.w	r4, r2, #128	; 0x80
 8009e66:	f640 720f 	movw	r2, #3855	; 0xf0f
 8009e6a:	ea05 0202 	and.w	r2, r5, r2
 8009e6e:	ea44 0202 	orr.w	r2, r4, r2
 8009e72:	600a      	str	r2, [r1, #0]
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 8009e74:	3301      	adds	r3, #1
 8009e76:	4563      	cmp	r3, ip
 8009e78:	d3ea      	bcc.n	8009e50 <SetDeviceAddress+0xc>
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
 8009e7a:	4b03      	ldr	r3, [pc, #12]	; (8009e88 <SetDeviceAddress+0x44>)
 8009e7c:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8009e80:	6018      	str	r0, [r3, #0]
#endif  /* STM32F10X_CL */  
}
 8009e82:	bd30      	pop	{r4, r5, pc}
 8009e84:	200037a0 	.word	0x200037a0
 8009e88:	40005c4c 	.word	0x40005c4c

08009e8c <In0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t In0_Process(void)
{
 8009e8c:	b510      	push	{r4, lr}
  uint32_t ControlState = pInformation->ControlState;
 8009e8e:	4c16      	ldr	r4, [pc, #88]	; (8009ee8 <In0_Process+0x5c>)
 8009e90:	6823      	ldr	r3, [r4, #0]
 8009e92:	7a1a      	ldrb	r2, [r3, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8009e94:	2a02      	cmp	r2, #2
 8009e96:	bf14      	ite	ne
 8009e98:	2100      	movne	r1, #0
 8009e9a:	2101      	moveq	r1, #1
 8009e9c:	2a04      	cmp	r2, #4
 8009e9e:	bf08      	it	eq
 8009ea0:	f041 0101 	orreq.w	r1, r1, #1
 8009ea4:	b121      	cbz	r1, 8009eb0 <In0_Process+0x24>
  {
    DataStageIn();
 8009ea6:	f7ff fc07 	bl	80096b8 <DataStageIn>
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
 8009eaa:	6823      	ldr	r3, [r4, #0]
 8009eac:	7a1b      	ldrb	r3, [r3, #8]
 8009eae:	e014      	b.n	8009eda <In0_Process+0x4e>
  }

  else if (ControlState == WAIT_STATUS_IN)
 8009eb0:	2a06      	cmp	r2, #6
 8009eb2:	d111      	bne.n	8009ed8 <In0_Process+0x4c>
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8009eb4:	785a      	ldrb	r2, [r3, #1]
 8009eb6:	2a05      	cmp	r2, #5
 8009eb8:	d10a      	bne.n	8009ed0 <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 8009eba:	781a      	ldrb	r2, [r3, #0]
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8009ebc:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 8009ec0:	d106      	bne.n	8009ed0 <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
 8009ec2:	78d8      	ldrb	r0, [r3, #3]
 8009ec4:	f7ff ffbe 	bl	8009e44 <SetDeviceAddress>
      pUser_Standard_Requests->User_SetDeviceAddress();
 8009ec8:	4b08      	ldr	r3, [pc, #32]	; (8009eec <In0_Process+0x60>)
 8009eca:	681b      	ldr	r3, [r3, #0]
 8009ecc:	6a1b      	ldr	r3, [r3, #32]
 8009ece:	4798      	blx	r3
    }
    (*pProperty->Process_Status_IN)();
 8009ed0:	4b07      	ldr	r3, [pc, #28]	; (8009ef0 <In0_Process+0x64>)
 8009ed2:	681b      	ldr	r3, [r3, #0]
 8009ed4:	689b      	ldr	r3, [r3, #8]
 8009ed6:	4798      	blx	r3
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
 8009ed8:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 8009eda:	4a03      	ldr	r2, [pc, #12]	; (8009ee8 <In0_Process+0x5c>)
 8009edc:	6812      	ldr	r2, [r2, #0]
 8009ede:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 8009ee0:	f7ff fd8c 	bl	80099fc <Post0_Process>
}
 8009ee4:	bd10      	pop	{r4, pc}
 8009ee6:	bf00      	nop
 8009ee8:	2000379c 	.word	0x2000379c
 8009eec:	20003798 	.word	0x20003798
 8009ef0:	20003794 	.word	0x20003794

08009ef4 <NOP_Process>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
}
 8009ef4:	4770      	bx	lr
	...

08009ef8 <CTR_LP>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
 8009ef8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint16_t wEPVal = 0;
 8009efa:	2200      	movs	r2, #0
 8009efc:	f8ad 2006 	strh.w	r2, [sp, #6]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009f00:	4f54      	ldr	r7, [pc, #336]	; (800a054 <CTR_LP+0x15c>)
 8009f02:	4e55      	ldr	r6, [pc, #340]	; (800a058 <CTR_LP+0x160>)
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8009f04:	e09d      	b.n	800a042 <CTR_LP+0x14a>
  {
    /* extract highest priority endpoint number */
    EPindex = (uint8_t)(wIstr & ISTR_EP_ID);
    if (EPindex == 0)
 8009f06:	f013 050f 	ands.w	r5, r3, #15
 8009f0a:	d171      	bne.n	8009ff0 <CTR_LP+0xf8>

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009f0c:	683a      	ldr	r2, [r7, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8009f0e:	f013 0f10 	tst.w	r3, #16

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009f12:	b292      	uxth	r2, r2
 8009f14:	8032      	strh	r2, [r6, #0]
	    SaveTState = SaveRState & EPTX_STAT;
 8009f16:	8831      	ldrh	r1, [r6, #0]
 8009f18:	4a50      	ldr	r2, [pc, #320]	; (800a05c <CTR_LP+0x164>)
 8009f1a:	f001 0130 	and.w	r1, r1, #48	; 0x30
 8009f1e:	8011      	strh	r1, [r2, #0]
	    SaveRState &=  EPRX_STAT;	
 8009f20:	8832      	ldrh	r2, [r6, #0]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009f22:	4c4c      	ldr	r4, [pc, #304]	; (800a054 <CTR_LP+0x15c>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	
 8009f24:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8009f28:	8032      	strh	r2, [r6, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8009f2a:	6839      	ldr	r1, [r7, #0]
 8009f2c:	f64b 72bf 	movw	r2, #49087	; 0xbfbf
 8009f30:	ea01 0202 	and.w	r2, r1, r2
 8009f34:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8009f38:	f082 0220 	eor.w	r2, r2, #32
 8009f3c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009f40:	f042 0280 	orr.w	r2, r2, #128	; 0x80

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009f44:	4d44      	ldr	r5, [pc, #272]	; (800a058 <CTR_LP+0x160>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8009f46:	603a      	str	r2, [r7, #0]

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8009f48:	d108      	bne.n	8009f5c <CTR_LP+0x64>

        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */


        _ClearEP_CTR_TX(ENDP0);
 8009f4a:	6822      	ldr	r2, [r4, #0]
 8009f4c:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8009f50:	ea02 0303 	and.w	r3, r2, r3
 8009f54:	6023      	str	r3, [r4, #0]
        In0_Process();
 8009f56:	f7ff ff99 	bl	8009e8c <In0_Process>
 8009f5a:	e01e      	b.n	8009f9a <CTR_LP+0xa2>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
 8009f5c:	683b      	ldr	r3, [r7, #0]
 8009f5e:	b29b      	uxth	r3, r3
 8009f60:	f8ad 3006 	strh.w	r3, [sp, #6]
        
        if ((wEPVal &EP_SETUP) != 0)
 8009f64:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009f68:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009f6c:	d008      	beq.n	8009f80 <CTR_LP+0x88>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
 8009f6e:	6822      	ldr	r2, [r4, #0]
 8009f70:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009f74:	ea02 0303 	and.w	r3, r2, r3
 8009f78:	6023      	str	r3, [r4, #0]
          Setup0_Process();
 8009f7a:	f7ff fddf 	bl	8009b3c <Setup0_Process>
 8009f7e:	e00c      	b.n	8009f9a <CTR_LP+0xa2>

		      _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
 8009f80:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009f84:	b21b      	sxth	r3, r3
 8009f86:	2b00      	cmp	r3, #0
 8009f88:	da5b      	bge.n	800a042 <CTR_LP+0x14a>
        {
          _ClearEP_CTR_RX(ENDP0);
 8009f8a:	6822      	ldr	r2, [r4, #0]
 8009f8c:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009f90:	ea02 0303 	and.w	r3, r2, r3
 8009f94:	6023      	str	r3, [r4, #0]
          Out0_Process();
 8009f96:	f7ff fd53 	bl	8009a40 <Out0_Process>
          /* before terminate set Tx & Rx status */
     
		     _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
 8009f9a:	6822      	ldr	r2, [r4, #0]
 8009f9c:	f64b 73bf 	movw	r3, #49087	; 0xbfbf
 8009fa0:	ea02 0303 	and.w	r3, r2, r3
 8009fa4:	882a      	ldrh	r2, [r5, #0]
 8009fa6:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 8009faa:	b292      	uxth	r2, r2
 8009fac:	b10a      	cbz	r2, 8009fb2 <CTR_LP+0xba>
 8009fae:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8009fb2:	4a29      	ldr	r2, [pc, #164]	; (800a058 <CTR_LP+0x160>)
 8009fb4:	8812      	ldrh	r2, [r2, #0]
 8009fb6:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8009fba:	b292      	uxth	r2, r2
 8009fbc:	b10a      	cbz	r2, 8009fc2 <CTR_LP+0xca>
 8009fbe:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8009fc2:	4a26      	ldr	r2, [pc, #152]	; (800a05c <CTR_LP+0x164>)
 8009fc4:	8812      	ldrh	r2, [r2, #0]
 8009fc6:	f002 0210 	and.w	r2, r2, #16
 8009fca:	b292      	uxth	r2, r2
 8009fcc:	b10a      	cbz	r2, 8009fd2 <CTR_LP+0xda>
 8009fce:	f083 0310 	eor.w	r3, r3, #16
 8009fd2:	4a22      	ldr	r2, [pc, #136]	; (800a05c <CTR_LP+0x164>)
 8009fd4:	8812      	ldrh	r2, [r2, #0]
 8009fd6:	f002 0220 	and.w	r2, r2, #32
 8009fda:	b292      	uxth	r2, r2
 8009fdc:	b10a      	cbz	r2, 8009fe2 <CTR_LP+0xea>
 8009fde:	f083 0320 	eor.w	r3, r3, #32
 8009fe2:	4a1f      	ldr	r2, [pc, #124]	; (800a060 <CTR_LP+0x168>)
 8009fe4:	ea43 0202 	orr.w	r2, r3, r2
 8009fe8:	4b1a      	ldr	r3, [pc, #104]	; (800a054 <CTR_LP+0x15c>)
 8009fea:	b292      	uxth	r2, r2
 8009fec:	601a      	str	r2, [r3, #0]
          return;
 8009fee:	e02f      	b.n	800a050 <CTR_LP+0x158>
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
 8009ff0:	00ac      	lsls	r4, r5, #2
 8009ff2:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8009ff6:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 8009ffa:	6823      	ldr	r3, [r4, #0]
 8009ffc:	b29b      	uxth	r3, r3
 8009ffe:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & EP_CTR_RX) != 0)
 800a002:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800a006:	b21b      	sxth	r3, r3
 800a008:	2b00      	cmp	r3, #0
 800a00a:	da0a      	bge.n	800a022 <CTR_LP+0x12a>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 800a00c:	6822      	ldr	r2, [r4, #0]
 800a00e:	f640 738f 	movw	r3, #3983	; 0xf8f
 800a012:	ea02 0303 	and.w	r3, r2, r3

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 800a016:	4a13      	ldr	r2, [pc, #76]	; (800a064 <CTR_LP+0x16c>)
      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
      if ((wEPVal & EP_CTR_RX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 800a018:	6023      	str	r3, [r4, #0]

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 800a01a:	1e6b      	subs	r3, r5, #1
 800a01c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800a020:	4798      	blx	r3

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
 800a022:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800a026:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a02a:	d00a      	beq.n	800a042 <CTR_LP+0x14a>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 800a02c:	6822      	ldr	r2, [r4, #0]
 800a02e:	f648 730f 	movw	r3, #36623	; 0x8f0f
 800a032:	ea02 0303 	and.w	r3, r2, r3

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 800a036:	4a0c      	ldr	r2, [pc, #48]	; (800a068 <CTR_LP+0x170>)
 800a038:	3d01      	subs	r5, #1
      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 800a03a:	6023      	str	r3, [r4, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 800a03c:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
 800a040:	4798      	blx	r3
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 800a042:	4a0a      	ldr	r2, [pc, #40]	; (800a06c <CTR_LP+0x174>)
 800a044:	6813      	ldr	r3, [r2, #0]
 800a046:	b29b      	uxth	r3, r3
 800a048:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800a04c:	f47f af5b 	bne.w	8009f06 <CTR_LP+0xe>
      } /* if((wEPVal & EP_CTR_TX) != 0) */

    }/* if(EPindex == 0) else */

  }/* while(...) */
}
 800a050:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800a052:	bf00      	nop
 800a054:	40005c00 	.word	0x40005c00
 800a058:	200037aa 	.word	0x200037aa
 800a05c:	200037ac 	.word	0x200037ac
 800a060:	ffff8080 	.word	0xffff8080
 800a064:	20000028 	.word	0x20000028
 800a068:	2000000c 	.word	0x2000000c
 800a06c:	40005c44 	.word	0x40005c44

0800a070 <UserToPMABufferCopy>:
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 800a070:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
 800a074:	3201      	adds	r2, #1
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 800a076:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 800a07a:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 800a07c:	0852      	lsrs	r2, r2, #1
 800a07e:	e008      	b.n	800a092 <UserToPMABufferCopy+0x22>
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 800a080:	f810 cc01 	ldrb.w	ip, [r0, #-1]
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (uint16_t) * pbUsrBuf;
 800a084:	f810 3c02 	ldrb.w	r3, [r0, #-2]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a088:	3a01      	subs	r2, #1
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 800a08a:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
    *pdwVal++ = temp2;
 800a08e:	f821 3c04 	strh.w	r3, [r1, #-4]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a092:	3002      	adds	r0, #2
 800a094:	3104      	adds	r1, #4
 800a096:	2a00      	cmp	r2, #0
 800a098:	d1f2      	bne.n	800a080 <UserToPMABufferCopy+0x10>
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
    pdwVal++;
    pbUsrBuf++;
  }
}
 800a09a:	4770      	bx	lr

0800a09c <PMAToUserBufferCopy>:
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 800a09c:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
 800a0a0:	3201      	adds	r2, #1
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 800a0a2:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 800a0a6:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 800a0a8:	0852      	lsrs	r2, r2, #1
 800a0aa:	e004      	b.n	800a0b6 <PMAToUserBufferCopy+0x1a>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 800a0ac:	f851 3b04 	ldr.w	r3, [r1], #4
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a0b0:	3a01      	subs	r2, #1
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 800a0b2:	f820 3b02 	strh.w	r3, [r0], #2
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 800a0b6:	2a00      	cmp	r2, #0
 800a0b8:	d1f8      	bne.n	800a0ac <PMAToUserBufferCopy+0x10>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
    pbUsrBuf++;
  }
}
 800a0ba:	4770      	bx	lr

0800a0bc <SetBTABLE>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetBTABLE(uint16_t wRegValue)
{
  _SetBTABLE(wRegValue);
 800a0bc:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 800a0c0:	4a02      	ldr	r2, [pc, #8]	; (800a0cc <SetBTABLE+0x10>)
 800a0c2:	ea00 0303 	and.w	r3, r0, r3
 800a0c6:	6013      	str	r3, [r2, #0]
}
 800a0c8:	4770      	bx	lr
 800a0ca:	bf00      	nop
 800a0cc:	40005c50 	.word	0x40005c50

0800a0d0 <SetEPType>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPType(uint8_t bEpNum, uint16_t wType)
{
  _SetEPType(bEpNum, wType);
 800a0d0:	0080      	lsls	r0, r0, #2
 800a0d2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a0d6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a0da:	6803      	ldr	r3, [r0, #0]
 800a0dc:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 800a0e0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a0e4:	ea43 0101 	orr.w	r1, r3, r1
 800a0e8:	b289      	uxth	r1, r1
 800a0ea:	6001      	str	r1, [r0, #0]
}
 800a0ec:	4770      	bx	lr

0800a0ee <GetEPType>:
* Output         : None.
* Return         : Endpoint Type
*******************************************************************************/
uint16_t GetEPType(uint8_t bEpNum)
{
  return(_GetEPType(bEpNum));
 800a0ee:	0080      	lsls	r0, r0, #2
 800a0f0:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a0f4:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a0f8:	6800      	ldr	r0, [r0, #0]
 800a0fa:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
}
 800a0fe:	4770      	bx	lr

0800a100 <SetEPTxStatus>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(uint8_t bEpNum, uint16_t wState)
{
  _SetEPTxStatus(bEpNum, wState);
 800a100:	0080      	lsls	r0, r0, #2
 800a102:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a106:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a10a:	6802      	ldr	r2, [r0, #0]
 800a10c:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 800a110:	ea02 0303 	and.w	r3, r2, r3
 800a114:	f001 0210 	and.w	r2, r1, #16
 800a118:	b292      	uxth	r2, r2
 800a11a:	b10a      	cbz	r2, 800a120 <SetEPTxStatus+0x20>
 800a11c:	f083 0310 	eor.w	r3, r3, #16
 800a120:	f001 0120 	and.w	r1, r1, #32
 800a124:	b289      	uxth	r1, r1
 800a126:	b109      	cbz	r1, 800a12c <SetEPTxStatus+0x2c>
 800a128:	f083 0320 	eor.w	r3, r3, #32
 800a12c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a130:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a134:	6003      	str	r3, [r0, #0]
}
 800a136:	4770      	bx	lr

0800a138 <SetEPTxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxValid(uint8_t bEpNum)
{
  _SetEPTxStatus(bEpNum, EP_TX_VALID);
 800a138:	0080      	lsls	r0, r0, #2
 800a13a:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a13e:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a142:	6802      	ldr	r2, [r0, #0]
 800a144:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 800a148:	ea02 0303 	and.w	r3, r2, r3
 800a14c:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 800a150:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a154:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a158:	6003      	str	r3, [r0, #0]
}
 800a15a:	4770      	bx	lr

0800a15c <SetEPRxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(uint8_t bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
 800a15c:	0080      	lsls	r0, r0, #2
 800a15e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a162:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a166:	6802      	ldr	r2, [r0, #0]
 800a168:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 800a16c:	ea02 0303 	and.w	r3, r2, r3
 800a170:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800a174:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a178:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a17c:	6003      	str	r3, [r0, #0]
}
 800a17e:	4770      	bx	lr

0800a180 <Clear_Status_Out>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(uint8_t bEpNum)
{
  _ClearEP_KIND(bEpNum);
 800a180:	0080      	lsls	r0, r0, #2
 800a182:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a186:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a18a:	6802      	ldr	r2, [r0, #0]
 800a18c:	f640 630f 	movw	r3, #3599	; 0xe0f
 800a190:	ea02 0303 	and.w	r3, r2, r3
 800a194:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a198:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a19c:	6003      	str	r3, [r0, #0]
}
 800a19e:	4770      	bx	lr

0800a1a0 <ClearDTOG_RX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(uint8_t bEpNum)
{
  _ClearDTOG_RX(bEpNum);
 800a1a0:	0080      	lsls	r0, r0, #2
 800a1a2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a1a6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a1aa:	6803      	ldr	r3, [r0, #0]
 800a1ac:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 800a1b0:	d009      	beq.n	800a1c6 <ClearDTOG_RX+0x26>
 800a1b2:	6802      	ldr	r2, [r0, #0]
 800a1b4:	f640 730f 	movw	r3, #3855	; 0xf0f
 800a1b8:	ea02 0303 	and.w	r3, r2, r3
 800a1bc:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800a1c0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a1c4:	6003      	str	r3, [r0, #0]
}
 800a1c6:	4770      	bx	lr

0800a1c8 <ClearDTOG_TX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(uint8_t bEpNum)
{
  _ClearDTOG_TX(bEpNum);
 800a1c8:	0080      	lsls	r0, r0, #2
 800a1ca:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a1ce:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a1d2:	6803      	ldr	r3, [r0, #0]
 800a1d4:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a1d8:	d009      	beq.n	800a1ee <ClearDTOG_TX+0x26>
 800a1da:	6802      	ldr	r2, [r0, #0]
 800a1dc:	f640 730f 	movw	r3, #3855	; 0xf0f
 800a1e0:	ea02 0303 	and.w	r3, r2, r3
 800a1e4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a1e8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800a1ec:	6003      	str	r3, [r0, #0]
}
 800a1ee:	4770      	bx	lr

0800a1f0 <SetEPTxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPTxAddr(bEpNum, wAddr);
 800a1f0:	4b06      	ldr	r3, [pc, #24]	; (800a20c <SetEPTxAddr+0x1c>)
 800a1f2:	0849      	lsrs	r1, r1, #1
 800a1f4:	681b      	ldr	r3, [r3, #0]
 800a1f6:	0049      	lsls	r1, r1, #1
 800a1f8:	b29b      	uxth	r3, r3
 800a1fa:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a1fe:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
 800a202:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
 800a206:	0040      	lsls	r0, r0, #1
 800a208:	6001      	str	r1, [r0, #0]
}
 800a20a:	4770      	bx	lr
 800a20c:	40005c50 	.word	0x40005c50

0800a210 <SetEPRxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPRxAddr(bEpNum, wAddr);
 800a210:	4b05      	ldr	r3, [pc, #20]	; (800a228 <SetEPRxAddr+0x18>)
 800a212:	0849      	lsrs	r1, r1, #1
 800a214:	681b      	ldr	r3, [r3, #0]
 800a216:	0049      	lsls	r1, r1, #1
 800a218:	b29b      	uxth	r3, r3
 800a21a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a21e:	4b03      	ldr	r3, [pc, #12]	; (800a22c <SetEPRxAddr+0x1c>)
 800a220:	18c3      	adds	r3, r0, r3
 800a222:	005b      	lsls	r3, r3, #1
 800a224:	6019      	str	r1, [r3, #0]
}
 800a226:	4770      	bx	lr
 800a228:	40005c50 	.word	0x40005c50
 800a22c:	20003004 	.word	0x20003004

0800a230 <GetEPTxAddr>:
* Output         : None.
* Return         : Rx buffer address. 
*******************************************************************************/
uint16_t GetEPTxAddr(uint8_t bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
 800a230:	4b05      	ldr	r3, [pc, #20]	; (800a248 <GetEPTxAddr+0x18>)
 800a232:	681b      	ldr	r3, [r3, #0]
 800a234:	b29b      	uxth	r3, r3
 800a236:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800a23a:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800a23e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800a242:	005b      	lsls	r3, r3, #1
 800a244:	8818      	ldrh	r0, [r3, #0]
}
 800a246:	4770      	bx	lr
 800a248:	40005c50 	.word	0x40005c50

0800a24c <GetEPRxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
uint16_t GetEPRxAddr(uint8_t bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
 800a24c:	4b04      	ldr	r3, [pc, #16]	; (800a260 <GetEPRxAddr+0x14>)
 800a24e:	681b      	ldr	r3, [r3, #0]
 800a250:	b29b      	uxth	r3, r3
 800a252:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a256:	4b03      	ldr	r3, [pc, #12]	; (800a264 <GetEPRxAddr+0x18>)
 800a258:	18c3      	adds	r3, r0, r3
 800a25a:	005b      	lsls	r3, r3, #1
 800a25c:	8818      	ldrh	r0, [r3, #0]
}
 800a25e:	4770      	bx	lr
 800a260:	40005c50 	.word	0x40005c50
 800a264:	20003004 	.word	0x20003004

0800a268 <SetEPTxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPTxCount(bEpNum, wCount);
 800a268:	4b04      	ldr	r3, [pc, #16]	; (800a27c <SetEPTxCount+0x14>)
 800a26a:	681b      	ldr	r3, [r3, #0]
 800a26c:	b29b      	uxth	r3, r3
 800a26e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a272:	4b03      	ldr	r3, [pc, #12]	; (800a280 <SetEPTxCount+0x18>)
 800a274:	18c3      	adds	r3, r0, r3
 800a276:	005b      	lsls	r3, r3, #1
 800a278:	6019      	str	r1, [r3, #0]
}
 800a27a:	4770      	bx	lr
 800a27c:	40005c50 	.word	0x40005c50
 800a280:	20003002 	.word	0x20003002

0800a284 <SetEPRxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPRxCount(bEpNum, wCount);
 800a284:	4b0d      	ldr	r3, [pc, #52]	; (800a2bc <SetEPRxCount+0x38>)
 800a286:	681a      	ldr	r2, [r3, #0]
 800a288:	4b0d      	ldr	r3, [pc, #52]	; (800a2c0 <SetEPRxCount+0x3c>)
 800a28a:	b292      	uxth	r2, r2
 800a28c:	18d3      	adds	r3, r2, r3
 800a28e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a292:	0040      	lsls	r0, r0, #1
 800a294:	293e      	cmp	r1, #62	; 0x3e
 800a296:	d909      	bls.n	800a2ac <SetEPRxCount+0x28>
 800a298:	094b      	lsrs	r3, r1, #5
 800a29a:	f011 0f1f 	tst.w	r1, #31
 800a29e:	d101      	bne.n	800a2a4 <SetEPRxCount+0x20>
 800a2a0:	3b01      	subs	r3, #1
 800a2a2:	b29b      	uxth	r3, r3
 800a2a4:	029b      	lsls	r3, r3, #10
 800a2a6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a2aa:	e005      	b.n	800a2b8 <SetEPRxCount+0x34>
 800a2ac:	084b      	lsrs	r3, r1, #1
 800a2ae:	f011 0f01 	tst.w	r1, #1
 800a2b2:	bf18      	it	ne
 800a2b4:	3301      	addne	r3, #1
 800a2b6:	029b      	lsls	r3, r3, #10
 800a2b8:	6003      	str	r3, [r0, #0]
}
 800a2ba:	4770      	bx	lr
 800a2bc:	40005c50 	.word	0x40005c50
 800a2c0:	20003006 	.word	0x20003006

0800a2c4 <GetEPRxCount>:
* Output         : None.
* Return         : Rx count value.
*******************************************************************************/
uint16_t GetEPRxCount(uint8_t bEpNum)
{
  return(_GetEPRxCount(bEpNum));
 800a2c4:	4b05      	ldr	r3, [pc, #20]	; (800a2dc <GetEPRxCount+0x18>)
 800a2c6:	681b      	ldr	r3, [r3, #0]
 800a2c8:	b29b      	uxth	r3, r3
 800a2ca:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a2ce:	4b04      	ldr	r3, [pc, #16]	; (800a2e0 <GetEPRxCount+0x1c>)
 800a2d0:	18c3      	adds	r3, r0, r3
 800a2d2:	005b      	lsls	r3, r3, #1
 800a2d4:	6818      	ldr	r0, [r3, #0]
 800a2d6:	0580      	lsls	r0, r0, #22
 800a2d8:	0d80      	lsrs	r0, r0, #22
}
 800a2da:	4770      	bx	lr
 800a2dc:	40005c50 	.word	0x40005c50
 800a2e0:	20003006 	.word	0x20003006

0800a2e4 <ByteSwap>:
uint16_t ByteSwap(uint16_t wSwW)
{
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
 800a2e4:	b2c3      	uxtb	r3, r0
 800a2e6:	0a00      	lsrs	r0, r0, #8
* Input          : wSwW: word to Swap.
* Output         : None.
* Return         : resulted word.
*******************************************************************************/
uint16_t ByteSwap(uint16_t wSwW)
{
 800a2e8:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
  return(wRet);
}
 800a2ec:	4770      	bx	lr
	...

0800a2f0 <APP_LCD_Data>:
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 800a2f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a2f2:	4c16      	ldr	r4, [pc, #88]	; (800a34c <APP_LCD_Data+0x5c>)
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 800a2f4:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a2f6:	7820      	ldrb	r0, [r4, #0]
 800a2f8:	2501      	movs	r5, #1
 800a2fa:	fa15 f200 	lsls.w	r2, r5, r0
 800a2fe:	4e14      	ldr	r6, [pc, #80]	; (800a350 <APP_LCD_Data+0x60>)
 800a300:	6833      	ldr	r3, [r6, #0]
 800a302:	421a      	tst	r2, r3
    return -1;
 800a304:	bf08      	it	eq
 800a306:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a30a:	d01d      	beq.n	800a348 <APP_LCD_Data+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 800a30c:	f640 11c4 	movw	r1, #2500	; 0x9c4
 800a310:	f7fd f8bc 	bl	800748c <MIOS32_BOARD_J15_PollUnbusy>
 800a314:	2800      	cmp	r0, #0
 800a316:	da08      	bge.n	800a32a <APP_LCD_Data+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a318:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 800a31a:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a31e:	409d      	lsls	r5, r3
 800a320:	6833      	ldr	r3, [r6, #0]
 800a322:	ea23 0505 	bic.w	r5, r3, r5
 800a326:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 800a328:	e00e      	b.n	800a348 <APP_LCD_Data+0x58>
  }

  // write data
  MIOS32_BOARD_J15_DataSet(data);
 800a32a:	4638      	mov	r0, r7
 800a32c:	f7fd f81c 	bl	8007368 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(1);
 800a330:	4628      	mov	r0, r5
 800a332:	f7fd f879 	bl	8007428 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a336:	4629      	mov	r1, r5
 800a338:	7820      	ldrb	r0, [r4, #0]
 800a33a:	f7fd f88d 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a33e:	7820      	ldrb	r0, [r4, #0]
 800a340:	2100      	movs	r1, #0
 800a342:	f7fd f889 	bl	8007458 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 800a346:	2000      	movs	r0, #0
}
 800a348:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a34a:	bf00      	nop
 800a34c:	200007af 	.word	0x200007af
 800a350:	20000c20 	.word	0x20000c20

0800a354 <APP_LCD_Cmd>:
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 800a354:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a356:	4c16      	ldr	r4, [pc, #88]	; (800a3b0 <APP_LCD_Cmd+0x5c>)
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 800a358:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a35a:	7820      	ldrb	r0, [r4, #0]
 800a35c:	2501      	movs	r5, #1
 800a35e:	fa15 f200 	lsls.w	r2, r5, r0
 800a362:	4e14      	ldr	r6, [pc, #80]	; (800a3b4 <APP_LCD_Cmd+0x60>)
 800a364:	6833      	ldr	r3, [r6, #0]
 800a366:	421a      	tst	r2, r3
    return -1;
 800a368:	bf08      	it	eq
 800a36a:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a36e:	d01d      	beq.n	800a3ac <APP_LCD_Cmd+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 800a370:	f640 11c4 	movw	r1, #2500	; 0x9c4
 800a374:	f7fd f88a 	bl	800748c <MIOS32_BOARD_J15_PollUnbusy>
 800a378:	2800      	cmp	r0, #0
 800a37a:	da08      	bge.n	800a38e <APP_LCD_Cmd+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a37c:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 800a37e:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a382:	409d      	lsls	r5, r3
 800a384:	6833      	ldr	r3, [r6, #0]
 800a386:	ea23 0505 	bic.w	r5, r3, r5
 800a38a:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 800a38c:	e00e      	b.n	800a3ac <APP_LCD_Cmd+0x58>
  }

  // write command
  MIOS32_BOARD_J15_DataSet(cmd);
 800a38e:	4638      	mov	r0, r7
 800a390:	f7fc ffea 	bl	8007368 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 800a394:	2000      	movs	r0, #0
 800a396:	f7fd f847 	bl	8007428 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a39a:	4629      	mov	r1, r5
 800a39c:	7820      	ldrb	r0, [r4, #0]
 800a39e:	f7fd f85b 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a3a2:	7820      	ldrb	r0, [r4, #0]
 800a3a4:	2100      	movs	r1, #0
 800a3a6:	f7fd f857 	bl	8007458 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 800a3aa:	2000      	movs	r0, #0
}
 800a3ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a3ae:	bf00      	nop
 800a3b0:	200007af 	.word	0x200007af
 800a3b4:	20000c20 	.word	0x20000c20

0800a3b8 <APP_LCD_Init>:
// Initializes application specific LCD driver
// IN: <mode>: optional configuration
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
 800a3b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a3ba:	4606      	mov	r6, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800a3bc:	f04f 30ff 	mov.w	r0, #4294967295
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 800a3c0:	2e00      	cmp	r6, #0
 800a3c2:	d15b      	bne.n	800a47c <APP_LCD_Init+0xc4>
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 800a3c4:	2001      	movs	r0, #1
 800a3c6:	f7fc ff6b 	bl	80072a0 <MIOS32_BOARD_J15_PortInit>
 800a3ca:	2800      	cmp	r0, #0
    return -2; // failed to initialize J15
 800a3cc:	bfb8      	it	lt
 800a3ce:	f06f 0001 	mvnlt.w	r0, #1
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 800a3d2:	db53      	blt.n	800a47c <APP_LCD_Init+0xc4>
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 800a3d4:	4c2a      	ldr	r4, [pc, #168]	; (800a480 <APP_LCD_Init+0xc8>)
 800a3d6:	2501      	movs	r5, #1
 800a3d8:	7823      	ldrb	r3, [r4, #0]
 800a3da:	4f2a      	ldr	r7, [pc, #168]	; (800a484 <APP_LCD_Init+0xcc>)
 800a3dc:	fa15 f303 	lsls.w	r3, r5, r3
 800a3e0:	683a      	ldr	r2, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 800a3e2:	2038      	movs	r0, #56	; 0x38

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 800a3e4:	4313      	orrs	r3, r2
 800a3e6:	603b      	str	r3, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 800a3e8:	f7fc ffbe 	bl	8007368 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 800a3ec:	4630      	mov	r0, r6
 800a3ee:	f7fd f81b 	bl	8007428 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a3f2:	4629      	mov	r1, r5
 800a3f4:	7820      	ldrb	r0, [r4, #0]
 800a3f6:	f7fd f82f 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a3fa:	4631      	mov	r1, r6
 800a3fc:	7820      	ldrb	r0, [r4, #0]
 800a3fe:	f7fd f82b 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_RW_Set(0);
 800a402:	4630      	mov	r0, r6
 800a404:	f7fd f81c 	bl	8007440 <MIOS32_BOARD_J15_RW_Set>
#ifdef MIOS32_DONT_USE_DELAY
  u32 delay;
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a408:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a40c:	f7fd f8d0 	bl	80075b0 <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a410:	4629      	mov	r1, r5
 800a412:	7820      	ldrb	r0, [r4, #0]
 800a414:	f7fd f820 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a418:	4631      	mov	r1, r6
 800a41a:	7820      	ldrb	r0, [r4, #0]
 800a41c:	f7fd f81c 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a420:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a424:	f7fd f8c4 	bl	80075b0 <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a428:	4629      	mov	r1, r5
 800a42a:	7820      	ldrb	r0, [r4, #0]
 800a42c:	f7fd f814 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a430:	4631      	mov	r1, r6
 800a432:	7820      	ldrb	r0, [r4, #0]
 800a434:	f7fd f810 	bl	8007458 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a438:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a43c:	f7fd f8b8 	bl	80075b0 <MIOS32_DELAY_Wait_uS>
#endif

  APP_LCD_Cmd(0x08); // Display Off
 800a440:	2008      	movs	r0, #8
 800a442:	f7ff ff87 	bl	800a354 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // Display On
 800a446:	200c      	movs	r0, #12
 800a448:	f7ff ff84 	bl	800a354 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x06); // Entry Mode
 800a44c:	2006      	movs	r0, #6
 800a44e:	f7ff ff81 	bl	800a354 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x01); // Clear Display
 800a452:	4628      	mov	r0, r5
 800a454:	f7ff ff7e 	bl	800a354 <APP_LCD_Cmd>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a458:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a45c:	f7fd f8a8 	bl	80075b0 <MIOS32_DELAY_Wait_uS>
  // modify cursor mapping, so that it complies with 3-line dog displays
  u8 cursor_map[] = {0x00, 0x10, 0x20, 0x30}; // offset line 0/1/2/3
  MIOS32_LCD_CursorMapSet(cursor_map);
#endif

  APP_LCD_Cmd(0x38); // experience from PIC based MIOS: without these lines
 800a460:	2038      	movs	r0, #56	; 0x38
 800a462:	f7ff ff77 	bl	800a354 <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // the LCD won't work correctly after a second APP_LCD_Init
 800a466:	200c      	movs	r0, #12
 800a468:	f7ff ff74 	bl	800a354 <APP_LCD_Cmd>

  return (display_available & (1 << mios32_lcd_device)) ? 0 : -1; // return -1 if display not available
 800a46c:	7823      	ldrb	r3, [r4, #0]
 800a46e:	409d      	lsls	r5, r3
 800a470:	683b      	ldr	r3, [r7, #0]
 800a472:	421d      	tst	r5, r3
 800a474:	bf0c      	ite	eq
 800a476:	f04f 30ff 	moveq.w	r0, #4294967295
 800a47a:	2000      	movne	r0, #0
}
 800a47c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a47e:	bf00      	nop
 800a480:	200007af 	.word	0x200007af
 800a484:	20000c20 	.word	0x20000c20

0800a488 <APP_LCD_Clear>:
// Clear Screen
// IN: -
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Clear(void)
{
 800a488:	b508      	push	{r3, lr}
  // -> send clear command
  return APP_LCD_Cmd(0x01);
 800a48a:	2001      	movs	r0, #1
 800a48c:	f7ff ff62 	bl	800a354 <APP_LCD_Cmd>
}
 800a490:	bd08      	pop	{r3, pc}
	...

0800a494 <APP_LCD_CursorSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 800a494:	2903      	cmp	r1, #3
// Sets cursor to given position
// IN: <column> and <line>
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
 800a496:	b508      	push	{r3, lr}
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
    return -1;
 800a498:	bf88      	it	hi
 800a49a:	f04f 30ff 	movhi.w	r0, #4294967295
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 800a49e:	d807      	bhi.n	800a4b0 <APP_LCD_CursorSet+0x1c>
    return -1;

  // -> set cursor address
  return APP_LCD_Cmd(0x80 | (mios32_lcd_cursor_map[line] + column));
 800a4a0:	4b04      	ldr	r3, [pc, #16]	; (800a4b4 <APP_LCD_CursorSet+0x20>)
 800a4a2:	5c5b      	ldrb	r3, [r3, r1]
 800a4a4:	1818      	adds	r0, r3, r0
 800a4a6:	f060 007f 	orn	r0, r0, #127	; 0x7f
 800a4aa:	b2c0      	uxtb	r0, r0
 800a4ac:	f7ff ff52 	bl	800a354 <APP_LCD_Cmd>
}
 800a4b0:	bd08      	pop	{r3, pc}
 800a4b2:	bf00      	nop
 800a4b4:	20003788 	.word	0x20003788

0800a4b8 <APP_LCD_GCursorSet>:
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_GCursorSet(u16 x, u16 y)
{
  // n.a.
  return -1;
}
 800a4b8:	f04f 30ff 	mov.w	r0, #4294967295
 800a4bc:	4770      	bx	lr

0800a4be <APP_LCD_BColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BColourSet(u32 rgb)
{
  return -1; // n.a.
}
 800a4be:	f04f 30ff 	mov.w	r0, #4294967295
 800a4c2:	4770      	bx	lr

0800a4c4 <APP_LCD_FColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_FColourSet(u32 rgb)
{
  return -1; // n.a.
}
 800a4c4:	f04f 30ff 	mov.w	r0, #4294967295
 800a4c8:	4770      	bx	lr

0800a4ca <APP_LCD_BitmapPrint>:
// Transfers a Bitmap within given boundaries to the LCD
// IN: bitmap
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BitmapPrint(mios32_lcd_bitmap_t bitmap)
{
 800a4ca:	b084      	sub	sp, #16
 800a4cc:	ab01      	add	r3, sp, #4
 800a4ce:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  return -1; // n.a.
}
 800a4d2:	f04f 30ff 	mov.w	r0, #4294967295
 800a4d6:	b004      	add	sp, #16
 800a4d8:	4770      	bx	lr
	...

0800a4dc <__libc_init_array>:
 800a4dc:	b570      	push	{r4, r5, r6, lr}
 800a4de:	4d0d      	ldr	r5, [pc, #52]	; (800a514 <__libc_init_array+0x38>)
 800a4e0:	4e0d      	ldr	r6, [pc, #52]	; (800a518 <__libc_init_array+0x3c>)
 800a4e2:	2400      	movs	r4, #0
 800a4e4:	1b76      	subs	r6, r6, r5
 800a4e6:	10b6      	asrs	r6, r6, #2
 800a4e8:	e003      	b.n	800a4f2 <__libc_init_array+0x16>
 800a4ea:	f855 3b04 	ldr.w	r3, [r5], #4
 800a4ee:	4798      	blx	r3
 800a4f0:	3401      	adds	r4, #1
 800a4f2:	42b4      	cmp	r4, r6
 800a4f4:	d3f9      	bcc.n	800a4ea <__libc_init_array+0xe>
 800a4f6:	4d09      	ldr	r5, [pc, #36]	; (800a51c <__libc_init_array+0x40>)
 800a4f8:	4e09      	ldr	r6, [pc, #36]	; (800a520 <__libc_init_array+0x44>)
 800a4fa:	f7fa febb 	bl	8005274 <_init>
 800a4fe:	1b76      	subs	r6, r6, r5
 800a500:	10b6      	asrs	r6, r6, #2
 800a502:	2400      	movs	r4, #0
 800a504:	e003      	b.n	800a50e <__libc_init_array+0x32>
 800a506:	f855 3b04 	ldr.w	r3, [r5], #4
 800a50a:	4798      	blx	r3
 800a50c:	3401      	adds	r4, #1
 800a50e:	42b4      	cmp	r4, r6
 800a510:	d3f9      	bcc.n	800a506 <__libc_init_array+0x2a>
 800a512:	bd70      	pop	{r4, r5, r6, pc}
 800a514:	0800b204 	.word	0x0800b204
 800a518:	0800b204 	.word	0x0800b204
 800a51c:	0800b204 	.word	0x0800b204
 800a520:	0800b204 	.word	0x0800b204

0800a524 <memcpy>:
 800a524:	2300      	movs	r3, #0
 800a526:	e005      	b.n	800a534 <memcpy+0x10>
 800a528:	f811 c003 	ldrb.w	ip, [r1, r3]
 800a52c:	3a01      	subs	r2, #1
 800a52e:	f800 c003 	strb.w	ip, [r0, r3]
 800a532:	3301      	adds	r3, #1
 800a534:	2a00      	cmp	r2, #0
 800a536:	d1f7      	bne.n	800a528 <memcpy+0x4>
 800a538:	4770      	bx	lr

0800a53a <memset>:
 800a53a:	4603      	mov	r3, r0
 800a53c:	e002      	b.n	800a544 <memset+0xa>
 800a53e:	f803 1b01 	strb.w	r1, [r3], #1
 800a542:	3a01      	subs	r2, #1
 800a544:	2a00      	cmp	r2, #0
 800a546:	d1fa      	bne.n	800a53e <memset+0x4>
 800a548:	4770      	bx	lr

0800a54a <strcpy>:
 800a54a:	2300      	movs	r3, #0
 800a54c:	5cca      	ldrb	r2, [r1, r3]
 800a54e:	54c2      	strb	r2, [r0, r3]
 800a550:	3301      	adds	r3, #1
 800a552:	2a00      	cmp	r2, #0
 800a554:	d1fa      	bne.n	800a54c <strcpy+0x2>
 800a556:	4770      	bx	lr

0800a558 <strlen>:
 800a558:	4603      	mov	r3, r0
 800a55a:	461a      	mov	r2, r3
 800a55c:	f813 1b01 	ldrb.w	r1, [r3], #1
 800a560:	2900      	cmp	r1, #0
 800a562:	d1fa      	bne.n	800a55a <strlen+0x2>
 800a564:	1a10      	subs	r0, r2, r0
 800a566:	4770      	bx	lr

0800a568 <strncpy>:
 800a568:	b510      	push	{r4, lr}
 800a56a:	4684      	mov	ip, r0
 800a56c:	e007      	b.n	800a57e <strncpy+0x16>
 800a56e:	f811 4b01 	ldrb.w	r4, [r1], #1
 800a572:	4663      	mov	r3, ip
 800a574:	f803 4b01 	strb.w	r4, [r3], #1
 800a578:	3a01      	subs	r2, #1
 800a57a:	469c      	mov	ip, r3
 800a57c:	b12c      	cbz	r4, 800a58a <strncpy+0x22>
 800a57e:	2a00      	cmp	r2, #0
 800a580:	d1f5      	bne.n	800a56e <strncpy+0x6>
 800a582:	e004      	b.n	800a58e <strncpy+0x26>
 800a584:	f803 4b01 	strb.w	r4, [r3], #1
 800a588:	3a01      	subs	r2, #1
 800a58a:	2a00      	cmp	r2, #0
 800a58c:	d1fa      	bne.n	800a584 <strncpy+0x1c>
 800a58e:	bd10      	pop	{r4, pc}
