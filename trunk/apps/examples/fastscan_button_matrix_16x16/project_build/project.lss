
project_build/project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .mios32_bsl   00004000  08000000  08000000  00008000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .isr_vector   000001e4  08004000  08004000  0000c000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000062a4  080041e4  080041e4  0000c1e4  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000be0  0800a488  0800a488  00012488  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00000058  20000000  0800b068  00018000  2**3  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00003750  20000058  0800b0c0  00018058  2**3  ALLOC
  6 ._usrstack    00000100  200037a8  200037a8  00018058  2**0  CONTENTS
  7 .ARM.attributes 00000031  00000000  00000000  00018158  2**0  CONTENTS, READONLY
  8 .comment      00000011  00000000  00000000  00018189  2**0  CONTENTS, READONLY
  9 .debug_aranges 000021c8  00000000  00000000  000181a0  2**3  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00005768  00000000  00000000  0001a368  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0001b895  00000000  00000000  0001fad0  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000651e  00000000  00000000  0003b365  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000c92b  00000000  00000000  00041883  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00004bac  00000000  00000000  0004e1b0  2**2  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00009e6b  00000000  00000000  00052d5c  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000faaa  00000000  00000000  0005cbc7  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubtypes 0000245f  00000000  00000000  0006c671  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 000022a8  00000000  00000000  0006ead0  2**0  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080041e4 <APP_Init>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
{
 80041e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  // initialize all LEDs
  MIOS32_BOARD_LED_Init(0xffffffff);
 80041e6:	f04f 30ff 	mov.w	r0, #4294967295
 80041ea:	f002 ff33 	bl	8007054 <MIOS32_BOARD_LED_Init>
 80041ee:	4b27      	ldr	r3, [pc, #156]	; (800428c <APP_Init+0xa8>)


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
    din_value[row] = 0xffffffff; // default state: buttons depressed
 80041f0:	f04f 32ff 	mov.w	r2, #4294967295
};

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
 80041f4:	f103 0140 	add.w	r1, r3, #64	; 0x40


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
    din_value[row] = 0xffffffff; // default state: buttons depressed
 80041f8:	f843 2f04 	str.w	r2, [r3, #4]!
  MIOS32_BOARD_LED_Init(0xffffffff);


  // initialize DIN arrays
  int row;
  for(row=0; row<MATRIX_NUM_ROWS; ++row) {
 80041fc:	428b      	cmp	r3, r1
 80041fe:	d1fb      	bne.n	80041f8 <APP_Init+0x14>
 8004200:	4b23      	ldr	r3, [pc, #140]	; (8004290 <APP_Init+0xac>)
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
    last_timestamp[i] = 0;
 8004202:	2400      	movs	r4, #0
};

/////////////////////////////////////////////////////////////////////////////
// This hook is called after startup to initialize the application
/////////////////////////////////////////////////////////////////////////////
void APP_Init(void)
 8004204:	f503 62c0 	add.w	r2, r3, #1536	; 0x600
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
    last_timestamp[i] = 0;
 8004208:	f843 4f04 	str.w	r4, [r3, #4]!
    din_value[row] = 0xffffffff; // default state: buttons depressed
  }

  // initialize timestamps
  int i;
  for(i=0; i<KEYBOARD_NUM_PINS; ++i) {
 800420c:	4293      	cmp	r3, r2
 800420e:	d1fb      	bne.n	8004208 <APP_Init+0x24>
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
 8004210:	b2e0      	uxtb	r0, r4
 8004212:	2104      	movs	r1, #4
    last_timestamp[i] = 0;
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
 8004214:	3401      	adds	r4, #1
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
 8004216:	f002 ff59 	bl	80070cc <MIOS32_BOARD_J5_PinInit>
    last_timestamp[i] = 0;
  }

    // initialize all pins of J5A, J5B and J5C as inputs with internal Pull-Up
  int pin;
  for(pin=0; pin<12; ++pin)
 800421a:	2c0c      	cmp	r4, #12
 800421c:	d1f8      	bne.n	8004210 <APP_Init+0x2c>
    MIOS32_BOARD_J5_PinInit(pin, MIOS32_BOARD_PIN_MODE_INPUT_PU);
	
  // initialize keyboard delay values
  keyboard_delay_fastest = INITIAL_KEYBOARD_DELAY_FASTEST;
 800421e:	4b1d      	ldr	r3, [pc, #116]	; (8004294 <APP_Init+0xb0>)
 8004220:	2400      	movs	r4, #0
 8004222:	601c      	str	r4, [r3, #0]
  keyboard_delay_slowest = INITIAL_KEYBOARD_DELAY_SLOWEST;
 8004224:	4b1c      	ldr	r3, [pc, #112]	; (8004298 <APP_Init+0xb4>)
 8004226:	227f      	movs	r2, #127	; 0x7f
 8004228:	601a      	str	r2, [r3, #0]
  
  no_velocity=MIOS32_BOARD_J5_PinGet(1);
 800422a:	2001      	movs	r0, #1
 800422c:	f002 ff96 	bl	800715c <MIOS32_BOARD_J5_PinGet>
 8004230:	4b1a      	ldr	r3, [pc, #104]	; (800429c <APP_Init+0xb8>)
 8004232:	4601      	mov	r1, r0
 8004234:	6018      	str	r0, [r3, #0]
  MIOS32_MIDI_SendDebugMessage("no_velocity:%02x",no_velocity);
 8004236:	481a      	ldr	r0, [pc, #104]	; (80042a0 <APP_Init+0xbc>)
 8004238:	f001 fae8 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  
  if (MIOS32_BOARD_J5_PinGet(0)){
 800423c:	4620      	mov	r0, r4
 800423e:	f002 ff8d 	bl	800715c <MIOS32_BOARD_J5_PinGet>
 8004242:	4b18      	ldr	r3, [pc, #96]	; (80042a4 <APP_Init+0xc0>)
 8004244:	b150      	cbz	r0, 800425c <APP_Init+0x78>
	selected_midi_port=0x20;
 8004246:	2220      	movs	r2, #32
 8004248:	601a      	str	r2, [r3, #0]
	MIOS32_LCD_CursorSet(0, 0); // X, Y
 800424a:	4621      	mov	r1, r4
 800424c:	4620      	mov	r0, r4
 800424e:	f001 f8b5 	bl	80053bc <MIOS32_LCD_CursorSet>
    MIOS32_LCD_PrintFormattedString("UART");
 8004252:	4815      	ldr	r0, [pc, #84]	; (80042a8 <APP_Init+0xc4>)
 8004254:	f001 f974 	bl	8005540 <MIOS32_LCD_PrintFormattedString>
	MIOS32_MIDI_SendDebugMessage("UART");
 8004258:	4813      	ldr	r0, [pc, #76]	; (80042a8 <APP_Init+0xc4>)
 800425a:	e008      	b.n	800426e <APP_Init+0x8a>
	}
  else {
	selected_midi_port=0x10;
 800425c:	2210      	movs	r2, #16
 800425e:	601a      	str	r2, [r3, #0]
	MIOS32_LCD_CursorSet(0, 0); // X, Y
 8004260:	4601      	mov	r1, r0
 8004262:	f001 f8ab 	bl	80053bc <MIOS32_LCD_CursorSet>
    MIOS32_LCD_PrintFormattedString("USB");
 8004266:	4811      	ldr	r0, [pc, #68]	; (80042ac <APP_Init+0xc8>)
 8004268:	f001 f96a 	bl	8005540 <MIOS32_LCD_PrintFormattedString>
	MIOS32_MIDI_SendDebugMessage("USB");
 800426c:	480f      	ldr	r0, [pc, #60]	; (80042ac <APP_Init+0xc8>)
 800426e:	f001 facd 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
	}

  // start matrix scan task
  xTaskCreate(TASK_MatrixScan, (signed portCHAR *)"MatrixScan", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_MATRIX_SCAN, NULL);
 8004272:	2302      	movs	r3, #2
 8004274:	9300      	str	r3, [sp, #0]
 8004276:	490e      	ldr	r1, [pc, #56]	; (80042b0 <APP_Init+0xcc>)
 8004278:	2300      	movs	r3, #0
 800427a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800427e:	480d      	ldr	r0, [pc, #52]	; (80042b4 <APP_Init+0xd0>)
 8004280:	9301      	str	r3, [sp, #4]
 8004282:	9302      	str	r3, [sp, #8]
 8004284:	9303      	str	r3, [sp, #12]
 8004286:	f000 fadf 	bl	8004848 <xTaskGenericCreate>
}
 800428a:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 800428c:	20000058 	.word	0x20000058
 8004290:	2000009c 	.word	0x2000009c
 8004294:	20000058 	.word	0x20000058
 8004298:	2000009c 	.word	0x2000009c
 800429c:	20000c24 	.word	0x20000c24
 80042a0:	0800a788 	.word	0x0800a788
 80042a4:	20000c20 	.word	0x20000c20
 80042a8:	0800a799 	.word	0x0800a799
 80042ac:	0800a79e 	.word	0x0800a79e
 80042b0:	0800a7a2 	.word	0x0800a7a2
 80042b4:	08004471 	.word	0x08004471

080042b8 <APP_Background>:

/////////////////////////////////////////////////////////////////////////////
// This task is running endless in background
/////////////////////////////////////////////////////////////////////////////
void APP_Background(void)
{
 80042b8:	b510      	push	{r4, lr}
  // endless loop
  while( 1 ) {
    // toggle the state of all LEDs (allows to measure the execution speed with a scope)
    MIOS32_BOARD_LED_Set(0xffffffff, ~MIOS32_BOARD_LED_Get());
	
	no_velocity=MIOS32_BOARD_J5_PinGet(1);
 80042ba:	4c06      	ldr	r4, [pc, #24]	; (80042d4 <APP_Background+0x1c>)
    old_state[pin] = 1;

  // endless loop
  while( 1 ) {
    // toggle the state of all LEDs (allows to measure the execution speed with a scope)
    MIOS32_BOARD_LED_Set(0xffffffff, ~MIOS32_BOARD_LED_Get());
 80042bc:	f002 fefe 	bl	80070bc <MIOS32_BOARD_LED_Get>
 80042c0:	43c1      	mvns	r1, r0
 80042c2:	f04f 30ff 	mov.w	r0, #4294967295
 80042c6:	f002 fee5 	bl	8007094 <MIOS32_BOARD_LED_Set>
	
	no_velocity=MIOS32_BOARD_J5_PinGet(1);
 80042ca:	2001      	movs	r0, #1
 80042cc:	f002 ff46 	bl	800715c <MIOS32_BOARD_J5_PinGet>
 80042d0:	6020      	str	r0, [r4, #0]
 80042d2:	e7f3      	b.n	80042bc <APP_Background+0x4>
 80042d4:	20000c24 	.word	0x20000c24

080042d8 <APP_MIDI_NotifyPackage>:
                   midi_package.evnt0, midi_package.evnt1, midi_package.evnt2);
	break;
	
    case 0x20: MIOS32_MIDI_SendPackage(0x10,  midi_package); break;
  }*/
}
 80042d8:	4770      	bx	lr

080042da <APP_DIN_NotifyToggle>:
// This hook is called when a button has been toggled
// pin_value is 1 when button released, and 0 when button pressed
/////////////////////////////////////////////////////////////////////////////
void APP_DIN_NotifyToggle(u32 pin, u32 pin_value)
{
}
 80042da:	4770      	bx	lr

080042dc <APP_ENC_NotifyChange>:
// incrementer is positive when encoder has been turned clockwise, else
// it is negative
/////////////////////////////////////////////////////////////////////////////
void APP_ENC_NotifyChange(u32 encoder, s32 incrementer)
{
}
 80042dc:	4770      	bx	lr
	...

080042e0 <APP_AIN_NotifyChange>:

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a pot has been moved
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
 80042e0:	b508      	push	{r3, lr}
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 80042e2:	4b06      	ldr	r3, [pc, #24]	; (80042fc <APP_AIN_NotifyChange+0x1c>)

/////////////////////////////////////////////////////////////////////////////
// This hook is called when a pot has been moved
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
 80042e4:	4602      	mov	r2, r0
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 80042e6:	7818      	ldrb	r0, [r3, #0]
/////////////////////////////////////////////////////////////////////////////
void APP_AIN_NotifyChange(u32 pin, u32 pin_value)
{
#if 1
  // convert 12bit value to 7bit value
  u8 value_7bit = 127-(pin_value >> 5);
 80042e8:	094b      	lsrs	r3, r1, #5
 80042ea:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f

  // send MIDI event
  MIOS32_MIDI_SendCC(selected_midi_port, Chn1, pin, value_7bit);
 80042ee:	b2d2      	uxtb	r2, r2
 80042f0:	b2db      	uxtb	r3, r3
 80042f2:	2100      	movs	r1, #0
 80042f4:	f001 f9df 	bl	80056b6 <MIOS32_MIDI_SendCC>
  u16 value_14bit = pin_value << 2;

  // send Pitch Bender event
  MIOS32_MIDI_SendPitchBend(selected_midi_port, pin, value_14bit);
#endif
}
 80042f8:	bd08      	pop	{r3, pc}
 80042fa:	bf00      	nop
 80042fc:	20000c20 	.word	0x20000c20

08004300 <BUTTON_NotifyToggle>:
// This task is called each mS to scan the button matrix
/////////////////////////////////////////////////////////////////////////////

// will be called on button pin changes (see TASK_BLM_Check)
void BUTTON_NotifyToggle(u8 row, u8 column, u8 pin_value, u32 timestamp)
{
 8004300:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004302:	b089      	sub	sp, #36	; 0x24
 8004304:	4694      	mov	ip, r2
 8004306:	4607      	mov	r7, r0
 8004308:	9105      	str	r1, [sp, #20]
 800430a:	9306      	str	r3, [sp, #24]
  // determine pin number based on row/column
  // based on pin map for fadar keyboard provided by Robin (see doc/ directory)
  // tested with utils/test_pinmap.pl

#if DEBUG_VERBOSE_LEVEL >= 3
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d\n",
 800430c:	4639      	mov	r1, r7
 800430e:	4663      	mov	r3, ip
 8004310:	484b      	ldr	r0, [pc, #300]	; (8004440 <BUTTON_NotifyToggle+0x140>)
 8004312:	9a05      	ldr	r2, [sp, #20]
 8004314:	f8cd c010 	str.w	ip, [sp, #16]
 8004318:	f001 fa78 	bl	800580c <MIOS32_MIDI_SendDebugMessage>

  // combine to pin value
//  if( column < 8 ) {
    // left half
//    if( row >= 0 && row <= 0x9 ) {
      pin = (column << 3) | bit3to1;
 800431c:	9905      	ldr	r1, [sp, #20]

  // pin number (counted from 0) consists of:
  //   bit #0 if row -> pin bit #0
  //int bit0 = row & 1;
  //   bit #2..0 of column -> pin bit #3..1
  int bit3to1 = row & 0x7;
 800431e:	f007 0607 	and.w	r6, r7, #7

  // combine to pin value
//  if( column < 8 ) {
    // left half
//    if( row >= 0 && row <= 0x9 ) {
      pin = (column << 3) | bit3to1;
 8004322:	ea46 06c1 	orr.w	r6, r6, r1, lsl #3
 // }

  // following check ensures that we never continue with an unexpected/invalid pin number.
  // e.g. this could address a memory location outside the last_timestamp[] array!
  // print a warning message in this case for analysis purposes
  if( pin < 0 || pin >= KEYBOARD_NUM_PINS ) {
 8004326:	f5b6 7fc0 	cmp.w	r6, #384	; 0x180
 800432a:	f8dd c010 	ldr.w	ip, [sp, #16]
#if DEBUG_VERBOSE_LEVEL >= 1
    DEBUG_MSG("WARNING: row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d NOT MAPPED!\n",
 800432e:	bf24      	itt	cs
 8004330:	9600      	strcs	r6, [sp, #0]
 8004332:	4844      	ldrcs	r0, [pc, #272]	; (8004444 <BUTTON_NotifyToggle+0x144>)
 // }

  // following check ensures that we never continue with an unexpected/invalid pin number.
  // e.g. this could address a memory location outside the last_timestamp[] array!
  // print a warning message in this case for analysis purposes
  if( pin < 0 || pin >= KEYBOARD_NUM_PINS ) {
 8004334:	d244      	bcs.n	80043c0 <BUTTON_NotifyToggle+0xc0>

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch

  // the note number lookup
  int note_number = note_table[pin];
 8004336:	4b44      	ldr	r3, [pc, #272]	; (8004448 <BUTTON_NotifyToggle+0x148>)
#endif
    return;
  }

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch
 8004338:	f3c7 05c0 	ubfx	r5, r7, #3, #1

  // the note number lookup
  int note_number = note_table[pin];
 800433c:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
  //    - send Note On event
  // c) first switch changes from 0->1 (pin_value == 1): 
  //    - send Note Off event (resp. Note On with velocity 0)
  //    - clear captured timestamp (allows to check for valid delay on next transition)

  unsigned key_ix = pin & 0xfffffffe;
 8004340:	f026 0301 	bic.w	r3, r6, #1

  // first or second switch if a key?
  u8 second_switch = ((row & 0x8) >> 3); // 0 if first switch, 1 if second switch

  // the note number lookup
  int note_number = note_table[pin];
 8004344:	2a7f      	cmp	r2, #127	; 0x7f
 8004346:	bfa8      	it	ge
 8004348:	227f      	movge	r2, #127	; 0x7f
  unsigned key_ix = pin & 0xfffffffe;
  int delay = -1;
  u8 send_note_on = 0;
  u8 send_note_off = 0;

  if( pin_value == 0 ) {
 800434a:	f1bc 0f00 	cmp.w	ip, #0
 800434e:	d117      	bne.n	8004380 <BUTTON_NotifyToggle+0x80>
 8004350:	493e      	ldr	r1, [pc, #248]	; (800444c <BUTTON_NotifyToggle+0x14c>)
    if( second_switch == 0 ) { // first switch
 8004352:	b91d      	cbnz	r5, 800435c <BUTTON_NotifyToggle+0x5c>
      last_timestamp[key_ix] = timestamp;
 8004354:	9a06      	ldr	r2, [sp, #24]
 8004356:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800435a:	e02d      	b.n	80043b8 <BUTTON_NotifyToggle+0xb8>
 //     if (no_velocity)
 //      send_note_on = 1;

    } else { // second switch
      if( last_timestamp[key_ix] ) {
 800435c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8004360:	2b00      	cmp	r3, #0
 8004362:	d029      	beq.n	80043b8 <BUTTON_NotifyToggle+0xb8>
	delay = timestamp - last_timestamp[key_ix];
 8004364:	f8dd c018 	ldr.w	ip, [sp, #24]
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
     if (no_velocity)
 8004368:	4839      	ldr	r0, [pc, #228]	; (8004450 <BUTTON_NotifyToggle+0x150>)
 //     if (no_velocity)
 //      send_note_on = 1;

    } else { // second switch
      if( last_timestamp[key_ix] ) {
	delay = timestamp - last_timestamp[key_ix];
 800436a:	ebc3 030c 	rsb	r3, r3, ip
 800436e:	9307      	str	r3, [sp, #28]
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 8004370:	4938      	ldr	r1, [pc, #224]	; (8004454 <BUTTON_NotifyToggle+0x154>)
 8004372:	4b39      	ldr	r3, [pc, #228]	; (8004458 <BUTTON_NotifyToggle+0x158>)
     if (no_velocity)
 8004374:	6800      	ldr	r0, [r0, #0]
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 8004376:	681b      	ldr	r3, [r3, #0]
 8004378:	6809      	ldr	r1, [r1, #0]
     if (no_velocity)
 800437a:	2800      	cmp	r0, #0
 800437c:	d137      	bne.n	80043ee <BUTTON_NotifyToggle+0xee>
 800437e:	e025      	b.n	80043cc <BUTTON_NotifyToggle+0xcc>
	delay = timestamp - last_timestamp[key_ix];
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
 8004380:	b9d5      	cbnz	r5, 80043b8 <BUTTON_NotifyToggle+0xb8>
      last_timestamp[key_ix] = 0;
 8004382:	4932      	ldr	r1, [pc, #200]	; (800444c <BUTTON_NotifyToggle+0x14c>)
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, KEYBOARD_MIDI_CHN, note_number, 0x00);
 8004384:	b2d4      	uxtb	r4, r2
	send_note_on = 1;
      }
    }
  } else {
    if( second_switch == 0 ) { // first switch
      last_timestamp[key_ix] = 0;
 8004386:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
	      row, column, pin_value, pin, timestamp, delay, velocity);
#endif
  } else if( send_note_off ) {
    // send Note On with velocity 0
    MIOS32_MIDI_SendNoteOn(0x20, KEYBOARD_MIDI_CHN, note_number, 0x00);
 800438a:	4622      	mov	r2, r4
 800438c:	4629      	mov	r1, r5
 800438e:	462b      	mov	r3, r5
 8004390:	2020      	movs	r0, #32
 8004392:	f8cd c010 	str.w	ip, [sp, #16]
 8004396:	f001 f988 	bl	80056aa <MIOS32_MIDI_SendNoteOn>
	MIOS32_MIDI_SendNoteOn(0x10, KEYBOARD_MIDI_CHN, note_number, 0x00);
 800439a:	4629      	mov	r1, r5
 800439c:	4622      	mov	r2, r4
 800439e:	2010      	movs	r0, #16
 80043a0:	462b      	mov	r3, r5
 80043a2:	f001 f982 	bl	80056aa <MIOS32_MIDI_SendNoteOn>
	

#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE OFF\n",
 80043a6:	9906      	ldr	r1, [sp, #24]
 80043a8:	9600      	str	r6, [sp, #0]
 80043aa:	9101      	str	r1, [sp, #4]
 80043ac:	482b      	ldr	r0, [pc, #172]	; (800445c <BUTTON_NotifyToggle+0x15c>)
 80043ae:	4639      	mov	r1, r7
 80043b0:	9a05      	ldr	r2, [sp, #20]
 80043b2:	f8dd c010 	ldr.w	ip, [sp, #16]
 80043b6:	e005      	b.n	80043c4 <BUTTON_NotifyToggle+0xc4>
	      row, column, pin_value, pin, timestamp);
#endif
  } else {
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> IGNORE\n",
 80043b8:	9a06      	ldr	r2, [sp, #24]
 80043ba:	4829      	ldr	r0, [pc, #164]	; (8004460 <BUTTON_NotifyToggle+0x160>)
 80043bc:	9600      	str	r6, [sp, #0]
 80043be:	9201      	str	r2, [sp, #4]
 80043c0:	9a05      	ldr	r2, [sp, #20]
 80043c2:	4639      	mov	r1, r7
 80043c4:	4663      	mov	r3, ip
 80043c6:	f001 fa21 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
 80043ca:	e036      	b.n	800443a <BUTTON_NotifyToggle+0x13a>
  // - if a note on or off event should be sent
  // - the measured delay (note on only)

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
 80043cc:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80043d0:	257f      	movs	r5, #127	; 0x7f
 80043d2:	ebc3 000c 	rsb	r0, r3, ip
 80043d6:	4345      	muls	r5, r0
 80043d8:	1acb      	subs	r3, r1, r3
 80043da:	fbb5 f5f3 	udiv	r5, r5, r3
 80043de:	f1c5 057f 	rsb	r5, r5, #127	; 0x7f
     if (no_velocity)
       velocity = 127;

    // saturate to ensure that range 1..127 won't be exceeded
    if( velocity < 1 )
 80043e2:	2d00      	cmp	r5, #0
 80043e4:	dd05      	ble.n	80043f2 <BUTTON_NotifyToggle+0xf2>
      velocity = 1;
    if( velocity > 127 )
      velocity = 127;
 80043e6:	2d7f      	cmp	r5, #127	; 0x7f
 80043e8:	bfa8      	it	ge
 80043ea:	257f      	movge	r5, #127	; 0x7f
 80043ec:	e002      	b.n	80043f4 <BUTTON_NotifyToggle+0xf4>

  if( send_note_on ) {
    // determine velocity depending on delay
    int velocity = 127 - (((delay-keyboard_delay_fastest) * 127) / (keyboard_delay_slowest-keyboard_delay_fastest));
     if (no_velocity)
       velocity = 127;
 80043ee:	257f      	movs	r5, #127	; 0x7f
 80043f0:	e000      	b.n	80043f4 <BUTTON_NotifyToggle+0xf4>

    // saturate to ensure that range 1..127 won't be exceeded
    if( velocity < 1 )
      velocity = 1;
 80043f2:	2501      	movs	r5, #1
    if( velocity > 127 )
      velocity = 127;

    last_velocity=velocity_table[velocity];
 80043f4:	4b1b      	ldr	r3, [pc, #108]	; (8004464 <BUTTON_NotifyToggle+0x164>)
 80043f6:	4c1c      	ldr	r4, [pc, #112]	; (8004468 <BUTTON_NotifyToggle+0x168>)
 80043f8:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
    MIOS32_MIDI_SendNoteOn(0x20, KEYBOARD_MIDI_CHN, note_number, last_velocity);
 80043fc:	fa5f fc82 	uxtb.w	ip, r2
    if( velocity < 1 )
      velocity = 1;
    if( velocity > 127 )
      velocity = 127;

    last_velocity=velocity_table[velocity];
 8004400:	6023      	str	r3, [r4, #0]
    MIOS32_MIDI_SendNoteOn(0x20, KEYBOARD_MIDI_CHN, note_number, last_velocity);
 8004402:	4662      	mov	r2, ip
 8004404:	b2db      	uxtb	r3, r3
 8004406:	2100      	movs	r1, #0
 8004408:	2020      	movs	r0, #32
 800440a:	f8cd c010 	str.w	ip, [sp, #16]
 800440e:	f001 f94c 	bl	80056aa <MIOS32_MIDI_SendNoteOn>
	MIOS32_MIDI_SendNoteOn(0x10, KEYBOARD_MIDI_CHN, note_number, last_velocity);
 8004412:	f8dd c010 	ldr.w	ip, [sp, #16]
 8004416:	7823      	ldrb	r3, [r4, #0]
 8004418:	2100      	movs	r1, #0
 800441a:	4662      	mov	r2, ip
 800441c:	2010      	movs	r0, #16
 800441e:	f001 f944 	bl	80056aa <MIOS32_MIDI_SendNoteOn>
	
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> NOTE ON (delay=%d); velocity=%d\n",
 8004422:	9906      	ldr	r1, [sp, #24]
 8004424:	9a07      	ldr	r2, [sp, #28]
 8004426:	9101      	str	r1, [sp, #4]
 8004428:	9202      	str	r2, [sp, #8]
 800442a:	4810      	ldr	r0, [pc, #64]	; (800446c <BUTTON_NotifyToggle+0x16c>)
 800442c:	4639      	mov	r1, r7
 800442e:	9a05      	ldr	r2, [sp, #20]
 8004430:	2300      	movs	r3, #0
 8004432:	9600      	str	r6, [sp, #0]
 8004434:	9503      	str	r5, [sp, #12]
 8004436:	f001 f9e9 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
#if DEBUG_VERBOSE_LEVEL >= 2
    DEBUG_MSG("row=0x%02x, column=0x%02x, pin_value=%d -> pin=%d, timestamp=%u -> IGNORE\n",
	      row, column, pin_value, pin, timestamp);
#endif
  }
}
 800443a:	b009      	add	sp, #36	; 0x24
 800443c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800443e:	bf00      	nop
 8004440:	0800a7ad 	.word	0x0800a7ad
 8004444:	0800a7d6 	.word	0x0800a7d6
 8004448:	0800a488 	.word	0x0800a488
 800444c:	200000a0 	.word	0x200000a0
 8004450:	20000c24 	.word	0x20000c24
 8004454:	2000009c 	.word	0x2000009c
 8004458:	20000058 	.word	0x20000058
 800445c:	0800a81e 	.word	0x0800a81e
 8004460:	0800a86b 	.word	0x0800a86b
 8004464:	0800a91c 	.word	0x0800a91c
 8004468:	20000c1c 	.word	0x20000c1c
 800446c:	0800a8b6 	.word	0x0800a8b6

08004470 <TASK_MatrixScan>:


static void TASK_MatrixScan(void *pvParameters)
{
 8004470:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004472:	b089      	sub	sp, #36	; 0x24
  while( 1 ) {
    // wait for next timesplice (1 mS)
    vTaskDelay(1 / portTICK_RATE_MS);
 8004474:	2001      	movs	r0, #1
 8004476:	f000 fbe3 	bl	8004c40 <vTaskDelay>

    // determine timestamp (we need it for delay measurements)
    mios32_sys_time_t t = MIOS32_SYS_TimeGet();
 800447a:	a806      	add	r0, sp, #24
 800447c:	f002 f89e 	bl	80065bc <MIOS32_SYS_TimeGet>
    u32 timestamp = 1000*t.seconds + t.fraction_ms;
 8004480:	9b07      	ldr	r3, [sp, #28]
 8004482:	9a06      	ldr	r2, [sp, #24]
 8004484:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8004488:	fb01 3302 	mla	r3, r1, r2, r3
 800448c:	f04f 36ff 	mov.w	r6, #4294967295
 8004490:	9302      	str	r3, [sp, #8]
 8004492:	4d37      	ldr	r5, [pc, #220]	; (8004570 <TASK_MatrixScan+0x100>)
    //   - shift selection pattern for *next* row to DOUT registers
    //   - read DIN values of previously selected row
    // since we need to select the first row before the first DIN values are latched, we loop from -1
    // to handle the initial state
    int row;
    for(row=-1; row<MATRIX_NUM_ROWS; ++row) {
 8004494:	4637      	mov	r7, r6
 8004496:	e00e      	b.n	80044b6 <TASK_MatrixScan+0x46>
      if( row >= 0 ) { // not required for initial scan
	// latch DIN values
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8004498:	2100      	movs	r1, #0
 800449a:	460a      	mov	r2, r1
 800449c:	2001      	movs	r0, #1
 800449e:	f002 f9bd 	bl	800681c <MIOS32_SPI_RC_PinSet>
	MIOS32_DELAY_Wait_uS(1);
 80044a2:	2001      	movs	r0, #1
 80044a4:	f003 f800 	bl	80074a8 <MIOS32_DELAY_Wait_uS>
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 80044a8:	2001      	movs	r0, #1
 80044aa:	2100      	movs	r1, #0
 80044ac:	4602      	mov	r2, r0
 80044ae:	f002 f9b5 	bl	800681c <MIOS32_SPI_RC_PinSet>
 80044b2:	3601      	adds	r6, #1
 80044b4:	3504      	adds	r5, #4
      }

      // determine selection mask for next row (written into DOUT registers while reading DIN registers)
      u16 select_row_pattern = ~(1 << (row+1));
 80044b6:	2201      	movs	r2, #1
 80044b8:	3701      	adds	r7, #1
 80044ba:	fa12 f407 	lsls.w	r4, r2, r7
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 80044be:	4610      	mov	r0, r2
 80044c0:	21ff      	movs	r1, #255	; 0xff
 80044c2:	f002 f9f3 	bl	80068ac <MIOS32_SPI_TransferByte>
	MIOS32_DELAY_Wait_uS(1);
	MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
      }

      // determine selection mask for next row (written into DOUT registers while reading DIN registers)
      u16 select_row_pattern = ~(1 << (row+1));
 80044c6:	43e4      	mvns	r4, r4
 80044c8:	b2a4      	uxth	r4, r4
#if MATRIX_DOUT_HAS_SINK_DRIVERS
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
 80044ca:	4684      	mov	ip, r0
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 80044cc:	0a21      	lsrs	r1, r4, #8
 80044ce:	2001      	movs	r0, #1
 80044d0:	f8cd c000 	str.w	ip, [sp]
 80044d4:	f002 f9ea 	bl	80068ac <MIOS32_SPI_TransferByte>
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 80044d8:	b2e1      	uxtb	r1, r4
      select_row_pattern ^= 0xffff; // invert selection pattern if sink drivers are connected to DOUT pins
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
 80044da:	4603      	mov	r3, r0
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 80044dc:	2001      	movs	r0, #1
 80044de:	9301      	str	r3, [sp, #4]
 80044e0:	f002 f9e4 	bl	80068ac <MIOS32_SPI_TransferByte>

      // latch new DOUT value
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 80044e4:	2100      	movs	r1, #0
 80044e6:	460a      	mov	r2, r1
#endif

      // read DIN, write DOUT
      u8 din0 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI,  0xff);
      u8 din1 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 8) & 0xff);
      u8 din2 = MIOS32_SPI_TransferByte(MIOS32_SRIO_SPI, (select_row_pattern >> 0) & 0xff);
 80044e8:	4604      	mov	r4, r0

      // latch new DOUT value
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 80044ea:	2001      	movs	r0, #1
 80044ec:	f002 f996 	bl	800681c <MIOS32_SPI_RC_PinSet>
      MIOS32_DELAY_Wait_uS(1);
 80044f0:	2001      	movs	r0, #1
 80044f2:	f002 ffd9 	bl	80074a8 <MIOS32_DELAY_Wait_uS>
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 80044f6:	2001      	movs	r0, #1
 80044f8:	2100      	movs	r1, #0
 80044fa:	4602      	mov	r2, r0
 80044fc:	f002 f98e 	bl	800681c <MIOS32_SPI_RC_PinSet>

      if( row >= 0 ) {
 8004500:	f1b6 3fff 	cmp.w	r6, #4294967295
 8004504:	9b01      	ldr	r3, [sp, #4]
 8004506:	f8dd c000 	ldr.w	ip, [sp]
 800450a:	d02e      	beq.n	800456a <TASK_MatrixScan+0xfa>
	// combine read DIN bytes to 24bit value
	u32 din_pattern = 0xff000000 | (din2 << 16) | (din1 << 8) | din0;
 800450c:	fa5f fc8c 	uxtb.w	ip, ip
 8004510:	f04c 4c7f 	orr.w	ip, ip, #4278190080	; 0xff000000
 8004514:	b2e4      	uxtb	r4, r4
 8004516:	ea4c 4404 	orr.w	r4, ip, r4, lsl #16
 800451a:	fa5f fc83 	uxtb.w	ip, r3

	// check if values have been changed via XOR combination with previously scanned value
	u32 changed = din_pattern ^ din_value[row];
 800451e:	f855 3c04 	ldr.w	r3, [r5, #-4]
      MIOS32_DELAY_Wait_uS(1);
      MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value

      if( row >= 0 ) {
	// combine read DIN bytes to 24bit value
	u32 din_pattern = 0xff000000 | (din2 << 16) | (din1 << 8) | din0;
 8004522:	ea44 2c0c 	orr.w	ip, r4, ip, lsl #8

	// check if values have been changed via XOR combination with previously scanned value
	u32 changed = din_pattern ^ din_value[row];
	if( changed ) {
 8004526:	ea9c 0303 	eors.w	r3, ip, r3
 800452a:	9303      	str	r3, [sp, #12]
 800452c:	d01d      	beq.n	800456a <TASK_MatrixScan+0xfa>
	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
	    if( changed & mask )
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);
 800452e:	b2f3      	uxtb	r3, r6

	// check if values have been changed via XOR combination with previously scanned value
	u32 changed = din_pattern ^ din_value[row];
	if( changed ) {
	  // store changed value
	  din_value[row] = din_pattern;
 8004530:	f845 cc04 	str.w	ip, [r5, #-4]
	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
	    if( changed & mask )
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);
 8004534:	9705      	str	r7, [sp, #20]
	  // store changed value
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
 8004536:	2400      	movs	r4, #0
	    u32 mask = 1 << column;
	    if( changed & mask )
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);
 8004538:	4637      	mov	r7, r6
 800453a:	9304      	str	r3, [sp, #16]
 800453c:	462e      	mov	r6, r5
 800453e:	4665      	mov	r5, ip
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
	    u32 mask = 1 << column;
 8004540:	2101      	movs	r1, #1
 8004542:	fa11 f304 	lsls.w	r3, r1, r4
	    if( changed & mask )
 8004546:	9a03      	ldr	r2, [sp, #12]
 8004548:	4213      	tst	r3, r2
 800454a:	d008      	beq.n	800455e <TASK_MatrixScan+0xee>
	      BUTTON_NotifyToggle(row, column, (din_pattern & mask) ? 1 : 0, timestamp);
 800454c:	422b      	tst	r3, r5
 800454e:	b2e1      	uxtb	r1, r4
 8004550:	bf0c      	ite	eq
 8004552:	2200      	moveq	r2, #0
 8004554:	2201      	movne	r2, #1
 8004556:	9804      	ldr	r0, [sp, #16]
 8004558:	9b02      	ldr	r3, [sp, #8]
 800455a:	f7ff fed1 	bl	8004300 <BUTTON_NotifyToggle>
	  // store changed value
	  din_value[row] = din_pattern;

	  // notify changed value
	  int column;
	  for(column=0; column<24; ++column) {
 800455e:	3401      	adds	r4, #1
 8004560:	2c18      	cmp	r4, #24
 8004562:	d1ed      	bne.n	8004540 <TASK_MatrixScan+0xd0>
 8004564:	4635      	mov	r5, r6
 8004566:	463e      	mov	r6, r7
 8004568:	9f05      	ldr	r7, [sp, #20]
    //   - shift selection pattern for *next* row to DOUT registers
    //   - read DIN values of previously selected row
    // since we need to select the first row before the first DIN values are latched, we loop from -1
    // to handle the initial state
    int row;
    for(row=-1; row<MATRIX_NUM_ROWS; ++row) {
 800456a:	2f10      	cmp	r7, #16
 800456c:	d194      	bne.n	8004498 <TASK_MatrixScan+0x28>
 800456e:	e781      	b.n	8004474 <TASK_MatrixScan+0x4>
 8004570:	2000005c 	.word	0x2000005c

08004574 <TASK_MIDI_Hooks>:
// MIDI task (separated from TASK_Hooks() to ensure parallel handling of
// MIDI events if a hook in TASK_Hooks() blocks)
/////////////////////////////////////////////////////////////////////////////
#if !defined(MIOS32_DONT_USE_MIDI)
static void TASK_MIDI_Hooks(void *pvParameters)
{
 8004574:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 8004576:	f000 fa61 	bl	8004a3c <xTaskGetTickCount>
 800457a:	ac02      	add	r4, sp, #8
 800457c:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8004580:	2101      	movs	r1, #1
 8004582:	4620      	mov	r0, r4
 8004584:	f000 fb84 	bl	8004c90 <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 8004588:	f000 fa58 	bl	8004a3c <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 800458c:	9a01      	ldr	r2, [sp, #4]
 800458e:	1f43      	subs	r3, r0, #5
 8004590:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 8004592:	bf38      	it	cc
 8004594:	9001      	strcc	r0, [sp, #4]

    // handle timeout/expire counters and USB packages
    MIOS32_MIDI_Periodic_mS();
 8004596:	f001 fc8f 	bl	8005eb8 <MIOS32_MIDI_Periodic_mS>

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 800459a:	4802      	ldr	r0, [pc, #8]	; (80045a4 <TASK_MIDI_Hooks+0x30>)
 800459c:	f001 faf2 	bl	8005b84 <MIOS32_MIDI_Receive_Handler>
  }
 80045a0:	e7ee      	b.n	8004580 <TASK_MIDI_Hooks+0xc>
 80045a2:	bf00      	nop
 80045a4:	080042d9 	.word	0x080042d9

080045a8 <TASK_Hooks>:

/////////////////////////////////////////////////////////////////////////////
// Remaining application hooks
/////////////////////////////////////////////////////////////////////////////
static void TASK_Hooks(void *pvParameters)
{
 80045a8:	b513      	push	{r0, r1, r4, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 80045aa:	f000 fa47 	bl	8004a3c <xTaskGetTickCount>
 80045ae:	ac02      	add	r4, sp, #8
 80045b0:	f844 0d04 	str.w	r0, [r4, #-4]!

  while( 1 ) {
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 80045b4:	2101      	movs	r1, #1
 80045b6:	4620      	mov	r0, r4
 80045b8:	f000 fb6a 	bl	8004c90 <vTaskDelayUntil>

    // skip delay gap if we had to wait for more than 5 ticks to avoid 
    // unnecessary repeats until xLastExecutionTime reached xTaskGetTickCount() again
    portTickType xCurrentTickCount = xTaskGetTickCount();
 80045bc:	f000 fa3e 	bl	8004a3c <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 80045c0:	9a01      	ldr	r2, [sp, #4]
 80045c2:	1f43      	subs	r3, r0, #5
 80045c4:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 80045c6:	bf38      	it	cc
 80045c8:	9001      	strcc	r0, [sp, #4]

#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
    // check for DIN pin changes, call APP_DIN_NotifyToggle on each toggled pin
    MIOS32_DIN_Handler(APP_DIN_NotifyToggle);
 80045ca:	4806      	ldr	r0, [pc, #24]	; (80045e4 <TASK_Hooks+0x3c>)
 80045cc:	f000 fe6c 	bl	80052a8 <MIOS32_DIN_Handler>

    // check for encoder changes, call APP_ENC_NotifyChanged on each change
# ifndef MIOS32_DONT_USE_ENC
    MIOS32_ENC_Handler(APP_ENC_NotifyChange);
 80045d0:	4805      	ldr	r0, [pc, #20]	; (80045e8 <TASK_Hooks+0x40>)
 80045d2:	f000 fecd 	bl	8005370 <MIOS32_ENC_Handler>
# endif
#endif

#if !defined(MIOS32_DONT_USE_AIN)
    // check for AIN pin changes, call APP_AIN_NotifyChange on each pin change
    MIOS32_AIN_Handler(APP_AIN_NotifyChange);
 80045d6:	4805      	ldr	r0, [pc, #20]	; (80045ec <TASK_Hooks+0x44>)
 80045d8:	f003 f8a4 	bl	8007724 <MIOS32_AIN_Handler>
#endif

#if !defined(MIOS32_DONT_USE_COM)
    // check for incoming COM messages
    MIOS32_COM_Receive_Handler();
 80045dc:	f001 fcf3 	bl	8005fc6 <MIOS32_COM_Receive_Handler>
#endif
  }
 80045e0:	e7e8      	b.n	80045b4 <TASK_Hooks+0xc>
 80045e2:	bf00      	nop
 80045e4:	080042db 	.word	0x080042db
 80045e8:	080042dd 	.word	0x080042dd
 80045ec:	080042e1 	.word	0x080042e1

080045f0 <main>:

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 80045f0:	b530      	push	{r4, r5, lr}
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 80045f2:	2000      	movs	r0, #0

/////////////////////////////////////////////////////////////////////////////
// Main function
/////////////////////////////////////////////////////////////////////////////
int main(void)
{
 80045f4:	b085      	sub	sp, #20
  // initialize hardware and MIOS32 modules
#ifndef MIOS32_DONT_USE_SYS
  MIOS32_SYS_Init(0);
 80045f6:	f001 ff51 	bl	800649c <MIOS32_SYS_Init>
#endif
#ifndef MIOS32_DONT_USE_DELAY
  MIOS32_DELAY_Init(0);
 80045fa:	2000      	movs	r0, #0
 80045fc:	f002 ff32 	bl	8007464 <MIOS32_DELAY_Init>
#endif
#ifndef MIOS32_DONT_USE_BOARD
  MIOS32_BOARD_Init(0);
 8004600:	2000      	movs	r0, #0
 8004602:	f002 fd1d 	bl	8007040 <MIOS32_BOARD_Init>
#endif
#ifndef MIOS32_DONT_USE_SPI
  MIOS32_SPI_Init(0);
 8004606:	2000      	movs	r0, #0
 8004608:	f002 fc2a 	bl	8006e60 <MIOS32_SPI_Init>
#endif
#ifndef MIOS32_DONT_USE_SRIO
  MIOS32_SRIO_Init(0);
 800460c:	2000      	movs	r0, #0
 800460e:	f000 fdd3 	bl	80051b8 <MIOS32_SRIO_Init>
#endif
#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DIN_Init(0);
 8004612:	2000      	movs	r0, #0
 8004614:	f000 fe1a 	bl	800524c <MIOS32_DIN_Init>
#endif
#if !defined(MIOS32_DONT_USE_DOUT) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_DOUT_Init(0);
 8004618:	2000      	movs	r0, #0
 800461a:	f000 fe6d 	bl	80052f8 <MIOS32_DOUT_Init>
#endif
#if !defined(MIOS32_DONT_USE_ENC) && !defined(MIOS32_DONT_USE_SRIO)
  MIOS32_ENC_Init(0);
 800461e:	2000      	movs	r0, #0
 8004620:	f000 fe78 	bl	8005314 <MIOS32_ENC_Init>
#endif
#if !defined(MIOS32_DONT_USE_MF)
  MIOS32_MF_Init(0);
 8004624:	2000      	movs	r0, #0
 8004626:	f001 fe9b 	bl	8006360 <MIOS32_MF_Init>
#endif
#if !defined(MIOS32_DONT_USE_AIN)
  MIOS32_AIN_Init(0);
 800462a:	2000      	movs	r0, #0
 800462c:	f002 ff48 	bl	80074c0 <MIOS32_AIN_Init>
#endif
#ifndef MIOS32_DONT_USE_IIC_BS
  MIOS32_IIC_BS_Init(0);
 8004630:	2000      	movs	r0, #0
 8004632:	f001 fe92 	bl	800635a <MIOS32_IIC_BS_Init>
#endif
#ifndef MIOS32_DONT_USE_USB
  MIOS32_USB_Init(0);
 8004636:	2000      	movs	r0, #0
 8004638:	f003 fa84 	bl	8007b44 <MIOS32_USB_Init>
#endif
#ifndef MIOS32_DONT_USE_MIDI
  MIOS32_MIDI_Init(0);
 800463c:	2000      	movs	r0, #0
 800463e:	f000 ff9b 	bl	8005578 <MIOS32_MIDI_Init>
#endif
#ifndef MIOS32_DONT_USE_OSC
  MIOS32_OSC_Init(0);
 8004642:	2000      	movs	r0, #0
 8004644:	f001 fc86 	bl	8005f54 <MIOS32_OSC_Init>
#endif
#ifndef MIOS32_DONT_USE_COM
  MIOS32_COM_Init(0);
 8004648:	2000      	movs	r0, #0
 800464a:	f001 fc89 	bl	8005f60 <MIOS32_COM_Init>
#endif
#ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_Init(0);
 800464e:	2000      	movs	r0, #0
 8004650:	f000 feee 	bl	8005430 <MIOS32_LCD_Init>
#ifdef MIOS32_USE_I2S
  MIOS32_I2S_Init(0);
#endif

  // call C++ constructors
  __libc_init_array();
 8004654:	f005 febe 	bl	800a3d4 <__libc_init_array>

  // initialize application
  APP_Init();
 8004658:	f7ff fdc4 	bl	80041e4 <APP_Init>

#if MIOS32_LCD_BOOT_MSG_DELAY
  // print boot message
# ifndef MIOS32_DONT_USE_LCD
  MIOS32_LCD_PrintBootMessage();
 800465c:	f000 ff50 	bl	8005500 <MIOS32_LCD_PrintBootMessage>
 8004660:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
    MIOS32_DELAY_Wait_uS(1000);
 8004664:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004668:	f002 ff1e 	bl	80074a8 <MIOS32_DELAY_Wait_uS>
# endif

  // wait for given delay (usually 2 seconds)
# ifndef MIOS32_DONT_USE_DELAY
  int delay = 0;
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
 800466c:	f114 34ff 	adds.w	r4, r4, #4294967295
 8004670:	d1f8      	bne.n	8004664 <main+0x74>
    MIOS32_DELAY_Wait_uS(1000);
# endif
#endif

  // start the task which calls the application hooks
  xTaskCreate(TASK_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 8004672:	2503      	movs	r5, #3
 8004674:	4623      	mov	r3, r4
 8004676:	490d      	ldr	r1, [pc, #52]	; (80046ac <main+0xbc>)
 8004678:	f44f 7280 	mov.w	r2, #256	; 0x100
 800467c:	480c      	ldr	r0, [pc, #48]	; (80046b0 <main+0xc0>)
 800467e:	9500      	str	r5, [sp, #0]
 8004680:	9401      	str	r4, [sp, #4]
 8004682:	9402      	str	r4, [sp, #8]
 8004684:	9403      	str	r4, [sp, #12]
 8004686:	f000 f8df 	bl	8004848 <xTaskGenericCreate>
#if !defined(MIOS32_DONT_USE_MIDI)
  xTaskCreate(TASK_MIDI_Hooks, (signed portCHAR *)"Hooks", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_HOOKS, NULL);
 800468a:	4908      	ldr	r1, [pc, #32]	; (80046ac <main+0xbc>)
 800468c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004690:	4623      	mov	r3, r4
 8004692:	4808      	ldr	r0, [pc, #32]	; (80046b4 <main+0xc4>)
 8004694:	9500      	str	r5, [sp, #0]
 8004696:	9401      	str	r4, [sp, #4]
 8004698:	9402      	str	r4, [sp, #8]
 800469a:	9403      	str	r4, [sp, #12]
 800469c:	f000 f8d4 	bl	8004848 <xTaskGenericCreate>
#endif

  // start the scheduler
  vTaskStartScheduler();
 80046a0:	f000 f9a0 	bl	80049e4 <vTaskStartScheduler>

  // Will only get here if there was not enough heap space to create the idle task
  return 0;
}
 80046a4:	4620      	mov	r0, r4
 80046a6:	b005      	add	sp, #20
 80046a8:	bd30      	pop	{r4, r5, pc}
 80046aa:	bf00      	nop
 80046ac:	0800ab1c 	.word	0x0800ab1c
 80046b0:	080045a9 	.word	0x080045a9
 80046b4:	08004575 	.word	0x08004575

080046b8 <vApplicationTickHook>:
  APP_SRIO_ServicePrepare();

  // start next SRIO scan - IRQ notification to SRIO_ServiceFinish()
  MIOS32_SRIO_ScanStart(SRIO_ServiceFinish);
#endif
}
 80046b8:	4770      	bx	lr

080046ba <vApplicationIdleHook>:

/////////////////////////////////////////////////////////////////////////////
// Idle Hook (called by FreeRTOS when nothing else to do)
/////////////////////////////////////////////////////////////////////////////
void vApplicationIdleHook(void)
{
 80046ba:	b508      	push	{r3, lr}
  // branch endless to application
  while( 1 ) {
    APP_Background();
 80046bc:	f7ff fdfc 	bl	80042b8 <APP_Background>
 80046c0:	e7fc      	b.n	80046bc <vApplicationIdleHook+0x2>
	...

080046c4 <_abort>:
// This function aborts any operations, but keeps MIDI alive (for uploading
// a new firmware)
// If MIDI isn't enabled, the status LED will be flashed
/////////////////////////////////////////////////////////////////////////////
void _abort(void)
{
 80046c4:	b570      	push	{r4, r5, r6, lr}
  // stop other tasks from running
  portENTER_CRITICAL();
 80046c6:	f000 fbf1 	bl	8004eac <vPortEnterCritical>

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
 80046ca:	2400      	movs	r4, #0
  while( 1 ) {
    ++delay_ctr;

    if( (delay_ctr % 100) == 0 ) {
 80046cc:	2664      	movs	r6, #100	; 0x64
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);

    if( (delay_ctr % 10000) == 0 ) {
 80046ce:	f242 7510 	movw	r5, #10000	; 0x2710

#ifndef MIOS32_DONT_USE_MIDI
  // keep MIDI alive, so that program code can be updated
  u32 delay_ctr = 0;
  while( 1 ) {
    ++delay_ctr;
 80046d2:	3401      	adds	r4, #1

    if( (delay_ctr % 100) == 0 ) {
 80046d4:	fbb4 f3f6 	udiv	r3, r4, r6
 80046d8:	fb06 4313 	mls	r3, r6, r3, r4
 80046dc:	b90b      	cbnz	r3, 80046e2 <_abort+0x1e>
      // handle timeout/expire counters and USB packages
      MIOS32_MIDI_Periodic_mS();
 80046de:	f001 fbeb 	bl	8005eb8 <MIOS32_MIDI_Periodic_mS>
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 80046e2:	4808      	ldr	r0, [pc, #32]	; (8004704 <_abort+0x40>)
 80046e4:	f001 fa4e 	bl	8005b84 <MIOS32_MIDI_Receive_Handler>

    if( (delay_ctr % 10000) == 0 ) {
 80046e8:	fbb4 f3f5 	udiv	r3, r4, r5
 80046ec:	fb05 4313 	mls	r3, r5, r3, r4
 80046f0:	2b00      	cmp	r3, #0
 80046f2:	d1ee      	bne.n	80046d2 <_abort+0xe>
      // toggle board LED
      MIOS32_BOARD_LED_Set(1, ~MIOS32_BOARD_LED_Get());
 80046f4:	f002 fce2 	bl	80070bc <MIOS32_BOARD_LED_Get>
 80046f8:	43c1      	mvns	r1, r0
 80046fa:	2001      	movs	r0, #1
 80046fc:	f002 fcca 	bl	8007094 <MIOS32_BOARD_LED_Set>
 8004700:	e7e7      	b.n	80046d2 <_abort+0xe>
 8004702:	bf00      	nop
 8004704:	080042d9 	.word	0x080042d9

08004708 <HardFault_Handler_c>:

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 8004708:	b510      	push	{r4, lr}
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 800470a:	6803      	ldr	r3, [r0, #0]

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 800470c:	b088      	sub	sp, #32
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 800470e:	9307      	str	r3, [sp, #28]
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 8004710:	6843      	ldr	r3, [r0, #4]
  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8004712:	4c33      	ldr	r4, [pc, #204]	; (80047e0 <HardFault_Handler_c+0xd8>)
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 8004714:	9306      	str	r3, [sp, #24]
  stacked_r2 = ((unsigned long) hardfault_args[2]);
 8004716:	6883      	ldr	r3, [r0, #8]
 8004718:	9305      	str	r3, [sp, #20]
  stacked_r3 = ((unsigned long) hardfault_args[3]);
 800471a:	68c3      	ldr	r3, [r0, #12]
 800471c:	9304      	str	r3, [sp, #16]

  stacked_r12 = ((unsigned long) hardfault_args[4]);
 800471e:	6903      	ldr	r3, [r0, #16]
 8004720:	9303      	str	r3, [sp, #12]
  stacked_lr = ((unsigned long) hardfault_args[5]);
 8004722:	6943      	ldr	r3, [r0, #20]
 8004724:	9302      	str	r3, [sp, #8]
  stacked_pc = ((unsigned long) hardfault_args[6]);
 8004726:	6983      	ldr	r3, [r0, #24]
 8004728:	9301      	str	r3, [sp, #4]
  stacked_psr = ((unsigned long) hardfault_args[7]);
 800472a:	69c3      	ldr	r3, [r0, #28]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 800472c:	4620      	mov	r0, r4
  stacked_r3 = ((unsigned long) hardfault_args[3]);

  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);
 800472e:	9300      	str	r3, [sp, #0]
  
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8004730:	f001 f86c 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("!!! HARD FAULT !!!\n");
 8004734:	482b      	ldr	r0, [pc, #172]	; (80047e4 <HardFault_Handler_c+0xdc>)
 8004736:	f001 f869 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("==================\n");
 800473a:	4620      	mov	r0, r4
 800473c:	f001 f866 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R0 = %08x\n", stacked_r0);
 8004740:	9907      	ldr	r1, [sp, #28]
 8004742:	4829      	ldr	r0, [pc, #164]	; (80047e8 <HardFault_Handler_c+0xe0>)
 8004744:	f001 f862 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R1 = %08x\n", stacked_r1);
 8004748:	9906      	ldr	r1, [sp, #24]
 800474a:	4828      	ldr	r0, [pc, #160]	; (80047ec <HardFault_Handler_c+0xe4>)
 800474c:	f001 f85e 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R2 = %08x\n", stacked_r2);
 8004750:	9905      	ldr	r1, [sp, #20]
 8004752:	4827      	ldr	r0, [pc, #156]	; (80047f0 <HardFault_Handler_c+0xe8>)
 8004754:	f001 f85a 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R3 = %08x\n", stacked_r3);
 8004758:	9904      	ldr	r1, [sp, #16]
 800475a:	4826      	ldr	r0, [pc, #152]	; (80047f4 <HardFault_Handler_c+0xec>)
 800475c:	f001 f856 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R12 = %08x\n", stacked_r12);
 8004760:	9903      	ldr	r1, [sp, #12]
 8004762:	4825      	ldr	r0, [pc, #148]	; (80047f8 <HardFault_Handler_c+0xf0>)
 8004764:	f001 f852 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("LR = %08x\n", stacked_lr);
 8004768:	9902      	ldr	r1, [sp, #8]
 800476a:	4824      	ldr	r0, [pc, #144]	; (80047fc <HardFault_Handler_c+0xf4>)
 800476c:	f001 f84e 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PC = %08x\n", stacked_pc);
 8004770:	9901      	ldr	r1, [sp, #4]
 8004772:	4823      	ldr	r0, [pc, #140]	; (8004800 <HardFault_Handler_c+0xf8>)
 8004774:	f001 f84a 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PSR = %08x\n", stacked_psr);
 8004778:	9900      	ldr	r1, [sp, #0]
 800477a:	4822      	ldr	r0, [pc, #136]	; (8004804 <HardFault_Handler_c+0xfc>)
 800477c:	f001 f846 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("BFAR = %08x\n", (*((volatile unsigned long *)(0xE000ED38))));
 8004780:	4b21      	ldr	r3, [pc, #132]	; (8004808 <HardFault_Handler_c+0x100>)
 8004782:	4822      	ldr	r0, [pc, #136]	; (800480c <HardFault_Handler_c+0x104>)
 8004784:	6819      	ldr	r1, [r3, #0]
 8004786:	f001 f841 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("CFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED28))));
 800478a:	4b21      	ldr	r3, [pc, #132]	; (8004810 <HardFault_Handler_c+0x108>)
 800478c:	4821      	ldr	r0, [pc, #132]	; (8004814 <HardFault_Handler_c+0x10c>)
 800478e:	6819      	ldr	r1, [r3, #0]
 8004790:	f001 f83c 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("HFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED2C))));
 8004794:	4b20      	ldr	r3, [pc, #128]	; (8004818 <HardFault_Handler_c+0x110>)
 8004796:	4821      	ldr	r0, [pc, #132]	; (800481c <HardFault_Handler_c+0x114>)
 8004798:	6819      	ldr	r1, [r3, #0]
 800479a:	f001 f837 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("DFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED30))));
 800479e:	4b20      	ldr	r3, [pc, #128]	; (8004820 <HardFault_Handler_c+0x118>)
 80047a0:	4820      	ldr	r0, [pc, #128]	; (8004824 <HardFault_Handler_c+0x11c>)
 80047a2:	6819      	ldr	r1, [r3, #0]
 80047a4:	f001 f832 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("AFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED3C))));
 80047a8:	4b1f      	ldr	r3, [pc, #124]	; (8004828 <HardFault_Handler_c+0x120>)
 80047aa:	4820      	ldr	r0, [pc, #128]	; (800482c <HardFault_Handler_c+0x124>)
 80047ac:	6819      	ldr	r1, [r3, #0]
 80047ae:	f001 f82d 	bl	800580c <MIOS32_MIDI_SendDebugMessage>

#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 80047b2:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80047b6:	f000 fed6 	bl	8005566 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 80047ba:	2000      	movs	r0, #0
 80047bc:	f000 fed7 	bl	800556e <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 80047c0:	2000      	movs	r0, #0
 80047c2:	f000 fdf5 	bl	80053b0 <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 80047c6:	f000 fe5b 	bl	8005480 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 80047ca:	2000      	movs	r0, #0
 80047cc:	4601      	mov	r1, r0
 80047ce:	f000 fdf5 	bl	80053bc <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("!! HARD FAULT !!");
 80047d2:	4817      	ldr	r0, [pc, #92]	; (8004830 <HardFault_Handler_c+0x128>)
 80047d4:	f000 fe86 	bl	80054e4 <MIOS32_LCD_PrintString>
#endif

  _abort();
 80047d8:	f7ff ff74 	bl	80046c4 <_abort>
}
 80047dc:	b008      	add	sp, #32
 80047de:	bd10      	pop	{r4, pc}
 80047e0:	0800ab78 	.word	0x0800ab78
 80047e4:	0800ab8c 	.word	0x0800ab8c
 80047e8:	0800aba0 	.word	0x0800aba0
 80047ec:	0800abab 	.word	0x0800abab
 80047f0:	0800abb6 	.word	0x0800abb6
 80047f4:	0800abc1 	.word	0x0800abc1
 80047f8:	0800abcc 	.word	0x0800abcc
 80047fc:	0800abd8 	.word	0x0800abd8
 8004800:	0800abe3 	.word	0x0800abe3
 8004804:	0800abee 	.word	0x0800abee
 8004808:	e000ed38 	.word	0xe000ed38
 800480c:	0800abfa 	.word	0x0800abfa
 8004810:	e000ed28 	.word	0xe000ed28
 8004814:	0800ac07 	.word	0x0800ac07
 8004818:	e000ed2c 	.word	0xe000ed2c
 800481c:	0800ac14 	.word	0x0800ac14
 8004820:	e000ed30 	.word	0xe000ed30
 8004824:	0800ac21 	.word	0x0800ac21
 8004828:	e000ed3c 	.word	0xe000ed3c
 800482c:	0800ac2e 	.word	0x0800ac2e
 8004830:	0800ac3b 	.word	0x0800ac3b

08004834 <HardFault_Handler>:


void HardFault_Handler(void)
{
  __asm("TST LR, #4");
 8004834:	f01e 0f04 	tst.w	lr, #4
  __asm("ITE EQ");
 8004838:	bf0c      	ite	eq
  __asm("MRSEQ R0, MSP");
 800483a:	f3ef 8008 	mrseq	r0, MSP
  __asm("MRSNE R0, PSP");
 800483e:	f3ef 8009 	mrsne	r0, PSP
  __asm("B HardFault_Handler_c");
 8004842:	f7ff bf61 	b.w	8004708 <HardFault_Handler_c>
}
 8004846:	4770      	bx	lr

08004848 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8004848:	b5f0      	push	{r4, r5, r6, r7, lr}
 800484a:	b085      	sub	sp, #20
 800484c:	9303      	str	r3, [sp, #12]
 800484e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004850:	9002      	str	r0, [sp, #8]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8004852:	2048      	movs	r0, #72	; 0x48
 8004854:	9300      	str	r3, [sp, #0]
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8004856:	460e      	mov	r6, r1
 8004858:	4614      	mov	r4, r2
 800485a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 800485c:	f000 fbfc 	bl	8005058 <pvPortMalloc>

	if( pxNewTCB != NULL )
 8004860:	9b00      	ldr	r3, [sp, #0]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8004862:	4605      	mov	r5, r0

	if( pxNewTCB != NULL )
 8004864:	2800      	cmp	r0, #0
 8004866:	f000 809b 	beq.w	80049a0 <xTaskGenericCreate+0x158>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 800486a:	b91b      	cbnz	r3, 8004874 <xTaskGenericCreate+0x2c>
 800486c:	00a0      	lsls	r0, r4, #2
 800486e:	f000 fbf3 	bl	8005058 <pvPortMalloc>
 8004872:	4603      	mov	r3, r0
 8004874:	632b      	str	r3, [r5, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8004876:	b91b      	cbnz	r3, 8004880 <xTaskGenericCreate+0x38>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8004878:	4628      	mov	r0, r5
 800487a:	f000 fbb7 	bl	8004fec <vPortFree>
 800487e:	e08f      	b.n	80049a0 <xTaskGenericCreate+0x158>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 8004880:	00a2      	lsls	r2, r4, #2
 8004882:	21a5      	movs	r1, #165	; 0xa5
 8004884:	4618      	mov	r0, r3
 8004886:	f005 fdd4 	bl	800a432 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 800488a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800488c:	3c01      	subs	r4, #1
 800488e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 8004892:	f023 0307 	bic.w	r3, r3, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8004896:	4631      	mov	r1, r6
 8004898:	2210      	movs	r2, #16
 800489a:	f105 0034 	add.w	r0, r5, #52	; 0x34
 800489e:	9300      	str	r3, [sp, #0]
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 80048a0:	2400      	movs	r4, #0
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80048a2:	f005 fddd 	bl	800a460 <strncpy>
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80048a6:	1d2e      	adds	r6, r5, #4
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 80048a8:	2f04      	cmp	r7, #4
 80048aa:	bf34      	ite	cc
 80048ac:	463a      	movcc	r2, r7
 80048ae:	2204      	movcs	r2, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
 80048b0:	62ea      	str	r2, [r5, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 80048b2:	646a      	str	r2, [r5, #68]	; 0x44
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 80048b4:	f885 4043 	strb.w	r4, [r5, #67]	; 0x43
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80048b8:	4630      	mov	r0, r6
 80048ba:	9201      	str	r2, [sp, #4]
 80048bc:	f000 fa6b 	bl	8004d96 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 80048c0:	f105 0018 	add.w	r0, r5, #24
 80048c4:	f000 fa67 	bl	8004d96 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80048c8:	9a01      	ldr	r2, [sp, #4]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80048ca:	9b00      	ldr	r3, [sp, #0]
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80048cc:	f1c2 0205 	rsb	r2, r2, #5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80048d0:	4618      	mov	r0, r3
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80048d2:	61aa      	str	r2, [r5, #24]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80048d4:	9902      	ldr	r1, [sp, #8]
 80048d6:	9a03      	ldr	r2, [sp, #12]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80048d8:	612d      	str	r5, [r5, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 80048da:	626d      	str	r5, [r5, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80048dc:	f000 fa95 	bl	8004e0a <pxPortInitialiseStack>
 80048e0:	6028      	str	r0, [r5, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
 80048e2:	f000 fae3 	bl	8004eac <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 80048e6:	4b31      	ldr	r3, [pc, #196]	; (80049ac <xTaskGenericCreate+0x164>)
 80048e8:	681a      	ldr	r2, [r3, #0]
 80048ea:	3201      	adds	r2, #1
 80048ec:	601a      	str	r2, [r3, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 80048ee:	681b      	ldr	r3, [r3, #0]
 80048f0:	2b01      	cmp	r3, #1
 80048f2:	d126      	bne.n	8004942 <xTaskGenericCreate+0xfa>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 80048f4:	4b2e      	ldr	r3, [pc, #184]	; (80049b0 <xTaskGenericCreate+0x168>)
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80048f6:	4a2f      	ldr	r2, [pc, #188]	; (80049b4 <xTaskGenericCreate+0x16c>)
		{
			uxCurrentNumberOfTasks++;
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 80048f8:	601d      	str	r5, [r3, #0]
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80048fa:	2314      	movs	r3, #20
 80048fc:	fb03 2004 	mla	r0, r3, r4, r2

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8004900:	3401      	adds	r4, #1
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8004902:	9201      	str	r2, [sp, #4]
 8004904:	9300      	str	r3, [sp, #0]
 8004906:	f000 fa3b 	bl	8004d80 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800490a:	2c05      	cmp	r4, #5
 800490c:	9a01      	ldr	r2, [sp, #4]
 800490e:	9b00      	ldr	r3, [sp, #0]
 8004910:	d1f4      	bne.n	80048fc <xTaskGenericCreate+0xb4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8004912:	4b29      	ldr	r3, [pc, #164]	; (80049b8 <xTaskGenericCreate+0x170>)
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8004914:	4c29      	ldr	r4, [pc, #164]	; (80049bc <xTaskGenericCreate+0x174>)
	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8004916:	4618      	mov	r0, r3
 8004918:	9300      	str	r3, [sp, #0]
 800491a:	f000 fa31 	bl	8004d80 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 800491e:	4620      	mov	r0, r4
 8004920:	f000 fa2e 	bl	8004d80 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 8004924:	4826      	ldr	r0, [pc, #152]	; (80049c0 <xTaskGenericCreate+0x178>)
 8004926:	f000 fa2b 	bl	8004d80 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 800492a:	4826      	ldr	r0, [pc, #152]	; (80049c4 <xTaskGenericCreate+0x17c>)
 800492c:	f000 fa28 	bl	8004d80 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8004930:	4825      	ldr	r0, [pc, #148]	; (80049c8 <xTaskGenericCreate+0x180>)
 8004932:	f000 fa25 	bl	8004d80 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8004936:	9b00      	ldr	r3, [sp, #0]
 8004938:	4a24      	ldr	r2, [pc, #144]	; (80049cc <xTaskGenericCreate+0x184>)
 800493a:	6013      	str	r3, [r2, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800493c:	4b24      	ldr	r3, [pc, #144]	; (80049d0 <xTaskGenericCreate+0x188>)
 800493e:	601c      	str	r4, [r3, #0]
 8004940:	e008      	b.n	8004954 <xTaskGenericCreate+0x10c>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8004942:	4b24      	ldr	r3, [pc, #144]	; (80049d4 <xTaskGenericCreate+0x18c>)
 8004944:	681b      	ldr	r3, [r3, #0]
 8004946:	b92b      	cbnz	r3, 8004954 <xTaskGenericCreate+0x10c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8004948:	4b19      	ldr	r3, [pc, #100]	; (80049b0 <xTaskGenericCreate+0x168>)
 800494a:	681a      	ldr	r2, [r3, #0]
 800494c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800494e:	42ba      	cmp	r2, r7
					{
						pxCurrentTCB = pxNewTCB;
 8004950:	bf98      	it	ls
 8004952:	601d      	strls	r5, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8004954:	4a20      	ldr	r2, [pc, #128]	; (80049d8 <xTaskGenericCreate+0x190>)
 8004956:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004958:	6811      	ldr	r1, [r2, #0]
 800495a:	428b      	cmp	r3, r1
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 800495c:	bf88      	it	hi
 800495e:	6013      	strhi	r3, [r2, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 8004960:	4a1e      	ldr	r2, [pc, #120]	; (80049dc <xTaskGenericCreate+0x194>)
 8004962:	6811      	ldr	r1, [r2, #0]
 8004964:	3101      	adds	r1, #1
 8004966:	6011      	str	r1, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 8004968:	4a1d      	ldr	r2, [pc, #116]	; (80049e0 <xTaskGenericCreate+0x198>)
 800496a:	6811      	ldr	r1, [r2, #0]
 800496c:	428b      	cmp	r3, r1
 800496e:	bf88      	it	hi
 8004970:	6013      	strhi	r3, [r2, #0]
 8004972:	4a10      	ldr	r2, [pc, #64]	; (80049b4 <xTaskGenericCreate+0x16c>)
 8004974:	2014      	movs	r0, #20
 8004976:	fb00 2003 	mla	r0, r0, r3, r2
 800497a:	4631      	mov	r1, r6
 800497c:	f000 fa0e 	bl	8004d9c <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 8004980:	f000 faa0 	bl	8004ec4 <vPortExitCritical>
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
 8004984:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004986:	b103      	cbz	r3, 800498a <xTaskGenericCreate+0x142>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 8004988:	601d      	str	r5, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
 800498a:	4b12      	ldr	r3, [pc, #72]	; (80049d4 <xTaskGenericCreate+0x18c>)
 800498c:	681b      	ldr	r3, [r3, #0]
 800498e:	b153      	cbz	r3, 80049a6 <xTaskGenericCreate+0x15e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8004990:	4b07      	ldr	r3, [pc, #28]	; (80049b0 <xTaskGenericCreate+0x168>)
 8004992:	681b      	ldr	r3, [r3, #0]
 8004994:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004996:	42bb      	cmp	r3, r7
 8004998:	d205      	bcs.n	80049a6 <xTaskGenericCreate+0x15e>
			{
				portYIELD_WITHIN_API();
 800499a:	f000 fa7f 	bl	8004e9c <vPortYieldFromISR>
 800499e:	e002      	b.n	80049a6 <xTaskGenericCreate+0x15e>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80049a0:	f04f 30ff 	mov.w	r0, #4294967295
 80049a4:	e000      	b.n	80049a8 <xTaskGenericCreate+0x160>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
 80049a6:	2001      	movs	r0, #1
			}
		}
	}

	return xReturn;
}
 80049a8:	b005      	add	sp, #20
 80049aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80049ac:	20000798 	.word	0x20000798
 80049b0:	20000744 	.word	0x20000744
 80049b4:	200006dc 	.word	0x200006dc
 80049b8:	2000076c 	.word	0x2000076c
 80049bc:	20000780 	.word	0x20000780
 80049c0:	20000748 	.word	0x20000748
 80049c4:	200006b4 	.word	0x200006b4
 80049c8:	200006c8 	.word	0x200006c8
 80049cc:	200006a8 	.word	0x200006a8
 80049d0:	20000760 	.word	0x20000760
 80049d4:	200006ac 	.word	0x200006ac
 80049d8:	2000079c 	.word	0x2000079c
 80049dc:	20000768 	.word	0x20000768
 80049e0:	20000764 	.word	0x20000764

080049e4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 80049e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 80049e6:	2400      	movs	r4, #0
 80049e8:	4623      	mov	r3, r4
 80049ea:	480c      	ldr	r0, [pc, #48]	; (8004a1c <vTaskStartScheduler+0x38>)
 80049ec:	490c      	ldr	r1, [pc, #48]	; (8004a20 <vTaskStartScheduler+0x3c>)
 80049ee:	f44f 7280 	mov.w	r2, #256	; 0x100
 80049f2:	9400      	str	r4, [sp, #0]
 80049f4:	9401      	str	r4, [sp, #4]
 80049f6:	9402      	str	r4, [sp, #8]
 80049f8:	9403      	str	r4, [sp, #12]
 80049fa:	f7ff ff25 	bl	8004848 <xTaskGenericCreate>

	if( xReturn == pdPASS )
 80049fe:	2801      	cmp	r0, #1
void vTaskStartScheduler( void )
{
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 8004a00:	4603      	mov	r3, r0

	if( xReturn == pdPASS )
 8004a02:	d109      	bne.n	8004a18 <vTaskStartScheduler+0x34>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8004a04:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004a08:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 8004a0c:	4a05      	ldr	r2, [pc, #20]	; (8004a24 <vTaskStartScheduler+0x40>)
 8004a0e:	6013      	str	r3, [r2, #0]
		xTickCount = ( portTickType ) 0;
 8004a10:	4b05      	ldr	r3, [pc, #20]	; (8004a28 <vTaskStartScheduler+0x44>)
 8004a12:	601c      	str	r4, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 8004a14:	f000 fa22 	bl	8004e5c <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
 8004a18:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8004a1a:	bf00      	nop
 8004a1c:	08004bd9 	.word	0x08004bd9
 8004a20:	0800ac4c 	.word	0x0800ac4c
 8004a24:	200006ac 	.word	0x200006ac
 8004a28:	2000075c 	.word	0x2000075c

08004a2c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8004a2c:	4b02      	ldr	r3, [pc, #8]	; (8004a38 <vTaskSuspendAll+0xc>)
 8004a2e:	681a      	ldr	r2, [r3, #0]
 8004a30:	3201      	adds	r2, #1
 8004a32:	601a      	str	r2, [r3, #0]
}
 8004a34:	4770      	bx	lr
 8004a36:	bf00      	nop
 8004a38:	20000740 	.word	0x20000740

08004a3c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
 8004a3c:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
 8004a3e:	f000 fa35 	bl	8004eac <vPortEnterCritical>
	{
		xTicks = xTickCount;
 8004a42:	4b03      	ldr	r3, [pc, #12]	; (8004a50 <xTaskGetTickCount+0x14>)
 8004a44:	681c      	ldr	r4, [r3, #0]
	}
	portEXIT_CRITICAL();
 8004a46:	f000 fa3d 	bl	8004ec4 <vPortExitCritical>

	return xTicks;
}
 8004a4a:	4620      	mov	r0, r4
 8004a4c:	bd10      	pop	{r4, pc}
 8004a4e:	bf00      	nop
 8004a50:	2000075c 	.word	0x2000075c

08004a54 <vTaskIncrementTick>:
void vTaskIncrementTick( void )
{
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004a54:	4b26      	ldr	r3, [pc, #152]	; (8004af0 <vTaskIncrementTick+0x9c>)
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 8004a56:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004a58:	681b      	ldr	r3, [r3, #0]
 8004a5a:	2b00      	cmp	r3, #0
 8004a5c:	d13c      	bne.n	8004ad8 <vTaskIncrementTick+0x84>
	{
		++xTickCount;
 8004a5e:	4b25      	ldr	r3, [pc, #148]	; (8004af4 <vTaskIncrementTick+0xa0>)
 8004a60:	681a      	ldr	r2, [r3, #0]
 8004a62:	3201      	adds	r2, #1
 8004a64:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
 8004a66:	681b      	ldr	r3, [r3, #0]
 8004a68:	2b00      	cmp	r3, #0
 8004a6a:	d128      	bne.n	8004abe <vTaskIncrementTick+0x6a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004a6c:	4a22      	ldr	r2, [pc, #136]	; (8004af8 <vTaskIncrementTick+0xa4>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004a6e:	4b23      	ldr	r3, [pc, #140]	; (8004afc <vTaskIncrementTick+0xa8>)
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8004a70:	6811      	ldr	r1, [r2, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8004a72:	6818      	ldr	r0, [r3, #0]
 8004a74:	6010      	str	r0, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
 8004a76:	6019      	str	r1, [r3, #0]
			xNumOfOverflows++;
 8004a78:	4b21      	ldr	r3, [pc, #132]	; (8004b00 <vTaskIncrementTick+0xac>)
 8004a7a:	681a      	ldr	r2, [r3, #0]
 8004a7c:	3201      	adds	r2, #1
 8004a7e:	601a      	str	r2, [r3, #0]
 8004a80:	e01d      	b.n	8004abe <vTaskIncrementTick+0x6a>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8004a82:	6839      	ldr	r1, [r7, #0]
 8004a84:	685a      	ldr	r2, [r3, #4]
 8004a86:	4291      	cmp	r1, r2
 8004a88:	d32c      	bcc.n	8004ae4 <vTaskIncrementTick+0x90>
 8004a8a:	1d1a      	adds	r2, r3, #4
 8004a8c:	4610      	mov	r0, r2
 8004a8e:	9201      	str	r2, [sp, #4]
 8004a90:	9300      	str	r3, [sp, #0]
 8004a92:	f000 f9aa 	bl	8004dea <vListRemove>
 8004a96:	9b00      	ldr	r3, [sp, #0]
 8004a98:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004a9a:	b122      	cbz	r2, 8004aa6 <vTaskIncrementTick+0x52>
 8004a9c:	f103 0018 	add.w	r0, r3, #24
 8004aa0:	f000 f9a3 	bl	8004dea <vListRemove>
 8004aa4:	9b00      	ldr	r3, [sp, #0]
 8004aa6:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8004aa8:	6823      	ldr	r3, [r4, #0]
 8004aaa:	9901      	ldr	r1, [sp, #4]
 8004aac:	4298      	cmp	r0, r3
 8004aae:	bf88      	it	hi
 8004ab0:	6020      	strhi	r0, [r4, #0]
 8004ab2:	2314      	movs	r3, #20
 8004ab4:	fb03 6000 	mla	r0, r3, r0, r6
 8004ab8:	f000 f970 	bl	8004d9c <vListInsertEnd>
 8004abc:	e003      	b.n	8004ac6 <vTaskIncrementTick+0x72>
 8004abe:	4d0e      	ldr	r5, [pc, #56]	; (8004af8 <vTaskIncrementTick+0xa4>)
 8004ac0:	4f0c      	ldr	r7, [pc, #48]	; (8004af4 <vTaskIncrementTick+0xa0>)
 8004ac2:	4c10      	ldr	r4, [pc, #64]	; (8004b04 <vTaskIncrementTick+0xb0>)
 8004ac4:	4e10      	ldr	r6, [pc, #64]	; (8004b08 <vTaskIncrementTick+0xb4>)
 8004ac6:	682b      	ldr	r3, [r5, #0]
 8004ac8:	681b      	ldr	r3, [r3, #0]
 8004aca:	b15b      	cbz	r3, 8004ae4 <vTaskIncrementTick+0x90>
 8004acc:	682b      	ldr	r3, [r5, #0]
 8004ace:	68db      	ldr	r3, [r3, #12]
 8004ad0:	68db      	ldr	r3, [r3, #12]
 8004ad2:	2b00      	cmp	r3, #0
 8004ad4:	d1d5      	bne.n	8004a82 <vTaskIncrementTick+0x2e>
 8004ad6:	e005      	b.n	8004ae4 <vTaskIncrementTick+0x90>
	}
	else
	{
		++uxMissedTicks;
 8004ad8:	4b0c      	ldr	r3, [pc, #48]	; (8004b0c <vTaskIncrementTick+0xb8>)
 8004ada:	681a      	ldr	r2, [r3, #0]
 8004adc:	3201      	adds	r2, #1
 8004ade:	601a      	str	r2, [r3, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
 8004ae0:	f7ff fdea 	bl	80046b8 <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
 8004ae4:	4b09      	ldr	r3, [pc, #36]	; (8004b0c <vTaskIncrementTick+0xb8>)
 8004ae6:	681b      	ldr	r3, [r3, #0]
 8004ae8:	b90b      	cbnz	r3, 8004aee <vTaskIncrementTick+0x9a>
		{
			vApplicationTickHook();
 8004aea:	f7ff fde5 	bl	80046b8 <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8004aee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004af0:	20000740 	.word	0x20000740
 8004af4:	2000075c 	.word	0x2000075c
 8004af8:	200006a8 	.word	0x200006a8
 8004afc:	20000760 	.word	0x20000760
 8004b00:	200006a4 	.word	0x200006a4
 8004b04:	20000764 	.word	0x20000764
 8004b08:	200006dc 	.word	0x200006dc
 8004b0c:	200006a0 	.word	0x200006a0

08004b10 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8004b10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
 8004b12:	f000 f9cb 	bl	8004eac <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8004b16:	4b28      	ldr	r3, [pc, #160]	; (8004bb8 <xTaskResumeAll+0xa8>)
 8004b18:	681a      	ldr	r2, [r3, #0]
 8004b1a:	3a01      	subs	r2, #1
 8004b1c:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8004b1e:	681d      	ldr	r5, [r3, #0]
 8004b20:	2d00      	cmp	r5, #0
 8004b22:	d144      	bne.n	8004bae <xTaskResumeAll+0x9e>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 8004b24:	4b25      	ldr	r3, [pc, #148]	; (8004bbc <xTaskResumeAll+0xac>)
 8004b26:	681c      	ldr	r4, [r3, #0]
 8004b28:	2c00      	cmp	r4, #0
 8004b2a:	d041      	beq.n	8004bb0 <xTaskResumeAll+0xa0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8004b2c:	4f24      	ldr	r7, [pc, #144]	; (8004bc0 <xTaskResumeAll+0xb0>)
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
 8004b2e:	4e25      	ldr	r6, [pc, #148]	; (8004bc4 <xTaskResumeAll+0xb4>)
 8004b30:	e01b      	b.n	8004b6a <xTaskResumeAll+0x5a>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
 8004b32:	f104 0018 	add.w	r0, r4, #24
 8004b36:	f000 f958 	bl	8004dea <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 8004b3a:	1d21      	adds	r1, r4, #4
 8004b3c:	4608      	mov	r0, r1
 8004b3e:	9101      	str	r1, [sp, #4]
 8004b40:	f000 f953 	bl	8004dea <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8004b44:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004b46:	6833      	ldr	r3, [r6, #0]
 8004b48:	9901      	ldr	r1, [sp, #4]
 8004b4a:	4298      	cmp	r0, r3
 8004b4c:	4b1e      	ldr	r3, [pc, #120]	; (8004bc8 <xTaskResumeAll+0xb8>)
 8004b4e:	bf88      	it	hi
 8004b50:	6030      	strhi	r0, [r6, #0]
 8004b52:	2214      	movs	r2, #20
 8004b54:	fb02 3000 	mla	r0, r2, r0, r3
 8004b58:	f000 f920 	bl	8004d9c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004b5c:	4a1b      	ldr	r2, [pc, #108]	; (8004bcc <xTaskResumeAll+0xbc>)
 8004b5e:	6813      	ldr	r3, [r2, #0]
 8004b60:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004b62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
 8004b64:	429a      	cmp	r2, r3
 8004b66:	bf28      	it	cs
 8004b68:	2501      	movcs	r5, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8004b6a:	683b      	ldr	r3, [r7, #0]
 8004b6c:	b11b      	cbz	r3, 8004b76 <xTaskResumeAll+0x66>
 8004b6e:	68fb      	ldr	r3, [r7, #12]
 8004b70:	68dc      	ldr	r4, [r3, #12]
 8004b72:	2c00      	cmp	r4, #0
 8004b74:	d1dd      	bne.n	8004b32 <xTaskResumeAll+0x22>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 8004b76:	4c16      	ldr	r4, [pc, #88]	; (8004bd0 <xTaskResumeAll+0xc0>)
 8004b78:	6823      	ldr	r3, [r4, #0]
 8004b7a:	b92b      	cbnz	r3, 8004b88 <xTaskResumeAll+0x78>
 8004b7c:	e008      	b.n	8004b90 <xTaskResumeAll+0x80>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
 8004b7e:	f7ff ff69 	bl	8004a54 <vTaskIncrementTick>
						--uxMissedTicks;
 8004b82:	6823      	ldr	r3, [r4, #0]
 8004b84:	3b01      	subs	r3, #1
 8004b86:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 8004b88:	6823      	ldr	r3, [r4, #0]
 8004b8a:	2b00      	cmp	r3, #0
 8004b8c:	d1f7      	bne.n	8004b7e <xTaskResumeAll+0x6e>
 8004b8e:	e007      	b.n	8004ba0 <xTaskResumeAll+0x90>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8004b90:	2d01      	cmp	r5, #1
 8004b92:	d005      	beq.n	8004ba0 <xTaskResumeAll+0x90>
 8004b94:	4a0f      	ldr	r2, [pc, #60]	; (8004bd4 <xTaskResumeAll+0xc4>)
 8004b96:	6812      	ldr	r2, [r2, #0]
 8004b98:	2a01      	cmp	r2, #1
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8004b9a:	bf18      	it	ne
 8004b9c:	461c      	movne	r4, r3
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8004b9e:	d107      	bne.n	8004bb0 <xTaskResumeAll+0xa0>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 8004ba0:	4b0c      	ldr	r3, [pc, #48]	; (8004bd4 <xTaskResumeAll+0xc4>)
 8004ba2:	2200      	movs	r2, #0
 8004ba4:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8004ba6:	f000 f979 	bl	8004e9c <vPortYieldFromISR>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 8004baa:	2401      	movs	r4, #1
 8004bac:	e000      	b.n	8004bb0 <xTaskResumeAll+0xa0>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8004bae:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
 8004bb0:	f000 f988 	bl	8004ec4 <vPortExitCritical>

	return xAlreadyYielded;
}
 8004bb4:	4620      	mov	r0, r4
 8004bb6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004bb8:	20000740 	.word	0x20000740
 8004bbc:	20000798 	.word	0x20000798
 8004bc0:	20000748 	.word	0x20000748
 8004bc4:	20000764 	.word	0x20000764
 8004bc8:	200006dc 	.word	0x200006dc
 8004bcc:	20000744 	.word	0x20000744
 8004bd0:	200006a0 	.word	0x200006a0
 8004bd4:	20000794 	.word	0x20000794

08004bd8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8004bd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8004bda:	4e15      	ldr	r6, [pc, #84]	; (8004c30 <prvIdleTask+0x58>)
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004bdc:	4d15      	ldr	r5, [pc, #84]	; (8004c34 <prvIdleTask+0x5c>)

				portENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
 8004bde:	4f16      	ldr	r7, [pc, #88]	; (8004c38 <prvIdleTask+0x60>)
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8004be0:	6833      	ldr	r3, [r6, #0]
 8004be2:	b1e3      	cbz	r3, 8004c1e <prvIdleTask+0x46>
		{
			vTaskSuspendAll();
 8004be4:	f7ff ff22 	bl	8004a2c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004be8:	682c      	ldr	r4, [r5, #0]
			xTaskResumeAll();
 8004bea:	f7ff ff91 	bl	8004b10 <xTaskResumeAll>

			if( !xListIsEmpty )
 8004bee:	b1b4      	cbz	r4, 8004c1e <prvIdleTask+0x46>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
 8004bf0:	f000 f95c 	bl	8004eac <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8004bf4:	682c      	ldr	r4, [r5, #0]
 8004bf6:	b10c      	cbz	r4, 8004bfc <prvIdleTask+0x24>
 8004bf8:	68eb      	ldr	r3, [r5, #12]
 8004bfa:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8004bfc:	1d20      	adds	r0, r4, #4
 8004bfe:	f000 f8f4 	bl	8004dea <vListRemove>
					--uxCurrentNumberOfTasks;
 8004c02:	683b      	ldr	r3, [r7, #0]
 8004c04:	3b01      	subs	r3, #1
 8004c06:	603b      	str	r3, [r7, #0]
					--uxTasksDeleted;
 8004c08:	6833      	ldr	r3, [r6, #0]
 8004c0a:	3b01      	subs	r3, #1
 8004c0c:	6033      	str	r3, [r6, #0]
				}
				portEXIT_CRITICAL();
 8004c0e:	f000 f959 	bl	8004ec4 <vPortExitCritical>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8004c12:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004c14:	f000 f9ea 	bl	8004fec <vPortFree>
		vPortFree( pxTCB );
 8004c18:	4620      	mov	r0, r4
 8004c1a:	f000 f9e7 	bl	8004fec <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8004c1e:	4a07      	ldr	r2, [pc, #28]	; (8004c3c <prvIdleTask+0x64>)
 8004c20:	6813      	ldr	r3, [r2, #0]
 8004c22:	2b01      	cmp	r3, #1
 8004c24:	d901      	bls.n	8004c2a <prvIdleTask+0x52>
			{
				taskYIELD();
 8004c26:	f000 f939 	bl	8004e9c <vPortYieldFromISR>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8004c2a:	f7ff fd46 	bl	80046ba <vApplicationIdleHook>
		}
		#endif
	}
 8004c2e:	e7d7      	b.n	8004be0 <prvIdleTask+0x8>
 8004c30:	200006b0 	.word	0x200006b0
 8004c34:	200006b4 	.word	0x200006b4
 8004c38:	20000798 	.word	0x20000798
 8004c3c:	200006dc 	.word	0x200006dc

08004c40 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8004c40:	b570      	push	{r4, r5, r6, lr}
 8004c42:	4604      	mov	r4, r0
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
 8004c44:	b1c0      	cbz	r0, 8004c78 <vTaskDelay+0x38>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8004c46:	4e0e      	ldr	r6, [pc, #56]	; (8004c80 <vTaskDelay+0x40>)
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
 8004c48:	f7ff fef0 	bl	8004a2c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8004c4c:	6835      	ldr	r5, [r6, #0]
 8004c4e:	1965      	adds	r5, r4, r5

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004c50:	4c0c      	ldr	r4, [pc, #48]	; (8004c84 <vTaskDelay+0x44>)
 8004c52:	6820      	ldr	r0, [r4, #0]
 8004c54:	3004      	adds	r0, #4
 8004c56:	f000 f8c8 	bl	8004dea <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8004c5a:	6823      	ldr	r3, [r4, #0]
 8004c5c:	605d      	str	r5, [r3, #4]

				if( xTimeToWake < xTickCount )
 8004c5e:	6833      	ldr	r3, [r6, #0]
 8004c60:	429d      	cmp	r5, r3
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004c62:	bf34      	ite	cc
 8004c64:	4b08      	ldrcc	r3, [pc, #32]	; (8004c88 <vTaskDelay+0x48>)
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004c66:	4b09      	ldrcs	r3, [pc, #36]	; (8004c8c <vTaskDelay+0x4c>)
 8004c68:	6818      	ldr	r0, [r3, #0]
 8004c6a:	6821      	ldr	r1, [r4, #0]
 8004c6c:	3104      	adds	r1, #4
 8004c6e:	f000 f8a2 	bl	8004db6 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
 8004c72:	f7ff ff4d 	bl	8004b10 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 8004c76:	b908      	cbnz	r0, 8004c7c <vTaskDelay+0x3c>
		{
			portYIELD_WITHIN_API();
 8004c78:	f000 f910 	bl	8004e9c <vPortYieldFromISR>
		}
	}
 8004c7c:	bd70      	pop	{r4, r5, r6, pc}
 8004c7e:	bf00      	nop
 8004c80:	2000075c 	.word	0x2000075c
 8004c84:	20000744 	.word	0x20000744
 8004c88:	20000760 	.word	0x20000760
 8004c8c:	200006a8 	.word	0x200006a8

08004c90 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8004c90:	b538      	push	{r3, r4, r5, lr}
 8004c92:	460c      	mov	r4, r1
 8004c94:	4605      	mov	r5, r0
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
 8004c96:	f7ff fec9 	bl	8004a2c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
 8004c9a:	4a17      	ldr	r2, [pc, #92]	; (8004cf8 <vTaskDelayUntil+0x68>)
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004c9c:	682b      	ldr	r3, [r5, #0]

			if( xTickCount < *pxPreviousWakeTime )
 8004c9e:	6811      	ldr	r1, [r2, #0]
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004ca0:	18e4      	adds	r4, r4, r3

			if( xTickCount < *pxPreviousWakeTime )
 8004ca2:	4299      	cmp	r1, r3
 8004ca4:	d202      	bcs.n	8004cac <vTaskDelayUntil+0x1c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 8004ca6:	429c      	cmp	r4, r3
 8004ca8:	d208      	bcs.n	8004cbc <vTaskDelayUntil+0x2c>
 8004caa:	e001      	b.n	8004cb0 <vTaskDelayUntil+0x20>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 8004cac:	429c      	cmp	r4, r3
 8004cae:	d307      	bcc.n	8004cc0 <vTaskDelayUntil+0x30>
 8004cb0:	6813      	ldr	r3, [r2, #0]
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8004cb2:	429c      	cmp	r4, r3
 8004cb4:	bf94      	ite	ls
 8004cb6:	2300      	movls	r3, #0
 8004cb8:	2301      	movhi	r3, #1
 8004cba:	e002      	b.n	8004cc2 <vTaskDelayUntil+0x32>
 8004cbc:	2300      	movs	r3, #0
 8004cbe:	e000      	b.n	8004cc2 <vTaskDelayUntil+0x32>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
 8004cc0:	2301      	movs	r3, #1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8004cc2:	602c      	str	r4, [r5, #0]

			if( xShouldDelay )
 8004cc4:	b18b      	cbz	r3, 8004cea <vTaskDelayUntil+0x5a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004cc6:	4d0d      	ldr	r5, [pc, #52]	; (8004cfc <vTaskDelayUntil+0x6c>)
 8004cc8:	6828      	ldr	r0, [r5, #0]
 8004cca:	3004      	adds	r0, #4
 8004ccc:	f000 f88d 	bl	8004dea <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8004cd0:	682b      	ldr	r3, [r5, #0]
 8004cd2:	605c      	str	r4, [r3, #4]

				if( xTimeToWake < xTickCount )
 8004cd4:	4b08      	ldr	r3, [pc, #32]	; (8004cf8 <vTaskDelayUntil+0x68>)
 8004cd6:	681b      	ldr	r3, [r3, #0]
 8004cd8:	429c      	cmp	r4, r3
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004cda:	bf34      	ite	cc
 8004cdc:	4b08      	ldrcc	r3, [pc, #32]	; (8004d00 <vTaskDelayUntil+0x70>)
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8004cde:	4b09      	ldrcs	r3, [pc, #36]	; (8004d04 <vTaskDelayUntil+0x74>)
 8004ce0:	6818      	ldr	r0, [r3, #0]
 8004ce2:	6829      	ldr	r1, [r5, #0]
 8004ce4:	3104      	adds	r1, #4
 8004ce6:	f000 f866 	bl	8004db6 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8004cea:	f7ff ff11 	bl	8004b10 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 8004cee:	b908      	cbnz	r0, 8004cf4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
 8004cf0:	f000 f8d4 	bl	8004e9c <vPortYieldFromISR>
		}
	}
 8004cf4:	bd38      	pop	{r3, r4, r5, pc}
 8004cf6:	bf00      	nop
 8004cf8:	2000075c 	.word	0x2000075c
 8004cfc:	20000744 	.word	0x20000744
 8004d00:	20000760 	.word	0x20000760
 8004d04:	200006a8 	.word	0x200006a8

08004d08 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8004d08:	4b18      	ldr	r3, [pc, #96]	; (8004d6c <vTaskSwitchContext+0x64>)

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8004d0a:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8004d0c:	681b      	ldr	r3, [r3, #0]
 8004d0e:	b133      	cbz	r3, 8004d1e <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8004d10:	2201      	movs	r2, #1
 8004d12:	4b17      	ldr	r3, [pc, #92]	; (8004d70 <vTaskSwitchContext+0x68>)
 8004d14:	e028      	b.n	8004d68 <vTaskSwitchContext+0x60>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
 8004d16:	6818      	ldr	r0, [r3, #0]
 8004d18:	3801      	subs	r0, #1
 8004d1a:	6018      	str	r0, [r3, #0]
 8004d1c:	e002      	b.n	8004d24 <vTaskSwitchContext+0x1c>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8004d1e:	4b15      	ldr	r3, [pc, #84]	; (8004d74 <vTaskSwitchContext+0x6c>)
 8004d20:	4915      	ldr	r1, [pc, #84]	; (8004d78 <vTaskSwitchContext+0x70>)
 8004d22:	2214      	movs	r2, #20
 8004d24:	f8d3 c000 	ldr.w	ip, [r3]
 8004d28:	4813      	ldr	r0, [pc, #76]	; (8004d78 <vTaskSwitchContext+0x70>)
 8004d2a:	fb02 fc0c 	mul.w	ip, r2, ip
 8004d2e:	f851 400c 	ldr.w	r4, [r1, ip]
 8004d32:	2c00      	cmp	r4, #0
 8004d34:	d0ef      	beq.n	8004d16 <vTaskSwitchContext+0xe>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8004d36:	4b0f      	ldr	r3, [pc, #60]	; (8004d74 <vTaskSwitchContext+0x6c>)
 8004d38:	f04f 0c14 	mov.w	ip, #20
 8004d3c:	6819      	ldr	r1, [r3, #0]
 8004d3e:	fb0c fc01 	mul.w	ip, ip, r1
 8004d42:	eb00 030c 	add.w	r3, r0, ip
 8004d46:	685a      	ldr	r2, [r3, #4]
 8004d48:	f10c 0c08 	add.w	ip, ip, #8
 8004d4c:	6852      	ldr	r2, [r2, #4]
 8004d4e:	4460      	add	r0, ip
 8004d50:	4282      	cmp	r2, r0
 8004d52:	605a      	str	r2, [r3, #4]
 8004d54:	bf04      	itt	eq
 8004d56:	6852      	ldreq	r2, [r2, #4]
 8004d58:	605a      	streq	r2, [r3, #4]
 8004d5a:	4b07      	ldr	r3, [pc, #28]	; (8004d78 <vTaskSwitchContext+0x70>)
 8004d5c:	2214      	movs	r2, #20
 8004d5e:	fb02 3101 	mla	r1, r2, r1, r3
 8004d62:	684b      	ldr	r3, [r1, #4]
 8004d64:	68da      	ldr	r2, [r3, #12]
 8004d66:	4b05      	ldr	r3, [pc, #20]	; (8004d7c <vTaskSwitchContext+0x74>)
 8004d68:	601a      	str	r2, [r3, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
 8004d6a:	bd10      	pop	{r4, pc}
 8004d6c:	20000740 	.word	0x20000740
 8004d70:	20000794 	.word	0x20000794
 8004d74:	20000764 	.word	0x20000764
 8004d78:	200006dc 	.word	0x200006dc
 8004d7c:	20000744 	.word	0x20000744

08004d80 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004d80:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004d84:	f04f 32ff 	mov.w	r2, #4294967295
 8004d88:	6082      	str	r2, [r0, #8]
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8004d8a:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8004d8c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8004d8e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = 0;
 8004d90:	2300      	movs	r3, #0
 8004d92:	6003      	str	r3, [r0, #0]
}
 8004d94:	4770      	bx	lr

08004d96 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8004d96:	2300      	movs	r3, #0
 8004d98:	6103      	str	r3, [r0, #16]
}
 8004d9a:	4770      	bx	lr

08004d9c <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8004d9c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004d9e:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8004da0:	608b      	str	r3, [r1, #8]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex->pxNext;
 8004da2:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004da4:	685a      	ldr	r2, [r3, #4]
 8004da6:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004da8:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004daa:	6803      	ldr	r3, [r0, #0]

	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8004dac:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004dae:	3301      	adds	r3, #1
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004db0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8004db2:	6003      	str	r3, [r0, #0]
}
 8004db4:	4770      	bx	lr

08004db6 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8004db6:	680a      	ldr	r2, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004db8:	f1b2 3fff 	cmp.w	r2, #4294967295
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8004dbc:	bf0c      	ite	eq
 8004dbe:	6903      	ldreq	r3, [r0, #16]
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004dc0:	f100 0308 	addne.w	r3, r0, #8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004dc4:	d101      	bne.n	8004dca <vListInsert+0x14>
 8004dc6:	e006      	b.n	8004dd6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8004dc8:	685b      	ldr	r3, [r3, #4]
 8004dca:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8004dce:	f8dc c000 	ldr.w	ip, [ip]
 8004dd2:	4594      	cmp	ip, r2
 8004dd4:	d9f8      	bls.n	8004dc8 <vListInsert+0x12>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004dd6:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004dd8:	6108      	str	r0, [r1, #16]
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8004dda:	6091      	str	r1, [r2, #8]
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004ddc:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8004dde:	6059      	str	r1, [r3, #4]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8004de0:	608b      	str	r3, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004de2:	6803      	ldr	r3, [r0, #0]
 8004de4:	3301      	adds	r3, #1
 8004de6:	6003      	str	r3, [r0, #0]
}
 8004de8:	4770      	bx	lr

08004dea <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004dea:	6843      	ldr	r3, [r0, #4]
 8004dec:	6882      	ldr	r2, [r0, #8]
 8004dee:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8004df0:	6882      	ldr	r2, [r0, #8]
 8004df2:	6053      	str	r3, [r2, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8004df4:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8004df6:	6859      	ldr	r1, [r3, #4]
 8004df8:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8004dfa:	bf08      	it	eq
 8004dfc:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8004dfe:	2200      	movs	r2, #0
 8004e00:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8004e02:	681a      	ldr	r2, [r3, #0]
 8004e04:	3a01      	subs	r2, #1
 8004e06:	601a      	str	r2, [r3, #0]
}
 8004e08:	4770      	bx	lr

08004e0a <pxPortInitialiseStack>:
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8004e0a:	1f03      	subs	r3, r0, #4
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8004e0c:	f04f 7c80 	mov.w	ip, #16777216	; 0x1000000
 8004e10:	f840 cc04 	str.w	ip, [r0, #-4]
	pxTopOfStack--;
 8004e14:	1f18      	subs	r0, r3, #4
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8004e16:	f843 1c04 	str.w	r1, [r3, #-4]
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
 8004e1a:	2100      	movs	r1, #0
 8004e1c:	f840 1c04 	str.w	r1, [r0, #-4]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8004e20:	f840 2c18 	str.w	r2, [r0, #-24]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8004e24:	f1a3 003c 	sub.w	r0, r3, #60	; 0x3c

	return pxTopOfStack;
}
 8004e28:	4770      	bx	lr
	...

08004e2c <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8004e2c:	4b06      	ldr	r3, [pc, #24]	; (8004e48 <pxCurrentTCBConst2>)
 8004e2e:	6819      	ldr	r1, [r3, #0]
 8004e30:	6808      	ldr	r0, [r1, #0]
 8004e32:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004e36:	f380 8809 	msr	PSP, r0
 8004e3a:	f04f 0000 	mov.w	r0, #0
 8004e3e:	f380 8811 	msr	BASEPRI, r0
 8004e42:	f04e 0e0d 	orr.w	lr, lr, #13
 8004e46:	4770      	bx	lr

08004e48 <pxCurrentTCBConst2>:
 8004e48:	20000744 	.word	0x20000744

08004e4c <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8004e4c:	4802      	ldr	r0, [pc, #8]	; (8004e58 <vPortStartFirstTask+0xc>)
 8004e4e:	6800      	ldr	r0, [r0, #0]
 8004e50:	6800      	ldr	r0, [r0, #0]
 8004e52:	f380 8808 	msr	MSP, r0
 8004e56:	df00      	svc	0
 8004e58:	e000ed08 	.word	0xe000ed08

08004e5c <xPortStartScheduler>:
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004e5c:	4b0b      	ldr	r3, [pc, #44]	; (8004e8c <xPortStartScheduler+0x30>)

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8004e5e:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004e60:	681a      	ldr	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004e62:	2400      	movs	r4, #0
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8004e64:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8004e68:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8004e6a:	681a      	ldr	r2, [r3, #0]
 8004e6c:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8004e70:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004e72:	4a07      	ldr	r2, [pc, #28]	; (8004e90 <xPortStartScheduler+0x34>)
 8004e74:	4b07      	ldr	r3, [pc, #28]	; (8004e94 <xPortStartScheduler+0x38>)
 8004e76:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8004e78:	2207      	movs	r2, #7
 8004e7a:	3b04      	subs	r3, #4
 8004e7c:	601a      	str	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004e7e:	4b06      	ldr	r3, [pc, #24]	; (8004e98 <xPortStartScheduler+0x3c>)
 8004e80:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8004e82:	f7ff ffe3 	bl	8004e4c <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 8004e86:	4620      	mov	r0, r4
 8004e88:	bd10      	pop	{r4, pc}
 8004e8a:	bf00      	nop
 8004e8c:	e000ed20 	.word	0xe000ed20
 8004e90:	0001193f 	.word	0x0001193f
 8004e94:	e000e014 	.word	0xe000e014
 8004e98:	20000000 	.word	0x20000000

08004e9c <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004e9c:	4b02      	ldr	r3, [pc, #8]	; (8004ea8 <vPortYieldFromISR+0xc>)
 8004e9e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004ea2:	601a      	str	r2, [r3, #0]
}
 8004ea4:	4770      	bx	lr
 8004ea6:	bf00      	nop
 8004ea8:	e000ed04 	.word	0xe000ed04

08004eac <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
 8004eac:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004eb0:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8004eb4:	4b02      	ldr	r3, [pc, #8]	; (8004ec0 <vPortEnterCritical+0x14>)
 8004eb6:	681a      	ldr	r2, [r3, #0]
 8004eb8:	3201      	adds	r2, #1
 8004eba:	601a      	str	r2, [r3, #0]
}
 8004ebc:	4770      	bx	lr
 8004ebe:	bf00      	nop
 8004ec0:	20000000 	.word	0x20000000

08004ec4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 8004ec4:	4a04      	ldr	r2, [pc, #16]	; (8004ed8 <vPortExitCritical+0x14>)
 8004ec6:	6813      	ldr	r3, [r2, #0]
 8004ec8:	3b01      	subs	r3, #1
 8004eca:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004ecc:	b91b      	cbnz	r3, 8004ed6 <vPortExitCritical+0x12>
	{
		portENABLE_INTERRUPTS();
 8004ece:	f04f 0000 	mov.w	r0, #0
 8004ed2:	f380 8811 	msr	BASEPRI, r0
	}
}
 8004ed6:	4770      	bx	lr
 8004ed8:	20000000 	.word	0x20000000

08004edc <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8004edc:	f3ef 8009 	mrs	r0, PSP
 8004ee0:	4b0c      	ldr	r3, [pc, #48]	; (8004f14 <pxCurrentTCBConst>)
 8004ee2:	681a      	ldr	r2, [r3, #0]
 8004ee4:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004ee8:	6010      	str	r0, [r2, #0]
 8004eea:	e92d 4008 	stmdb	sp!, {r3, lr}
 8004eee:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004ef2:	f380 8811 	msr	BASEPRI, r0
 8004ef6:	f7ff ff07 	bl	8004d08 <vTaskSwitchContext>
 8004efa:	f04f 0000 	mov.w	r0, #0
 8004efe:	f380 8811 	msr	BASEPRI, r0
 8004f02:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8004f06:	6819      	ldr	r1, [r3, #0]
 8004f08:	6808      	ldr	r0, [r1, #0]
 8004f0a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004f0e:	f380 8809 	msr	PSP, r0
 8004f12:	4770      	bx	lr

08004f14 <pxCurrentTCBConst>:
 8004f14:	20000744 	.word	0x20000744

08004f18 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8004f18:	b508      	push	{r3, lr}
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8004f1a:	4b07      	ldr	r3, [pc, #28]	; (8004f38 <xPortSysTickHandler+0x20>)
 8004f1c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004f20:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8004f22:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8004f26:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8004f2a:	f7ff fd93 	bl	8004a54 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8004f2e:	f04f 0000 	mov.w	r0, #0
 8004f32:	f380 8811 	msr	BASEPRI, r0
}
 8004f36:	bd08      	pop	{r3, pc}
 8004f38:	e000ed04 	.word	0xe000ed04

08004f3c <umm_make_new_block>:

// ----------------------------------------------------------------------------

static void umm_make_new_block( unsigned short int c,
                                unsigned short int blocks,
                                unsigned short int freemask ) {
 8004f3c:	b5f0      	push	{r4, r5, r6, r7, lr}

     UMM_NBLOCK(c+blocks) = UMM_NBLOCK(c) & UMM_BLOCKNO_MASK;
 8004f3e:	240c      	movs	r4, #12
 8004f40:	fb04 fc00 	mul.w	ip, r4, r0
 8004f44:	1809      	adds	r1, r1, r0
 8004f46:	4b0b      	ldr	r3, [pc, #44]	; (8004f74 <umm_make_new_block+0x38>)
 8004f48:	fb04 f501 	mul.w	r5, r4, r1
 8004f4c:	f833 600c 	ldrh.w	r6, [r3, ip]
 8004f50:	195f      	adds	r7, r3, r5
 8004f52:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
 8004f56:	535e      	strh	r6, [r3, r5]
     UMM_PBLOCK(c+blocks) = c;
 8004f58:	8078      	strh	r0, [r7, #2]

     UMM_PBLOCK(UMM_NBLOCK(c) & UMM_BLOCKNO_MASK) = (c+blocks);
 8004f5a:	f833 000c 	ldrh.w	r0, [r3, ip]
 8004f5e:	b289      	uxth	r1, r1
 8004f60:	0440      	lsls	r0, r0, #17
 8004f62:	0c40      	lsrs	r0, r0, #17
 8004f64:	fb04 3400 	mla	r4, r4, r0, r3
 8004f68:	8061      	strh	r1, [r4, #2]
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
 8004f6a:	ea42 0101 	orr.w	r1, r2, r1
 8004f6e:	f823 100c 	strh.w	r1, [r3, ip]
}
 8004f72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004f74:	20000c34 	.word	0x20000c34

08004f78 <umm_disconnect_from_free_list>:
// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 8004f78:	210c      	movs	r1, #12
     UMM_NBLOCK(c)                                = (c+blocks) | freemask;
}

// ----------------------------------------------------------------------------

static void umm_disconnect_from_free_list( unsigned short int c ) {
 8004f7a:	b510      	push	{r4, lr}
    // Disconnect this block from the FREE list

    UMM_NFREE(UMM_PFREE(c)) = UMM_NFREE(c);
 8004f7c:	4348      	muls	r0, r1
 8004f7e:	4b0a      	ldr	r3, [pc, #40]	; (8004fa8 <umm_disconnect_from_free_list+0x30>)
 8004f80:	181a      	adds	r2, r3, r0
 8004f82:	f8b2 c006 	ldrh.w	ip, [r2, #6]
 8004f86:	8894      	ldrh	r4, [r2, #4]
 8004f88:	fb01 3c0c 	mla	ip, r1, ip, r3
 8004f8c:	f8ac 4004 	strh.w	r4, [ip, #4]
    UMM_PFREE(UMM_NFREE(c)) = UMM_PFREE(c);
 8004f90:	f8b2 c004 	ldrh.w	ip, [r2, #4]
 8004f94:	88d2      	ldrh	r2, [r2, #6]
 8004f96:	fb01 310c 	mla	r1, r1, ip, r3
 8004f9a:	80ca      	strh	r2, [r1, #6]

    // And clear the free block indicator

    UMM_NBLOCK(c) &= (~UMM_FREELIST_MASK);
 8004f9c:	5a1a      	ldrh	r2, [r3, r0]
 8004f9e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004fa2:	521a      	strh	r2, [r3, r0]
}
 8004fa4:	bd10      	pop	{r4, pc}
 8004fa6:	bf00      	nop
 8004fa8:	20000c34 	.word	0x20000c34

08004fac <umm_assimilate_up>:

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 8004fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 8004fae:	250c      	movs	r5, #12
 8004fb0:	fb05 f600 	mul.w	r6, r5, r0
 8004fb4:	4c0c      	ldr	r4, [pc, #48]	; (8004fe8 <umm_assimilate_up+0x3c>)

// ----------------------------------------------------------------------------

// static int foo = 0;

static void umm_assimilate_up( unsigned short int c ) {
 8004fb6:	4607      	mov	r7, r0

  if( UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_FREELIST_MASK ) {
 8004fb8:	5ba0      	ldrh	r0, [r4, r6]
 8004fba:	fb05 f300 	mul.w	r3, r5, r0
 8004fbe:	5ee3      	ldrsh	r3, [r4, r3]
 8004fc0:	2b00      	cmp	r3, #0
 8004fc2:	da0f      	bge.n	8004fe4 <umm_assimilate_up+0x38>

    DBG_LOG_DEBUG( "Assimilate up to next block, which is FREE\n" );

    // Disconnect the next block from the FREE list

    umm_disconnect_from_free_list( UMM_NBLOCK(c) );
 8004fc4:	f7ff ffd8 	bl	8004f78 <umm_disconnect_from_free_list>

    // Assimilate the next block with this one

    UMM_PBLOCK(UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK) = c;
 8004fc8:	5ba3      	ldrh	r3, [r4, r6]
 8004fca:	436b      	muls	r3, r5
 8004fcc:	5ae3      	ldrh	r3, [r4, r3]
 8004fce:	045b      	lsls	r3, r3, #17
 8004fd0:	0c5b      	lsrs	r3, r3, #17
 8004fd2:	fb05 4303 	mla	r3, r5, r3, r4
 8004fd6:	805f      	strh	r7, [r3, #2]
    UMM_NBLOCK(c) = UMM_NBLOCK(UMM_NBLOCK(c)) & UMM_BLOCKNO_MASK;
 8004fd8:	5ba3      	ldrh	r3, [r4, r6]
 8004fda:	435d      	muls	r5, r3
 8004fdc:	5b63      	ldrh	r3, [r4, r5]
 8004fde:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8004fe2:	53a3      	strh	r3, [r4, r6]
  } 
}
 8004fe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004fe6:	bf00      	nop
 8004fe8:	20000c34 	.word	0x20000c34

08004fec <vPortFree>:
    return( UMM_PBLOCK(c) );
}

// ----------------------------------------------------------------------------

void umm_free( void *ptr ) {
 8004fec:	b570      	push	{r4, r5, r6, lr}
 8004fee:	4606      	mov	r6, r0

  unsigned short int c;

  // If we're being asked to free a NULL pointer, well that's just silly!

  if( (void *)0 == ptr ) {
 8004ff0:	2800      	cmp	r0, #0
 8004ff2:	d02e      	beq.n	8005052 <vPortFree+0x66>
  //
  UMM_CRITICAL_ENTRY();

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 8004ff4:	4c17      	ldr	r4, [pc, #92]	; (8005054 <vPortFree+0x68>)
 8004ff6:	250c      	movs	r5, #12
 8004ff8:	1b36      	subs	r6, r6, r4
  // NOTE:  See the new umm_info() function that you can use to see if a ptr is
  //        on the free list!

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 8004ffa:	f7ff fd17 	bl	8004a2c <vTaskSuspendAll>

  // Figure out which block we're in. Note the use of truncated division...

  c = (ptr-(void *)(&(umm_heap[0])))/sizeof(umm_block);
 8004ffe:	fbb6 f6f5 	udiv	r6, r6, r5
 8005002:	b2b6      	uxth	r6, r6

  DBG_LOG_DEBUG( "Freeing block %6d\n", c );

  // Now let's assimilate this block with the next one if possible.

  umm_assimilate_up( c );
 8005004:	4630      	mov	r0, r6
 8005006:	f7ff ffd1 	bl	8004fac <umm_assimilate_up>

  // Then assimilate with the previous block if possible

  if( UMM_NBLOCK(UMM_PBLOCK(c)) & UMM_FREELIST_MASK ) {
 800500a:	fb05 f306 	mul.w	r3, r5, r6
 800500e:	18e2      	adds	r2, r4, r3
 8005010:	8850      	ldrh	r0, [r2, #2]
 8005012:	4368      	muls	r0, r5
 8005014:	5e21      	ldrsh	r1, [r4, r0]
 8005016:	2900      	cmp	r1, #0
 8005018:	da0b      	bge.n	8005032 <vPortFree+0x46>

// ----------------------------------------------------------------------------

static unsigned short int umm_assimilate_down( unsigned short int c, unsigned short int freemask ) {

    UMM_NBLOCK(UMM_PBLOCK(c)) = UMM_NBLOCK(c) | freemask;
 800501a:	5ae1      	ldrh	r1, [r4, r3]
 800501c:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 8005020:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 8005024:	5221      	strh	r1, [r4, r0]
    UMM_PBLOCK(UMM_NBLOCK(c)) = UMM_PBLOCK(c);
 8005026:	5ae3      	ldrh	r3, [r4, r3]
 8005028:	8852      	ldrh	r2, [r2, #2]
 800502a:	fb05 4403 	mla	r4, r5, r3, r4
 800502e:	8062      	strh	r2, [r4, #2]
 8005030:	e00d      	b.n	800504e <vPortFree+0x62>
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 8005032:	88a1      	ldrh	r1, [r4, #4]
 8005034:	fb05 4501 	mla	r5, r5, r1, r4
    UMM_NFREE(c)            = UMM_NFREE(0);
 8005038:	8091      	strh	r1, [r2, #4]
    UMM_PFREE(c)            = 0;
 800503a:	2100      	movs	r1, #0
    // The previous block is not a free block, so add this one to the head
    // of the free list

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
 800503c:	80ee      	strh	r6, [r5, #6]
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
    UMM_NFREE(0)            = c;
 800503e:	80a6      	strh	r6, [r4, #4]

    DBG_LOG_DEBUG( "Just add to head of free list\n" );

    UMM_PFREE(UMM_NFREE(0)) = c;
    UMM_NFREE(c)            = UMM_NFREE(0);
    UMM_PFREE(c)            = 0;
 8005040:	80d1      	strh	r1, [r2, #6]
    UMM_NFREE(0)            = c;

    UMM_NBLOCK(c)          |= UMM_FREELIST_MASK;
 8005042:	5ae2      	ldrh	r2, [r4, r3]
 8005044:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8005048:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 800504c:	52e2      	strh	r2, [r4, r3]
  }
#endif

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 800504e:	f7ff fd5f 	bl	8004b10 <xTaskResumeAll>
}
 8005052:	bd70      	pop	{r4, r5, r6, pc}
 8005054:	20000c34 	.word	0x20000c34

08005058 <pvPortMalloc>:

// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {
 8005058:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800505a:	4606      	mov	r6, r0
  // the very first thing we do is figure out if we're being asked to allocate
  // a size of 0 - and if we are we'll simply return a null pointer. if not
  // then reduce the size by 1 byte so that the subsequent calculations on
  // the number of blocks to allocate are easier...

  if( 0 == size ) {
 800505c:	2800      	cmp	r0, #0
 800505e:	d07f      	beq.n	8005160 <pvPortMalloc+0x108>
    return( (void *)NULL );
  }

  // Protect the critical section...
  //
  UMM_CRITICAL_ENTRY();
 8005060:	f7ff fce4 	bl	8004a2c <vTaskSuspendAll>
  //
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
 8005064:	2e08      	cmp	r6, #8
 8005066:	d907      	bls.n	8005078 <pvPortMalloc+0x20>
    return( 1 );

  // If it's for more than that, then we need to figure out the number of
  // additional whole blocks the size of an umm_block are required.

  size -= ( 1 + (sizeof(((umm_block *)0)->body)) );
 8005068:	f1a6 0109 	sub.w	r1, r6, #9

  return( 2 + size/(sizeof(umm_block)) );
 800506c:	230c      	movs	r3, #12
 800506e:	fbb1 f1f3 	udiv	r1, r1, r3
 8005072:	3102      	adds	r1, #2
 8005074:	b289      	uxth	r1, r1
 8005076:	e000      	b.n	800507a <pvPortMalloc+0x22>
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((umm_block *)0)->body)) )
    return( 1 );
 8005078:	2101      	movs	r1, #1
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 800507a:	483a      	ldr	r0, [pc, #232]	; (8005164 <pvPortMalloc+0x10c>)

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;
 800507c:	f647 73ff 	movw	r3, #32767	; 0x7fff
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);
 8005080:	8884      	ldrh	r4, [r0, #4]
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 8005082:	2500      	movs	r5, #0
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
 8005084:	4622      	mov	r2, r4
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 8005086:	f04f 0e0c 	mov.w	lr, #12
 800508a:	e018      	b.n	80050be <pvPortMalloc+0x66>
    blockSize = (UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK) - cf;
 800508c:	f830 500c 	ldrh.w	r5, [r0, ip]
 8005090:	046d      	lsls	r5, r5, #17
 8005092:	ebc4 4555 	rsb	r5, r4, r5, lsr #17
 8005096:	b2ad      	uxth	r5, r5
#if defined UMM_FIRST_FIT
    // This is the first block that fits!
    if( (blockSize >= blocks) )
        break;
#elif defined UMM_BEST_FIT
    if( (blockSize >= blocks) && (blockSize < bestSize) ) {
 8005098:	428d      	cmp	r5, r1
 800509a:	bf34      	ite	cc
 800509c:	f04f 0c00 	movcc.w	ip, #0
 80050a0:	f04f 0c01 	movcs.w	ip, #1
 80050a4:	429d      	cmp	r5, r3
 80050a6:	bf2c      	ite	cs
 80050a8:	f04f 0c00 	movcs.w	ip, #0
 80050ac:	f00c 0c01 	andcc.w	ip, ip, #1
 80050b0:	f1bc 0f00 	cmp.w	ip, #0
 80050b4:	bf18      	it	ne
 80050b6:	4622      	movne	r2, r4
 80050b8:	bf18      	it	ne
 80050ba:	462b      	movne	r3, r5
// ----------------------------------------------------------------------------

void *umm_malloc( size_t size ) {

  unsigned short int blocks;
  unsigned short int blockSize = 0;
 80050bc:	4634      	mov	r4, r6
  cf = UMM_NFREE(0);

  bestBlock = UMM_NFREE(0);
  bestSize  = 0x7FFF;

  while( UMM_NFREE(cf) ) {
 80050be:	fb0e fc04 	mul.w	ip, lr, r4
 80050c2:	eb00 060c 	add.w	r6, r0, ip
 80050c6:	88b6      	ldrh	r6, [r6, #4]
 80050c8:	2e00      	cmp	r6, #0
 80050ca:	d1df      	bne.n	800508c <pvPortMalloc+0x34>
#endif

    cf = UMM_NFREE(cf);
  }

  if( 0x7FFF != bestSize ) {
 80050cc:	f647 70ff 	movw	r0, #32767	; 0x7fff
 80050d0:	4283      	cmp	r3, r0
 80050d2:	bf18      	it	ne
 80050d4:	461d      	movne	r5, r3
 80050d6:	bf18      	it	ne
 80050d8:	4614      	movne	r4, r2
    cf        = bestBlock;
    blockSize = bestSize;
  }

  if( UMM_NBLOCK(cf) & UMM_BLOCKNO_MASK ) {
 80050da:	220c      	movs	r2, #12
 80050dc:	4362      	muls	r2, r4
 80050de:	4b21      	ldr	r3, [pc, #132]	; (8005164 <pvPortMalloc+0x10c>)
 80050e0:	5a9a      	ldrh	r2, [r3, r2]
 80050e2:	0452      	lsls	r2, r2, #17
 80050e4:	0c56      	lsrs	r6, r2, #17
 80050e6:	b182      	cbz	r2, 800510a <pvPortMalloc+0xb2>
    // This is an existing block in the memory heap, we just need to split off
    // what we need, unlink it from the free list and mark it as in use, and
    // link the rest of the block back into the freelist as if it was a new
    // block on the free list...

    if( blockSize == blocks ) {
 80050e8:	428d      	cmp	r5, r1
 80050ea:	d103      	bne.n	80050f4 <pvPortMalloc+0x9c>
      // It's an exact fit and we don't neet to split off a block.
      DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - exact\n", blocks, cf );

      // Disconnect this block from the FREE list

      umm_disconnect_from_free_list( cf );
 80050ec:	4620      	mov	r0, r4
 80050ee:	f7ff ff43 	bl	8004f78 <umm_disconnect_from_free_list>
 80050f2:	e02e      	b.n	8005152 <pvPortMalloc+0xfa>

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 80050f4:	1a6d      	subs	r5, r5, r1
 80050f6:	b2ad      	uxth	r5, r5
 80050f8:	4620      	mov	r0, r4
 80050fa:	4629      	mov	r1, r5
 80050fc:	f44f 4200 	mov.w	r2, #32768	; 0x8000

     cf += blockSize-blocks;
 8005100:	192c      	adds	r4, r5, r4

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - existing\n", blocks, cf );

     umm_make_new_block( cf, blockSize-blocks, UMM_FREELIST_MASK );
 8005102:	f7ff ff1b 	bl	8004f3c <umm_make_new_block>

     cf += blockSize-blocks;
 8005106:	b2a4      	uxth	r4, r4
 8005108:	e023      	b.n	8005152 <pvPortMalloc+0xfa>
    // We're at the end of the heap - allocate a new block, but check to see if
    // there's enough memory left for the requested block! Actually, we may need
    // one more than that if we're initializing the umm_heap for the first
    // time, which happens in the next conditional...

    if( UMM_NUMBLOCKS <= cf+blocks+1 ) {
 800510a:	1862      	adds	r2, r4, r1
 800510c:	f5b2 7f55 	cmp.w	r2, #852	; 0x354
 8005110:	db06      	blt.n	8005120 <pvPortMalloc+0xc8>
      DBG_LOG_WARNING(  "Can't allocate %5d blocks at %5d\n", blocks, cf );
 8005112:	4622      	mov	r2, r4
 8005114:	4814      	ldr	r0, [pc, #80]	; (8005168 <pvPortMalloc+0x110>)
 8005116:	f000 fb79 	bl	800580c <MIOS32_MIDI_SendDebugMessage>

      // Release the critical section...
      //
      UMM_CRITICAL_EXIT();
 800511a:	f7ff fcf9 	bl	8004b10 <xTaskResumeAll>

      return( (void *)NULL );
 800511e:	e01f      	b.n	8005160 <pvPortMalloc+0x108>

    // Now check to see if we need to initialize the free list...this assumes
    // that the BSS is set to 0 on startup. We should rarely get to the end of
    // the free list so this is the "cheapest" place to put the initialization!

    if( 0 == cf ) {
 8005120:	b91c      	cbnz	r4, 800512a <pvPortMalloc+0xd2>
      DBG_LOG_DEBUG( "Initializing malloc free block pointer\n" );
      UMM_NBLOCK(0) = 1;
 8005122:	2201      	movs	r2, #1
 8005124:	801a      	strh	r2, [r3, #0]
      UMM_NFREE(0)  = 1;
 8005126:	809a      	strh	r2, [r3, #4]
      cf            = 1;
 8005128:	3401      	adds	r4, #1
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 800512a:	220c      	movs	r2, #12
 800512c:	fb02 f304 	mul.w	r3, r2, r4
 8005130:	4e0c      	ldr	r6, [pc, #48]	; (8005164 <pvPortMalloc+0x10c>)
 8005132:	1865      	adds	r5, r4, r1
 8005134:	18f1      	adds	r1, r6, r3
 8005136:	88c8      	ldrh	r0, [r1, #6]
 8005138:	b2af      	uxth	r7, r5
 800513a:	fb02 6000 	mla	r0, r2, r0, r6

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 800513e:	fb02 6505 	mla	r5, r2, r5, r6
      cf            = 1;
    }

    DBG_LOG_DEBUG( "Allocating %6d blocks starting at %6d - new     \n", blocks, cf );

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;
 8005142:	8087      	strh	r7, [r0, #4]

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );
 8005144:	4628      	mov	r0, r5
 8005146:	9301      	str	r3, [sp, #4]
 8005148:	f005 f968 	bl	800a41c <memcpy>

    UMM_NBLOCK(cf)           = cf+blocks;
 800514c:	9b01      	ldr	r3, [sp, #4]
    UMM_PBLOCK(cf+blocks)    = cf;
 800514e:	806c      	strh	r4, [r5, #2]

    UMM_NFREE(UMM_PFREE(cf)) = cf+blocks;

    memcpy( &UMM_BLOCK(cf+blocks), &UMM_BLOCK(cf), sizeof(umm_block) );

    UMM_NBLOCK(cf)           = cf+blocks;
 8005150:	52f7      	strh	r7, [r6, r3]
    UMM_PBLOCK(cf+blocks)    = cf;
  }

  // Release the critical section...
  //
  UMM_CRITICAL_EXIT();
 8005152:	f7ff fcdd 	bl	8004b10 <xTaskResumeAll>

  return( (void *)&UMM_DATA(cf) );
 8005156:	4b03      	ldr	r3, [pc, #12]	; (8005164 <pvPortMalloc+0x10c>)
 8005158:	260c      	movs	r6, #12
 800515a:	fb06 3604 	mla	r6, r6, r4, r3
 800515e:	3604      	adds	r6, #4
}
 8005160:	4630      	mov	r0, r6
 8005162:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005164:	20000c34 	.word	0x20000c34
 8005168:	0800ad50 	.word	0x0800ad50

0800516c <Reset_Handler>:
 * @param  None
 * @retval : None
*/

void Reset_Handler(void)
{
 800516c:	4668      	mov	r0, sp
 800516e:	f020 0107 	bic.w	r1, r0, #7
 8005172:	468d      	mov	sp, r1
 8005174:	b501      	push	{r0, lr}
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8005176:	4a0a      	ldr	r2, [pc, #40]	; (80051a0 <Reset_Handler+0x34>)
 8005178:	4b0a      	ldr	r3, [pc, #40]	; (80051a4 <Reset_Handler+0x38>)
 800517a:	490b      	ldr	r1, [pc, #44]	; (80051a8 <Reset_Handler+0x3c>)
 800517c:	e003      	b.n	8005186 <Reset_Handler+0x1a>
  {
    *(pulDest++) = *(pulSrc++);
 800517e:	f852 0b04 	ldr.w	r0, [r2], #4
 8005182:	f843 0b04 	str.w	r0, [r3], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8005186:	428b      	cmp	r3, r1
 8005188:	d3f9      	bcc.n	800517e <Reset_Handler+0x12>
 800518a:	4b08      	ldr	r3, [pc, #32]	; (80051ac <Reset_Handler+0x40>)
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 800518c:	4908      	ldr	r1, [pc, #32]	; (80051b0 <Reset_Handler+0x44>)
  {
    *(pulDest++) = 0;
 800518e:	2200      	movs	r2, #0
 8005190:	e001      	b.n	8005196 <Reset_Handler+0x2a>
 8005192:	f843 2b04 	str.w	r2, [r3], #4
  for(pulDest = &_sdata; pulDest < &_edata; )
  {
    *(pulDest++) = *(pulSrc++);
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8005196:	428b      	cmp	r3, r1
 8005198:	d3fb      	bcc.n	8005192 <Reset_Handler+0x26>
  {
    *(pulDest++) = 0;
  }

  /* Call the application's entry point.*/
  main();
 800519a:	f7ff fa29 	bl	80045f0 <main>
 800519e:	e7fe      	b.n	800519e <Reset_Handler+0x32>
 80051a0:	0800b068 	.word	0x0800b068
 80051a4:	20000000 	.word	0x20000000
 80051a8:	20000058 	.word	0x20000058
 80051ac:	20000058 	.word	0x20000058
 80051b0:	200037a8 	.word	0x200037a8

080051b4 <_init>:
}

// dummy for newer gcc versions
void _init()
{
}
 80051b4:	4770      	bx	lr

080051b6 <Default_Handler>:
 * @param  None     
 * @retval : None       
*/

void Default_Handler(void) 
{
 80051b6:	e7fe      	b.n	80051b6 <Default_Handler>

080051b8 <MIOS32_SRIO_Init>:
//! Initializes SPI pins and peripheral
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
 80051b8:	b538      	push	{r3, r4, r5, lr}
  // currently only mode 0 supported
  if( mode != 0 )
 80051ba:	bb50      	cbnz	r0, 8005212 <MIOS32_SRIO_Init+0x5a>
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 80051bc:	4b16      	ldr	r3, [pc, #88]	; (8005218 <MIOS32_SRIO_Init+0x60>)

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 80051be:	4d17      	ldr	r5, [pc, #92]	; (800521c <MIOS32_SRIO_Init+0x64>)
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 80051c0:	f8df e05c 	ldr.w	lr, [pc, #92]	; 8005220 <MIOS32_SRIO_Init+0x68>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 80051c4:	f8df c05c 	ldr.w	ip, [pc, #92]	; 8005224 <MIOS32_SRIO_Init+0x6c>
    mios32_srio_din_changed[i] = 0;   // no change
 80051c8:	4917      	ldr	r1, [pc, #92]	; (8005228 <MIOS32_SRIO_Init+0x70>)
    return -1; // unsupported mode

  u8 i;

  // disable notification hook
  srio_scan_finished_hook = NULL;
 80051ca:	6018      	str	r0, [r3, #0]

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 80051cc:	4603      	mov	r3, r0
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 80051ce:	22ff      	movs	r2, #255	; 0xff

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 80051d0:	542b      	strb	r3, [r5, r0]
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 80051d2:	f80e 2000 	strb.w	r2, [lr, r0]
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 80051d6:	f80c 2000 	strb.w	r2, [ip, r0]
    mios32_srio_din_changed[i] = 0;   // no change
 80051da:	540b      	strb	r3, [r1, r0]
 80051dc:	3001      	adds	r0, #1

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0x00;       // passive state (LEDs off)
 80051de:	2400      	movs	r4, #0
  srio_scan_finished_hook = NULL;

  // clear chains
  // will be done again in MIOS32_DIN_Init and MIOS32_DOUT_Init
  // we don't reference to these functions here to allow the programmer to remove/replace these driver modules)
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 80051e0:	2810      	cmp	r0, #16
 80051e2:	d1f4      	bne.n	80051ce <MIOS32_SRIO_Init+0x16>
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
    mios32_srio_din_changed[i] = 0;   // no change
  }

  // initial state of RCLK
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 80051e4:	2001      	movs	r0, #1
 80051e6:	4602      	mov	r2, r0
 80051e8:	4621      	mov	r1, r4
 80051ea:	f001 fb17 	bl	800681c <MIOS32_SPI_RC_PinSet>

  // init GPIO structure
  // using 2 MHz instead of 50 MHz to avoid fast transients which can cause flickering!
  // optionally using open drain mode for cheap and sufficient levelshifting from 3.3V to 5V
#if MIOS32_SRIO_OUTPUTS_OD
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 80051ee:	2103      	movs	r1, #3
 80051f0:	2001      	movs	r0, #1
 80051f2:	f001 fa63 	bl	80066bc <MIOS32_SPI_IO_Init>
#else
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK);
#endif

  // init SPI port for baudrate of ca. 2 uS period @ 72 MHz
  MIOS32_SPI_TransferModeInit(MIOS32_SRIO_SPI, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_64);
 80051f6:	2205      	movs	r2, #5
 80051f8:	2001      	movs	r0, #1
 80051fa:	2103      	movs	r1, #3
 80051fc:	f001 fdac 	bl	8006d58 <MIOS32_SPI_TransferModeInit>

  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;
 8005200:	4b0a      	ldr	r3, [pc, #40]	; (800522c <MIOS32_SRIO_Init+0x74>)
 8005202:	2201      	movs	r2, #1
 8005204:	701a      	strb	r2, [r3, #0]

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 8005206:	4b0a      	ldr	r3, [pc, #40]	; (8005230 <MIOS32_SRIO_Init+0x78>)
  debounce_ctr = 0;
  
  return 0;
 8005208:	4620      	mov	r0, r4
  // notify that SRIO values have been transfered
  // (cleared on each ScanStart, set on each DMA IRQ invokation for proper synchronisation)
  srio_values_transfered = 1;

  // initial debounce time (debouncing disabled)
  debounce_time = 0;
 800520a:	701c      	strb	r4, [r3, #0]
  debounce_ctr = 0;
 800520c:	4b09      	ldr	r3, [pc, #36]	; (8005234 <MIOS32_SRIO_Init+0x7c>)
 800520e:	701c      	strb	r4, [r3, #0]
  
  return 0;
 8005210:	e001      	b.n	8005216 <MIOS32_SRIO_Init+0x5e>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005212:	f04f 30ff 	mov.w	r0, #4294967295
  // initial debounce time (debouncing disabled)
  debounce_time = 0;
  debounce_ctr = 0;
  
  return 0;
}
 8005216:	bd38      	pop	{r3, r4, r5, pc}
 8005218:	200007a0 	.word	0x200007a0
 800521c:	20003440 	.word	0x20003440
 8005220:	20003460 	.word	0x20003460
 8005224:	20003450 	.word	0x20003450
 8005228:	20003430 	.word	0x20003430
 800522c:	200007a5 	.word	0x200007a5
 8005230:	200007a4 	.word	0x200007a4
 8005234:	200007a6 	.word	0x200007a6

08005238 <MIOS32_SRIO_DebounceStart>:
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 8005238:	4b02      	ldr	r3, [pc, #8]	; (8005244 <MIOS32_SRIO_DebounceStart+0xc>)
  return 0; // no error
}
 800523a:	2000      	movs	r0, #0
//! it in a common application.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SRIO_DebounceStart(void)
{
  debounce_ctr = debounce_time;
 800523c:	781a      	ldrb	r2, [r3, #0]
 800523e:	4b02      	ldr	r3, [pc, #8]	; (8005248 <MIOS32_SRIO_DebounceStart+0x10>)
 8005240:	701a      	strb	r2, [r3, #0]
  return 0; // no error
}
 8005242:	4770      	bx	lr
 8005244:	200007a4 	.word	0x200007a4
 8005248:	200007a6 	.word	0x200007a6

0800524c <MIOS32_DIN_Init>:
s32 MIOS32_DIN_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 800524c:	b960      	cbnz	r0, 8005268 <MIOS32_DIN_Init+0x1c>
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 800524e:	f8df c020 	ldr.w	ip, [pc, #32]	; 8005270 <MIOS32_DIN_Init+0x24>
    mios32_srio_din_changed[i] = 0;
 8005252:	4a08      	ldr	r2, [pc, #32]	; (8005274 <MIOS32_DIN_Init+0x28>)
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 8005254:	21ff      	movs	r1, #255	; 0xff
    mios32_srio_din_changed[i] = 0;
 8005256:	4603      	mov	r3, r0
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 8005258:	f80c 1000 	strb.w	r1, [ip, r0]
    mios32_srio_din_changed[i] = 0;
 800525c:	5413      	strb	r3, [r2, r0]
 800525e:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8005260:	2810      	cmp	r0, #16
 8005262:	d1f9      	bne.n	8005258 <MIOS32_DIN_Init+0xc>
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
 8005264:	2000      	movs	r0, #0
 8005266:	e001      	b.n	800526c <MIOS32_DIN_Init+0x20>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005268:	f04f 30ff 	mov.w	r0, #4294967295
    mios32_srio_din[i] = 0xff; // passive state
    mios32_srio_din_changed[i] = 0;
  }

  return 0;
}
 800526c:	4770      	bx	lr
 800526e:	bf00      	nop
 8005270:	20003460 	.word	0x20003460
 8005274:	20003430 	.word	0x20003430

08005278 <MIOS32_DIN_SRChangedGetAndClear>:
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 8005278:	280f      	cmp	r0, #15
//! \param[in] mask pin mask (8bit value)
//! \return 8bit value which contains the selected (masked) change flags
//! \return no error status (-1)! - if unavailable SR selected, 0x00 will be returned
/////////////////////////////////////////////////////////////////////////////
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
 800527a:	b570      	push	{r4, r5, r6, lr}
 800527c:	4604      	mov	r4, r0
 800527e:	460e      	mov	r6, r1
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
 8005280:	d80c      	bhi.n	800529c <MIOS32_DIN_SRChangedGetAndClear+0x24>
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
 8005282:	f001 f9cf 	bl	8006624 <MIOS32_IRQ_Disable>
  changed = mios32_srio_din_changed[sr] & mask;
 8005286:	4b07      	ldr	r3, [pc, #28]	; (80052a4 <MIOS32_DIN_SRChangedGetAndClear+0x2c>)
 8005288:	5d1d      	ldrb	r5, [r3, r4]
  mios32_srio_din_changed[sr] &= ~mask;
 800528a:	5d1a      	ldrb	r2, [r3, r4]
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
  changed = mios32_srio_din_changed[sr] & mask;
 800528c:	ea06 0505 	and.w	r5, r6, r5
  mios32_srio_din_changed[sr] &= ~mask;
 8005290:	ea22 0606 	bic.w	r6, r2, r6
 8005294:	551e      	strb	r6, [r3, r4]
  MIOS32_IRQ_Enable();
 8005296:	f001 f9db 	bl	8006650 <MIOS32_IRQ_Enable>

  return changed;
 800529a:	e000      	b.n	800529e <MIOS32_DIN_SRChangedGetAndClear+0x26>
{
  u8 changed;

  // check if SR available
  if( sr >= MIOS32_SRIO_NUM_SR )
    return 0x00;
 800529c:	2500      	movs	r5, #0
  changed = mios32_srio_din_changed[sr] & mask;
  mios32_srio_din_changed[sr] &= ~mask;
  MIOS32_IRQ_Enable();

  return changed;
}
 800529e:	4628      	mov	r0, r5
 80052a0:	bd70      	pop	{r4, r5, r6, pc}
 80052a2:	bf00      	nop
 80052a4:	20003430 	.word	0x20003430

080052a8 <MIOS32_DIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_Handler(void *_callback)
{
 80052a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80052aa:	4606      	mov	r6, r0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
    return -1;
 80052ac:	f04f 30ff 	mov.w	r0, #4294967295
#if MIOS32_SRIO_NUM_SR == 0
  return -1;
#endif

  // no callback function?
  if( _callback == NULL )
 80052b0:	b1fe      	cbz	r6, 80052f2 <MIOS32_DIN_Handler+0x4a>
 80052b2:	2400      	movs	r4, #0

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
    
    // check if there are pin changes (mask all pins)
    changed = MIOS32_DIN_SRChangedGetAndClear(sr, 0xff);
 80052b4:	4620      	mov	r0, r4
 80052b6:	21ff      	movs	r1, #255	; 0xff
 80052b8:	f7ff ffde 	bl	8005278 <MIOS32_DIN_SRChangedGetAndClear>
 80052bc:	4607      	mov	r7, r0

    // any pin change at this SR?
    if( !changed )
 80052be:	b1a0      	cbz	r0, 80052ea <MIOS32_DIN_Handler+0x42>
 80052c0:	2500      	movs	r5, #0

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 80052c2:	00e3      	lsls	r3, r4, #3
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
 80052c4:	fa57 f205 	asrs.w	r2, r7, r5
 80052c8:	f012 0f01 	tst.w	r2, #1
 80052cc:	d00a      	beq.n	80052e4 <MIOS32_DIN_Handler+0x3c>
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 80052ce:	4a09      	ldr	r2, [pc, #36]	; (80052f4 <MIOS32_DIN_Handler+0x4c>)
 80052d0:	18e8      	adds	r0, r5, r3
 80052d2:	5d11      	ldrb	r1, [r2, r4]
 80052d4:	9301      	str	r3, [sp, #4]
 80052d6:	4129      	asrs	r1, r5
 80052d8:	f001 0101 	and.w	r1, r1, #1
 80052dc:	47b0      	blx	r6

	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
 80052de:	f7ff ffab 	bl	8005238 <MIOS32_SRIO_DebounceStart>
 80052e2:	9b01      	ldr	r3, [sp, #4]
    // any pin change at this SR?
    if( !changed )
      continue;

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
 80052e4:	3501      	adds	r5, #1
 80052e6:	2d08      	cmp	r5, #8
 80052e8:	d1ec      	bne.n	80052c4 <MIOS32_DIN_Handler+0x1c>
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all shift registers for DIN pin changes
  for(sr=0; sr<MIOS32_SRIO_NUM_SR; ++sr) {
 80052ea:	3401      	adds	r4, #1
 80052ec:	2c10      	cmp	r4, #16
 80052ee:	d1e1      	bne.n	80052b4 <MIOS32_DIN_Handler+0xc>
	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
      }
  }

  return 0;
 80052f0:	2000      	movs	r0, #0
}
 80052f2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80052f4:	20003460 	.word	0x20003460

080052f8 <MIOS32_DOUT_Init>:
s32 MIOS32_DOUT_Init(u32 mode)
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 80052f8:	b938      	cbnz	r0, 800530a <MIOS32_DOUT_Init+0x12>
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
 80052fa:	4a05      	ldr	r2, [pc, #20]	; (8005310 <MIOS32_DOUT_Init+0x18>)
 80052fc:	4603      	mov	r3, r0
 80052fe:	5413      	strb	r3, [r2, r0]
 8005300:	3001      	adds	r0, #1
  if( mode != 0 )
    return -1; // unsupported mode

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8005302:	2810      	cmp	r0, #16
 8005304:	d1fb      	bne.n	80052fe <MIOS32_DOUT_Init+0x6>
    mios32_srio_dout[i] = 0;
  }

  return 0;
 8005306:	2000      	movs	r0, #0
 8005308:	e001      	b.n	800530e <MIOS32_DOUT_Init+0x16>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800530a:	f04f 30ff 	mov.w	r0, #4294967295
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_dout[i] = 0;
  }

  return 0;
}
 800530e:	4770      	bx	lr
 8005310:	20003440 	.word	0x20003440

08005314 <MIOS32_ENC_Init>:
//! Initializes encoder driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Init(u32 mode)
{
 8005314:	b510      	push	{r4, lr}
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 8005316:	bb20      	cbnz	r0, 8005362 <MIOS32_ENC_Init+0x4e>
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 8005318:	4c13      	ldr	r4, [pc, #76]	; (8005368 <MIOS32_ENC_Init+0x54>)

    enc_state[i].state = 0xf; // all pins released
 800531a:	4914      	ldr	r1, [pc, #80]	; (800536c <MIOS32_ENC_Init+0x58>)
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 800531c:	4602      	mov	r2, r0
 800531e:	f804 2020 	strb.w	r2, [r4, r0, lsl #2]

    enc_state[i].state = 0xf; // all pins released
 8005322:	f811 3030 	ldrb.w	r3, [r1, r0, lsl #3]
    enc_state[i].decinc = 0;
 8005326:	f043 030f 	orr.w	r3, r3, #15
 800532a:	f36f 1304 	bfc	r3, #4, #1
 800532e:	f801 3030 	strb.w	r3, [r1, r0, lsl #3]
    enc_state[i].incrementer = 0;
 8005332:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
 8005336:	f893 c003 	ldrb.w	ip, [r3, #3]
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 800533a:	3001      	adds	r0, #1
    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
 800533c:	f00c 0cf0 	and.w	ip, ip, #240	; 0xf0
 8005340:	f36f 1c07 	bfc	ip, #4, #4
 8005344:	f883 c003 	strb.w	ip, [r3, #3]
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 8005348:	f893 c005 	ldrb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 800534c:	2840      	cmp	r0, #64	; 0x40
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
 800534e:	f36f 0c03 	bfc	ip, #0, #4
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder

    enc_state[i].state = 0xf; // all pins released
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
 8005352:	705a      	strb	r2, [r3, #1]
    enc_state[i].accelerator = 0;
 8005354:	709a      	strb	r2, [r3, #2]
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
 8005356:	711a      	strb	r2, [r3, #4]
    enc_state[i].predivider = 0;
 8005358:	f883 c005 	strb.w	ip, [r3, #5]
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 800535c:	d1df      	bne.n	800531e <MIOS32_ENC_Init+0xa>
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
 800535e:	2000      	movs	r0, #0
 8005360:	e001      	b.n	8005366 <MIOS32_ENC_Init+0x52>
{
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005362:	f04f 30ff 	mov.w	r0, #4294967295
    enc_state[i].prev_acc = 0;
    enc_state[i].predivider = 0;
  }

  return 0; // no error
}
 8005366:	bd10      	pop	{r4, pc}
 8005368:	20003470 	.word	0x20003470
 800536c:	20003570 	.word	0x20003570

08005370 <MIOS32_ENC_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Handler(void *_callback)
{
 8005370:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005372:	4605      	mov	r5, r0
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
    return -1;
 8005374:	f04f 30ff 	mov.w	r0, #4294967295
  u8 enc;
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
 8005378:	b1bd      	cbz	r5, 80053aa <MIOS32_ENC_Handler+0x3a>
 800537a:	2400      	movs	r4, #0
  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
    if( (incrementer = enc_state[enc].incrementer) ) {
 800537c:	4f0b      	ldr	r7, [pc, #44]	; (80053ac <MIOS32_ENC_Handler+0x3c>)
      enc_state[enc].incrementer = 0;
 800537e:	4626      	mov	r6, r4

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
 8005380:	f001 f950 	bl	8006624 <MIOS32_IRQ_Disable>
    if( (incrementer = enc_state[enc].incrementer) ) {
 8005384:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
 8005388:	f993 1001 	ldrsb.w	r1, [r3, #1]
 800538c:	b139      	cbz	r1, 800539e <MIOS32_ENC_Handler+0x2e>
      enc_state[enc].incrementer = 0;
 800538e:	705e      	strb	r6, [r3, #1]
      MIOS32_IRQ_Enable();
 8005390:	9101      	str	r1, [sp, #4]
 8005392:	f001 f95d 	bl	8006650 <MIOS32_IRQ_Enable>

      // call the hook
      callback(enc, incrementer);
 8005396:	4620      	mov	r0, r4
 8005398:	9901      	ldr	r1, [sp, #4]
 800539a:	47a8      	blx	r5
 800539c:	e001      	b.n	80053a2 <MIOS32_ENC_Handler+0x32>
    } else {
      MIOS32_IRQ_Enable();
 800539e:	f001 f957 	bl	8006650 <MIOS32_IRQ_Enable>
 80053a2:	3401      	adds	r4, #1
  // no callback function?
  if( _callback == NULL )
    return -1;

  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
 80053a4:	2c40      	cmp	r4, #64	; 0x40
 80053a6:	d1eb      	bne.n	8005380 <MIOS32_ENC_Handler+0x10>
    } else {
      MIOS32_IRQ_Enable();
    }
  }

  return 0; // no error
 80053a8:	2000      	movs	r0, #0
}
 80053aa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80053ac:	20003570 	.word	0x20003570

080053b0 <MIOS32_LCD_DeviceSet>:
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 80053b0:	4b01      	ldr	r3, [pc, #4]	; (80053b8 <MIOS32_LCD_DeviceSet+0x8>)
 80053b2:	7018      	strb	r0, [r3, #0]

  return 0; // no error
}
 80053b4:	2000      	movs	r0, #0
 80053b6:	4770      	bx	lr
 80053b8:	200007a7 	.word	0x200007a7

080053bc <MIOS32_LCD_CursorSet>:
//! \param[in] column number
//! \param[in] line number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorSet(u16 column, u16 line)
{
 80053bc:	b508      	push	{r3, lr}
  // set character position
  mios32_lcd_column = column;
 80053be:	4b0b      	ldr	r3, [pc, #44]	; (80053ec <MIOS32_LCD_CursorSet+0x30>)
 80053c0:	8018      	strh	r0, [r3, #0]
  mios32_lcd_line = line;
 80053c2:	4b0b      	ldr	r3, [pc, #44]	; (80053f0 <MIOS32_LCD_CursorSet+0x34>)
 80053c4:	8019      	strh	r1, [r3, #0]

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
  if( font_bitmap.width ) {
 80053c6:	4b0b      	ldr	r3, [pc, #44]	; (80053f4 <MIOS32_LCD_CursorSet+0x38>)
 80053c8:	889a      	ldrh	r2, [r3, #4]
 80053ca:	b112      	cbz	r2, 80053d2 <MIOS32_LCD_CursorSet+0x16>
    font_width = font_bitmap.width;
 80053cc:	b2d2      	uxtb	r2, r2
    font_height = font_bitmap.height;
 80053ce:	799b      	ldrb	r3, [r3, #6]
 80053d0:	e001      	b.n	80053d6 <MIOS32_LCD_CursorSet+0x1a>
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
 80053d2:	2308      	movs	r3, #8
  // set character position
  mios32_lcd_column = column;
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
 80053d4:	2206      	movs	r2, #6
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 80053d6:	4342      	muls	r2, r0
 80053d8:	f8df c01c 	ldr.w	ip, [pc, #28]	; 80053f8 <MIOS32_LCD_CursorSet+0x3c>
  mios32_lcd_y = line * font_height;
 80053dc:	434b      	muls	r3, r1
  if( font_bitmap.width ) {
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
  }

  mios32_lcd_x = column * font_width;
 80053de:	f8ac 2000 	strh.w	r2, [ip]
  mios32_lcd_y = line * font_height;
 80053e2:	4a06      	ldr	r2, [pc, #24]	; (80053fc <MIOS32_LCD_CursorSet+0x40>)
 80053e4:	8013      	strh	r3, [r2, #0]

  // forward new cursor position to app driver
  return APP_LCD_CursorSet(column, line);
 80053e6:	f004 ffd1 	bl	800a38c <APP_LCD_CursorSet>
}
 80053ea:	bd08      	pop	{r3, pc}
 80053ec:	2000377e 	.word	0x2000377e
 80053f0:	20003784 	.word	0x20003784
 80053f4:	20003770 	.word	0x20003770
 80053f8:	20003788 	.word	0x20003788
 80053fc:	2000377c 	.word	0x2000377c

08005400 <MIOS32_LCD_GCursorSet>:
//! \param[in] x position
//! \param[in] y position
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_GCursorSet(u16 x, u16 y)
{
 8005400:	b508      	push	{r3, lr}
  mios32_lcd_x = x;
 8005402:	4b03      	ldr	r3, [pc, #12]	; (8005410 <MIOS32_LCD_GCursorSet+0x10>)
 8005404:	8018      	strh	r0, [r3, #0]
  mios32_lcd_y = y;
 8005406:	4b03      	ldr	r3, [pc, #12]	; (8005414 <MIOS32_LCD_GCursorSet+0x14>)
 8005408:	8019      	strh	r1, [r3, #0]

  // forward new cursor position to app driver
  return APP_LCD_GCursorSet(x, y);
 800540a:	f004 ffd1 	bl	800a3b0 <APP_LCD_GCursorSet>
}
 800540e:	bd08      	pop	{r3, pc}
 8005410:	20003788 	.word	0x20003788
 8005414:	2000377c 	.word	0x2000377c

08005418 <MIOS32_LCD_CursorMapSet>:
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
    mios32_lcd_cursor_map[i] = map_table[i];
 8005418:	4a04      	ldr	r2, [pc, #16]	; (800542c <MIOS32_LCD_CursorMapSet+0x14>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 800541a:	2300      	movs	r3, #0
    mios32_lcd_cursor_map[i] = map_table[i];
 800541c:	5cc1      	ldrb	r1, [r0, r3]
 800541e:	5499      	strb	r1, [r3, r2]
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 8005420:	3301      	adds	r3, #1
 8005422:	2b04      	cmp	r3, #4
 8005424:	d1fa      	bne.n	800541c <MIOS32_LCD_CursorMapSet+0x4>
    mios32_lcd_cursor_map[i] = map_table[i];

  return 0; // no error
}
 8005426:	2000      	movs	r0, #0
 8005428:	4770      	bx	lr
 800542a:	bf00      	nop
 800542c:	20003780 	.word	0x20003780

08005430 <MIOS32_LCD_Init>:
//! Initializes LCD driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Init(u32 mode)
{
 8005430:	b513      	push	{r0, r1, r4, lr}
 8005432:	4604      	mov	r4, r0
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005434:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_Init(u32 mode)
{
  s32 ret;

  // currently only mode 0 supported
  if( mode != 0 )
 8005438:	b9d4      	cbnz	r4, 8005470 <MIOS32_LCD_Init+0x40>
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 800543a:	4b0e      	ldr	r3, [pc, #56]	; (8005474 <MIOS32_LCD_Init+0x44>)

  // disable font bitmap
  font_bitmap.width = 0;

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 800543c:	a802      	add	r0, sp, #8
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // initial LCD type (can be set to a different type in APP_LCD_Init()
  mios32_lcd_type = MIOS32_LCD_TYPE_CLCD;
 800543e:	701c      	strb	r4, [r3, #0]

  // disable font bitmap
  font_bitmap.width = 0;
 8005440:	4b0d      	ldr	r3, [pc, #52]	; (8005478 <MIOS32_LCD_Init+0x48>)
 8005442:	809c      	strh	r4, [r3, #4]

  // set initial cursor map for character LCDs
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 8005444:	4b0d      	ldr	r3, [pc, #52]	; (800547c <MIOS32_LCD_Init+0x4c>)
 8005446:	681b      	ldr	r3, [r3, #0]
 8005448:	f840 3d04 	str.w	r3, [r0, #-4]!
  MIOS32_LCD_CursorMapSet(cursor_map);
 800544c:	f7ff ffe4 	bl	8005418 <MIOS32_LCD_CursorMapSet>
  // note: this has to be done before APP_LCD_Init() is called, so that
  // the driver is able to modify the default cursor mapping
  // usage example: "dog" LCDs

  // call application specific init function
  if( (ret=APP_LCD_Init(mode)) < 0 )
 8005450:	4620      	mov	r0, r4
 8005452:	f004 ff2d 	bl	800a2b0 <APP_LCD_Init>
 8005456:	2800      	cmp	r0, #0
 8005458:	db0a      	blt.n	8005470 <MIOS32_LCD_Init+0x40>
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
  // -> forward to app_lcd
  return APP_LCD_Clear();
 800545a:	f004 ff91 	bl	800a380 <APP_LCD_Clear>

  // clear screen
  MIOS32_LCD_Clear();

  // set character and graphical cursor to initial position
  MIOS32_LCD_CursorSet(0, 0);
 800545e:	4621      	mov	r1, r4
 8005460:	4620      	mov	r0, r4
 8005462:	f7ff ffab 	bl	80053bc <MIOS32_LCD_CursorSet>
  MIOS32_LCD_GCursorSet(0, 0);
 8005466:	4620      	mov	r0, r4
 8005468:	4621      	mov	r1, r4
 800546a:	f7ff ffc9 	bl	8005400 <MIOS32_LCD_GCursorSet>

  return 0; // no error
 800546e:	4620      	mov	r0, r4
}
 8005470:	bd1c      	pop	{r2, r3, r4, pc}
 8005472:	bf00      	nop
 8005474:	20003786 	.word	0x20003786
 8005478:	20003770 	.word	0x20003770
 800547c:	0800ad74 	.word	0x0800ad74

08005480 <MIOS32_LCD_Clear>:
/////////////////////////////////////////////////////////////////////////////
//! Clear Screen
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
 8005480:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_Clear();
 8005482:	f004 ff7d 	bl	800a380 <APP_LCD_Clear>
}
 8005486:	bd08      	pop	{r3, pc}

08005488 <MIOS32_LCD_PrintChar>:
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 8005488:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 800548a:	4b13      	ldr	r3, [pc, #76]	; (80054d8 <MIOS32_LCD_PrintChar+0x50>)
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 800548c:	4684      	mov	ip, r0
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
 800548e:	781b      	ldrb	r3, [r3, #0]
 8005490:	2b01      	cmp	r3, #1
 8005492:	d117      	bne.n	80054c4 <MIOS32_LCD_PrintChar+0x3c>
    if( !font_bitmap.width )
 8005494:	4b11      	ldr	r3, [pc, #68]	; (80054dc <MIOS32_LCD_PrintChar+0x54>)
      return -1;    // font not initialized yet!
 8005496:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_LCD_PrintChar(char c)
{
  s32 status;

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
 800549a:	889a      	ldrh	r2, [r3, #4]
 800549c:	b1d2      	cbz	r2, 80054d4 <MIOS32_LCD_PrintChar+0x4c>
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 800549e:	f10d 0e04 	add.w	lr, sp, #4
 80054a2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80054a6:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
 80054aa:	88da      	ldrh	r2, [r3, #6]
 80054ac:	8919      	ldrh	r1, [r3, #8]
 80054ae:	08d2      	lsrs	r2, r2, #3
 80054b0:	434a      	muls	r2, r1
 80054b2:	fb0c 0c02 	mla	ip, ip, r2, r0

  if( mios32_lcd_type == MIOS32_LCD_TYPE_GLCD ) {
    if( !font_bitmap.width )
      return -1;    // font not initialized yet!

    mios32_lcd_bitmap_t bitmap = font_bitmap;
 80054b6:	f8cd c004 	str.w	ip, [sp, #4]
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
    status = APP_LCD_BitmapPrint(bitmap);
 80054ba:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 80054be:	f004 ff80 	bl	800a3c2 <APP_LCD_BitmapPrint>
 80054c2:	e001      	b.n	80054c8 <MIOS32_LCD_PrintChar+0x40>
  } else {
    status = APP_LCD_Data(c);
 80054c4:	f004 fe90 	bl	800a1e8 <APP_LCD_Data>
  }

  if( status >= 0 ) {
 80054c8:	2800      	cmp	r0, #0
 80054ca:	db03      	blt.n	80054d4 <MIOS32_LCD_PrintChar+0x4c>
    // increment cursor
    ++mios32_lcd_column;
 80054cc:	4b04      	ldr	r3, [pc, #16]	; (80054e0 <MIOS32_LCD_PrintChar+0x58>)
 80054ce:	881a      	ldrh	r2, [r3, #0]
 80054d0:	3201      	adds	r2, #1
 80054d2:	801a      	strh	r2, [r3, #0]
  }

  return status;
}
 80054d4:	b005      	add	sp, #20
 80054d6:	bd00      	pop	{pc}
 80054d8:	20003786 	.word	0x20003786
 80054dc:	20003770 	.word	0x20003770
 80054e0:	2000377e 	.word	0x2000377e

080054e4 <MIOS32_LCD_PrintString>:
//! Prints a \\0 (zero) terminated string
//! \param[in] str pointer to string
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
 80054e4:	b538      	push	{r3, r4, r5, lr}
 80054e6:	4605      	mov	r5, r0
  s32 status = 0;
 80054e8:	2400      	movs	r4, #0

  while( *str != '\0' )
 80054ea:	e002      	b.n	80054f2 <MIOS32_LCD_PrintString+0xe>
    status |= MIOS32_LCD_PrintChar(*str++);
 80054ec:	f7ff ffcc 	bl	8005488 <MIOS32_LCD_PrintChar>
 80054f0:	4304      	orrs	r4, r0
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintString(char *str)
{
  s32 status = 0;

  while( *str != '\0' )
 80054f2:	f815 0b01 	ldrb.w	r0, [r5], #1
 80054f6:	2800      	cmp	r0, #0
 80054f8:	d1f8      	bne.n	80054ec <MIOS32_LCD_PrintString+0x8>
    status |= MIOS32_LCD_PrintChar(*str++);

  return status;
}
 80054fa:	4620      	mov	r0, r4
 80054fc:	bd38      	pop	{r3, r4, r5, pc}
	...

08005500 <MIOS32_LCD_PrintBootMessage>:
//! The message is automatically print by the programming model after each reset.<BR>
//! It will also be returned on a SysEx query.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintBootMessage(void)
{
 8005500:	b538      	push	{r3, r4, r5, lr}
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 8005502:	4b0c      	ldr	r3, [pc, #48]	; (8005534 <MIOS32_LCD_PrintBootMessage+0x34>)
 8005504:	2400      	movs	r4, #0
 8005506:	701c      	strb	r4, [r3, #0]
s32 MIOS32_LCD_PrintBootMessage(void)
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
 8005508:	4621      	mov	r1, r4
 800550a:	4620      	mov	r0, r4
 800550c:	f7ff ff56 	bl	80053bc <MIOS32_LCD_CursorSet>
 8005510:	4605      	mov	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 8005512:	4809      	ldr	r0, [pc, #36]	; (8005538 <MIOS32_LCD_PrintBootMessage+0x38>)
 8005514:	f7ff ffe6 	bl	80054e4 <MIOS32_LCD_PrintString>
  status |= MIOS32_LCD_CursorSet(0, 1);
 8005518:	2101      	movs	r1, #1
{
  s32 status = 0;

  status |= MIOS32_LCD_DeviceSet(0);
  status |= MIOS32_LCD_CursorSet(0, 0);
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 800551a:	ea40 0505 	orr.w	r5, r0, r5
  status |= MIOS32_LCD_CursorSet(0, 1);
 800551e:	4620      	mov	r0, r4
 8005520:	f7ff ff4c 	bl	80053bc <MIOS32_LCD_CursorSet>
 8005524:	4305      	orrs	r5, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE2);
 8005526:	4805      	ldr	r0, [pc, #20]	; (800553c <MIOS32_LCD_PrintBootMessage+0x3c>)
 8005528:	f7ff ffdc 	bl	80054e4 <MIOS32_LCD_PrintString>
 800552c:	ea45 0000 	orr.w	r0, r5, r0

  return status;
}
 8005530:	bd38      	pop	{r3, r4, r5, pc}
 8005532:	bf00      	nop
 8005534:	200007a7 	.word	0x200007a7
 8005538:	0800ad78 	.word	0x0800ad78
 800553c:	0800ad89 	.word	0x0800ad89

08005540 <MIOS32_LCD_PrintFormattedString>:
//! \param[in] *format zero-terminated format string - 64 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
 8005540:	b40f      	push	{r0, r1, r2, r3}
 8005542:	b510      	push	{r4, lr}
 8005544:	b092      	sub	sp, #72	; 0x48
 8005546:	aa14      	add	r2, sp, #80	; 0x50
 8005548:	f852 1b04 	ldr.w	r1, [r2], #4
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
  vsprintf((char *)buffer, format, args);
 800554c:	ac01      	add	r4, sp, #4
 800554e:	4620      	mov	r0, r4
s32 MIOS32_LCD_PrintFormattedString(char *format, ...)
{
  char buffer[64]; // TODO: tmp!!! Provide a streamed COM method later!
  va_list args;

  va_start(args, format);
 8005550:	9211      	str	r2, [sp, #68]	; 0x44
  vsprintf((char *)buffer, format, args);
 8005552:	f003 f9e6 	bl	8008922 <vsprintf>
  return MIOS32_LCD_PrintString(buffer);
 8005556:	4620      	mov	r0, r4
 8005558:	f7ff ffc4 	bl	80054e4 <MIOS32_LCD_PrintString>
}
 800555c:	b012      	add	sp, #72	; 0x48
 800555e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8005562:	b004      	add	sp, #16
 8005564:	4770      	bx	lr

08005566 <MIOS32_LCD_BColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_BColourSet(u32 rgb)
{
 8005566:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_BColourSet(rgb);
 8005568:	f004 ff25 	bl	800a3b6 <APP_LCD_BColourSet>
}
 800556c:	bd08      	pop	{r3, pc}

0800556e <MIOS32_LCD_FColourSet>:
//!    u32 colour = (r << 16) | (g << 8) | (b << 0);
//! \endcode
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_FColourSet(u32 rgb)
{
 800556e:	b508      	push	{r3, lr}
  // -> forward to app_lcd
  return APP_LCD_FColourSet(rgb);
 8005570:	f004 ff24 	bl	800a3bc <APP_LCD_FColourSet>
}
 8005574:	bd08      	pop	{r3, pc}
	...

08005578 <MIOS32_MIDI_Init>:
//! Initializes MIDI layer
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
 8005578:	b538      	push	{r3, r4, r5, lr}
 800557a:	4604      	mov	r4, r0
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800557c:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 8005580:	2c00      	cmp	r4, #0
 8005582:	d12c      	bne.n	80055de <MIOS32_MIDI_Init+0x66>
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
 8005584:	4a16      	ldr	r2, [pc, #88]	; (80055e0 <MIOS32_MIDI_Init+0x68>)
 8005586:	2310      	movs	r3, #16
 8005588:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 800558a:	4a16      	ldr	r2, [pc, #88]	; (80055e4 <MIOS32_MIDI_Init+0x6c>)
  timeout_callback_func = NULL;
  debug_command_callback_func = NULL;

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 800558c:	4620      	mov	r0, r4
  if( mode != 0 )
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 800558e:	7013      	strb	r3, [r2, #0]

  // disable callback functions
  direct_rx_callback_func = NULL;
 8005590:	4b15      	ldr	r3, [pc, #84]	; (80055e8 <MIOS32_MIDI_Init+0x70>)
 8005592:	601c      	str	r4, [r3, #0]
  direct_tx_callback_func = NULL;
 8005594:	4b15      	ldr	r3, [pc, #84]	; (80055ec <MIOS32_MIDI_Init+0x74>)
 8005596:	601c      	str	r4, [r3, #0]
  sysex_callback_func = NULL;
 8005598:	4b15      	ldr	r3, [pc, #84]	; (80055f0 <MIOS32_MIDI_Init+0x78>)
 800559a:	601c      	str	r4, [r3, #0]
  timeout_callback_func = NULL;
 800559c:	4b15      	ldr	r3, [pc, #84]	; (80055f4 <MIOS32_MIDI_Init+0x7c>)
 800559e:	601c      	str	r4, [r3, #0]
  debug_command_callback_func = NULL;
 80055a0:	4b15      	ldr	r3, [pc, #84]	; (80055f8 <MIOS32_MIDI_Init+0x80>)
 80055a2:	601c      	str	r4, [r3, #0]

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 80055a4:	f002 fc30 	bl	8007e08 <MIOS32_USB_MIDI_Init>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
  s32 ret = 0;
 80055a8:	0fc5      	lsrs	r5, r0, #31
  if( MIOS32_USB_MIDI_Init(0) < 0 )
    ret |= (1 << 0);
#endif

#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
 80055aa:	4620      	mov	r0, r4
 80055ac:	f000 fd2c 	bl	8006008 <MIOS32_UART_MIDI_Init>
 80055b0:	2800      	cmp	r0, #0
    ret |= (1 << 1);
 80055b2:	bfb8      	it	lt
 80055b4:	f045 0502 	orrlt.w	r5, r5, #2
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 80055b8:	2000      	movs	r0, #0
 80055ba:	f000 fec3 	bl	8006344 <MIOS32_IIC_MIDI_Init>
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
 80055be:	4a0f      	ldr	r2, [pc, #60]	; (80055fc <MIOS32_MIDI_Init+0x84>)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
    ret |= (1 << 1);
#endif

#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
 80055c0:	2800      	cmp	r0, #0
    ret |= (1 << 2);
 80055c2:	bfb8      	it	lt
 80055c4:	f045 0504 	orrlt.w	r5, r5, #4
#endif

  last_sysex_port = DEFAULT;
 80055c8:	2300      	movs	r3, #0
 80055ca:	7013      	strb	r3, [r2, #0]
  sysex_state.ALL = 0;
 80055cc:	4a0c      	ldr	r2, [pc, #48]	; (8005600 <MIOS32_MIDI_Init+0x88>)

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
  sysex_timeout_ctr_flags.ALL = 0;

  return -ret;
 80055ce:	4268      	negs	r0, r5
  if( MIOS32_IIC_MIDI_Init(0) < 0 )
    ret |= (1 << 2);
#endif

  last_sysex_port = DEFAULT;
  sysex_state.ALL = 0;
 80055d0:	7013      	strb	r3, [r2, #0]

  // TODO: allow to change device ID (read from flash, resp. BSL based EEPROM emulation)
  sysex_device_id = 0x00;
 80055d2:	4a0c      	ldr	r2, [pc, #48]	; (8005604 <MIOS32_MIDI_Init+0x8c>)
 80055d4:	7013      	strb	r3, [r2, #0]

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
 80055d6:	4a0c      	ldr	r2, [pc, #48]	; (8005608 <MIOS32_MIDI_Init+0x90>)
 80055d8:	8013      	strh	r3, [r2, #0]
  sysex_timeout_ctr_flags.ALL = 0;
 80055da:	4a0c      	ldr	r2, [pc, #48]	; (800560c <MIOS32_MIDI_Init+0x94>)
 80055dc:	6013      	str	r3, [r2, #0]

  return -ret;
}
 80055de:	bd38      	pop	{r3, r4, r5, pc}
 80055e0:	20000004 	.word	0x20000004
 80055e4:	20000005 	.word	0x20000005
 80055e8:	200007b0 	.word	0x200007b0
 80055ec:	200007a8 	.word	0x200007a8
 80055f0:	200007cc 	.word	0x200007cc
 80055f4:	200007d0 	.word	0x200007d0
 80055f8:	200007c4 	.word	0x200007c4
 80055fc:	200007b4 	.word	0x200007b4
 8005600:	200007bc 	.word	0x200007bc
 8005604:	200007b5 	.word	0x200007b5
 8005608:	200007b6 	.word	0x200007b6
 800560c:	200007c8 	.word	0x200007c8

08005610 <MIOS32_MIDI_SendPackage>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8005610:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] package MIDI package
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
 8005614:	b570      	push	{r4, r5, r6, lr}
 8005616:	4605      	mov	r5, r0
 8005618:	460c      	mov	r4, r1
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 800561a:	d104      	bne.n	8005626 <MIOS32_MIDI_SendPackage+0x16>
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
 800561c:	2801      	cmp	r0, #1
 800561e:	bf0c      	ite	eq
 8005620:	4b16      	ldreq	r3, [pc, #88]	; (800567c <MIOS32_MIDI_SendPackage+0x6c>)
 8005622:	4b17      	ldrne	r3, [pc, #92]	; (8005680 <MIOS32_MIDI_SendPackage+0x70>)
 8005624:	781d      	ldrb	r5, [r3, #0]

  // insert subport number into package
  package.cable = port & 0xf;

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 8005626:	4b17      	ldr	r3, [pc, #92]	; (8005684 <MIOS32_MIDI_SendPackage+0x74>)
  if( !(port & 0xf0) ) {
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
  }

  // insert subport number into package
  package.cable = port & 0xf;
 8005628:	f005 060f 	and.w	r6, r5, #15

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 800562c:	681b      	ldr	r3, [r3, #0]
 800562e:	b12b      	cbz	r3, 800563c <MIOS32_MIDI_SendPackage+0x2c>
 8005630:	f366 1407 	bfi	r4, r6, #4, #4
    s32 status;
    if( (status=direct_tx_callback_func(port, package)) )
 8005634:	4628      	mov	r0, r5
 8005636:	4621      	mov	r1, r4
 8005638:	4798      	blx	r3
 800563a:	b9e8      	cbnz	r0, 8005678 <MIOS32_MIDI_SendPackage+0x68>
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 800563c:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 8005640:	2d20      	cmp	r5, #32
 8005642:	d00c      	beq.n	800565e <MIOS32_MIDI_SendPackage+0x4e>
 8005644:	2d30      	cmp	r5, #48	; 0x30
 8005646:	d011      	beq.n	800566c <MIOS32_MIDI_SendPackage+0x5c>
 8005648:	2d10      	cmp	r5, #16
      return -1; // IIC_MIDI has been disabled
#endif
      
    default:
      // invalid port
      return -1;
 800564a:	bf18      	it	ne
 800564c:	f04f 30ff 	movne.w	r0, #4294967295
    if( (status=direct_tx_callback_func(port, package)) )
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 8005650:	d112      	bne.n	8005678 <MIOS32_MIDI_SendPackage+0x68>
 8005652:	f366 1407 	bfi	r4, r6, #4, #4
    case USB0://..15
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      return MIOS32_USB_MIDI_PackageSend(package);
 8005656:	4620      	mov	r0, r4
 8005658:	f002 fc48 	bl	8007eec <MIOS32_USB_MIDI_PackageSend>
 800565c:	e00c      	b.n	8005678 <MIOS32_MIDI_SendPackage+0x68>
 800565e:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // USB has been disabled
#endif

    case UART0://..15
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
      return MIOS32_UART_MIDI_PackageSend(package.cable, package);
 8005662:	4630      	mov	r0, r6
 8005664:	4621      	mov	r1, r4
 8005666:	f000 fd89 	bl	800617c <MIOS32_UART_MIDI_PackageSend>
 800566a:	e005      	b.n	8005678 <MIOS32_MIDI_SendPackage+0x68>
 800566c:	f366 1407 	bfi	r4, r6, #4, #4
      return -1; // UART_MIDI has been disabled
#endif

    case IIC0://..15
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      return MIOS32_IIC_MIDI_PackageSend(package.cable, package);
 8005670:	4630      	mov	r0, r6
 8005672:	4621      	mov	r1, r4
 8005674:	f000 fe6b 	bl	800634e <MIOS32_IIC_MIDI_PackageSend>
      
    default:
      // invalid port
      return -1;
  }
}
 8005678:	bd70      	pop	{r4, r5, r6, pc}
 800567a:	bf00      	nop
 800567c:	20000005 	.word	0x20000005
 8005680:	20000004 	.word	0x20000004
 8005684:	200007a8 	.word	0x200007a8

08005688 <MIOS32_MIDI_SendEvent>:
//! \param[in] evnt2 third MIDI byte
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendEvent(mios32_midi_port_t port, u8 evnt0, u8 evnt1, u8 evnt2)
{
 8005688:	b508      	push	{r3, lr}

  // MEMO: don't optimize this function by calling MIOS32_MIDI_SendSpecialEvent
  // from here, because the 4 * u8 parameter list of this function leads
  // to best compile results (4*u8 combined to a single u32)

  package.type  = evnt0 >> 4;
 800568a:	f04f 0c00 	mov.w	ip, #0
 800568e:	ea4f 1e11 	mov.w	lr, r1, lsr #4
 8005692:	f36e 0c03 	bfi	ip, lr, #0, #4
  package.evnt0 = evnt0;
 8005696:	f361 2c0f 	bfi	ip, r1, #8, #8
  package.evnt1 = evnt1;
 800569a:	f362 4c17 	bfi	ip, r2, #16, #8
  package.evnt2 = evnt2;
 800569e:	f363 6c1f 	bfi	ip, r3, #24, #8
  return MIOS32_MIDI_SendPackage(port, package);
 80056a2:	4661      	mov	r1, ip
 80056a4:	f7ff ffb4 	bl	8005610 <MIOS32_MIDI_SendPackage>
}
 80056a8:	bd08      	pop	{r3, pc}

080056aa <MIOS32_MIDI_SendNoteOn>:

s32 MIOS32_MIDI_SendNoteOff(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x80 | chn, note, vel); }

s32 MIOS32_MIDI_SendNoteOn(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x90 | chn, note, vel); }
 80056aa:	b508      	push	{r3, lr}
 80056ac:	f041 0190 	orr.w	r1, r1, #144	; 0x90
 80056b0:	f7ff ffea 	bl	8005688 <MIOS32_MIDI_SendEvent>
 80056b4:	bd08      	pop	{r3, pc}

080056b6 <MIOS32_MIDI_SendCC>:

s32 MIOS32_MIDI_SendPolyPressure(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xa0 | chn, note, val); }

s32 MIOS32_MIDI_SendCC(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 cc_number, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xb0 | chn, cc_number,   val); }
 80056b6:	b508      	push	{r3, lr}
 80056b8:	f041 01b0 	orr.w	r1, r1, #176	; 0xb0
 80056bc:	f7ff ffe4 	bl	8005688 <MIOS32_MIDI_SendEvent>
 80056c0:	bd08      	pop	{r3, pc}

080056c2 <MIOS32_MIDI_SendSysEx>:
//! \param[in] count number of bytes
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendSysEx(mios32_midi_port_t port, u8 *stream, u32 count)
{
 80056c2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80056c4:	b085      	sub	sp, #20
 80056c6:	4617      	mov	r7, r2
 80056c8:	9003      	str	r0, [sp, #12]
 80056ca:	460d      	mov	r5, r1
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 80056cc:	2600      	movs	r6, #0
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 80056ce:	2306      	movs	r3, #6
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 80056d0:	2207      	movs	r2, #7
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 80056d2:	f04f 0c04 	mov.w	ip, #4
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 80056d6:	e040      	b.n	800575a <MIOS32_MIDI_SendSysEx+0x98>
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 80056d8:	1bb9      	subs	r1, r7, r6
 80056da:	2902      	cmp	r1, #2
 80056dc:	d014      	beq.n	8005708 <MIOS32_MIDI_SendSysEx+0x46>
 80056de:	2903      	cmp	r1, #3
 80056e0:	d01f      	beq.n	8005722 <MIOS32_MIDI_SendSysEx+0x60>
 80056e2:	2901      	cmp	r1, #1
 80056e4:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
 80056e6:	bf18      	it	ne
 80056e8:	f36c 0403 	bfine	r4, ip, #0, #4
 80056ec:	f106 0601 	add.w	r6, r6, #1
	package.evnt0 = stream[offset++];
 80056f0:	bf18      	it	ne
 80056f2:	f361 240f 	bfine	r4, r1, #8, #8

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
    // package type depends on number of remaining bytes
    switch( count-offset ) {
 80056f6:	d11a      	bne.n	800572e <MIOS32_MIDI_SendSysEx+0x6c>
      case 1: 
	package.type = 0x5; // SysEx ends with following single byte. 
 80056f8:	2005      	movs	r0, #5
 80056fa:	f360 0403 	bfi	r4, r0, #0, #4
	package.evnt0 = stream[offset++];
 80056fe:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = 0x00;
 8005702:	f36f 4417 	bfc	r4, #16, #8
 8005706:	e009      	b.n	800571c <MIOS32_MIDI_SendSysEx+0x5a>
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
	package.evnt0 = stream[offset++];
 8005708:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 800570a:	f363 0403 	bfi	r4, r3, #0, #4
	package.evnt0 = stream[offset++];
 800570e:	3601      	adds	r6, #1
 8005710:	f361 240f 	bfi	r4, r1, #8, #8
	package.evnt1 = stream[offset++];
 8005714:	5da9      	ldrb	r1, [r5, r6]
 8005716:	3601      	adds	r6, #1
 8005718:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = 0x00;
 800571c:	f36f 641f 	bfc	r4, #24, #8
	break;
 8005720:	e00d      	b.n	800573e <MIOS32_MIDI_SendSysEx+0x7c>
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
	package.evnt0 = stream[offset++];
 8005722:	5da9      	ldrb	r1, [r5, r6]
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 8005724:	f362 0403 	bfi	r4, r2, #0, #4
	package.evnt0 = stream[offset++];
 8005728:	f361 240f 	bfi	r4, r1, #8, #8
 800572c:	3601      	adds	r6, #1
	package.evnt2 = stream[offset++];
	break;
      default:
	package.type = 0x4; // SysEx starts or continues
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
 800572e:	5da9      	ldrb	r1, [r5, r6]
 8005730:	3601      	adds	r6, #1
 8005732:	f361 4417 	bfi	r4, r1, #16, #8
	package.evnt2 = stream[offset++];
 8005736:	5da9      	ldrb	r1, [r5, r6]
 8005738:	3601      	adds	r6, #1
 800573a:	f361 641f 	bfi	r4, r1, #24, #8
    }

    res=MIOS32_MIDI_SendPackage(port, package);
 800573e:	9803      	ldr	r0, [sp, #12]
 8005740:	4621      	mov	r1, r4
 8005742:	9201      	str	r2, [sp, #4]
 8005744:	9302      	str	r3, [sp, #8]
 8005746:	f8cd c000 	str.w	ip, [sp]
 800574a:	f7ff ff61 	bl	8005610 <MIOS32_MIDI_SendPackage>

    // expection? (e.g., port not available)
    if( res < 0 )
 800574e:	2800      	cmp	r0, #0
 8005750:	9a01      	ldr	r2, [sp, #4]
 8005752:	9b02      	ldr	r3, [sp, #8]
 8005754:	f8dd c000 	ldr.w	ip, [sp]
 8005758:	db02      	blt.n	8005760 <MIOS32_MIDI_SendSysEx+0x9e>
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 800575a:	42be      	cmp	r6, r7
 800575c:	d3bc      	bcc.n	80056d8 <MIOS32_MIDI_SendSysEx+0x16>
    // expection? (e.g., port not available)
    if( res < 0 )
      return res;
  }

  return 0;
 800575e:	2000      	movs	r0, #0
}
 8005760:	b005      	add	sp, #20
 8005762:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005764 <MIOS32_MIDI_SYSEX_SendAckStr>:

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 8005764:	b510      	push	{r4, lr}
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005766:	23f0      	movs	r3, #240	; 0xf0

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
{
 8005768:	b0a0      	sub	sp, #128	; 0x80
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 800576a:	f88d 3000 	strb.w	r3, [sp]
 800576e:	2300      	movs	r3, #0
 8005770:	f88d 3001 	strb.w	r3, [sp, #1]
 8005774:	f88d 3002 	strb.w	r3, [sp, #2]
 8005778:	337e      	adds	r3, #126	; 0x7e
 800577a:	f88d 3003 	strb.w	r3, [sp, #3]
 800577e:	2332      	movs	r3, #50	; 0x32
 8005780:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005784:	4b0e      	ldr	r3, [pc, #56]	; (80057c0 <MIOS32_MIDI_SYSEX_SendAckStr+0x5c>)
}

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
 8005786:	f10d 0c6b 	add.w	ip, sp, #107	; 0x6b

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 800578a:	781b      	ldrb	r3, [r3, #0]
 800578c:	f88d 3005 	strb.w	r3, [sp, #5]

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;
 8005790:	230f      	movs	r3, #15
 8005792:	f88d 3006 	strb.w	r3, [sp, #6]
 8005796:	466b      	mov	r3, sp
 8005798:	1dda      	adds	r2, r3, #7
 800579a:	e003      	b.n	80057a4 <MIOS32_MIDI_SYSEX_SendAckStr+0x40>

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
    *sysex_buffer_ptr++ = str[i];
 800579c:	f802 4b01 	strb.w	r4, [r2], #1

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
 80057a0:	4562      	cmp	r2, ip
 80057a2:	d003      	beq.n	80057ac <MIOS32_MIDI_SYSEX_SendAckStr+0x48>
 80057a4:	f811 4b01 	ldrb.w	r4, [r1], #1
 80057a8:	2c00      	cmp	r4, #0
 80057aa:	d1f7      	bne.n	800579c <MIOS32_MIDI_SYSEX_SendAckStr+0x38>
    *sysex_buffer_ptr++ = str[i];

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 80057ac:	21f7      	movs	r1, #247	; 0xf7
 80057ae:	f802 1b01 	strb.w	r1, [r2], #1

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80057b2:	1ad2      	subs	r2, r2, r3
 80057b4:	4669      	mov	r1, sp
 80057b6:	f7ff ff84 	bl	80056c2 <MIOS32_MIDI_SendSysEx>
}
 80057ba:	b020      	add	sp, #128	; 0x80
 80057bc:	bd10      	pop	{r4, pc}
 80057be:	bf00      	nop
 80057c0:	200007b5 	.word	0x200007b5

080057c4 <MIOS32_MIDI_SYSEX_SendAck>:
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 80057c4:	b500      	push	{lr}
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 80057c6:	23f0      	movs	r3, #240	; 0xf0
/////////////////////////////////////////////////////////////////////////////
// This function sends a SysEx acknowledge to notify the user about the received command
// expects acknowledge code (e.g. 0x0f for good, 0x0e for error) and additional argument
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
{
 80057c8:	b089      	sub	sp, #36	; 0x24
  u8 sysex_buffer[32]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 80057ca:	f88d 3000 	strb.w	r3, [sp]
 80057ce:	2300      	movs	r3, #0
 80057d0:	f88d 3001 	strb.w	r3, [sp, #1]
 80057d4:	f88d 3002 	strb.w	r3, [sp, #2]
 80057d8:	337e      	adds	r3, #126	; 0x7e
 80057da:	f88d 3003 	strb.w	r3, [sp, #3]
 80057de:	2332      	movs	r3, #50	; 0x32
 80057e0:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80057e4:	4b08      	ldr	r3, [pc, #32]	; (8005808 <MIOS32_MIDI_SYSEX_SendAck+0x44>)

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
 80057e6:	f88d 1006 	strb.w	r1, [sp, #6]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80057ea:	781b      	ldrb	r3, [r3, #0]

  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;
 80057ec:	f88d 2007 	strb.w	r2, [sp, #7]

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 80057f0:	f88d 3005 	strb.w	r3, [sp, #5]

  // send footer
  *sysex_buffer_ptr++ = 0xf7;

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80057f4:	4669      	mov	r1, sp
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 80057f6:	23f7      	movs	r3, #247	; 0xf7

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80057f8:	2209      	movs	r2, #9
  // send ack code and argument
  *sysex_buffer_ptr++ = ack_code;
  *sysex_buffer_ptr++ = ack_arg;

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 80057fa:	f88d 3008 	strb.w	r3, [sp, #8]

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 80057fe:	f7ff ff60 	bl	80056c2 <MIOS32_MIDI_SendSysEx>
}
 8005802:	b009      	add	sp, #36	; 0x24
 8005804:	bd00      	pop	{pc}
 8005806:	bf00      	nop
 8005808:	200007b5 	.word	0x200007b5

0800580c <MIOS32_MIDI_SendDebugMessage>:
//! \param[in] *format zero-terminated format string - 128 characters supported maximum!
//! \param ... additional arguments
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendDebugMessage(char *format, ...)
{
 800580c:	b40f      	push	{r0, r1, r2, r3}
 800580e:	b530      	push	{r4, r5, lr}
 8005810:	b0a5      	sub	sp, #148	; 0x94
 8005812:	9c28      	ldr	r4, [sp, #160]	; 0xa0

  // failsave: if format string is longer than 100 chars, break here
  // note that this is a weak protection: if %s is used, or a lot of other format tokens,
  // the resulting string could still lead to a buffer overflow
  // other the other hand we don't want to allocate too many byte for buffer[] to save stack
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
 8005814:	ad02      	add	r5, sp, #8
  if( strlen(format) > 100 ) {
 8005816:	4620      	mov	r0, r4
 8005818:	f004 fe1a 	bl	800a450 <strlen>
 800581c:	2864      	cmp	r0, #100	; 0x64
 800581e:	d91e      	bls.n	800585e <MIOS32_MIDI_SendDebugMessage+0x52>
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
 8005820:	4628      	mov	r0, r5
 8005822:	4920      	ldr	r1, [pc, #128]	; (80058a4 <MIOS32_MIDI_SendDebugMessage+0x98>)
 8005824:	f004 fe0d 	bl	800a442 <strcpy>
    vsprintf(str, format, args);
  }

  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8005828:	23f0      	movs	r3, #240	; 0xf0
 800582a:	f88d 3000 	strb.w	r3, [sp]
 800582e:	2300      	movs	r3, #0
 8005830:	f88d 3001 	strb.w	r3, [sp, #1]
 8005834:	f88d 3002 	strb.w	r3, [sp, #2]
 8005838:	337e      	adds	r3, #126	; 0x7e
 800583a:	f88d 3003 	strb.w	r3, [sp, #3]
 800583e:	2332      	movs	r3, #50	; 0x32
 8005840:	f88d 3004 	strb.w	r3, [sp, #4]

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005844:	4b18      	ldr	r3, [pc, #96]	; (80058a8 <MIOS32_MIDI_SendDebugMessage+0x9c>)

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
 8005846:	2208      	movs	r2, #8
  u8 *sysex_buffer_ptr = buffer;
  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8005848:	781b      	ldrb	r3, [r3, #0]
 800584a:	f88d 3005 	strb.w	r3, [sp, #5]

  // debug message: ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_DEBUG;
 800584e:	230d      	movs	r3, #13
 8005850:	f88d 3006 	strb.w	r3, [sp, #6]

  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string
 8005854:	3333      	adds	r3, #51	; 0x33
 8005856:	f88d 3007 	strb.w	r3, [sp, #7]
 800585a:	ab02      	add	r3, sp, #8
 800585c:	e00f      	b.n	800587e <MIOS32_MIDI_SendDebugMessage+0x72>
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 800585e:	aa29      	add	r2, sp, #164	; 0xa4
    vsprintf(str, format, args);
 8005860:	4628      	mov	r0, r5
 8005862:	4621      	mov	r1, r4
  char *str = (char *)((size_t)buffer+sizeof(mios32_midi_sysex_header)+3);
  if( strlen(format) > 100 ) {
    strcpy(str, "(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
  } else {
    // transform formatted string into string
    va_start(args, format);
 8005864:	9223      	str	r2, [sp, #140]	; 0x8c
    vsprintf(str, format, args);
 8005866:	f003 f85c 	bl	8008922 <vsprintf>
 800586a:	e7dd      	b.n	8005828 <MIOS32_MIDI_SendDebugMessage+0x1c>

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
 800586c:	3201      	adds	r2, #1
 800586e:	b292      	uxth	r2, r2
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 8005870:	f000 007f 	and.w	r0, r0, #127	; 0x7f
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 8005874:	2a88      	cmp	r2, #136	; 0x88
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 8005876:	f803 0c01 	strb.w	r0, [r3, #-1]
 800587a:	4619      	mov	r1, r3
  // command identifier
  *sysex_buffer_ptr++ = 0x40; // output string

  // search end of string and determine length
  u16 len = sizeof(mios32_midi_sysex_header) + 3;
  for(i=0; i<128 && (*sysex_buffer_ptr != 0); ++i) {
 800587c:	d004      	beq.n	8005888 <MIOS32_MIDI_SendDebugMessage+0x7c>
 800587e:	4619      	mov	r1, r3
 8005880:	f813 0b01 	ldrb.w	r0, [r3], #1
 8005884:	2800      	cmp	r0, #0
 8005886:	d1f1      	bne.n	800586c <MIOS32_MIDI_SendDebugMessage+0x60>
    *sysex_buffer_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8005888:	23f7      	movs	r3, #247	; 0xf7
 800588a:	700b      	strb	r3, [r1, #0]
  ++len;

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 800588c:	4b07      	ldr	r3, [pc, #28]	; (80058ac <MIOS32_MIDI_SendDebugMessage+0xa0>)
    ++len;
  }

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
  ++len;
 800588e:	3201      	adds	r2, #1

  return MIOS32_MIDI_SendSysEx(debug_port, buffer, len);
 8005890:	7818      	ldrb	r0, [r3, #0]
 8005892:	b292      	uxth	r2, r2
 8005894:	4669      	mov	r1, sp
 8005896:	f7ff ff14 	bl	80056c2 <MIOS32_MIDI_SendSysEx>
}
 800589a:	b025      	add	sp, #148	; 0x94
 800589c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80058a0:	b004      	add	sp, #16
 80058a2:	4770      	bx	lr
 80058a4:	0800adbc 	.word	0x0800adbc
 80058a8:	200007b5 	.word	0x200007b5
 80058ac:	20000005 	.word	0x20000005

080058b0 <MIOS32_MIDI_SYSEX_Cmd>:

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 80058b0:	b530      	push	{r4, r5, lr}
 80058b2:	460b      	mov	r3, r1
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 80058b4:	4959      	ldr	r1, [pc, #356]	; (8005a1c <MIOS32_MIDI_SYSEX_Cmd+0x16c>)

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 80058b6:	b08b      	sub	sp, #44	; 0x2c
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 80058b8:	7809      	ldrb	r1, [r1, #0]

/////////////////////////////////////////////////////////////////////////////
// This function handles the sysex commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
 80058ba:	4604      	mov	r4, r0
#if MIOS32_MIDI_BSL_ENHANCEMENTS
  // this compile switch should only be activated for the bootloader!
  if( BSL_SYSEX_Cmd(port, cmd_state, midi_in, sysex_cmd) >= 0 )
    return 0; // BSL has serviced this command - no error
#endif
  switch( sysex_cmd ) {
 80058bc:	290d      	cmp	r1, #13
 80058be:	d05e      	beq.n	800597e <MIOS32_MIDI_SYSEX_Cmd+0xce>
 80058c0:	d801      	bhi.n	80058c6 <MIOS32_MIDI_SYSEX_Cmd+0x16>
 80058c2:	b139      	cbz	r1, 80058d4 <MIOS32_MIDI_SYSEX_Cmd+0x24>
 80058c4:	e09d      	b.n	8005a02 <MIOS32_MIDI_SYSEX_Cmd+0x152>
 80058c6:	290e      	cmp	r1, #14
 80058c8:	f000 80a5 	beq.w	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
 80058cc:	290f      	cmp	r1, #15
 80058ce:	f040 8098 	bne.w	8005a02 <MIOS32_MIDI_SYSEX_Cmd+0x152>
 80058d2:	e08a      	b.n	80059ea <MIOS32_MIDI_SYSEX_Cmd+0x13a>
static s32 MIOS32_MIDI_SYSEX_Cmd_Query(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 query_req = 0;
  char str_buffer[40];

  switch( cmd_state ) {
 80058d4:	b11b      	cbz	r3, 80058de <MIOS32_MIDI_SYSEX_Cmd+0x2e>
 80058d6:	2b01      	cmp	r3, #1
 80058d8:	4b51      	ldr	r3, [pc, #324]	; (8005a20 <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 80058da:	d102      	bne.n	80058e2 <MIOS32_MIDI_SYSEX_Cmd+0x32>
 80058dc:	e056      	b.n	800598c <MIOS32_MIDI_SYSEX_Cmd+0xdc>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      query_req = 0;
 80058de:	4a50      	ldr	r2, [pc, #320]	; (8005a20 <MIOS32_MIDI_SYSEX_Cmd+0x170>)
 80058e0:	e098      	b.n	8005a14 <MIOS32_MIDI_SYSEX_Cmd+0x164>
    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      query_req = midi_in;
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      switch( query_req ) {
 80058e2:	781b      	ldrb	r3, [r3, #0]
 80058e4:	2b05      	cmp	r3, #5
 80058e6:	d025      	beq.n	8005934 <MIOS32_MIDI_SYSEX_Cmd+0x84>
 80058e8:	d80a      	bhi.n	8005900 <MIOS32_MIDI_SYSEX_Cmd+0x50>
 80058ea:	2b02      	cmp	r3, #2
 80058ec:	d017      	beq.n	800591e <MIOS32_MIDI_SYSEX_Cmd+0x6e>
 80058ee:	d802      	bhi.n	80058f6 <MIOS32_MIDI_SYSEX_Cmd+0x46>
 80058f0:	2b01      	cmp	r3, #1
 80058f2:	d140      	bne.n	8005976 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80058f4:	e011      	b.n	800591a <MIOS32_MIDI_SYSEX_Cmd+0x6a>
 80058f6:	2b03      	cmp	r3, #3
 80058f8:	d013      	beq.n	8005922 <MIOS32_MIDI_SYSEX_Cmd+0x72>
 80058fa:	2b04      	cmp	r3, #4
 80058fc:	d13b      	bne.n	8005976 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 80058fe:	e012      	b.n	8005926 <MIOS32_MIDI_SYSEX_Cmd+0x76>
 8005900:	2b08      	cmp	r3, #8
 8005902:	d02f      	beq.n	8005964 <MIOS32_MIDI_SYSEX_Cmd+0xb4>
 8005904:	d804      	bhi.n	8005910 <MIOS32_MIDI_SYSEX_Cmd+0x60>
 8005906:	2b06      	cmp	r3, #6
 8005908:	d01e      	beq.n	8005948 <MIOS32_MIDI_SYSEX_Cmd+0x98>
 800590a:	2b07      	cmp	r3, #7
 800590c:	d133      	bne.n	8005976 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 800590e:	e01e      	b.n	800594e <MIOS32_MIDI_SYSEX_Cmd+0x9e>
 8005910:	2b09      	cmp	r3, #9
 8005912:	d029      	beq.n	8005968 <MIOS32_MIDI_SYSEX_Cmd+0xb8>
 8005914:	2b7f      	cmp	r3, #127	; 0x7f
 8005916:	d12e      	bne.n	8005976 <MIOS32_MIDI_SYSEX_Cmd+0xc6>
 8005918:	e02a      	b.n	8005970 <MIOS32_MIDI_SYSEX_Cmd+0xc0>
        case 0x01: // operating system
	  MIOS32_MIDI_SYSEX_SendAckStr(port, "MIOS32");
 800591a:	4942      	ldr	r1, [pc, #264]	; (8005a24 <MIOS32_MIDI_SYSEX_Cmd+0x174>)
 800591c:	e025      	b.n	800596a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x02: // Board
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_BOARD_STR);
 800591e:	4942      	ldr	r1, [pc, #264]	; (8005a28 <MIOS32_MIDI_SYSEX_Cmd+0x178>)
 8005920:	e023      	b.n	800596a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x03: // Core Family
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_FAMILY_STR);
 8005922:	4942      	ldr	r1, [pc, #264]	; (8005a2c <MIOS32_MIDI_SYSEX_Cmd+0x17c>)
 8005924:	e021      	b.n	800596a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
 8005926:	f000 fd5b 	bl	80063e0 <MIOS32_SYS_ChipIDGet>
 800592a:	466d      	mov	r5, sp
 800592c:	4602      	mov	r2, r0
 800592e:	4940      	ldr	r1, [pc, #256]	; (8005a30 <MIOS32_MIDI_SYSEX_Cmd+0x180>)
 8005930:	4668      	mov	r0, sp
 8005932:	e012      	b.n	800595a <MIOS32_MIDI_SYSEX_Cmd+0xaa>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 8005934:	4668      	mov	r0, sp
 8005936:	f000 fd69 	bl	800640c <MIOS32_SYS_SerialNumberGet>
 800593a:	2800      	cmp	r0, #0
 800593c:	466d      	mov	r5, sp
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
 800593e:	bfbc      	itt	lt
 8005940:	4620      	movlt	r0, r4
 8005942:	493c      	ldrlt	r1, [pc, #240]	; (8005a34 <MIOS32_MIDI_SYSEX_Cmd+0x184>)
        case 0x04: // Chip ID
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
	  MIOS32_MIDI_SYSEX_SendAckStr(port, (char *)str_buffer);
	  break;
        case 0x05: // Serial Number
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 8005944:	da0b      	bge.n	800595e <MIOS32_MIDI_SYSEX_Cmd+0xae>
 8005946:	e010      	b.n	800596a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	    MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  else
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
	  break;
        case 0x06: // Flash Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_FlashSizeGet());
 8005948:	f000 fd50 	bl	80063ec <MIOS32_SYS_FlashSizeGet>
 800594c:	e001      	b.n	8005952 <MIOS32_MIDI_SYSEX_Cmd+0xa2>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
	  break;
        case 0x07: // RAM Memory Size
	  sprintf(str_buffer, "%d", MIOS32_SYS_RAMSizeGet());
 800594e:	f000 fd55 	bl	80063fc <MIOS32_SYS_RAMSizeGet>
 8005952:	4939      	ldr	r1, [pc, #228]	; (8005a38 <MIOS32_MIDI_SYSEX_Cmd+0x188>)
 8005954:	4602      	mov	r2, r0
 8005956:	466d      	mov	r5, sp
 8005958:	4668      	mov	r0, sp
 800595a:	f002 ffd3 	bl	8008904 <sprintf>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
 800595e:	4620      	mov	r0, r4
 8005960:	4669      	mov	r1, sp
 8005962:	e002      	b.n	800596a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x08: // Application Name Line #1
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE1);
 8005964:	4935      	ldr	r1, [pc, #212]	; (8005a3c <MIOS32_MIDI_SYSEX_Cmd+0x18c>)
 8005966:	e000      	b.n	800596a <MIOS32_MIDI_SYSEX_Cmd+0xba>
	  break;
        case 0x09: // Application Name Line #2
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE2);
 8005968:	4935      	ldr	r1, [pc, #212]	; (8005a40 <MIOS32_MIDI_SYSEX_Cmd+0x190>)
 800596a:	f7ff fefb 	bl	8005764 <MIOS32_MIDI_SYSEX_SendAckStr>
 800596e:	e052      	b.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
#if MIOS32_MIDI_BSL_ENHANCEMENTS
	  // release halt state (or sending upload request) instead of reseting the core
	  BSL_SYSEX_ReleaseHaltState();
#else
	  // reset core (this will send an upload request)
	  MIOS32_SYS_Reset();
 8005970:	f000 fcfa 	bl	8006368 <MIOS32_SYS_Reset>
 8005974:	e04f      	b.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  // but other core families could contain an empty stumb!
#endif
	  break;
        default: 
	  // unknown query
	  MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNKNOWN_QUERY);
 8005976:	4620      	mov	r0, r4
 8005978:	210e      	movs	r1, #14
 800597a:	220d      	movs	r2, #13
 800597c:	e03e      	b.n	80059fc <MIOS32_MIDI_SYSEX_Cmd+0x14c>
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Debug(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  static u8 debug_req = 0xff;

  switch( cmd_state ) {
 800597e:	b11b      	cbz	r3, 8005988 <MIOS32_MIDI_SYSEX_Cmd+0xd8>
 8005980:	2b01      	cmp	r3, #1
 8005982:	4d30      	ldr	r5, [pc, #192]	; (8005a44 <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 8005984:	d114      	bne.n	80059b0 <MIOS32_MIDI_SYSEX_Cmd+0x100>
 8005986:	e003      	b.n	8005990 <MIOS32_MIDI_SYSEX_Cmd+0xe0>

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
 8005988:	4b2e      	ldr	r3, [pc, #184]	; (8005a44 <MIOS32_MIDI_SYSEX_Cmd+0x194>)
 800598a:	22ff      	movs	r2, #255	; 0xff
 800598c:	701a      	strb	r2, [r3, #0]
 800598e:	e042      	b.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005990:	782b      	ldrb	r3, [r5, #0]
 8005992:	2bff      	cmp	r3, #255	; 0xff
	debug_req = midi_in;
 8005994:	bf08      	it	eq
 8005996:	702a      	strbeq	r2, [r5, #0]
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      debug_req = 0xff;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      if( debug_req == 0xff ) {
 8005998:	d03d      	beq.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	debug_req = midi_in;
      } else {
	switch( debug_req ) {
 800599a:	2b00      	cmp	r3, #0
 800599c:	d13b      	bne.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  case 0x00: // input string
	    if( debug_command_callback_func != NULL )
 800599e:	4b2a      	ldr	r3, [pc, #168]	; (8005a48 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 80059a0:	681b      	ldr	r3, [r3, #0]
 80059a2:	2b00      	cmp	r3, #0
 80059a4:	d037      	beq.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	      debug_command_callback_func(last_sysex_port, (char)midi_in);
 80059a6:	4929      	ldr	r1, [pc, #164]	; (8005a4c <MIOS32_MIDI_SYSEX_Cmd+0x19c>)
 80059a8:	7808      	ldrb	r0, [r1, #0]
 80059aa:	4611      	mov	r1, r2
 80059ac:	4798      	blx	r3
 80059ae:	e032      	b.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	}
      }
      break;

    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      if( debug_req == 0x00 ) {
 80059b0:	782a      	ldrb	r2, [r5, #0]
 80059b2:	b9ba      	cbnz	r2, 80059e4 <MIOS32_MIDI_SYSEX_Cmd+0x134>
	// send acknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 80059b4:	210f      	movs	r1, #15
 80059b6:	f7ff ff05 	bl	80057c4 <MIOS32_MIDI_SYSEX_SendAck>

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
 80059ba:	782b      	ldrb	r3, [r5, #0]
 80059bc:	2b00      	cmp	r3, #0
 80059be:	d12a      	bne.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
 80059c0:	4b21      	ldr	r3, [pc, #132]	; (8005a48 <MIOS32_MIDI_SYSEX_Cmd+0x198>)
 80059c2:	681b      	ldr	r3, [r3, #0]
 80059c4:	2b00      	cmp	r3, #0
 80059c6:	d126      	bne.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 80059c8:	4b21      	ldr	r3, [pc, #132]	; (8005a50 <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 80059ca:	2c01      	cmp	r4, #1
//! This function returns the MIDI_DEBUG port
//! \return the debug port
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIOS32_MIDI_DebugPortGet(void)
{
  return debug_port;
 80059cc:	781d      	ldrb	r5, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 80059ce:	4821      	ldr	r0, [pc, #132]	; (8005a54 <MIOS32_MIDI_SYSEX_Cmd+0x1a4>)
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
    return -1;

  debug_port = port;
 80059d0:	bf18      	it	ne
 80059d2:	701c      	strbne	r4, [r3, #0]
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);

	if( debug_req == 0 && debug_command_callback_func == NULL ) {
	  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
	  MIOS32_MIDI_DebugPortSet(port);
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n", port);
 80059d4:	4621      	mov	r1, r4
 80059d6:	f7ff ff19 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
//! \param[in] port MIDI port (USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_DebugPortSet(mios32_midi_port_t port)
{
  if( port == MIDI_DEBUG ) // avoid recursion
 80059da:	2d01      	cmp	r5, #1
    return -1;

  debug_port = port;
 80059dc:	bf1c      	itt	ne
 80059de:	4b1c      	ldrne	r3, [pc, #112]	; (8005a50 <MIOS32_MIDI_SYSEX_Cmd+0x1a0>)
 80059e0:	701d      	strbne	r5, [r3, #0]
 80059e2:	e018      	b.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	  MIOS32_MIDI_DebugPortSet(prev_debug_port);
	}

      } else {
	// send disacknowledge
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNSUPPORTED_DEBUG);
 80059e4:	210e      	movs	r1, #14
 80059e6:	2210      	movs	r2, #16
 80059e8:	e008      	b.n	80059fc <MIOS32_MIDI_SYSEX_Cmd+0x14c>
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {

    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
 80059ea:	4a1b      	ldr	r2, [pc, #108]	; (8005a58 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
/////////////////////////////////////////////////////////////////////////////
// Command 0F: Ping (just send back acknowledge if no additional byte has been received)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Cmd_Ping(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
{
  switch( cmd_state ) {
 80059ec:	b113      	cbz	r3, 80059f4 <MIOS32_MIDI_SYSEX_Cmd+0x144>
 80059ee:	2b01      	cmp	r3, #1
 80059f0:	4a19      	ldr	r2, [pc, #100]	; (8005a58 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 80059f2:	d101      	bne.n	80059f8 <MIOS32_MIDI_SYSEX_Cmd+0x148>
    case MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN:
      sysex_state.PING_BYTE_RECEIVED = 0;
      break;

    case MIOS32_MIDI_SYSEX_CMD_STATE_CONT:
      sysex_state.PING_BYTE_RECEIVED = 1;
 80059f4:	6053      	str	r3, [r2, #4]
 80059f6:	e00e      	b.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
    default: // MIOS32_MIDI_SYSEX_CMD_STATE_END
      // TODO: send 0xf7 if merger enabled

      // send acknowledge if no additional byte has been received
      // to avoid feedback loop if two cores are directly connected
      if( !sysex_state.PING_BYTE_RECEIVED )
 80059f8:	6852      	ldr	r2, [r2, #4]
 80059fa:	b962      	cbnz	r2, 8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 80059fc:	f7ff fee2 	bl	80057c4 <MIOS32_MIDI_SYSEX_SendAck>
 8005a00:	e009      	b.n	8005a16 <MIOS32_MIDI_SYSEX_Cmd+0x166>
      MIOS32_MIDI_SYSEX_Cmd_Ping(port, cmd_state, midi_in);
      break;
    default:
      // unknown command
      // TODO: send 0xf7 if merger enabled
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
 8005a02:	210e      	movs	r1, #14
 8005a04:	460a      	mov	r2, r1
 8005a06:	4620      	mov	r0, r4
 8005a08:	f7ff fedc 	bl	80057c4 <MIOS32_MIDI_SYSEX_SendAck>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005a0c:	4a12      	ldr	r2, [pc, #72]	; (8005a58 <MIOS32_MIDI_SYSEX_Cmd+0x1a8>)
 8005a0e:	2300      	movs	r3, #0
 8005a10:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005a12:	4a02      	ldr	r2, [pc, #8]	; (8005a1c <MIOS32_MIDI_SYSEX_Cmd+0x16c>)
 8005a14:	7013      	strb	r3, [r2, #0]
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
      MIOS32_MIDI_SYSEX_CmdFinished();      
  }

  return 0; // no error
}
 8005a16:	2000      	movs	r0, #0
 8005a18:	b00b      	add	sp, #44	; 0x2c
 8005a1a:	bd30      	pop	{r4, r5, pc}
 8005a1c:	200007ac 	.word	0x200007ac
 8005a20:	200007b8 	.word	0x200007b8
 8005a24:	0800ae0f 	.word	0x0800ae0f
 8005a28:	0800ae16 	.word	0x0800ae16
 8005a2c:	0800ae26 	.word	0x0800ae26
 8005a30:	0800ae30 	.word	0x0800ae30
 8005a34:	0800ae35 	.word	0x0800ae35
 8005a38:	0800ae37 	.word	0x0800ae37
 8005a3c:	0800ad78 	.word	0x0800ad78
 8005a40:	0800ad89 	.word	0x0800ad89
 8005a44:	20000006 	.word	0x20000006
 8005a48:	200007c4 	.word	0x200007c4
 8005a4c:	200007b4 	.word	0x200007b4
 8005a50:	20000005 	.word	0x20000005
 8005a54:	0800ae3a 	.word	0x0800ae3a
 8005a58:	200007bc 	.word	0x200007bc

08005a5c <MIOS32_MIDI_SYSEX_Parser>:
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005a5c:	29f7      	cmp	r1, #247	; 0xf7

/////////////////////////////////////////////////////////////////////////////
// This function parses an incoming sysex stream for MIOS32 commands
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
{
 8005a5e:	b510      	push	{r4, lr}
 8005a60:	460a      	mov	r2, r1
  // ignore realtime messages (see MIDI spec - realtime messages can
  // always be injected into events/streams, and don't change the running status)
  if( midi_in >= 0xf8 )
 8005a62:	d85c      	bhi.n	8005b1e <MIOS32_MIDI_SYSEX_Parser+0xc2>
    return 0;

  // TODO: here we could send an error notification, that multiple devices are trying to access the device
  if( sysex_state.MY_SYSEX && port != last_sysex_port )
 8005a64:	4b2f      	ldr	r3, [pc, #188]	; (8005b24 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005a66:	781c      	ldrb	r4, [r3, #0]
 8005a68:	f004 0308 	and.w	r3, r4, #8
 8005a6c:	b2db      	uxtb	r3, r3
 8005a6e:	b11b      	cbz	r3, 8005a78 <MIOS32_MIDI_SYSEX_Parser+0x1c>
 8005a70:	492d      	ldr	r1, [pc, #180]	; (8005b28 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005a72:	7809      	ldrb	r1, [r1, #0]
 8005a74:	4281      	cmp	r1, r0
 8005a76:	d14f      	bne.n	8005b18 <MIOS32_MIDI_SYSEX_Parser+0xbc>
  // USB upload is only allowed via USB0
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
 8005a78:	f1a0 0111 	sub.w	r1, r0, #17
 8005a7c:	b2c9      	uxtb	r1, r1
 8005a7e:	2906      	cmp	r1, #6
 8005a80:	d94a      	bls.n	8005b18 <MIOS32_MIDI_SYSEX_Parser+0xbc>
    return -1;

  last_sysex_port = port;
 8005a82:	4929      	ldr	r1, [pc, #164]	; (8005b28 <MIOS32_MIDI_SYSEX_Parser+0xcc>)
 8005a84:	7008      	strb	r0, [r1, #0]

  // branch depending on state
  if( !sysex_state.MY_SYSEX ) {
 8005a86:	bb0b      	cbnz	r3, 8005acc <MIOS32_MIDI_SYSEX_Parser+0x70>
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
 8005a88:	4b26      	ldr	r3, [pc, #152]	; (8005b24 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005a8a:	781b      	ldrb	r3, [r3, #0]
 8005a8c:	f003 0307 	and.w	r3, r3, #7
 8005a90:	2b04      	cmp	r3, #4
 8005a92:	d803      	bhi.n	8005a9c <MIOS32_MIDI_SYSEX_Parser+0x40>
 8005a94:	4925      	ldr	r1, [pc, #148]	; (8005b2c <MIOS32_MIDI_SYSEX_Parser+0xd0>)
 8005a96:	5cc9      	ldrb	r1, [r1, r3]
 8005a98:	4291      	cmp	r1, r2
 8005a9a:	d123      	bne.n	8005ae4 <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005a9c:	f004 0407 	and.w	r4, r4, #7
 8005aa0:	2c05      	cmp	r4, #5
 8005aa2:	d103      	bne.n	8005aac <MIOS32_MIDI_SYSEX_Parser+0x50>
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
 8005aa4:	4922      	ldr	r1, [pc, #136]	; (8005b30 <MIOS32_MIDI_SYSEX_Parser+0xd4>)
 8005aa6:	7809      	ldrb	r1, [r1, #0]
 8005aa8:	4291      	cmp	r1, r2
 8005aaa:	d11b      	bne.n	8005ae4 <MIOS32_MIDI_SYSEX_Parser+0x88>
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005aac:	3301      	adds	r3, #1
 8005aae:	f003 0207 	and.w	r2, r3, #7
 8005ab2:	4b1c      	ldr	r3, [pc, #112]	; (8005b24 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005ab4:	2a05      	cmp	r2, #5
 8005ab6:	7819      	ldrb	r1, [r3, #0]
 8005ab8:	f362 0102 	bfi	r1, r2, #0, #3
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005abc:	bf84      	itt	hi
 8005abe:	b2ca      	uxtbhi	r2, r1
 8005ac0:	f042 0208 	orrhi.w	r2, r2, #8
    if( (sysex_state.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.CTR]) ||
	(sysex_state.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
      // incoming byte doesn't match
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      if( ++sysex_state.CTR > sizeof(mios32_midi_sysex_header) ) {
 8005ac4:	7019      	strb	r1, [r3, #0]
	// complete header received, waiting for data
	sysex_state.MY_SYSEX = 1;
 8005ac6:	bf88      	it	hi
 8005ac8:	701a      	strbhi	r2, [r3, #0]
 8005aca:	e028      	b.n	8005b1e <MIOS32_MIDI_SYSEX_Parser+0xc2>
      }
    }
  } else {
    // check for end of SysEx message or invalid status byte
    if( midi_in >= 0x80 ) {
 8005acc:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005ad0:	d00e      	beq.n	8005af0 <MIOS32_MIDI_SYSEX_Parser+0x94>
      if( midi_in == 0xf7 && sysex_state.CMD ) {
 8005ad2:	2af7      	cmp	r2, #247	; 0xf7
 8005ad4:	d106      	bne.n	8005ae4 <MIOS32_MIDI_SYSEX_Parser+0x88>
 8005ad6:	f004 0410 	and.w	r4, r4, #16
 8005ada:	b2e4      	uxtb	r4, r4
 8005adc:	b114      	cbz	r4, 8005ae4 <MIOS32_MIDI_SYSEX_Parser+0x88>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
 8005ade:	2102      	movs	r1, #2
 8005ae0:	f7ff fee6 	bl	80058b0 <MIOS32_MIDI_SYSEX_Cmd>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005ae4:	4b0f      	ldr	r3, [pc, #60]	; (8005b24 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005ae6:	2000      	movs	r0, #0
 8005ae8:	7018      	strb	r0, [r3, #0]
  sysex_cmd = 0;
 8005aea:	4b12      	ldr	r3, [pc, #72]	; (8005b34 <MIOS32_MIDI_SYSEX_Parser+0xd8>)
 8005aec:	7018      	strb	r0, [r3, #0]
 8005aee:	e017      	b.n	8005b20 <MIOS32_MIDI_SYSEX_Parser+0xc4>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
      }
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
 8005af0:	f004 0410 	and.w	r4, r4, #16
 8005af4:	b2e4      	uxtb	r4, r4
 8005af6:	b95c      	cbnz	r4, 8005b10 <MIOS32_MIDI_SYSEX_Parser+0xb4>
	sysex_state.CMD = 1;
 8005af8:	4b0a      	ldr	r3, [pc, #40]	; (8005b24 <MIOS32_MIDI_SYSEX_Parser+0xc8>)
 8005afa:	7819      	ldrb	r1, [r3, #0]
 8005afc:	f041 0110 	orr.w	r1, r1, #16
 8005b00:	7019      	strb	r1, [r3, #0]
	sysex_cmd = midi_in;
 8005b02:	4b0c      	ldr	r3, [pc, #48]	; (8005b34 <MIOS32_MIDI_SYSEX_Parser+0xd8>)
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005b04:	4621      	mov	r1, r4
      MIOS32_MIDI_SYSEX_CmdFinished();
    } else {
      // check if command byte has been received
      if( !sysex_state.CMD ) {
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
 8005b06:	701a      	strb	r2, [r3, #0]
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
 8005b08:	f7ff fed2 	bl	80058b0 <MIOS32_MIDI_SYSEX_Cmd>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005b0c:	4620      	mov	r0, r4
 8005b0e:	e007      	b.n	8005b20 <MIOS32_MIDI_SYSEX_Parser+0xc4>
	sysex_state.CMD = 1;
	sysex_cmd = midi_in;
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_BEGIN, midi_in);
      }
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
 8005b10:	2101      	movs	r1, #1
 8005b12:	f7ff fecd 	bl	80058b0 <MIOS32_MIDI_SYSEX_Cmd>
 8005b16:	e002      	b.n	8005b1e <MIOS32_MIDI_SYSEX_Parser+0xc2>
  // this covers the scenario where other USB1..7 ports are used for MIDI Port forwarding, and a MIOS8 core
  // is connected to one of these ports
  // MIOS Studio reports "Detected MIOS8 and MIOS32 response - selection not supported yet!" in this case
  // By ignoring >= USB1 <= USB7 we have at least a workaround which works (for example) for MIDIbox LC
  if( port >= USB1 && port <= USB7 )
    return -1;
 8005b18:	f04f 30ff 	mov.w	r0, #4294967295
 8005b1c:	e000      	b.n	8005b20 <MIOS32_MIDI_SYSEX_Parser+0xc4>
      else
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
    }
  }

  return 0; // no error
 8005b1e:	2000      	movs	r0, #0
}
 8005b20:	bd10      	pop	{r4, pc}
 8005b22:	bf00      	nop
 8005b24:	200007bc 	.word	0x200007bc
 8005b28:	200007b4 	.word	0x200007b4
 8005b2c:	0800aed8 	.word	0x0800aed8
 8005b30:	200007b5 	.word	0x200007b5
 8005b34:	200007ac 	.word	0x200007ac

08005b38 <MIOS32_MIDI_TimeOut>:

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005b38:	b510      	push	{r4, lr}
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005b3a:	4a0d      	ldr	r2, [pc, #52]	; (8005b70 <MIOS32_MIDI_TimeOut+0x38>)

/////////////////////////////////////////////////////////////////////////////
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
 8005b3c:	4604      	mov	r4, r0
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
 8005b3e:	7813      	ldrb	r3, [r2, #0]
 8005b40:	f003 0308 	and.w	r3, r3, #8
 8005b44:	b2db      	uxtb	r3, r3
 8005b46:	b13b      	cbz	r3, 8005b58 <MIOS32_MIDI_TimeOut+0x20>
 8005b48:	4b0a      	ldr	r3, [pc, #40]	; (8005b74 <MIOS32_MIDI_TimeOut+0x3c>)
 8005b4a:	781b      	ldrb	r3, [r3, #0]
 8005b4c:	4283      	cmp	r3, r0
 8005b4e:	d103      	bne.n	8005b58 <MIOS32_MIDI_TimeOut+0x20>
// an invalid message
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_CmdFinished(void)
{
  // clear all status variables
  sysex_state.ALL = 0;
 8005b50:	2300      	movs	r3, #0
 8005b52:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8005b54:	4a08      	ldr	r2, [pc, #32]	; (8005b78 <MIOS32_MIDI_TimeOut+0x40>)
 8005b56:	7013      	strb	r3, [r2, #0]
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.MY_SYSEX && port == last_sysex_port )
    MIOS32_MIDI_SYSEX_CmdFinished();

  // optional hook to application
  if( timeout_callback_func != NULL )
 8005b58:	4b08      	ldr	r3, [pc, #32]	; (8005b7c <MIOS32_MIDI_TimeOut+0x44>)
 8005b5a:	681b      	ldr	r3, [r3, #0]
 8005b5c:	b10b      	cbz	r3, 8005b62 <MIOS32_MIDI_TimeOut+0x2a>
    timeout_callback_func(port);
 8005b5e:	4620      	mov	r0, r4
 8005b60:	4798      	blx	r3

#if 1
  // this debug message should always be active, so that common users are informed about the exception
  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_Receive_Handler] Timeout on port 0x%02x\n", port);
 8005b62:	4621      	mov	r1, r4
 8005b64:	4806      	ldr	r0, [pc, #24]	; (8005b80 <MIOS32_MIDI_TimeOut+0x48>)
 8005b66:	f7ff fe51 	bl	800580c <MIOS32_MIDI_SendDebugMessage>
#endif

  return 0; // no error
}
 8005b6a:	2000      	movs	r0, #0
 8005b6c:	bd10      	pop	{r4, pc}
 8005b6e:	bf00      	nop
 8005b70:	200007bc 	.word	0x200007bc
 8005b74:	200007b4 	.word	0x200007b4
 8005b78:	200007ac 	.word	0x200007ac
 8005b7c:	200007d0 	.word	0x200007d0
 8005b80:	0800ae88 	.word	0x0800ae88

08005b84 <MIOS32_MIDI_Receive_Handler>:
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005b84:	b5f0      	push	{r4, r5, r6, r7, lr}

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005b86:	2200      	movs	r2, #0
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005b88:	b089      	sub	sp, #36	; 0x24
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005b8a:	2101      	movs	r1, #1
//! which can be installed via MIOS32_MIDI_SysExCallback_Init()
//!
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Receive_Handler(void *_callback_package)
{
 8005b8c:	4605      	mov	r5, r0
  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
  u8 again = 1;
 8005b8e:	9104      	str	r1, [sp, #16]

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 packages_forwarded = 0;
 8005b90:	9201      	str	r2, [sp, #4]
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
  u8 total_packages_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
 8005b92:	9203      	str	r2, [sp, #12]
  u8 port;
  mios32_midi_package_t package;

  void (*callback_package)(mios32_midi_port_t port, mios32_midi_package_t midi_package) = _callback_package;

  u8 intf = 0; // interface to be checked
 8005b94:	4613      	mov	r3, r2
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005b96:	4fc5      	ldr	r7, [pc, #788]	; (8005eac <MIOS32_MIDI_Receive_Handler+0x328>)
 8005b98:	e000      	b.n	8005b9c <MIOS32_MIDI_Receive_Handler+0x18>

      MIOS32_MIDI_TimeOut(timeout_port);
      sysex_timeout_ctr_flags.ALL = 0;
      again = 0;
    }
  } while( again );
 8005b9a:	9b05      	ldr	r3, [sp, #20]
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8005b9c:	1c5a      	adds	r2, r3, #1
 8005b9e:	b2d2      	uxtb	r2, r2
 8005ba0:	9205      	str	r2, [sp, #20]
 8005ba2:	2b0b      	cmp	r3, #11
 8005ba4:	d851      	bhi.n	8005c4a <MIOS32_MIDI_Receive_Handler+0xc6>
 8005ba6:	e8df f003 	tbb	[pc, r3]
 8005baa:	0e06      	.short	0x0e06
 8005bac:	26201a14 	.word	0x26201a14
 8005bb0:	3e38322c 	.word	0x3e38322c
 8005bb4:	4a44      	.short	0x4a44
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
      case 0: status = MIOS32_USB_MIDI_PackageReceive(&package); port = USB0 + package.cable; break;
 8005bb6:	a807      	add	r0, sp, #28
 8005bb8:	f002 f9b2 	bl	8007f20 <MIOS32_USB_MIDI_PackageReceive>
 8005bbc:	9c07      	ldr	r4, [sp, #28]
 8005bbe:	f3c4 1403 	ubfx	r4, r4, #4, #4
 8005bc2:	3410      	adds	r4, #16
 8005bc4:	e052      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 0: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART0_ASSIGNMENT == 1
      case 1: status = MIOS32_UART_MIDI_PackageReceive(0, &package); port = UART0; break;
 8005bc6:	2000      	movs	r0, #0
 8005bc8:	a907      	add	r1, sp, #28
 8005bca:	f000 fae3 	bl	8006194 <MIOS32_UART_MIDI_PackageReceive>
 8005bce:	2420      	movs	r4, #32
 8005bd0:	e04c      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 1: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART1_ASSIGNMENT == 1
      case 2: status = MIOS32_UART_MIDI_PackageReceive(1, &package); port = UART1; break;
 8005bd2:	2001      	movs	r0, #1
 8005bd4:	a907      	add	r1, sp, #28
 8005bd6:	f000 fadd 	bl	8006194 <MIOS32_UART_MIDI_PackageReceive>
 8005bda:	2421      	movs	r4, #33	; 0x21
 8005bdc:	e046      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 2: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI) && MIOS32_UART2_ASSIGNMENT == 1
      case 3: status = MIOS32_UART_MIDI_PackageReceive(2, &package); port = UART2; break;
 8005bde:	2002      	movs	r0, #2
 8005be0:	a907      	add	r1, sp, #28
 8005be2:	f000 fad7 	bl	8006194 <MIOS32_UART_MIDI_PackageReceive>
 8005be6:	2422      	movs	r4, #34	; 0x22
 8005be8:	e040      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 3: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 4: status = MIOS32_IIC_MIDI_PackageReceive(0, &package); port = IIC0; break;
 8005bea:	2000      	movs	r0, #0
 8005bec:	a907      	add	r1, sp, #28
 8005bee:	f000 fbb1 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005bf2:	2430      	movs	r4, #48	; 0x30
 8005bf4:	e03a      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 4: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 5: status = MIOS32_IIC_MIDI_PackageReceive(1, &package); port = IIC1; break;
 8005bf6:	2001      	movs	r0, #1
 8005bf8:	a907      	add	r1, sp, #28
 8005bfa:	f000 fbab 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005bfe:	2431      	movs	r4, #49	; 0x31
 8005c00:	e034      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 5: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 6: status = MIOS32_IIC_MIDI_PackageReceive(2, &package); port = IIC2; break;
 8005c02:	2002      	movs	r0, #2
 8005c04:	a907      	add	r1, sp, #28
 8005c06:	f000 fba5 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005c0a:	2432      	movs	r4, #50	; 0x32
 8005c0c:	e02e      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 6: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 7: status = MIOS32_IIC_MIDI_PackageReceive(3, &package); port = IIC3; break;
 8005c0e:	2003      	movs	r0, #3
 8005c10:	a907      	add	r1, sp, #28
 8005c12:	f000 fb9f 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005c16:	2433      	movs	r4, #51	; 0x33
 8005c18:	e028      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 7: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 8: status = MIOS32_IIC_MIDI_PackageReceive(4, &package); port = IIC4; break;
 8005c1a:	2004      	movs	r0, #4
 8005c1c:	a907      	add	r1, sp, #28
 8005c1e:	f000 fb99 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005c22:	2434      	movs	r4, #52	; 0x34
 8005c24:	e022      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 8: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 9: status = MIOS32_IIC_MIDI_PackageReceive(5, &package); port = IIC5; break;
 8005c26:	2005      	movs	r0, #5
 8005c28:	a907      	add	r1, sp, #28
 8005c2a:	f000 fb93 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005c2e:	2435      	movs	r4, #53	; 0x35
 8005c30:	e01c      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 9: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 10: status = MIOS32_IIC_MIDI_PackageReceive(6, &package); port = IIC6; break;
 8005c32:	2006      	movs	r0, #6
 8005c34:	a907      	add	r1, sp, #28
 8005c36:	f000 fb8d 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005c3a:	2436      	movs	r4, #54	; 0x36
 8005c3c:	e016      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 10: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_IIC) && !defined(MIOS32_DONT_USE_IIC_MIDI)
      case 11: status = MIOS32_IIC_MIDI_PackageReceive(7, &package); port = IIC7; break;
 8005c3e:	2007      	movs	r0, #7
 8005c40:	a907      	add	r1, sp, #28
 8005c42:	f000 fb87 	bl	8006354 <MIOS32_IIC_MIDI_PackageReceive>
 8005c46:	2437      	movs	r4, #55	; 0x37
 8005c48:	e010      	b.n	8005c6c <MIOS32_MIDI_Receive_Handler+0xe8>
#else
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
 8005c4a:	9a01      	ldr	r2, [sp, #4]
 8005c4c:	9903      	ldr	r1, [sp, #12]
 8005c4e:	1e13      	subs	r3, r2, #0
 8005c50:	bf18      	it	ne
 8005c52:	2301      	movne	r3, #1
 8005c54:	2909      	cmp	r1, #9
 8005c56:	bf8c      	ite	hi
 8005c58:	2300      	movhi	r3, #0
 8005c5a:	f003 0301 	andls.w	r3, r3, #1
 8005c5e:	2b00      	cmp	r3, #0
 8005c60:	f000 811f 	beq.w	8005ea2 <MIOS32_MIDI_Receive_Handler+0x31e>
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
 8005c64:	2200      	movs	r2, #0
 8005c66:	9201      	str	r2, [sp, #4]
      case 11: status = -1; break;
#endif
      default:
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
 8005c68:	9205      	str	r2, [sp, #20]
 8005c6a:	e0e8      	b.n	8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
	}
	status = -1; // empty round - no message
    }

    // timeout detected by interface?
    if( status == -10 ) {
 8005c6c:	f110 0f0a 	cmn.w	r0, #10
 8005c70:	d104      	bne.n	8005c7c <MIOS32_MIDI_Receive_Handler+0xf8>
      MIOS32_MIDI_TimeOut(port);
 8005c72:	4620      	mov	r0, r4
 8005c74:	f7ff ff60 	bl	8005b38 <MIOS32_MIDI_TimeOut>
      again = 0;
 8005c78:	2300      	movs	r3, #0
 8005c7a:	e112      	b.n	8005ea2 <MIOS32_MIDI_Receive_Handler+0x31e>
    } else if( status >= 0 ) { // message received?
 8005c7c:	2800      	cmp	r0, #0
 8005c7e:	f2c0 80de 	blt.w	8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005c82:	9901      	ldr	r1, [sp, #4]
      ++total_packages_forwarded;
 8005c84:	9a03      	ldr	r2, [sp, #12]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005c86:	1c4b      	adds	r3, r1, #1
 8005c88:	b2db      	uxtb	r3, r3
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005c8a:	9907      	ldr	r1, [sp, #28]
    if( status == -10 ) {
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
 8005c8c:	9301      	str	r3, [sp, #4]
      ++total_packages_forwarded;
 8005c8e:	1c53      	adds	r3, r2, #1
 8005c90:	b2db      	uxtb	r3, r3

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005c92:	f36f 1107 	bfc	r1, #4, #4
      MIOS32_MIDI_TimeOut(port);
      again = 0;
    } else if( status >= 0 ) { // message received?
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;
 8005c96:	9303      	str	r3, [sp, #12]

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005c98:	f001 030f 	and.w	r3, r1, #15
 8005c9c:	f103 0208 	add.w	r2, r3, #8
 8005ca0:	f002 020f 	and.w	r2, r2, #15
 8005ca4:	2a06      	cmp	r2, #6
      // notify that a package has been forwarded
      ++packages_forwarded;
      ++total_packages_forwarded;

      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;
 8005ca6:	9107      	str	r1, [sp, #28]

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
 8005ca8:	d804      	bhi.n	8005cb4 <MIOS32_MIDI_Receive_Handler+0x130>
	if( callback_package != NULL )
	  callback_package(port, package);
 8005caa:	4620      	mov	r0, r4
      // remove cable number from package (MIOS32_MIDI passes it's own port number)
      package.cable = 0;

      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
 8005cac:	2d00      	cmp	r5, #0
 8005cae:	f040 80c5 	bne.w	8005e3c <MIOS32_MIDI_Receive_Handler+0x2b8>
 8005cb2:	e0c4      	b.n	8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;

	switch( package.type ) {
 8005cb4:	1e9a      	subs	r2, r3, #2
 8005cb6:	2a0d      	cmp	r2, #13
 8005cb8:	f200 80c1 	bhi.w	8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005cbc:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005cc0:	00710071 	.word	0x00710071
 8005cc4:	006d000e 	.word	0x006d000e
 8005cc8:	00740074 	.word	0x00740074
 8005ccc:	00bf00bf 	.word	0x00bf00bf
 8005cd0:	00bf00bf 	.word	0x00bf00bf
 8005cd4:	00bf00bf 	.word	0x00bf00bf
 8005cd8:	000e00bf 	.word	0x000e00bf
	    break;

	  case 0x4: // SysEx starts or continues (3 bytes)
	  case 0xf: // Single byte is interpreted as SysEx as well (I noticed that portmidi sometimes sends single bytes!)

	    if( package.evnt0 >= 0xf8 ) { // relevant for package type 0xf
 8005cdc:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005ce0:	29f7      	cmp	r1, #247	; 0xf7
 8005ce2:	d85e      	bhi.n	8005da2 <MIOS32_MIDI_Receive_Handler+0x21e>
	      if( callback_package != NULL )
		callback_package(port, package); // -> realtime event is forwarded as event
	      break;
	    }

	    if( package.evnt0 == 0xf0 ) {
 8005ce4:	29f0      	cmp	r1, #240	; 0xf0
 8005ce6:	d11c      	bne.n	8005d22 <MIOS32_MIDI_Receive_Handler+0x19e>
	      // cheap timeout mechanism - see comments above the sysex_timeout_ctr declaration
	      if( !sysex_timeout_ctr_flags.ALL ) {
 8005ce8:	4a71      	ldr	r2, [pc, #452]	; (8005eb0 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005cea:	6813      	ldr	r3, [r2, #0]
 8005cec:	b9cb      	cbnz	r3, 8005d22 <MIOS32_MIDI_Receive_Handler+0x19e>
		switch( port & 0xf0 ) {
 8005cee:	f004 02f0 	and.w	r2, r4, #240	; 0xf0
 8005cf2:	2a10      	cmp	r2, #16
 8005cf4:	d002      	beq.n	8005cfc <MIOS32_MIDI_Receive_Handler+0x178>
 8005cf6:	2a30      	cmp	r2, #48	; 0x30
 8005cf8:	d113      	bne.n	8005d22 <MIOS32_MIDI_Receive_Handler+0x19e>
 8005cfa:	e009      	b.n	8005d10 <MIOS32_MIDI_Receive_Handler+0x18c>
		  case USB0://..15
		    sysex_timeout_ctr = 0;
 8005cfc:	4a6d      	ldr	r2, [pc, #436]	; (8005eb4 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005cfe:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.usb_receives = (1 << (port & 0xf));
 8005d00:	2201      	movs	r2, #1
 8005d02:	f004 030f 	and.w	r3, r4, #15
 8005d06:	fa12 f303 	lsls.w	r3, r2, r3
 8005d0a:	4a69      	ldr	r2, [pc, #420]	; (8005eb0 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005d0c:	8013      	strh	r3, [r2, #0]
		    break;
 8005d0e:	e008      	b.n	8005d22 <MIOS32_MIDI_Receive_Handler+0x19e>
		  case UART0://..15
		    // already done in MIOS32_UART_MIDI_PackageReceive()
		    break;
		  case IIC0://..15
		    sysex_timeout_ctr = 0;
 8005d10:	4a68      	ldr	r2, [pc, #416]	; (8005eb4 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005d12:	8013      	strh	r3, [r2, #0]
		    sysex_timeout_ctr_flags.iic_receives = (1 << (port & 0xf));
 8005d14:	2201      	movs	r2, #1
 8005d16:	f004 030f 	and.w	r3, r4, #15
 8005d1a:	fa12 f303 	lsls.w	r3, r2, r3
 8005d1e:	4a64      	ldr	r2, [pc, #400]	; (8005eb0 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005d20:	8053      	strh	r3, [r2, #2]
		    // no timeout protection for remaining interfaces (yet)
		}
	      }
	    }

	    MIOS32_MIDI_SYSEX_Parser(port, package.evnt0); // -> forward to MIOS32 SysEx Parser
 8005d22:	4620      	mov	r0, r4
 8005d24:	f7ff fe9a 	bl	8005a5c <MIOS32_MIDI_SYSEX_Parser>
	    if( package.type != 0x0f ) {
 8005d28:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8005d2c:	f003 030f 	and.w	r3, r3, #15
 8005d30:	2b0f      	cmp	r3, #15
 8005d32:	d009      	beq.n	8005d48 <MIOS32_MIDI_Receive_Handler+0x1c4>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
 8005d34:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005d38:	4620      	mov	r0, r4
 8005d3a:	f7ff fe8f 	bl	8005a5c <MIOS32_MIDI_SYSEX_Parser>
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
 8005d3e:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005d42:	4620      	mov	r0, r4
 8005d44:	f7ff fe8a 	bl	8005a5c <MIOS32_MIDI_SYSEX_Parser>
	    }

	    if( sysex_callback_func != NULL ) {
 8005d48:	683e      	ldr	r6, [r7, #0]
 8005d4a:	b1de      	cbz	r6, 8005d84 <MIOS32_MIDI_Receive_Handler+0x200>
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005d4c:	f89d 101d 	ldrb.w	r1, [sp, #29]
 8005d50:	4620      	mov	r0, r4
 8005d52:	47b0      	blx	r6
	      if( package.type != 0x0f ) {
 8005d54:	f89d 301c 	ldrb.w	r3, [sp, #28]
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
	      MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8005d58:	b2c6      	uxtb	r6, r0
	      if( package.type != 0x0f ) {
 8005d5a:	f003 030f 	and.w	r3, r3, #15
 8005d5e:	2b0f      	cmp	r3, #15
 8005d60:	d010      	beq.n	8005d84 <MIOS32_MIDI_Receive_Handler+0x200>
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005d62:	f89d 101e 	ldrb.w	r1, [sp, #30]
 8005d66:	683b      	ldr	r3, [r7, #0]
 8005d68:	4620      	mov	r0, r4
 8005d6a:	4798      	blx	r3
 8005d6c:	4602      	mov	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005d6e:	683b      	ldr	r3, [r7, #0]
 8005d70:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8005d74:	9200      	str	r2, [sp, #0]
 8005d76:	4620      	mov	r0, r4
 8005d78:	4798      	blx	r3
	    }

	    if( sysex_callback_func != NULL ) {
	      filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
	      if( package.type != 0x0f ) {
		filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 8005d7a:	9a00      	ldr	r2, [sp, #0]
 8005d7c:	4302      	orrs	r2, r0
		filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 8005d7e:	ea42 0606 	orr.w	r6, r2, r6
 8005d82:	b2f6      	uxtb	r6, r6
	      }
	    }

	    if( callback_package != NULL && !filter_sysex )
 8005d84:	1e2b      	subs	r3, r5, #0
 8005d86:	bf18      	it	ne
 8005d88:	2301      	movne	r3, #1
 8005d8a:	2e00      	cmp	r6, #0
 8005d8c:	bf14      	ite	ne
 8005d8e:	2600      	movne	r6, #0
 8005d90:	f003 0601 	andeq.w	r6, r3, #1
 8005d94:	2e00      	cmp	r6, #0
 8005d96:	d052      	beq.n	8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
 8005d98:	e04e      	b.n	8005e38 <MIOS32_MIDI_Receive_Handler+0x2b4>
	      callback_package(port, package);

	    break;

	  case 0x5:   // Single-byte System Common Message or SysEx ends with following single byte. 
	    if( package.evnt0 >= 0xf8 ) {
 8005d9a:	f89d 201d 	ldrb.w	r2, [sp, #29]
 8005d9e:	2af7      	cmp	r2, #247	; 0xf7
 8005da0:	d902      	bls.n	8005da8 <MIOS32_MIDI_Receive_Handler+0x224>
	      if( callback_package != NULL )
 8005da2:	2d00      	cmp	r5, #0
 8005da4:	d148      	bne.n	8005e38 <MIOS32_MIDI_Receive_Handler+0x2b4>
 8005da6:	e04a      	b.n	8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
	    }
	    // no >= 0xf8 event: continue!

	  case 0x6:   // SysEx ends with following two bytes.
	  case 0x7: { // SysEx ends with following three bytes.
	    u8 num_bytes = package.type - 0x5 + 1;
 8005da8:	3b04      	subs	r3, #4
 8005daa:	b2db      	uxtb	r3, r3
 8005dac:	9302      	str	r3, [sp, #8]
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
 8005dae:	2b00      	cmp	r3, #0
 8005db0:	d079      	beq.n	8005ea6 <MIOS32_MIDI_Receive_Handler+0x322>
	      current_byte = package.evnt0;
 8005db2:	f89d 601d 	ldrb.w	r6, [sp, #29]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005db6:	4620      	mov	r0, r4
 8005db8:	4631      	mov	r1, r6
 8005dba:	f7ff fe4f 	bl	8005a5c <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005dbe:	683b      	ldr	r3, [r7, #0]
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005dc0:	461a      	mov	r2, r3
	    u8 current_byte = 0;

	    if( num_bytes >= 1 ) {
	      current_byte = package.evnt0;
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
	      if( sysex_callback_func != NULL )
 8005dc2:	b11b      	cbz	r3, 8005dcc <MIOS32_MIDI_Receive_Handler+0x248>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005dc4:	4620      	mov	r0, r4
 8005dc6:	4631      	mov	r1, r6
 8005dc8:	4798      	blx	r3
 8005dca:	b2c2      	uxtb	r2, r0
	    }

	    if( num_bytes >= 2 ) {
 8005dcc:	9b02      	ldr	r3, [sp, #8]
 8005dce:	2b01      	cmp	r3, #1
 8005dd0:	d024      	beq.n	8005e1c <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt1;
 8005dd2:	f89d 601e 	ldrb.w	r6, [sp, #30]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005dd6:	4620      	mov	r0, r4
 8005dd8:	4631      	mov	r1, r6
 8005dda:	9200      	str	r2, [sp, #0]
 8005ddc:	f7ff fe3e 	bl	8005a5c <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005de0:	683b      	ldr	r3, [r7, #0]
 8005de2:	9a00      	ldr	r2, [sp, #0]
 8005de4:	b133      	cbz	r3, 8005df4 <MIOS32_MIDI_Receive_Handler+0x270>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005de6:	4620      	mov	r0, r4
 8005de8:	4631      	mov	r1, r6
 8005dea:	4798      	blx	r3
 8005dec:	9a00      	ldr	r2, [sp, #0]
 8005dee:	ea40 0202 	orr.w	r2, r0, r2
 8005df2:	b2d2      	uxtb	r2, r2
	    }

	    if( num_bytes >= 3 ) {
 8005df4:	9902      	ldr	r1, [sp, #8]
 8005df6:	2902      	cmp	r1, #2
 8005df8:	d010      	beq.n	8005e1c <MIOS32_MIDI_Receive_Handler+0x298>
	      current_byte = package.evnt2;
 8005dfa:	f89d 601f 	ldrb.w	r6, [sp, #31]
	      MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8005dfe:	4620      	mov	r0, r4
 8005e00:	4631      	mov	r1, r6
 8005e02:	9200      	str	r2, [sp, #0]
 8005e04:	f7ff fe2a 	bl	8005a5c <MIOS32_MIDI_SYSEX_Parser>
	      if( sysex_callback_func != NULL )
 8005e08:	683b      	ldr	r3, [r7, #0]
 8005e0a:	9a00      	ldr	r2, [sp, #0]
 8005e0c:	b133      	cbz	r3, 8005e1c <MIOS32_MIDI_Receive_Handler+0x298>
		filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8005e0e:	4620      	mov	r0, r4
 8005e10:	4631      	mov	r1, r6
 8005e12:	4798      	blx	r3
 8005e14:	9a00      	ldr	r2, [sp, #0]
 8005e16:	ea40 0202 	orr.w	r2, r0, r2
 8005e1a:	b2d2      	uxtb	r2, r2
	    }

	    // reset timeout protection if required
	    if( current_byte == 0xf7 )
 8005e1c:	2ef7      	cmp	r6, #247	; 0xf7
 8005e1e:	d102      	bne.n	8005e26 <MIOS32_MIDI_Receive_Handler+0x2a2>
	      sysex_timeout_ctr_flags.ALL = 0;
 8005e20:	4b23      	ldr	r3, [pc, #140]	; (8005eb0 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005e22:	2100      	movs	r1, #0
 8005e24:	6019      	str	r1, [r3, #0]

	    // forward as package if not filtered
	    if( callback_package != NULL && !filter_sysex )
 8005e26:	1e2b      	subs	r3, r5, #0
 8005e28:	bf18      	it	ne
 8005e2a:	2301      	movne	r3, #1
 8005e2c:	2a00      	cmp	r2, #0
 8005e2e:	bf14      	ite	ne
 8005e30:	2300      	movne	r3, #0
 8005e32:	f003 0301 	andeq.w	r3, r3, #1
 8005e36:	b113      	cbz	r3, 8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
	      callback_package(port, package);
 8005e38:	9907      	ldr	r1, [sp, #28]
 8005e3a:	4620      	mov	r0, r4
 8005e3c:	47a8      	blx	r5
	}	  
      }
    }

    // timeout detected by this handler?
    if( sysex_timeout_ctr_flags.ALL && sysex_timeout_ctr > 1000 ) {
 8005e3e:	4b1c      	ldr	r3, [pc, #112]	; (8005eb0 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005e40:	681a      	ldr	r2, [r3, #0]
 8005e42:	b33a      	cbz	r2, 8005e94 <MIOS32_MIDI_Receive_Handler+0x310>
 8005e44:	491b      	ldr	r1, [pc, #108]	; (8005eb4 <MIOS32_MIDI_Receive_Handler+0x330>)
 8005e46:	880a      	ldrh	r2, [r1, #0]
 8005e48:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 8005e4c:	d922      	bls.n	8005e94 <MIOS32_MIDI_Receive_Handler+0x310>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
 8005e4e:	8819      	ldrh	r1, [r3, #0]
 8005e50:	b161      	cbz	r1, 8005e6c <MIOS32_MIDI_Receive_Handler+0x2e8>
 8005e52:	2200      	movs	r2, #0
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
 8005e54:	fa51 f302 	asrs.w	r3, r1, r2
 8005e58:	f013 0301 	ands.w	r3, r3, #1
 8005e5c:	d103      	bne.n	8005e66 <MIOS32_MIDI_Receive_Handler+0x2e2>
      u8 timeout_port = 0;

      // determine port
      if( sysex_timeout_ctr_flags.usb_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005e5e:	3201      	adds	r2, #1
 8005e60:	2a10      	cmp	r2, #16
 8005e62:	d1f7      	bne.n	8005e54 <MIOS32_MIDI_Receive_Handler+0x2d0>
	  if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005e64:	461a      	mov	r2, r3
	timeout_port = USB0 + i;
 8005e66:	3210      	adds	r2, #16
 8005e68:	b2d0      	uxtb	r0, r2
 8005e6a:	e00d      	b.n	8005e88 <MIOS32_MIDI_Receive_Handler+0x304>
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
 8005e6c:	8858      	ldrh	r0, [r3, #2]
 8005e6e:	b158      	cbz	r0, 8005e88 <MIOS32_MIDI_Receive_Handler+0x304>
 8005e70:	460b      	mov	r3, r1
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
 8005e72:	fa50 f203 	asrs.w	r2, r0, r3
 8005e76:	f012 0201 	ands.w	r2, r2, #1
 8005e7a:	d103      	bne.n	8005e84 <MIOS32_MIDI_Receive_Handler+0x300>
	if( i >= 16 ) // failsafe
	  i = 0;
	timeout_port = USB0 + i;
      } else if( sysex_timeout_ctr_flags.iic_receives ) {
	int i; // i'm missing a prio instruction in C!
	for(i=0; i<16; ++i)
 8005e7c:	3301      	adds	r3, #1
 8005e7e:	2b10      	cmp	r3, #16
 8005e80:	d1f7      	bne.n	8005e72 <MIOS32_MIDI_Receive_Handler+0x2ee>
	  if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
	    break;
	if( i >= 16 ) // failsafe
	  i = 0;
 8005e82:	4613      	mov	r3, r2
	timeout_port = IIC0 + i;
 8005e84:	3330      	adds	r3, #48	; 0x30
 8005e86:	b2d8      	uxtb	r0, r3
      }

      MIOS32_MIDI_TimeOut(timeout_port);
 8005e88:	f7ff fe56 	bl	8005b38 <MIOS32_MIDI_TimeOut>
      sysex_timeout_ctr_flags.ALL = 0;
 8005e8c:	4b08      	ldr	r3, [pc, #32]	; (8005eb0 <MIOS32_MIDI_Receive_Handler+0x32c>)
 8005e8e:	2200      	movs	r2, #0
 8005e90:	601a      	str	r2, [r3, #0]
 8005e92:	e003      	b.n	8005e9c <MIOS32_MIDI_Receive_Handler+0x318>
      again = 0;
    }
  } while( again );
 8005e94:	9a04      	ldr	r2, [sp, #16]
 8005e96:	2a00      	cmp	r2, #0
 8005e98:	f47f ae7f 	bne.w	8005b9a <MIOS32_MIDI_Receive_Handler+0x16>

  return 0;
}
 8005e9c:	2000      	movs	r0, #0
 8005e9e:	b009      	add	sp, #36	; 0x24
 8005ea0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	// allow 10 forwards maximum to yield some CPU time for other tasks
	if( packages_forwarded && total_packages_forwarded < 10 ) {
	  intf = 0; // restart with USB
	  packages_forwarded = 0; // for checking, if packages still have been forwarded in next round
	} else {
	  again = 0; // no more interfaces to be processed
 8005ea2:	9304      	str	r3, [sp, #16]
 8005ea4:	e7cb      	b.n	8005e3e <MIOS32_MIDI_Receive_Handler+0x2ba>
      // branch depending on package type
      if( package.type >= 0x8 && package.type < 0xf ) {
	if( callback_package != NULL )
	  callback_package(port, package);
      } else {
	u8 filter_sysex = 0;
 8005ea6:	9a02      	ldr	r2, [sp, #8]
 8005ea8:	e7bd      	b.n	8005e26 <MIOS32_MIDI_Receive_Handler+0x2a2>
 8005eaa:	bf00      	nop
 8005eac:	200007cc 	.word	0x200007cc
 8005eb0:	200007c8 	.word	0x200007c8
 8005eb4:	200007b6 	.word	0x200007b6

08005eb8 <MIOS32_MIDI_Periodic_mS>:
//! by a task in the programming model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Periodic_mS(void)
{
 8005eb8:	b510      	push	{r4, lr}
  s32 status = 0;

#ifndef MIOS32_DONT_USE_USB_MIDI
  status |= MIOS32_USB_MIDI_Periodic_mS();
 8005eba:	f002 f85d 	bl	8007f78 <MIOS32_USB_MIDI_Periodic_mS>
 8005ebe:	4604      	mov	r4, r0
#endif

#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
 8005ec0:	f000 f8ca 	bl	8006058 <MIOS32_UART_MIDI_Periodic_mS>
 8005ec4:	ea40 0404 	orr.w	r4, r0, r4
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005ec8:	f000 fa3f 	bl	800634a <MIOS32_IIC_MIDI_Periodic_mS>
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005ecc:	4b05      	ldr	r3, [pc, #20]	; (8005ee4 <MIOS32_MIDI_Periodic_mS+0x2c>)
 8005ece:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005ed2:	881a      	ldrh	r2, [r3, #0]
#ifndef MIOS32_DONT_USE_UART_MIDI
  status |= MIOS32_UART_MIDI_Periodic_mS();
#endif

#ifndef MIOS32_DONT_USE_IIC_MIDI
  status |= MIOS32_IIC_MIDI_Periodic_mS();
 8005ed4:	ea44 0000 	orr.w	r0, r4, r0
#endif

  // increment timeout counter for incoming packages
  // an incomplete event will be timed out after 1000 ticks (1 second)
  if( sysex_timeout_ctr < 65535 )
 8005ed8:	428a      	cmp	r2, r1
 8005eda:	d001      	beq.n	8005ee0 <MIOS32_MIDI_Periodic_mS+0x28>
    ++sysex_timeout_ctr;
 8005edc:	3201      	adds	r2, #1
 8005ede:	801a      	strh	r2, [r3, #0]

  return status;
}
 8005ee0:	bd10      	pop	{r4, pc}
 8005ee2:	bf00      	nop
 8005ee4:	200007b6 	.word	0x200007b6

08005ee8 <MIOS32_MIDI_SendByteToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_byte received MIDI byte
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendByteToRxCallback(mios32_midi_port_t port, u8 midi_byte)
{
 8005ee8:	b508      	push	{r3, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL )
 8005eea:	4b03      	ldr	r3, [pc, #12]	; (8005ef8 <MIOS32_MIDI_SendByteToRxCallback+0x10>)
 8005eec:	681b      	ldr	r3, [r3, #0]
 8005eee:	b10b      	cbz	r3, 8005ef4 <MIOS32_MIDI_SendByteToRxCallback+0xc>
    return direct_rx_callback_func(port, midi_byte);
 8005ef0:	4798      	blx	r3
 8005ef2:	e000      	b.n	8005ef6 <MIOS32_MIDI_SendByteToRxCallback+0xe>
  return 0; // no error
 8005ef4:	4618      	mov	r0, r3
}
 8005ef6:	bd08      	pop	{r3, pc}
 8005ef8:	200007b0 	.word	0x200007b0

08005efc <MIOS32_MIDI_SendPackageToRxCallback>:
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005efc:	b5f0      	push	{r4, r5, r6, r7, lr}
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005efe:	4e13      	ldr	r6, [pc, #76]	; (8005f4c <MIOS32_MIDI_SendPackageToRxCallback+0x50>)
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005f00:	b085      	sub	sp, #20
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005f02:	6834      	ldr	r4, [r6, #0]
//! \param[in] port MIDI port (DEFAULT, USB0..USB7, UART0..UART2, IIC0..IIC7)
//! \param[in] midi_package received MIDI package
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
 8005f04:	4607      	mov	r7, r0
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
 8005f06:	b1ec      	cbz	r4, 8005f44 <MIOS32_MIDI_SendPackageToRxCallback+0x48>
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005f08:	f3c1 6307 	ubfx	r3, r1, #24, #8
 8005f0c:	f88d 300e 	strb.w	r3, [sp, #14]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005f10:	4b0f      	ldr	r3, [pc, #60]	; (8005f50 <MIOS32_MIDI_SendPackageToRxCallback+0x54>)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005f12:	f3c1 4207 	ubfx	r2, r1, #16, #8
 8005f16:	f3c1 2007 	ubfx	r0, r1, #8, #8
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
 8005f1a:	2400      	movs	r4, #0
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005f1c:	f001 010f 	and.w	r1, r1, #15
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackageToRxCallback(mios32_midi_port_t port, mios32_midi_package_t midi_package)
{
  // note: here we could filter the user hook execution on special situations
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8005f20:	f88d 200d 	strb.w	r2, [sp, #13]
 8005f24:	f88d 000c 	strb.w	r0, [sp, #12]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8005f28:	5c5a      	ldrb	r2, [r3, r1]
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005f2a:	4625      	mov	r5, r4
 8005f2c:	e008      	b.n	8005f40 <MIOS32_MIDI_SendPackageToRxCallback+0x44>
      status |= direct_rx_callback_func(port, buffer[i]);
 8005f2e:	ab03      	add	r3, sp, #12
 8005f30:	5d59      	ldrb	r1, [r3, r5]
 8005f32:	4638      	mov	r0, r7
 8005f34:	9201      	str	r2, [sp, #4]
 8005f36:	6833      	ldr	r3, [r6, #0]
 8005f38:	4798      	blx	r3
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005f3a:	9a01      	ldr	r2, [sp, #4]
      status |= direct_rx_callback_func(port, buffer[i]);
 8005f3c:	4304      	orrs	r4, r0
  if( direct_rx_callback_func != NULL ) {
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
    int i;
    s32 status = 0;
    for(i=0; i<len; ++i)
 8005f3e:	3501      	adds	r5, #1
 8005f40:	4295      	cmp	r5, r2
 8005f42:	dbf4      	blt.n	8005f2e <MIOS32_MIDI_SendPackageToRxCallback+0x32>
      status |= direct_rx_callback_func(port, buffer[i]);
    return status;
  }
  return 0; // no error
}
 8005f44:	4620      	mov	r0, r4
 8005f46:	b005      	add	sp, #20
 8005f48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005f4a:	bf00      	nop
 8005f4c:	200007b0 	.word	0x200007b0
 8005f50:	0800adac 	.word	0x0800adac

08005f54 <MIOS32_OSC_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_OSC_Init(u32 mode)
{
  if( mode > 0 )
    return -1; // only mode 0 supported yet
 8005f54:	2800      	cmp	r0, #0
 8005f56:	bf14      	ite	ne
 8005f58:	f04f 30ff 	movne.w	r0, #4294967295
 8005f5c:	2000      	moveq	r0, #0

  return 0; // no error
}
 8005f5e:	4770      	bx	lr

08005f60 <MIOS32_COM_Init>:
s32 MIOS32_COM_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 8005f60:	b938      	cbnz	r0, 8005f72 <MIOS32_COM_Init+0x12>
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 8005f62:	4b05      	ldr	r3, [pc, #20]	; (8005f78 <MIOS32_COM_Init+0x18>)

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 8005f64:	4a05      	ldr	r2, [pc, #20]	; (8005f7c <MIOS32_COM_Init+0x1c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 8005f66:	6018      	str	r0, [r3, #0]

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 8005f68:	2310      	movs	r3, #16
 8005f6a:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_COM_DEBUG_PORT;
 8005f6c:	4a04      	ldr	r2, [pc, #16]	; (8005f80 <MIOS32_COM_Init+0x20>)
 8005f6e:	7013      	strb	r3, [r2, #0]
#if MIOS32_UART0_ASSIGNMENT == 2 || MIOS32_UART1_ASSIGNMENT == 2 || MIOS32_UART2_ASSIGNMENT == 2 || MIOS32_UART3_ASSIGNMENT == 2
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
 8005f70:	e001      	b.n	8005f76 <MIOS32_COM_Init+0x16>
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8005f72:	f04f 30ff 	mov.w	r0, #4294967295
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
}
 8005f76:	4770      	bx	lr
 8005f78:	200007d4 	.word	0x200007d4
 8005f7c:	20000007 	.word	0x20000007
 8005f80:	20000008 	.word	0x20000008

08005f84 <MIOS32_COM_SendBuffer>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8005f84:	f010 0ff0 	tst.w	r0, #240	; 0xf0
//! \param[in] len buffer length
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
 8005f88:	b508      	push	{r3, lr}
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8005f8a:	d104      	bne.n	8005f96 <MIOS32_COM_SendBuffer+0x12>
    port = (port == COM_DEBUG) ? debug_port : default_port;
 8005f8c:	2801      	cmp	r0, #1
 8005f8e:	bf0c      	ite	eq
 8005f90:	4b06      	ldreq	r3, [pc, #24]	; (8005fac <MIOS32_COM_SendBuffer+0x28>)
 8005f92:	4b07      	ldrne	r3, [pc, #28]	; (8005fb0 <MIOS32_COM_SendBuffer+0x2c>)
 8005f94:	7818      	ldrb	r0, [r3, #0]
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 8005f96:	0903      	lsrs	r3, r0, #4
 8005f98:	2b02      	cmp	r3, #2
    case 1:
#if !defined(MIOS32_DONT_USE_USB) && defined(MIOS32_USE_USB_COM)
      return MIOS32_USB_COM_TxBufferPutMore(port & 0xf, buffer, len);
#else
      return -1; // USB has been disabled
 8005f9a:	bf18      	it	ne
 8005f9c:	f04f 30ff 	movne.w	r0, #4294967295
  if( !(port & 0xf0) ) {
    port = (port == COM_DEBUG) ? debug_port : default_port;
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 8005fa0:	d103      	bne.n	8005faa <MIOS32_COM_SendBuffer+0x26>
      return -1; // USB has been disabled
#endif

    case 2:
#if !defined(MIOS32_DONT_USE_UART)
      return MIOS32_UART_TxBufferPutMore(port & 0xf, buffer, len);
 8005fa2:	f000 000f 	and.w	r0, r0, #15
 8005fa6:	f002 f9c5 	bl	8008334 <MIOS32_UART_TxBufferPutMore>
      
    default:
      // invalid port
      return -1;
  }
}
 8005faa:	bd08      	pop	{r3, pc}
 8005fac:	20000008 	.word	0x20000008
 8005fb0:	20000007 	.word	0x20000007

08005fb4 <MIOS32_COM_SendChar>:
//! \param[in] c character
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendChar(mios32_com_port_t port, char c)
{
 8005fb4:	b507      	push	{r0, r1, r2, lr}
 8005fb6:	ab02      	add	r3, sp, #8
 8005fb8:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return MIOS32_COM_SendBuffer(port, (u8 *)&c, 1);
 8005fbc:	4619      	mov	r1, r3
 8005fbe:	2201      	movs	r2, #1
 8005fc0:	f7ff ffe0 	bl	8005f84 <MIOS32_COM_SendBuffer>
}
 8005fc4:	bd0e      	pop	{r1, r2, r3, pc}

08005fc6 <MIOS32_COM_Receive_Handler>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_Receive_Handler(void)
{
  u8 port = DEFAULT;

  u8 intf = 0; // interface to be checked
 8005fc6:	2300      	movs	r3, #0
 8005fc8:	e000      	b.n	8005fcc <MIOS32_COM_Receive_Handler+0x6>
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8005fca:	4613      	mov	r3, r2
 8005fcc:	1c5a      	adds	r2, r3, #1
 8005fce:	2b04      	cmp	r3, #4
 8005fd0:	b2d2      	uxtb	r2, r2
 8005fd2:	d9fa      	bls.n	8005fca <MIOS32_COM_Receive_Handler+0x4>
	receive_callback_func(port, (u8)status);
    }
  } while( again );

  return 0;
}
 8005fd4:	2000      	movs	r0, #0
 8005fd6:	4770      	bx	lr

08005fd8 <MIOS32_UART_MIDI_RS_Reset>:
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 8005fd8:	2801      	cmp	r0, #1
//! \return -1 if port not available
//! \return < 0 on errors
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
 8005fda:	b510      	push	{r4, lr}
 8005fdc:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
    return -1; // port not available
 8005fde:	bf88      	it	hi
 8005fe0:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 8005fe4:	d80b      	bhi.n	8005ffe <MIOS32_UART_MIDI_RS_Reset+0x26>
    return -1; // port not available

  MIOS32_IRQ_Disable();
 8005fe6:	f000 fb1d 	bl	8006624 <MIOS32_IRQ_Disable>
  rs_last[uart_port] = 0xff;
 8005fea:	4b05      	ldr	r3, [pc, #20]	; (8006000 <MIOS32_UART_MIDI_RS_Reset+0x28>)
 8005fec:	22ff      	movs	r2, #255	; 0xff
 8005fee:	551a      	strb	r2, [r3, r4]
  rs_expire_ctr[uart_port] = 0;
 8005ff0:	4b04      	ldr	r3, [pc, #16]	; (8006004 <MIOS32_UART_MIDI_RS_Reset+0x2c>)
 8005ff2:	2200      	movs	r2, #0
 8005ff4:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
  MIOS32_IRQ_Enable();
 8005ff8:	f000 fb2a 	bl	8006650 <MIOS32_IRQ_Enable>

  return 0;
 8005ffc:	2000      	movs	r0, #0
#endif
}
 8005ffe:	bd10      	pop	{r4, pc}
 8006000:	200007d8 	.word	0x200007d8
 8006004:	200007f8 	.word	0x200007f8

08006008 <MIOS32_UART_MIDI_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Init(u32 mode)
{
 8006008:	b510      	push	{r4, lr}
 800600a:	4604      	mov	r4, r0
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800600c:	f04f 30ff 	mov.w	r0, #4294967295
#else
  int i;


  // currently only mode 0 supported
  if( mode != 0 )
 8006010:	b9ec      	cbnz	r4, 800604e <MIOS32_UART_MIDI_Init+0x46>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 8006012:	4b0f      	ldr	r3, [pc, #60]	; (8006050 <MIOS32_UART_MIDI_Init+0x48>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 8006014:	22ff      	movs	r2, #255	; 0xff
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 8006016:	601c      	str	r4, [r3, #0]
  midix->running_status = 0x00;
 8006018:	711c      	strb	r4, [r3, #4]
  midix->expected_bytes = 0x00;
 800601a:	715c      	strb	r4, [r3, #5]
  midix->wait_bytes = 0x00;
 800601c:	719c      	strb	r4, [r3, #6]
  midix->sysex_ctr = 0x00;
 800601e:	71dc      	strb	r4, [r3, #7]
  midix->timeout_ctr = 0;
 8006020:	811c      	strh	r4, [r3, #8]
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 8006022:	60dc      	str	r4, [r3, #12]
  midix->running_status = 0x00;
 8006024:	741c      	strb	r4, [r3, #16]
  midix->expected_bytes = 0x00;
 8006026:	745c      	strb	r4, [r3, #17]
  midix->wait_bytes = 0x00;
 8006028:	749c      	strb	r4, [r3, #18]
  midix->sysex_ctr = 0x00;
 800602a:	74dc      	strb	r4, [r3, #19]
  midix->timeout_ctr = 0;
 800602c:	829c      	strh	r4, [r3, #20]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 800602e:	4b09      	ldr	r3, [pc, #36]	; (8006054 <MIOS32_UART_MIDI_Init+0x4c>)
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 8006030:	4620      	mov	r0, r4
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RecordReset(i);

  // enable running status optimisation by default for all ports
  // clear timeout counters
  rs_optimisation = ~0; // -> all-one
 8006032:	701a      	strb	r2, [r3, #0]
  for(i=0; i<MIOS32_UART_NUM; ++i)
    MIOS32_UART_MIDI_RS_Reset(i);
 8006034:	f7ff ffd0 	bl	8005fd8 <MIOS32_UART_MIDI_RS_Reset>
 8006038:	2001      	movs	r0, #1
 800603a:	f7ff ffcd 	bl	8005fd8 <MIOS32_UART_MIDI_RS_Reset>

  // if any MIDI assignment:
#if MIOS32_UART0_ASSIGNMENT == 1 || MIOS32_UART1_ASSIGNMENT == 1 || MIOS32_UART2_ASSIGNMENT == 1
  // initialize U(S)ART interface
  if( MIOS32_UART_Init(0) < 0 )
 800603e:	4620      	mov	r0, r4
 8006040:	f001 ffe2 	bl	8008008 <MIOS32_UART_Init>
    return -1; // initialisation of U(S)ART Interface failed
 8006044:	2800      	cmp	r0, #0
 8006046:	bfb4      	ite	lt
 8006048:	f04f 30ff 	movlt.w	r0, #4294967295
 800604c:	2000      	movge	r0, #0
#endif

  return 0; // no error
#endif
}
 800604e:	bd10      	pop	{r4, pc}
 8006050:	200007dc 	.word	0x200007dc
 8006054:	200007f4 	.word	0x200007f4

08006058 <MIOS32_UART_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Periodic_mS(void)
{
 8006058:	b508      	push	{r3, lr}
#if MIOS32_UART_NUM
  u8 uart_port;

  MIOS32_IRQ_Disable();
 800605a:	f000 fae3 	bl	8006624 <MIOS32_IRQ_Disable>
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 800605e:	4b12      	ldr	r3, [pc, #72]	; (80060a8 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 8006060:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006064:	881a      	ldrh	r2, [r3, #0]
 8006066:	428a      	cmp	r2, r1
 8006068:	d001      	beq.n	800606e <MIOS32_UART_MIDI_Periodic_mS+0x16>
      ++rs_expire_ctr[uart_port];
 800606a:	3201      	adds	r2, #1
 800606c:	801a      	strh	r2, [r3, #0]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 800606e:	4b0f      	ldr	r3, [pc, #60]	; (80060ac <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 8006070:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006074:	891a      	ldrh	r2, [r3, #8]
 8006076:	428a      	cmp	r2, r1
 8006078:	d001      	beq.n	800607e <MIOS32_UART_MIDI_Periodic_mS+0x26>
      ++midi_rec[uart_port].timeout_ctr;
 800607a:	3201      	adds	r2, #1
 800607c:	811a      	strh	r2, [r3, #8]
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 800607e:	4b0a      	ldr	r3, [pc, #40]	; (80060a8 <MIOS32_UART_MIDI_Periodic_mS+0x50>)
 8006080:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006084:	885a      	ldrh	r2, [r3, #2]
 8006086:	428a      	cmp	r2, r1
 8006088:	d001      	beq.n	800608e <MIOS32_UART_MIDI_Periodic_mS+0x36>
      ++rs_expire_ctr[uart_port];
 800608a:	3201      	adds	r2, #1
 800608c:	805a      	strh	r2, [r3, #2]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 800608e:	4b07      	ldr	r3, [pc, #28]	; (80060ac <MIOS32_UART_MIDI_Periodic_mS+0x54>)
 8006090:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8006094:	8a9a      	ldrh	r2, [r3, #20]
 8006096:	428a      	cmp	r2, r1
 8006098:	d001      	beq.n	800609e <MIOS32_UART_MIDI_Periodic_mS+0x46>
      ++midi_rec[uart_port].timeout_ctr;
 800609a:	3201      	adds	r2, #1
 800609c:	829a      	strh	r2, [r3, #20]
  }
  MIOS32_IRQ_Enable();
 800609e:	f000 fad7 	bl	8006650 <MIOS32_IRQ_Enable>
  // (atomic operation not required in MIOS32_UART_MIDI_PackageSend_NonBlocking() due to single-byte accesses)
#endif

  return 0; // no error
}
 80060a2:	2000      	movs	r0, #0
 80060a4:	bd08      	pop	{r3, pc}
 80060a6:	bf00      	nop
 80060a8:	200007f8 	.word	0x200007f8
 80060ac:	200007dc 	.word	0x200007dc

080060b0 <MIOS32_UART_MIDI_PackageSend_NonBlocking>:
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 80060b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80060b2:	2801      	cmp	r0, #1
 80060b4:	f3c1 2607 	ubfx	r6, r1, #8, #8
 80060b8:	f001 030f 	and.w	r3, r1, #15
 80060bc:	f3c1 4207 	ubfx	r2, r1, #16, #8
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 80060c0:	4604      	mov	r4, r0
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 80060c2:	b2f7      	uxtb	r7, r6
 80060c4:	f3c1 6107 	ubfx	r1, r1, #24, #8
 80060c8:	d844      	bhi.n	8006154 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa4>
 80060ca:	e046      	b.n	800615a <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xaa>

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};

    if( rs_expire_ctr[uart_port] > 1000 ) {
 80060cc:	4826      	ldr	r0, [pc, #152]	; (8006168 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xb8>)
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 80060ce:	f88d 6004 	strb.w	r6, [sp, #4]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 80060d2:	f830 c014 	ldrh.w	ip, [r0, r4, lsl #1]
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 80060d6:	f88d 2005 	strb.w	r2, [sp, #5]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 80060da:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 80060de:	f88d 1006 	strb.w	r1, [sp, #6]

    if( rs_expire_ctr[uart_port] > 1000 ) {
 80060e2:	d903      	bls.n	80060ec <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x3c>
      // the current RS is expired each second to ensure that a status byte will be sent
      // if the MIDI cable is (re)connected during runtime
      MIOS32_UART_MIDI_RS_Reset(uart_port);
 80060e4:	4620      	mov	r0, r4
 80060e6:	f7ff ff77 	bl	8005fd8 <MIOS32_UART_MIDI_RS_Reset>
 80060ea:	e022      	b.n	8006132 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
#if 0
      // for optional monitoring of the optimisation
      MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS 0x%02x expired!\n", uart_port);
#endif
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
 80060ec:	f8df c07c 	ldr.w	ip, [pc, #124]	; 800616c <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xbc>
 80060f0:	f89c c000 	ldrb.w	ip, [ip]
 80060f4:	fa4c fc04 	asr.w	ip, ip, r4
 80060f8:	f01c 0f01 	tst.w	ip, #1
 80060fc:	d019      	beq.n	8006132 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
 80060fe:	2b07      	cmp	r3, #7
 8006100:	dd17      	ble.n	8006132 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  package.cin >= NoteOff && package.cin <= PitchBend &&
 8006102:	2b0e      	cmp	r3, #14
 8006104:	bfcc      	ite	gt
 8006106:	2300      	movgt	r3, #0
 8006108:	2301      	movle	r3, #1
 800610a:	2d01      	cmp	r5, #1
 800610c:	bf94      	ite	ls
 800610e:	2300      	movls	r3, #0
 8006110:	f003 0301 	andhi.w	r3, r3, #1
 8006114:	b16b      	cbz	r3, 8006132 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
 8006116:	4b16      	ldr	r3, [pc, #88]	; (8006170 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)
 8006118:	5d1b      	ldrb	r3, [r3, r4]
 800611a:	42bb      	cmp	r3, r7
 800611c:	d106      	bne.n	800612c <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x7c>
	  buffer[0] = package.evnt1;
	  buffer[1] = package.evnt2;
	  --len;
 800611e:	3d01      	subs	r5, #1
    } else {
      if( (rs_optimisation & (1 << uart_port)) &&
	  package.cin >= NoteOff && package.cin <= PitchBend &&
	  len > 1 ) { // (len check is a failsafe measure)
	if( package.evnt0 == rs_last[uart_port] ) {
	  buffer[0] = package.evnt1;
 8006120:	f88d 2004 	strb.w	r2, [sp, #4]
	  buffer[1] = package.evnt2;
 8006124:	f88d 1005 	strb.w	r1, [sp, #5]
	  --len;
 8006128:	b2ed      	uxtb	r5, r5
 800612a:	e002      	b.n	8006132 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x82>
	  // for optional monitoring of the optimisation
	  MIOS32_MIDI_SendDebugMessage("[MIOS32_UART_MIDI:%d] RS optimized (%02x) %02x %02x\n", uart_port, package.evnt0, package.evnt1, package.evnt2);
#endif
	} else {
	  // new running status
	  rs_expire_ctr[uart_port] = 0;
 800612c:	2300      	movs	r3, #0
 800612e:	f820 3014 	strh.w	r3, [r0, r4, lsl #1]
      }
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
 8006132:	2ff7      	cmp	r7, #247	; 0xf7
      rs_last[uart_port] = package.evnt0;
 8006134:	bf98      	it	ls
 8006136:	4b0e      	ldrls	r3, [pc, #56]	; (8006170 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 8006138:	4620      	mov	r0, r4
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
      rs_last[uart_port] = package.evnt0;
 800613a:	bf98      	it	ls
 800613c:	551e      	strbls	r6, [r3, r4]


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 800613e:	a901      	add	r1, sp, #4
 8006140:	462a      	mov	r2, r5
 8006142:	f002 f8f7 	bl	8008334 <MIOS32_UART_TxBufferPutMore>
 8006146:	3002      	adds	r0, #2
 8006148:	2802      	cmp	r0, #2
 800614a:	bf9c      	itt	ls
 800614c:	4b09      	ldrls	r3, [pc, #36]	; (8006174 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc4>)
 800614e:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
 8006152:	d901      	bls.n	8006158 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 8006154:	f04f 30ff 	mov.w	r0, #4294967295

  } else {
    return 0; // no bytes to send -> no error
  }
#endif
}
 8006158:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
 800615a:	4807      	ldr	r0, [pc, #28]	; (8006178 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc8>)
 800615c:	5cc5      	ldrb	r5, [r0, r3]
      case -2: return -2; // buffer full, request retry
      default: return -1; // UART error
    }

  } else {
    return 0; // no bytes to send -> no error
 800615e:	4628      	mov	r0, r5
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
  if( len ) {
 8006160:	2d00      	cmp	r5, #0
 8006162:	d1b3      	bne.n	80060cc <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x1c>
 8006164:	e7f8      	b.n	8006158 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xa8>
 8006166:	bf00      	nop
 8006168:	200007f8 	.word	0x200007f8
 800616c:	200007f4 	.word	0x200007f4
 8006170:	200007d8 	.word	0x200007d8
 8006174:	0800aee0 	.word	0x0800aee0
 8006178:	0800adac 	.word	0x0800adac

0800617c <MIOS32_UART_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: UART_MIDI device not available
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend(u8 uart_port, mios32_midi_package_t package)
{
 800617c:	b538      	push	{r3, r4, r5, lr}
 800617e:	4605      	mov	r5, r0
 8006180:	460c      	mov	r4, r1
  s32 error;

  while( (error=MIOS32_UART_MIDI_PackageSend_NonBlocking(uart_port, package)) == -2);
 8006182:	4628      	mov	r0, r5
 8006184:	4621      	mov	r1, r4
 8006186:	f7ff ff93 	bl	80060b0 <MIOS32_UART_MIDI_PackageSend_NonBlocking>
 800618a:	f110 0f02 	cmn.w	r0, #2
 800618e:	d0f8      	beq.n	8006182 <MIOS32_UART_MIDI_PackageSend+0x6>

  return error;
}
 8006190:	bd38      	pop	{r3, r4, r5, pc}
	...

08006194 <MIOS32_UART_MIDI_PackageReceive>:
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 8006194:	2801      	cmp	r0, #1
//! \return -1: no package in buffer
//! \return -10: incoming MIDI package timed out (incomplete package received)
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageReceive(u8 uart_port, mios32_midi_package_t *package)
{
 8006196:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006198:	4604      	mov	r4, r0
 800619a:	460e      	mov	r6, r1
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled - accordingly no package in buffer
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
    return -1;
 800619c:	bf88      	it	hi
 800619e:	f04f 30ff 	movhi.w	r0, #4294967295
    // notify that incomplete package has been received
    return -10;
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 80061a2:	f200 80c5 	bhi.w	8006330 <MIOS32_UART_MIDI_PackageReceive+0x19c>
 80061a6:	e09e      	b.n	80062e6 <MIOS32_UART_MIDI_PackageReceive+0x152>
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
    u8 byte = (u8)status;
 80061a8:	b2c0      	uxtb	r0, r0

    if( byte & 0x80 ) { // new MIDI status
 80061aa:	f010 0f80 	tst.w	r0, #128	; 0x80
 80061ae:	d048      	beq.n	8006242 <MIOS32_UART_MIDI_PackageReceive+0xae>
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
 80061b0:	28f7      	cmp	r0, #247	; 0xf7
 80061b2:	d908      	bls.n	80061c6 <MIOS32_UART_MIDI_PackageReceive+0x32>
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
 80061b4:	6833      	ldr	r3, [r6, #0]
 80061b6:	f043 030f 	orr.w	r3, r3, #15
 80061ba:	6033      	str	r3, [r6, #0]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
 80061bc:	2300      	movs	r3, #0
    if( byte & 0x80 ) { // new MIDI status
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
	// Realtime messages don't change the running status and can be sent immediately
	// They also don't touch the timeout counter!
	package->cin = 0xf; // F: single byte
	package->evnt0 = byte;
 80061be:	7070      	strb	r0, [r6, #1]
	package->evnt1 = 0x00;
 80061c0:	70b3      	strb	r3, [r6, #2]
	package->evnt2 = 0x00;
 80061c2:	70f3      	strb	r3, [r6, #3]
 80061c4:	e0b5      	b.n	8006332 <MIOS32_UART_MIDI_PackageReceive+0x19e>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 80061c6:	f3c0 1302 	ubfx	r3, r0, #4, #3
 80061ca:	5cfb      	ldrb	r3, [r7, r3]
	package->evnt0 = byte;
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
 80061cc:	7128      	strb	r0, [r5, #4]
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 80061ce:	716b      	strb	r3, [r5, #5]

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 80061d0:	2b00      	cmp	r3, #0
 80061d2:	d12e      	bne.n	8006232 <MIOS32_UART_MIDI_PackageReceive+0x9e>
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 80061d4:	4958      	ldr	r1, [pc, #352]	; (8006338 <MIOS32_UART_MIDI_PackageReceive+0x1a4>)
 80061d6:	f000 020f 	and.w	r2, r0, #15
 80061da:	5c8a      	ldrb	r2, [r1, r2]

	  if( byte == 0xf0 ) {
 80061dc:	28f0      	cmp	r0, #240	; 0xf0
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 80061de:	716a      	strb	r2, [r5, #5]

	  if( byte == 0xf0 ) {
 80061e0:	d103      	bne.n	80061ea <MIOS32_UART_MIDI_PackageReceive+0x56>
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
	    midix->sysex_ctr = 0x01;
 80061e2:	2201      	movs	r2, #1

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];

	  if( byte == 0xf0 ) {
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
 80061e4:	7068      	strb	r0, [r5, #1]
	    midix->sysex_ctr = 0x01;
 80061e6:	71ea      	strb	r2, [r5, #7]
 80061e8:	e024      	b.n	8006234 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	  } else if( byte == 0xf7 ) {
 80061ea:	28f7      	cmp	r0, #247	; 0xf7
 80061ec:	d122      	bne.n	8006234 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	    switch( midix->sysex_ctr ) {
 80061ee:	79ea      	ldrb	r2, [r5, #7]
 80061f0:	b11a      	cbz	r2, 80061fa <MIOS32_UART_MIDI_PackageReceive+0x66>
 80061f2:	2a01      	cmp	r2, #1
 80061f4:	782a      	ldrb	r2, [r5, #0]
 80061f6:	d110      	bne.n	800621a <MIOS32_UART_MIDI_PackageReceive+0x86>
 80061f8:	e008      	b.n	800620c <MIOS32_UART_MIDI_PackageReceive+0x78>
 	      case 0:
		midix->package.cin = 5; // 5: SysEx ends with single byte
 80061fa:	782b      	ldrb	r3, [r5, #0]
 80061fc:	2105      	movs	r1, #5
 80061fe:	f361 0303 	bfi	r3, r1, #0, #4
 8006202:	702b      	strb	r3, [r5, #0]
		midix->package.evnt0 = 0xf7;
 8006204:	7068      	strb	r0, [r5, #1]
		midix->package.evnt1 = 0x00;
 8006206:	70aa      	strb	r2, [r5, #2]
		midix->package.evnt2 = 0x00;
 8006208:	70ea      	strb	r2, [r5, #3]
		break;
 800620a:	e00c      	b.n	8006226 <MIOS32_UART_MIDI_PackageReceive+0x92>
	      case 1:
		midix->package.cin = 6; // 6: SysEx ends with two bytes
 800620c:	2106      	movs	r1, #6
 800620e:	f361 0203 	bfi	r2, r1, #0, #4
 8006212:	702a      	strb	r2, [r5, #0]
		// midix->package.evnt0 = // already stored
		midix->package.evnt1 = 0xf7;
 8006214:	70a8      	strb	r0, [r5, #2]
		midix->package.evnt2 = 0x00;
 8006216:	70eb      	strb	r3, [r5, #3]
		break;
 8006218:	e005      	b.n	8006226 <MIOS32_UART_MIDI_PackageReceive+0x92>
	      default:
		midix->package.cin = 7; // 7: SysEx ends with three bytes
 800621a:	4613      	mov	r3, r2
 800621c:	2207      	movs	r2, #7
 800621e:	f362 0303 	bfi	r3, r2, #0, #4
 8006222:	702b      	strb	r3, [r5, #0]
		// midix->package.evnt0 = // already stored
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
 8006224:	70e8      	strb	r0, [r5, #3]
		break;
	    }
	    *package = midix->package;
 8006226:	682b      	ldr	r3, [r5, #0]
 8006228:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
 800622a:	2300      	movs	r3, #0
 800622c:	71eb      	strb	r3, [r5, #7]
		// midix->package.evnt1 = // already stored
		midix->package.evnt2 = 0xf7;
		break;
	    }
	    *package = midix->package;
	    package_complete = 1; // -> forward to caller
 800622e:	3301      	adds	r3, #1
 8006230:	e000      	b.n	8006234 <MIOS32_UART_MIDI_PackageReceive+0xa0>
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];

	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 8006232:	2300      	movs	r3, #0
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
	  }
	}

	midix->wait_bytes = midix->expected_bytes;
 8006234:	796a      	ldrb	r2, [r5, #5]
 8006236:	71aa      	strb	r2, [r5, #6]
	midix->timeout_ctr = 0; // reset timeout counter
 8006238:	2200      	movs	r2, #0
 800623a:	812a      	strh	r2, [r5, #8]
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 800623c:	2b00      	cmp	r3, #0
 800623e:	d057      	beq.n	80062f0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
 8006240:	e077      	b.n	8006332 <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 8006242:	792b      	ldrb	r3, [r5, #4]
 8006244:	2bf0      	cmp	r3, #240	; 0xf0
 8006246:	d117      	bne.n	8006278 <MIOS32_UART_MIDI_PackageReceive+0xe4>
	switch( ++midix->sysex_ctr ) {
 8006248:	79eb      	ldrb	r3, [r5, #7]
 800624a:	3301      	adds	r3, #1
 800624c:	b2db      	uxtb	r3, r3
 800624e:	2b01      	cmp	r3, #1
 8006250:	71eb      	strb	r3, [r5, #7]
 8006252:	d002      	beq.n	800625a <MIOS32_UART_MIDI_PackageReceive+0xc6>
 8006254:	2b02      	cmp	r3, #2
 8006256:	d104      	bne.n	8006262 <MIOS32_UART_MIDI_PackageReceive+0xce>
 8006258:	e001      	b.n	800625e <MIOS32_UART_MIDI_PackageReceive+0xca>
  	  case 1:
	    midix->package.evnt0 = byte; 
 800625a:	7068      	strb	r0, [r5, #1]
	    break;
 800625c:	e048      	b.n	80062f0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  case 2: 
	    midix->package.evnt1 = byte; 
 800625e:	70a8      	strb	r0, [r5, #2]
	    break;
 8006260:	e046      	b.n	80062f0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  default: // 3
	    midix->package.evnt2 = byte;

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 8006262:	782b      	ldrb	r3, [r5, #0]
 8006264:	2204      	movs	r2, #4
 8006266:	f362 0303 	bfi	r3, r2, #0, #4
	    break;
	  case 2: 
	    midix->package.evnt1 = byte; 
	    break;
	  default: // 3
	    midix->package.evnt2 = byte;
 800626a:	70e8      	strb	r0, [r5, #3]

	    // Send three-byte event
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 800626c:	702b      	strb	r3, [r5, #0]
	    *package = midix->package;
 800626e:	682b      	ldr	r3, [r5, #0]
 8006270:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
 8006272:	2300      	movs	r3, #0
 8006274:	71eb      	strb	r3, [r5, #7]
 8006276:	e05c      	b.n	8006332 <MIOS32_UART_MIDI_PackageReceive+0x19e>
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
 8006278:	79ab      	ldrb	r3, [r5, #6]
 800627a:	b923      	cbnz	r3, 8006286 <MIOS32_UART_MIDI_PackageReceive+0xf2>
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 800627c:	796a      	ldrb	r2, [r5, #5]
	  midix->timeout_ctr = 0; // reset timeout counter
 800627e:	812b      	strh	r3, [r5, #8]
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
	}
      } else { // Common MIDI message or 0xf1 >= status >= 0xf7
	if( !midix->wait_bytes ) {
	  // received new MIDI event with running status
	  midix->wait_bytes = midix->expected_bytes - 1;
 8006280:	3a01      	subs	r2, #1
 8006282:	71aa      	strb	r2, [r5, #6]
 8006284:	e001      	b.n	800628a <MIOS32_UART_MIDI_PackageReceive+0xf6>
	  midix->timeout_ctr = 0; // reset timeout counter
	} else {
	  --midix->wait_bytes;
 8006286:	3b01      	subs	r3, #1
 8006288:	71ab      	strb	r3, [r5, #6]
	}

	if( midix->expected_bytes == 1 ) {
 800628a:	796b      	ldrb	r3, [r5, #5]
 800628c:	2b01      	cmp	r3, #1
 800628e:	d103      	bne.n	8006298 <MIOS32_UART_MIDI_PackageReceive+0x104>
	  midix->package.evnt1 = byte;
	  midix->package.evnt2 = 0x00;
 8006290:	3b01      	subs	r3, #1
	} else {
	  --midix->wait_bytes;
	}

	if( midix->expected_bytes == 1 ) {
	  midix->package.evnt1 = byte;
 8006292:	70a8      	strb	r0, [r5, #2]
	  midix->package.evnt2 = 0x00;
 8006294:	70eb      	strb	r3, [r5, #3]
 8006296:	e004      	b.n	80062a2 <MIOS32_UART_MIDI_PackageReceive+0x10e>
	} else {
	  if( midix->wait_bytes )
 8006298:	79ab      	ldrb	r3, [r5, #6]
 800629a:	b10b      	cbz	r3, 80062a0 <MIOS32_UART_MIDI_PackageReceive+0x10c>
	    midix->package.evnt1 = byte;
 800629c:	70a8      	strb	r0, [r5, #2]
 800629e:	e000      	b.n	80062a2 <MIOS32_UART_MIDI_PackageReceive+0x10e>
	  else
	    midix->package.evnt2 = byte;
 80062a0:	70e8      	strb	r0, [r5, #3]
	}
	
	if( !midix->wait_bytes ) {
 80062a2:	79ab      	ldrb	r3, [r5, #6]
 80062a4:	bb23      	cbnz	r3, 80062f0 <MIOS32_UART_MIDI_PackageReceive+0x15c>
	  if( (midix->running_status & 0xf0) != 0xf0 ) {
 80062a6:	792b      	ldrb	r3, [r5, #4]
 80062a8:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80062ac:	2af0      	cmp	r2, #240	; 0xf0
 80062ae:	d002      	beq.n	80062b6 <MIOS32_UART_MIDI_PackageReceive+0x122>
	    midix->package.cin = midix->running_status >> 4; // common MIDI message
 80062b0:	091a      	lsrs	r2, r3, #4
 80062b2:	782b      	ldrb	r3, [r5, #0]
 80062b4:	e00b      	b.n	80062ce <MIOS32_UART_MIDI_PackageReceive+0x13a>
	  } else {
	    switch( midix->expected_bytes ) { // MEMO: == 0 comparison was a bug in original MBHP_USB code
 80062b6:	796b      	ldrb	r3, [r5, #5]
 80062b8:	b11b      	cbz	r3, 80062c2 <MIOS32_UART_MIDI_PackageReceive+0x12e>
 80062ba:	2b01      	cmp	r3, #1
 80062bc:	782b      	ldrb	r3, [r5, #0]
 80062be:	d105      	bne.n	80062cc <MIOS32_UART_MIDI_PackageReceive+0x138>
 80062c0:	e002      	b.n	80062c8 <MIOS32_UART_MIDI_PackageReceive+0x134>
  	      case 0: 
		midix->package.cin = 5; // 5: SysEx common with one byte
 80062c2:	782b      	ldrb	r3, [r5, #0]
 80062c4:	2205      	movs	r2, #5
 80062c6:	e002      	b.n	80062ce <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      case 1: 
		midix->package.cin = 2; // 2: SysEx common with two bytes
 80062c8:	2202      	movs	r2, #2
 80062ca:	e000      	b.n	80062ce <MIOS32_UART_MIDI_PackageReceive+0x13a>
		break;
  	      default: 
		midix->package.cin = 3; // 3: SysEx common with three bytes
 80062cc:	2203      	movs	r2, #3
 80062ce:	f362 0303 	bfi	r3, r2, #0, #4
 80062d2:	702b      	strb	r3, [r5, #0]
		break;
	    }
	  }

	  midix->package.evnt0 = midix->running_status;
 80062d4:	230c      	movs	r3, #12
 80062d6:	4363      	muls	r3, r4
 80062d8:	4a18      	ldr	r2, [pc, #96]	; (800633c <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 80062da:	18d1      	adds	r1, r2, r3
 80062dc:	7908      	ldrb	r0, [r1, #4]
 80062de:	7048      	strb	r0, [r1, #1]
	  // midix->package.evnt1 = // already stored
	  // midix->package.evnt2 = // already stored
	  *package = midix->package;
 80062e0:	58d3      	ldr	r3, [r2, r3]
 80062e2:	6033      	str	r3, [r6, #0]
 80062e4:	e025      	b.n	8006332 <MIOS32_UART_MIDI_PackageReceive+0x19e>

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 80062e6:	4b15      	ldr	r3, [pc, #84]	; (800633c <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 80062e8:	250c      	movs	r5, #12
 80062ea:	fb05 3504 	mla	r5, r5, r4, r3
	package->evnt1 = 0x00;
	package->evnt2 = 0x00;
	package_complete = 1;
      } else {
	midix->running_status = byte;
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 80062ee:	4f14      	ldr	r7, [pc, #80]	; (8006340 <MIOS32_UART_MIDI_PackageReceive+0x1ac>)
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 80062f0:	4620      	mov	r0, r4
 80062f2:	f001 ff2d 	bl	8008150 <MIOS32_UART_RxBufferGet>
 80062f6:	2800      	cmp	r0, #0
 80062f8:	f6bf af56 	bge.w	80061a8 <MIOS32_UART_MIDI_PackageReceive+0x14>
 80062fc:	2000      	movs	r0, #0
      }
    }
  }

  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
 80062fe:	230c      	movs	r3, #12
 8006300:	435c      	muls	r4, r3
 8006302:	490e      	ldr	r1, [pc, #56]	; (800633c <MIOS32_UART_MIDI_PackageReceive+0x1a8>)
 8006304:	190b      	adds	r3, r1, r4
 8006306:	799a      	ldrb	r2, [r3, #6]
 8006308:	b16a      	cbz	r2, 8006326 <MIOS32_UART_MIDI_PackageReceive+0x192>
 800630a:	891a      	ldrh	r2, [r3, #8]
 800630c:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 8006310:	d909      	bls.n	8006326 <MIOS32_UART_MIDI_PackageReceive+0x192>
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 8006312:	2200      	movs	r2, #0
 8006314:	510a      	str	r2, [r1, r4]
  midix->running_status = 0x00;
 8006316:	711a      	strb	r2, [r3, #4]
  midix->expected_bytes = 0x00;
 8006318:	715a      	strb	r2, [r3, #5]
  midix->wait_bytes = 0x00;
 800631a:	719a      	strb	r2, [r3, #6]
  midix->sysex_ctr = 0x00;
 800631c:	71da      	strb	r2, [r3, #7]
  midix->timeout_ctr = 0;
 800631e:	811a      	strh	r2, [r3, #8]
  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
    // stop waiting
    MIOS32_UART_MIDI_RecordReset(uart_port);
    // notify that incomplete package has been received
    return -10;
 8006320:	f06f 0009 	mvn.w	r0, #9
 8006324:	e004      	b.n	8006330 <MIOS32_UART_MIDI_PackageReceive+0x19c>
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
 8006326:	2800      	cmp	r0, #0
 8006328:	bf0c      	ite	eq
 800632a:	f04f 30ff 	moveq.w	r0, #4294967295
 800632e:	2000      	movne	r0, #0
#endif
}
 8006330:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 8006332:	2001      	movs	r0, #1
 8006334:	e7e3      	b.n	80062fe <MIOS32_UART_MIDI_PackageReceive+0x16a>
 8006336:	bf00      	nop
 8006338:	0800ad9c 	.word	0x0800ad9c
 800633c:	200007dc 	.word	0x200007dc
 8006340:	0800aed0 	.word	0x0800aed0

08006344 <MIOS32_IIC_MIDI_Init>:
  // TODO: send optimisation flag to IIC_MIDI device once it has been scanned!
#endif

  return 0; // no error
#endif
}
 8006344:	f04f 30ff 	mov.w	r0, #4294967295
 8006348:	4770      	bx	lr

0800634a <MIOS32_IIC_MIDI_Periodic_mS>:
s32 MIOS32_IIC_MIDI_Periodic_mS(void)
{
  // currently only a dummy - RS optimisation handled by IIC_MIDI device

  return 0;
}
 800634a:	2000      	movs	r0, #0
 800634c:	4770      	bx	lr

0800634e <MIOS32_IIC_MIDI_PackageSend>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageSend(u8 iic_port, mios32_midi_package_t package)
{
  return _MIOS32_IIC_MIDI_PackageSend(iic_port, package, 0); // blocking mode
}
 800634e:	f04f 30ff 	mov.w	r0, #4294967295
 8006352:	4770      	bx	lr

08006354 <MIOS32_IIC_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IIC_MIDI_PackageReceive(u8 iic_port, mios32_midi_package_t *package)
{
  return _MIOS32_IIC_MIDI_PackageReceive(iic_port, package, 0); // blocking
}
 8006354:	f04f 30ff 	mov.w	r0, #4294967295
 8006358:	4770      	bx	lr

0800635a <MIOS32_IIC_BS_Init>:
  if( MIOS32_IIC_BS_ScanBankSticks() < 0 )
    return -2; // we don't expect that any other task accesses the IIC port yet!

  return 0; // no error
#endif
}
 800635a:	f04f 30ff 	mov.w	r0, #4294967295
 800635e:	4770      	bx	lr

08006360 <MIOS32_MF_Init>:
    mf_state[i].config.cfg.pwm_duty_cycle_up = 1;
  }

  return 0;
#endif
}
 8006360:	f04f 30ff 	mov.w	r0, #4294967295
 8006364:	4770      	bx	lr
	...

08006368 <MIOS32_SYS_Reset>:
//!   <LI>reset STM32
//! </UL>
//! \return < 0 if reset failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Reset(void)
{
 8006368:	b508      	push	{r3, lr}
  // disable all RTOS tasks
#ifndef MIOS32_DONT_USE_FREERTOS
  portENTER_CRITICAL(); // port specific FreeRTOS function to disable tasks (nested)
 800636a:	f7fe fd9f 	bl	8004eac <vPortEnterCritical>

  // print reboot message if LCD enabled
#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 800636e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8006372:	f7ff f8f8 	bl	8005566 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 8006376:	2000      	movs	r0, #0
 8006378:	f7ff f8f9 	bl	800556e <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 800637c:	2000      	movs	r0, #0
 800637e:	f7ff f817 	bl	80053b0 <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 8006382:	f7ff f87d 	bl	8005480 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 8006386:	2000      	movs	r0, #0
 8006388:	4601      	mov	r1, r0
 800638a:	f7ff f817 	bl	80053bc <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("Bootloader Mode "); // 16 chars
 800638e:	4811      	ldr	r0, [pc, #68]	; (80063d4 <MIOS32_SYS_Reset+0x6c>)
 8006390:	f7ff f8a8 	bl	80054e4 <MIOS32_LCD_PrintString>
#endif

  // wait until all MIDI OUT buffers are empty (TODO)

  // disable all interrupts
  MIOS32_IRQ_Disable();
 8006394:	f000 f946 	bl	8006624 <MIOS32_IRQ_Disable>

  // turn off all board LEDs
  MIOS32_BOARD_LED_Set(0xffffffff, 0x00000000);
 8006398:	2100      	movs	r1, #0
 800639a:	f04f 30ff 	mov.w	r0, #4294967295
 800639e:	f000 fe79 	bl	8007094 <MIOS32_BOARD_LED_Set>
#else
  //  NVIC_GenerateSystemReset();
#ifdef MIOS32_BOARD_STM32_PRIMER
  RCC_APB2PeriphResetCmd(0xfffffff0, ENABLE); // Primer: don't reset GPIOA/AF + GPIOB due to USB detach pin
#else
  RCC_APB2PeriphResetCmd(0xfffffff8, ENABLE); // MBHP_CORE_STM32: don't reset GPIOA/AF due to USB pins
 80063a2:	f06f 0007 	mvn.w	r0, #7
 80063a6:	2101      	movs	r1, #1
 80063a8:	f002 ffae 	bl	8009308 <RCC_APB2PeriphResetCmd>
#endif
  RCC_APB1PeriphResetCmd(0xff7fffff, ENABLE); // don't reset USB, so that the connection can survive!
 80063ac:	f46f 0000 	mvn.w	r0, #8388608	; 0x800000
 80063b0:	2101      	movs	r1, #1
 80063b2:	f002 ffb7 	bl	8009324 <RCC_APB1PeriphResetCmd>
  RCC_APB2PeriphResetCmd(0xffffffff, DISABLE);
 80063b6:	f04f 30ff 	mov.w	r0, #4294967295
 80063ba:	2100      	movs	r1, #0
 80063bc:	f002 ffa4 	bl	8009308 <RCC_APB2PeriphResetCmd>
  RCC_APB1PeriphResetCmd(0xffffffff, DISABLE);
 80063c0:	f04f 30ff 	mov.w	r0, #4294967295
 80063c4:	2100      	movs	r1, #0
 80063c6:	f002 ffad 	bl	8009324 <RCC_APB1PeriphResetCmd>
  // not available in v3.0.0 library anymore? - copy from v2.0.1
  SCB->AIRCR = NVIC_AIRCR_VECTKEY | (1 << NVIC_VECTRESET);
#endif
#if 1
  // and this is the code for v3.3.0
  SCB->AIRCR = (0x5fa << SCB_AIRCR_VECTKEY_Pos) | (1 << SCB_AIRCR_VECTRESET_Pos);
 80063ca:	4a03      	ldr	r2, [pc, #12]	; (80063d8 <MIOS32_SYS_Reset+0x70>)
 80063cc:	4b03      	ldr	r3, [pc, #12]	; (80063dc <MIOS32_SYS_Reset+0x74>)
 80063ce:	60da      	str	r2, [r3, #12]
 80063d0:	e7fe      	b.n	80063d0 <MIOS32_SYS_Reset+0x68>
 80063d2:	bf00      	nop
 80063d4:	0800aeec 	.word	0x0800aeec
 80063d8:	05fa0001 	.word	0x05fa0001
 80063dc:	e000ed00 	.word	0xe000ed00

080063e0 <MIOS32_SYS_ChipIDGet>:
//! \return the chip ID
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_ChipIDGet(void)
{
  // stored in DBGMCU_IDCODE register
  return MEM32(0xe0042000);
 80063e0:	4b01      	ldr	r3, [pc, #4]	; (80063e8 <MIOS32_SYS_ChipIDGet+0x8>)
 80063e2:	6818      	ldr	r0, [r3, #0]
}
 80063e4:	4770      	bx	lr
 80063e6:	bf00      	nop
 80063e8:	e0042000 	.word	0xe0042000

080063ec <MIOS32_SYS_FlashSizeGet>:
//! \return the Flash size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_FlashSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e0) * 0x400;
 80063ec:	4b02      	ldr	r3, [pc, #8]	; (80063f8 <MIOS32_SYS_FlashSizeGet+0xc>)
 80063ee:	8818      	ldrh	r0, [r3, #0]
 80063f0:	b280      	uxth	r0, r0
 80063f2:	0280      	lsls	r0, r0, #10
}
 80063f4:	4770      	bx	lr
 80063f6:	bf00      	nop
 80063f8:	1ffff7e0 	.word	0x1ffff7e0

080063fc <MIOS32_SYS_RAMSizeGet>:
//! \return the RAM size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_RAMSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1ffff7e2) * 0x400;
 80063fc:	4b02      	ldr	r3, [pc, #8]	; (8006408 <MIOS32_SYS_RAMSizeGet+0xc>)
 80063fe:	8818      	ldrh	r0, [r3, #0]
 8006400:	b280      	uxth	r0, r0
 8006402:	0280      	lsls	r0, r0, #10
}
 8006404:	4770      	bx	lr
 8006406:	bf00      	nop
 8006408:	1ffff7e2 	.word	0x1ffff7e2

0800640c <MIOS32_SYS_SerialNumberGet>:
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 800640c:	2300      	movs	r3, #0
    u8 b = MEM8(0x1ffff7e8 + (i/2));
 800640e:	4a0b      	ldr	r2, [pc, #44]	; (800643c <MIOS32_SYS_SerialNumberGet+0x30>)
 8006410:	1059      	asrs	r1, r3, #1
 8006412:	188a      	adds	r2, r1, r2
 8006414:	7812      	ldrb	r2, [r2, #0]
    if( !(i & 1) )
 8006416:	f013 0f01 	tst.w	r3, #1
      b >>= 4;
 800641a:	bf08      	it	eq
 800641c:	0912      	lsreq	r2, r2, #4
    b &= 0x0f;
 800641e:	f002 020f 	and.w	r2, r2, #15

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
 8006422:	2a09      	cmp	r2, #9
 8006424:	bf94      	ite	ls
 8006426:	2130      	movls	r1, #48	; 0x30
 8006428:	2137      	movhi	r1, #55	; 0x37
 800642a:	188a      	adds	r2, r1, r2
 800642c:	54c2      	strb	r2, [r0, r3]
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
 800642e:	3301      	adds	r3, #1
 8006430:	2b18      	cmp	r3, #24
 8006432:	d1ec      	bne.n	800640e <MIOS32_SYS_SerialNumberGet+0x2>
      b >>= 4;
    b &= 0x0f;

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
  }
  str[i] = 0;
 8006434:	2300      	movs	r3, #0
 8006436:	7603      	strb	r3, [r0, #24]

  return 0; // no error
}
 8006438:	4618      	mov	r0, r3
 800643a:	4770      	bx	lr
 800643c:	1ffff7e8 	.word	0x1ffff7e8

08006440 <MIOS32_SYS_TimeSet>:
//! Note that this format isn't completely compatible to the NTP timestamp format,
//! as the fraction has only mS accuracy
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_TimeSet(mios32_sys_time_t t)
{
 8006440:	b507      	push	{r0, r1, r2, lr}
 8006442:	466b      	mov	r3, sp
 8006444:	e883 0003 	stmia.w	r3, {r0, r1}
  // taken from STM32 example "RTC/Calendar"
  // adapted to clock RTC via HSE  oscillator

  // Enable PWR and BKP clocks
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 8006448:	2101      	movs	r1, #1
 800644a:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 800644e:	f002 ff4d 	bl	80092ec <RCC_APB1PeriphClockCmd>

  // Allow access to BKP Domain
  PWR_BackupAccessCmd(ENABLE);
 8006452:	2001      	movs	r0, #1
 8006454:	f003 f806 	bl	8009464 <PWR_BackupAccessCmd>

  // Reset Backup Domain
  BKP_DeInit();
 8006458:	f002 fffc 	bl	8009454 <BKP_DeInit>

  // Select HSE (divided by 128) as RTC Clock Source
  RCC_RTCCLKConfig(RCC_RTCCLKSource_HSE_Div128);
 800645c:	f44f 7040 	mov.w	r0, #768	; 0x300
 8006460:	f002 fec6 	bl	80091f0 <RCC_RTCCLKConfig>

  // Enable RTC Clock
  RCC_RTCCLKCmd(ENABLE);
 8006464:	2001      	movs	r0, #1
 8006466:	f002 fecb 	bl	8009200 <RCC_RTCCLKCmd>

  // Wait for RTC registers synchronization
  RTC_WaitForSynchro();
 800646a:	f002 ffe5 	bl	8009438 <RTC_WaitForSynchro>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800646e:	f002 ffdb 	bl	8009428 <RTC_WaitForLastTask>

  // Enable the RTC Second
  RTC_ITConfig(RTC_IT_SEC, ENABLE);
 8006472:	2001      	movs	r0, #1
 8006474:	4601      	mov	r1, r0
 8006476:	f002 ff95 	bl	80093a4 <RTC_ITConfig>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800647a:	f002 ffd5 	bl	8009428 <RTC_WaitForLastTask>

  // Set RTC prescaler: set RTC period to 1sec
  RTC_SetPrescaler(RTC_PREDIVIDER-1);
 800647e:	4806      	ldr	r0, [pc, #24]	; (8006498 <MIOS32_SYS_TimeSet+0x58>)
 8006480:	f002 ffc2 	bl	8009408 <RTC_SetPrescaler>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 8006484:	f002 ffd0 	bl	8009428 <RTC_WaitForLastTask>

  // Change the current time
  // (fraction not taken into account here)
  RTC_SetCounter(t.seconds);
 8006488:	9800      	ldr	r0, [sp, #0]
 800648a:	f002 ffaf 	bl	80093ec <RTC_SetCounter>

  // Wait until last write operation on RTC registers has finished
  RTC_WaitForLastTask();
 800648e:	f002 ffcb 	bl	8009428 <RTC_WaitForLastTask>

  return 0; // no error
}
 8006492:	2000      	movs	r0, #0
 8006494:	bd0e      	pop	{r1, r2, r3, pc}
 8006496:	bf00      	nop
 8006498:	00016e35 	.word	0x00016e35

0800649c <MIOS32_SYS_Init>:
//! </UL>
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
 800649c:	b530      	push	{r4, r5, lr}
 800649e:	4605      	mov	r5, r0
 80064a0:	b085      	sub	sp, #20
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80064a2:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;

  // currently only mode 0 supported
  if( mode != 0 )
 80064a6:	2d00      	cmp	r5, #0
 80064a8:	d177      	bne.n	800659a <MIOS32_SYS_Init+0xfe>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80064aa:	ac03      	add	r4, sp, #12
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  // Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
 80064ac:	2101      	movs	r1, #1
 80064ae:	207d      	movs	r0, #125	; 0x7d
 80064b0:	f002 ff0e 	bl	80092d0 <RCC_APB2PeriphClockCmd>
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80064b4:	4620      	mov	r0, r4
 80064b6:	f002 fa95 	bl	80089e4 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 80064ba:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80064bc:	4621      	mov	r1, r4
			 | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 80064be:	f88d 300f 	strb.w	r3, [sp, #15]
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80064c2:	4837      	ldr	r0, [pc, #220]	; (80065a0 <MIOS32_SYS_Init+0x104>)

  // Activate pull-ups on all pins by default
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
 80064c4:	f24e 73ff 	movw	r3, #59391	; 0xe7ff
 80064c8:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80064cc:	f002 fa31 	bl	8008932 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 80064d0:	f04f 33ff 	mov.w	r3, #4294967295
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 80064d4:	4621      	mov	r1, r4
 80064d6:	4833      	ldr	r0, [pc, #204]	; (80065a4 <MIOS32_SYS_Init+0x108>)
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin   = 0xffff & ~GPIO_Pin_11 & ~GPIO_Pin_12; // exclude USB pins
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin   = 0xffff;
 80064d8:	f8ad 300c 	strh.w	r3, [sp, #12]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 80064dc:	f002 fa29 	bl	8008932 <GPIO_Init>
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 80064e0:	4621      	mov	r1, r4
 80064e2:	4831      	ldr	r0, [pc, #196]	; (80065a8 <MIOS32_SYS_Init+0x10c>)
 80064e4:	f002 fa25 	bl	8008932 <GPIO_Init>
  GPIO_Init(GPIOB, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 80064e8:	4621      	mov	r1, r4
 80064ea:	4830      	ldr	r0, [pc, #192]	; (80065ac <MIOS32_SYS_Init+0x110>)
 80064ec:	f002 fa21 	bl	8008932 <GPIO_Init>
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 80064f0:	f002 fe48 	bl	8009184 <RCC_GetSYSCLKSource>
 80064f4:	2808      	cmp	r0, #8
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Init(u32 mode)
{
  ErrorStatus HSEStartUpStatus = ERROR;
 80064f6:	bf08      	it	eq
 80064f8:	462c      	moveq	r4, r5
#else
  GPIO_Init(GPIOB, &GPIO_InitStructure);
#endif

  // init clock system if chip doesn't already run with PLL
  if( RCC_GetSYSCLKSource() != 0x08 ) {
 80064fa:	d033      	beq.n	8006564 <MIOS32_SYS_Init+0xc8>
    // Start with the clocks in their expected state
    RCC_DeInit();
 80064fc:	f002 fdec 	bl	80090d8 <RCC_DeInit>

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);
 8006500:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8006504:	f002 fe08 	bl	8009118 <RCC_HSEConfig>

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 8006508:	f002 ff36 	bl	8009378 <RCC_WaitForHSEStartUp>

    if( HSEStartUpStatus == SUCCESS ) {
 800650c:	2801      	cmp	r0, #1

    // Enable HSE (high speed external clock)
    RCC_HSEConfig(RCC_HSE_ON);

    // Wait till HSE is ready
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
 800650e:	4604      	mov	r4, r0

    if( HSEStartUpStatus == SUCCESS ) {
 8006510:	d128      	bne.n	8006564 <MIOS32_SYS_Init+0xc8>
      // Enable Prefetch Buffer
      FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 8006512:	2010      	movs	r0, #16
 8006514:	f002 fab2 	bl	8008a7c <FLASH_PrefetchBufferCmd>

      // Flash 2 wait state
      FLASH_SetLatency(FLASH_Latency_2);
 8006518:	2002      	movs	r0, #2
 800651a:	f002 faa5 	bl	8008a68 <FLASH_SetLatency>

      // HCLK = SYSCLK
      RCC_HCLKConfig(RCC_SYSCLK_Div1);
 800651e:	4628      	mov	r0, r5
 8006520:	f002 fe38 	bl	8009194 <RCC_HCLKConfig>

      // PCLK2 = HCLK
      RCC_PCLK2Config(RCC_HCLK_Div1);
 8006524:	4628      	mov	r0, r5
 8006526:	f002 fe49 	bl	80091bc <RCC_PCLK2Config>

      // PCLK1 = HCLK/2
      RCC_PCLK1Config(RCC_HCLK_Div2);
 800652a:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800652e:	f002 fe3b 	bl	80091a8 <RCC_PCLK1Config>

      // ADCCLK = PCLK2/6
      RCC_ADCCLKConfig(RCC_PCLK2_Div6);
 8006532:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8006536:	f002 fe51 	bl	80091dc <RCC_ADCCLKConfig>
      // PLL configuration: PLLCLK = (PLL2 / 5) * 9 = 72 MHz
      RCC_PREDIV1Config(RCC_PREDIV1_Source_PLL2, RCC_PREDIV1_Div5);
      RCC_PLLConfig(RCC_PLLSource_PREDIV1, RCC_PLLMul_9);
#else
      // PLLCLK = 12MHz * 6 = 72 MHz
      RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_6);
 800653a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800653e:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 8006542:	f002 fe05 	bl	8009150 <RCC_PLLConfig>
#endif

      // Enable PLL
      RCC_PLLCmd(ENABLE);
 8006546:	4620      	mov	r0, r4
 8006548:	f002 fe0c 	bl	8009164 <RCC_PLLCmd>

      // Wait till PLL is ready
      while( RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET );
 800654c:	2039      	movs	r0, #57	; 0x39
 800654e:	f002 fefd 	bl	800934c <RCC_GetFlagStatus>
 8006552:	2800      	cmp	r0, #0
 8006554:	d0fa      	beq.n	800654c <MIOS32_SYS_Init+0xb0>

      // Select PLL as system clock source
      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 8006556:	2002      	movs	r0, #2
 8006558:	f002 fe0a 	bl	8009170 <RCC_SYSCLKConfig>

      // Wait till PLL is used as system clock source
      while( RCC_GetSYSCLKSource() != 0x08 );
 800655c:	f002 fe12 	bl	8009184 <RCC_GetSYSCLKSource>
 8006560:	2808      	cmp	r0, #8
 8006562:	d1fb      	bne.n	800655c <MIOS32_SYS_Init+0xc0>
    }
  }

  // Set the Vector Table base address as specified in .ld file (-> mios32_sys_isr_vector)
  NVIC_SetVectorTable((u32)&mios32_sys_isr_vector, 0x0);
 8006564:	2100      	movs	r1, #0
 8006566:	4812      	ldr	r0, [pc, #72]	; (80065b0 <MIOS32_SYS_Init+0x114>)
 8006568:	f002 ff8c 	bl	8009484 <NVIC_SetVectorTable>
  NVIC_PriorityGroupConfig(MIOS32_IRQ_PRIGROUP);
 800656c:	f44f 7040 	mov.w	r0, #768	; 0x300
 8006570:	f002 ff7e 	bl	8009470 <NVIC_PriorityGroupConfig>

  // Configure HCLK clock as SysTick clock source
  SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );
 8006574:	2004      	movs	r0, #4
 8006576:	f002 ff91 	bl	800949c <SysTick_CLKSourceConfig>

  // configure debug control register DBGMCU_CR (we want to stop timers in CPU HALT mode)
  // flags can be overruled in mios32_config.h
  MEM32(0xe0042004) = MIOS32_SYS_STM32_DBGMCU_CR;
 800657a:	4a0e      	ldr	r2, [pc, #56]	; (80065b4 <MIOS32_SYS_Init+0x118>)
 800657c:	4b0e      	ldr	r3, [pc, #56]	; (80065b8 <MIOS32_SYS_Init+0x11c>)
 800657e:	601a      	str	r2, [r3, #0]

  // initialize system clock
  mios32_sys_time_t t = { .seconds=0, .fraction_ms=0 };
 8006580:	2300      	movs	r3, #0
 8006582:	9301      	str	r3, [sp, #4]
 8006584:	9302      	str	r3, [sp, #8]
  MIOS32_SYS_TimeSet(t);
 8006586:	ab01      	add	r3, sp, #4
 8006588:	e893 0003 	ldmia.w	r3, {r0, r1}
 800658c:	f7ff ff58 	bl	8006440 <MIOS32_SYS_TimeSet>

  // error during clock configuration?
  return HSEStartUpStatus == SUCCESS ? 0 : -1;
 8006590:	2c01      	cmp	r4, #1
 8006592:	bf14      	ite	ne
 8006594:	f04f 30ff 	movne.w	r0, #4294967295
 8006598:	2000      	moveq	r0, #0
}
 800659a:	b005      	add	sp, #20
 800659c:	bd30      	pop	{r4, r5, pc}
 800659e:	bf00      	nop
 80065a0:	40010800 	.word	0x40010800
 80065a4:	40011000 	.word	0x40011000
 80065a8:	40011400 	.word	0x40011400
 80065ac:	40010c00 	.word	0x40010c00
 80065b0:	08004000 	.word	0x08004000
 80065b4:	001fff00 	.word	0x001fff00
 80065b8:	e0042004 	.word	0xe0042004

080065bc <MIOS32_SYS_TimeGet>:
//!   int milliseconds = t.fraction_ms;
//! \endcode
//! \return the system time in a mios32_sys_time_t structure
/////////////////////////////////////////////////////////////////////////////
mios32_sys_time_t MIOS32_SYS_TimeGet(void)
{
 80065bc:	b570      	push	{r4, r5, r6, lr}
 80065be:	4604      	mov	r4, r0
  // therefore interrupts are disabled
  // Disadvantage: bad for interrupt latency...
  // However, expected execution time is ca. 500 nS for two loops (best case),
  // and 750 nS for three loops (worst case)

  MIOS32_IRQ_Disable();
 80065c0:	f000 f830 	bl	8006624 <MIOS32_IRQ_Disable>
  seconds = divider = 0;
 80065c4:	2200      	movs	r2, #0
 80065c6:	4611      	mov	r1, r2
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
 80065c8:	4b12      	ldr	r3, [pc, #72]	; (8006614 <MIOS32_SYS_TimeGet+0x58>)
 80065ca:	e001      	b.n	80065d0 <MIOS32_SYS_TimeGet+0x14>
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 80065cc:	462a      	mov	r2, r5
  MIOS32_IRQ_Disable();
  seconds = divider = 0;
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
 80065ce:	4631      	mov	r1, r6
 80065d0:	8b18      	ldrh	r0, [r3, #24]
 80065d2:	8b9e      	ldrh	r6, [r3, #28]
 80065d4:	b2b6      	uxth	r6, r6
 80065d6:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 80065da:	8a18      	ldrh	r0, [r3, #16]
 80065dc:	8a9d      	ldrh	r5, [r3, #20]
  } while( seconds != last_seconds && divider != last_divider );
 80065de:	1a71      	subs	r1, r6, r1
 80065e0:	bf18      	it	ne
 80065e2:	2101      	movne	r1, #1
  seconds = divider = 0;
  do {
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
 80065e4:	b2ad      	uxth	r5, r5
 80065e6:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
  } while( seconds != last_seconds && divider != last_divider );
 80065ea:	4295      	cmp	r5, r2
 80065ec:	bf0c      	ite	eq
 80065ee:	2200      	moveq	r2, #0
 80065f0:	f001 0201 	andne.w	r2, r1, #1
 80065f4:	2a00      	cmp	r2, #0
 80065f6:	d1e9      	bne.n	80065cc <MIOS32_SYS_TimeGet+0x10>
  MIOS32_IRQ_Enable();
 80065f8:	f000 f82a 	bl	8006650 <MIOS32_IRQ_Enable>

  mios32_sys_time_t t = {
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
 80065fc:	4b06      	ldr	r3, [pc, #24]	; (8006618 <MIOS32_SYS_TimeGet+0x5c>)
 80065fe:	4a07      	ldr	r2, [pc, #28]	; (800661c <MIOS32_SYS_TimeGet+0x60>)
 8006600:	435d      	muls	r5, r3
 8006602:	4b07      	ldr	r3, [pc, #28]	; (8006620 <MIOS32_SYS_TimeGet+0x64>)
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
  } while( seconds != last_seconds && divider != last_divider );
  MIOS32_IRQ_Enable();
 8006604:	6026      	str	r6, [r4, #0]

  mios32_sys_time_t t = {
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
 8006606:	18eb      	adds	r3, r5, r3
 8006608:	fbb3 f3f2 	udiv	r3, r3, r2
    last_seconds = seconds;
    last_divider = divider;
    seconds = ((u32)RTC->CNTH << 16) | RTC->CNTL;
    divider = ((u32)RTC->DIVH << 16) | RTC->DIVL;
  } while( seconds != last_seconds && divider != last_divider );
  MIOS32_IRQ_Enable();
 800660c:	6063      	str	r3, [r4, #4]
    .seconds = seconds,
    .fraction_ms = (1000 * (RTC_PREDIVIDER-1-divider)) / RTC_PREDIVIDER
  };

  return t;
}
 800660e:	4620      	mov	r0, r4
 8006610:	bd70      	pop	{r4, r5, r6, pc}
 8006612:	bf00      	nop
 8006614:	40002800 	.word	0x40002800
 8006618:	fffffc18 	.word	0xfffffc18
 800661c:	00016e36 	.word	0x00016e36
 8006620:	05967f08 	.word	0x05967f08

08006624 <MIOS32_IRQ_Disable>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Disable(void)
{
  // get current priority if nested level == 0
  if( !nested_ctr ) {
 8006624:	4b08      	ldr	r3, [pc, #32]	; (8006648 <MIOS32_IRQ_Disable+0x24>)
 8006626:	681b      	ldr	r3, [r3, #0]
 8006628:	b91b      	cbnz	r3, 8006632 <MIOS32_IRQ_Disable+0xe>
    __asm volatile (			   \
 800662a:	f3ef 8210 	mrs	r2, PRIMASK
 800662e:	4b07      	ldr	r3, [pc, #28]	; (800664c <MIOS32_IRQ_Disable+0x28>)
 8006630:	601a      	str	r2, [r3, #0]
		    : "=r" (prev_primask)  \
		    );
  }

  // disable interrupts
  __asm volatile ( \
 8006632:	f04f 0001 	mov.w	r0, #1
 8006636:	f380 8810 	msr	PRIMASK, r0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 800663a:	4b03      	ldr	r3, [pc, #12]	; (8006648 <MIOS32_IRQ_Disable+0x24>)

  return 0; // no error
}
 800663c:	2000      	movs	r0, #0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 800663e:	681a      	ldr	r2, [r3, #0]
 8006640:	3201      	adds	r2, #1
 8006642:	601a      	str	r2, [r3, #0]

  return 0; // no error
}
 8006644:	4770      	bx	lr
 8006646:	bf00      	nop
 8006648:	20000800 	.word	0x20000800
 800664c:	200007fc 	.word	0x200007fc

08006650 <MIOS32_IRQ_Enable>:
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 8006650:	4a06      	ldr	r2, [pc, #24]	; (800666c <MIOS32_IRQ_Enable+0x1c>)
    return -1; // nesting error
 8006652:	f04f 30ff 	mov.w	r0, #4294967295
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 8006656:	6813      	ldr	r3, [r2, #0]
 8006658:	b13b      	cbz	r3, 800666a <MIOS32_IRQ_Enable+0x1a>
    return -1; // nesting error

  // decrease nesting level
  --nested_ctr;
 800665a:	3b01      	subs	r3, #1
 800665c:	6013      	str	r3, [r2, #0]

  // set back previous priority once nested level reached 0 again
  if( nested_ctr == 0 ) {
 800665e:	b91b      	cbnz	r3, 8006668 <MIOS32_IRQ_Enable+0x18>
    __asm volatile ( \
 8006660:	4b03      	ldr	r3, [pc, #12]	; (8006670 <MIOS32_IRQ_Enable+0x20>)
 8006662:	681b      	ldr	r3, [r3, #0]
 8006664:	f383 8810 	msr	PRIMASK, r3
		    "	msr primask, %0\n" \
		    :: "r" (prev_primask)  \
		    );
  }

  return 0; // no error
 8006668:	2000      	movs	r0, #0
}
 800666a:	4770      	bx	lr
 800666c:	20000800 	.word	0x20000800
 8006670:	200007fc 	.word	0x200007fc

08006674 <MIOS32_IRQ_Install>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 8006674:	290f      	cmp	r1, #15
    return -1; // invalid priority
 8006676:	bf88      	it	hi
 8006678:	f04f 30ff 	movhi.w	r0, #4294967295
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 800667c:	d818      	bhi.n	80066b0 <MIOS32_IRQ_Install+0x3c>
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
 800667e:	4b0d      	ldr	r3, [pc, #52]	; (80066b4 <MIOS32_IRQ_Install+0x40>)
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 8006680:	b242      	sxtb	r2, r0
 8006682:	68db      	ldr	r3, [r3, #12]
 8006684:	0952      	lsrs	r2, r2, #5
 8006686:	43db      	mvns	r3, r3
 8006688:	f3c3 2302 	ubfx	r3, r3, #8, #3
  u32 tmppre = (4 - tmppriority);
 800668c:	f1c3 0304 	rsb	r3, r3, #4
  tmppriority = priority << tmppre;
 8006690:	4099      	lsls	r1, r3
  tmppriority = tmppriority << 4;
  NVIC->IP[IRQn] = tmppriority;
 8006692:	4b09      	ldr	r3, [pc, #36]	; (80066b8 <MIOS32_IRQ_Install+0x44>)
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
  u32 tmppre = (4 - tmppriority);
  tmppriority = priority << tmppre;
  tmppriority = tmppriority << 4;
 8006694:	0109      	lsls	r1, r1, #4
  NVIC->IP[IRQn] = tmppriority;
 8006696:	18c3      	adds	r3, r0, r3
 8006698:	b2c9      	uxtb	r1, r1
 800669a:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
 800669e:	f000 001f 	and.w	r0, r0, #31
 80066a2:	2301      	movs	r3, #1
 80066a4:	fa13 f000 	lsls.w	r0, r3, r0
 80066a8:	4b03      	ldr	r3, [pc, #12]	; (80066b8 <MIOS32_IRQ_Install+0x44>)
 80066aa:	f843 0022 	str.w	r0, [r3, r2, lsl #2]

  NVIC_EnableIRQ(IRQn);

  return 0; // no error
 80066ae:	2000      	movs	r0, #0
}
 80066b0:	4770      	bx	lr
 80066b2:	bf00      	nop
 80066b4:	e000ed00 	.word	0xe000ed00
 80066b8:	e000e100 	.word	0xe000e100

080066bc <MIOS32_SPI_IO_Init>:
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported pin driver mode
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_IO_Init(u8 spi, mios32_spi_pin_driver_t spi_pin_driver)
{
 80066bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80066be:	4604      	mov	r4, r0
 80066c0:	460d      	mov	r5, r1
  // init GPIO structure
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80066c2:	a801      	add	r0, sp, #4
 80066c4:	f002 f98e 	bl	80089e4 <GPIO_StructInit>

  // select pin driver and output mode
  u32 af_mode;
  u32 gp_mode;

  switch( spi_pin_driver ) {
 80066c8:	2d03      	cmp	r5, #3
 80066ca:	f200 809e 	bhi.w	800680a <MIOS32_SPI_IO_Init+0x14e>
 80066ce:	e8df f005 	tbb	[pc, r5]
 80066d2:	0802      	.short	0x0802
 80066d4:	140e      	.short	0x140e
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80066d6:	2303      	movs	r3, #3
 80066d8:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 80066dc:	2510      	movs	r5, #16
  u32 gp_mode;

  switch( spi_pin_driver ) {
    case MIOS32_SPI_PIN_DRIVER_STRONG:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_PP;
 80066de:	3315      	adds	r3, #21
      gp_mode = GPIO_Mode_Out_PP;
      break;
 80066e0:	e010      	b.n	8006704 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80066e2:	2303      	movs	r3, #3
 80066e4:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 80066e8:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_STRONG_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      af_mode = GPIO_Mode_AF_OD;
 80066ea:	3319      	adds	r3, #25
      gp_mode = GPIO_Mode_Out_OD;
      break;
 80066ec:	e00a      	b.n	8006704 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80066ee:	2302      	movs	r3, #2
 80066f0:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_PP;
      gp_mode = GPIO_Mode_Out_PP;
 80066f4:	2510      	movs	r5, #16
      gp_mode = GPIO_Mode_Out_OD;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_PP;
 80066f6:	3316      	adds	r3, #22
      gp_mode = GPIO_Mode_Out_PP;
      break;
 80066f8:	e004      	b.n	8006704 <MIOS32_SPI_IO_Init+0x48>

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80066fa:	2302      	movs	r3, #2
 80066fc:	f88d 3006 	strb.w	r3, [sp, #6]
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
 8006700:	2514      	movs	r5, #20
      gp_mode = GPIO_Mode_Out_PP;
      break;

    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      af_mode = GPIO_Mode_AF_OD;
 8006702:	331a      	adds	r3, #26

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 8006704:	2c01      	cmp	r4, #1
 8006706:	d030      	beq.n	800676a <MIOS32_SPI_IO_Init+0xae>
 8006708:	d305      	bcc.n	8006716 <MIOS32_SPI_IO_Init+0x5a>
 800670a:	2c02      	cmp	r4, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 800670c:	bf18      	it	ne
 800670e:	f06f 0001 	mvnne.w	r0, #1

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 8006712:	d17c      	bne.n	800680e <MIOS32_SPI_IO_Init+0x152>
 8006714:	e04c      	b.n	80067b0 <MIOS32_SPI_IO_Init+0xf4>
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 8006716:	ac02      	add	r4, sp, #8
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 8006718:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 800671c:	2320      	movs	r3, #32
 800671e:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
 8006722:	483b      	ldr	r0, [pc, #236]	; (8006810 <MIOS32_SPI_IO_Init+0x154>)
 8006724:	4621      	mov	r1, r4
 8006726:	f002 f904 	bl	8008932 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 800672a:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 800672c:	4838      	ldr	r0, [pc, #224]	; (8006810 <MIOS32_SPI_IO_Init+0x154>)
 800672e:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 8006730:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 8006734:	f002 f8fd 	bl	8008932 <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 8006738:	2310      	movs	r3, #16
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 800673a:	4835      	ldr	r0, [pc, #212]	; (8006810 <MIOS32_SPI_IO_Init+0x154>)
 800673c:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 800673e:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
      GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 8006742:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 8006746:	f002 f8f4 	bl	8008932 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 800674a:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 800674e:	4831      	ldr	r0, [pc, #196]	; (8006814 <MIOS32_SPI_IO_Init+0x158>)
 8006750:	4621      	mov	r1, r4
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 8006752:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 8006756:	f002 f8ec 	bl	8008932 <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800675a:	2348      	movs	r3, #72	; 0x48
 800675c:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MISO_PIN;
 8006760:	2340      	movs	r3, #64	; 0x40
 8006762:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
 8006766:	482a      	ldr	r0, [pc, #168]	; (8006810 <MIOS32_SPI_IO_Init+0x154>)
 8006768:	e04a      	b.n	8006800 <MIOS32_SPI_IO_Init+0x144>
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 800676a:	ac02      	add	r4, sp, #8
    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
 800676c:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 8006770:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006774:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 8006778:	4827      	ldr	r0, [pc, #156]	; (8006818 <MIOS32_SPI_IO_Init+0x15c>)
 800677a:	4621      	mov	r1, r4
 800677c:	f002 f8d9 	bl	8008932 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 8006780:	f248 0300 	movw	r3, #32768	; 0x8000
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 8006784:	4824      	ldr	r0, [pc, #144]	; (8006818 <MIOS32_SPI_IO_Init+0x15c>)
 8006786:	4621      	mov	r1, r4
#else
      // SCLK and DOUT are outputs assigned to alternate functions
      GPIO_InitStructure.GPIO_Mode = af_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 8006788:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 800678c:	f002 f8d1 	bl	8008932 <GPIO_Init>
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 8006790:	f44f 5380 	mov.w	r3, #4096	; 0x1000
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 8006794:	4820      	ldr	r0, [pc, #128]	; (8006818 <MIOS32_SPI_IO_Init+0x15c>)
 8006796:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 8006798:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
      GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
    
      // RCLK outputs assigned to GPIO
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 800679c:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80067a0:	f002 f8c7 	bl	8008932 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
#endif
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80067a4:	2348      	movs	r3, #72	; 0x48
 80067a6:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MISO_PIN;
 80067aa:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80067ae:	e024      	b.n	80067fa <MIOS32_SPI_IO_Init+0x13e>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
 80067b0:	ac02      	add	r4, sp, #8
 80067b2:	2340      	movs	r3, #64	; 0x40
 80067b4:	f824 3d04 	strh.w	r3, [r4, #-4]!
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 80067b8:	4817      	ldr	r0, [pc, #92]	; (8006818 <MIOS32_SPI_IO_Init+0x15c>)
 80067ba:	4621      	mov	r1, r4
    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
 80067bc:	f88d 5007 	strb.w	r5, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 80067c0:	f002 f8b7 	bl	8008932 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 80067c4:	2320      	movs	r3, #32
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 80067c6:	4814      	ldr	r0, [pc, #80]	; (8006818 <MIOS32_SPI_IO_Init+0x15c>)
 80067c8:	4621      	mov	r1, r4
#else
      // RCLK, SCLK and DOUT assigned to GPIO (due to SW emulation)
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 80067ca:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 80067ce:	f002 f8b0 	bl	8008932 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 80067d2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 80067d6:	480f      	ldr	r0, [pc, #60]	; (8006814 <MIOS32_SPI_IO_Init+0x158>)
 80067d8:	4621      	mov	r1, r4
      GPIO_InitStructure.GPIO_Mode = gp_mode;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 80067da:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 80067de:	f002 f8a8 	bl	8008932 <GPIO_Init>
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 80067e2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 80067e6:	480b      	ldr	r0, [pc, #44]	; (8006814 <MIOS32_SPI_IO_Init+0x158>)
 80067e8:	4621      	mov	r1, r4
      GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
      GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 80067ea:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 80067ee:	f002 f8a0 	bl	8008932 <GPIO_Init>
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80067f2:	2348      	movs	r3, #72	; 0x48
 80067f4:	f88d 3007 	strb.w	r3, [sp, #7]
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 80067f8:	2380      	movs	r3, #128	; 0x80
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 80067fa:	4807      	ldr	r0, [pc, #28]	; (8006818 <MIOS32_SPI_IO_Init+0x15c>)
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
      GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
    
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 80067fc:	f8ad 3004 	strh.w	r3, [sp, #4]
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 8006800:	4621      	mov	r1, r4
 8006802:	f002 f896 	bl	8008932 <GPIO_Init>

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006806:	2000      	movs	r0, #0
      // DIN is input with pull-up
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
      GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
      GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);

      break;
 8006808:	e001      	b.n	800680e <MIOS32_SPI_IO_Init+0x152>
      af_mode = GPIO_Mode_AF_OD;
      gp_mode = GPIO_Mode_Out_OD;
      break;

    default:
      return -3; // unsupported pin driver mode
 800680a:	f06f 0002 	mvn.w	r0, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 800680e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8006810:	40010800 	.word	0x40010800
 8006814:	40011000 	.word	0x40011000
 8006818:	40010c00 	.word	0x40010c00

0800681c <MIOS32_SPI_RC_PinSet>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 800681c:	2801      	cmp	r0, #1
 800681e:	d017      	beq.n	8006850 <MIOS32_SPI_RC_PinSet+0x34>
 8006820:	d305      	bcc.n	800682e <MIOS32_SPI_RC_PinSet+0x12>
 8006822:	2802      	cmp	r0, #2
      }
      break;
#endif

    default:
      return -2; // unsupported SPI port
 8006824:	bf18      	it	ne
 8006826:	f06f 0101 	mvnne.w	r1, #1
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 800682a:	d137      	bne.n	800689c <MIOS32_SPI_RC_PinSet+0x80>
 800682c:	e01a      	b.n	8006864 <MIOS32_SPI_RC_PinSet+0x48>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 800682e:	b111      	cbz	r1, 8006836 <MIOS32_SPI_RC_PinSet+0x1a>
 8006830:	2901      	cmp	r1, #1
 8006832:	d131      	bne.n	8006898 <MIOS32_SPI_RC_PinSet+0x7c>
 8006834:	e006      	b.n	8006844 <MIOS32_SPI_RC_PinSet+0x28>
        case 0:
	  if( pin_value )
 8006836:	b112      	cbz	r2, 800683e <MIOS32_SPI_RC_PinSet+0x22>
	    MIOS32_SPI0_RCLK1_PORT->BSRR = MIOS32_SPI0_RCLK1_PIN;
 8006838:	2210      	movs	r2, #16
 800683a:	4b19      	ldr	r3, [pc, #100]	; (80068a0 <MIOS32_SPI_RC_PinSet+0x84>)
 800683c:	e01a      	b.n	8006874 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
 800683e:	2110      	movs	r1, #16
 8006840:	4b17      	ldr	r3, [pc, #92]	; (80068a0 <MIOS32_SPI_RC_PinSet+0x84>)
 8006842:	e026      	b.n	8006892 <MIOS32_SPI_RC_PinSet+0x76>

        case 1:
	  if( pin_value )
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
	  else
	    MIOS32_SPI0_RCLK2_PORT->BRR  = MIOS32_SPI0_RCLK2_PIN;
 8006844:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	  else
	    MIOS32_SPI0_RCLK1_PORT->BRR  = MIOS32_SPI0_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 8006848:	b312      	cbz	r2, 8006890 <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI0_RCLK2_PORT->BSRR = MIOS32_SPI0_RCLK2_PIN;
 800684a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800684e:	e01b      	b.n	8006888 <MIOS32_SPI_RC_PinSet+0x6c>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 8006850:	bb11      	cbnz	r1, 8006898 <MIOS32_SPI_RC_PinSet+0x7c>
        case 0:
	  if( pin_value )
 8006852:	b11a      	cbz	r2, 800685c <MIOS32_SPI_RC_PinSet+0x40>
	    MIOS32_SPI1_RCLK1_PORT->BSRR = MIOS32_SPI1_RCLK1_PIN;
 8006854:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8006858:	4b12      	ldr	r3, [pc, #72]	; (80068a4 <MIOS32_SPI_RC_PinSet+0x88>)
 800685a:	e00b      	b.n	8006874 <MIOS32_SPI_RC_PinSet+0x58>
	  else
	    MIOS32_SPI1_RCLK1_PORT->BRR  = MIOS32_SPI1_RCLK1_PIN;
 800685c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8006860:	4b10      	ldr	r3, [pc, #64]	; (80068a4 <MIOS32_SPI_RC_PinSet+0x88>)
 8006862:	e016      	b.n	8006892 <MIOS32_SPI_RC_PinSet+0x76>

    case 2:
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      switch( rc_pin ) {
 8006864:	b111      	cbz	r1, 800686c <MIOS32_SPI_RC_PinSet+0x50>
 8006866:	2901      	cmp	r1, #1
 8006868:	d116      	bne.n	8006898 <MIOS32_SPI_RC_PinSet+0x7c>
 800686a:	e008      	b.n	800687e <MIOS32_SPI_RC_PinSet+0x62>
        case 0:
	  if( pin_value )
 800686c:	b122      	cbz	r2, 8006878 <MIOS32_SPI_RC_PinSet+0x5c>
	    MIOS32_SPI2_RCLK1_PORT->BSRR = MIOS32_SPI2_RCLK1_PIN;
 800686e:	4b0e      	ldr	r3, [pc, #56]	; (80068a8 <MIOS32_SPI_RC_PinSet+0x8c>)
 8006870:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8006874:	611a      	str	r2, [r3, #16]
 8006876:	e011      	b.n	800689c <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
 8006878:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800687c:	e008      	b.n	8006890 <MIOS32_SPI_RC_PinSet+0x74>

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 800687e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	  else
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
 8006882:	b12a      	cbz	r2, 8006890 <MIOS32_SPI_RC_PinSet+0x74>
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 8006884:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8006888:	4b07      	ldr	r3, [pc, #28]	; (80068a8 <MIOS32_SPI_RC_PinSet+0x8c>)

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 800688a:	2100      	movs	r1, #0
	    MIOS32_SPI2_RCLK1_PORT->BRR  = MIOS32_SPI2_RCLK1_PIN;
	  break;

        case 1:
	  if( pin_value )
	    MIOS32_SPI2_RCLK2_PORT->BSRR = MIOS32_SPI2_RCLK2_PIN;
 800688c:	611a      	str	r2, [r3, #16]
 800688e:	e005      	b.n	800689c <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
 8006890:	4b05      	ldr	r3, [pc, #20]	; (80068a8 <MIOS32_SPI_RC_PinSet+0x8c>)
 8006892:	6159      	str	r1, [r3, #20]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006894:	4611      	mov	r1, r2
 8006896:	e001      	b.n	800689c <MIOS32_SPI_RC_PinSet+0x80>
	  else
	    MIOS32_SPI2_RCLK2_PORT->BRR  = MIOS32_SPI2_RCLK2_PIN;
	  break;

        default:
	  return -3; // unsupported RC pin
 8006898:	f06f 0102 	mvn.w	r1, #2
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 800689c:	4608      	mov	r0, r1
 800689e:	4770      	bx	lr
 80068a0:	40010800 	.word	0x40010800
 80068a4:	40010c00 	.word	0x40010c00
 80068a8:	40011000 	.word	0x40011000

080068ac <MIOS32_SPI_TransferByte>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 80068ac:	2801      	cmp	r0, #1
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported SPI mode configured via MIOS32_SPI_TransferModeInit()
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
 80068ae:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 80068b0:	f000 823c 	beq.w	8006d2c <MIOS32_SPI_TransferByte+0x480>
    case 0:
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI0_PTR;
 80068b4:	bf38      	it	cc
 80068b6:	f8df 3490 	ldrcc.w	r3, [pc, #1168]	; 8006d48 <MIOS32_SPI_TransferByte+0x49c>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 80068ba:	f0c0 8238 	bcc.w	8006d2e <MIOS32_SPI_TransferByte+0x482>
 80068be:	2802      	cmp	r0, #2
      return in_data; // END of SW emulation - EXIT here!
#endif
    } break;

    default:
      return -2; // unsupported SPI port
 80068c0:	bf18      	it	ne
 80068c2:	f06f 0001 	mvnne.w	r0, #1
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 80068c6:	f040 823d 	bne.w	8006d44 <MIOS32_SPI_TransferByte+0x498>
#else
    // Software Emulation
    {
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
 80068ca:	f8df 3480 	ldr.w	r3, [pc, #1152]	; 8006d4c <MIOS32_SPI_TransferByte+0x4a0>
 80068ce:	781b      	ldrb	r3, [r3, #0]
 80068d0:	2b03      	cmp	r3, #3
 80068d2:	f200 8235 	bhi.w	8006d40 <MIOS32_SPI_TransferByte+0x494>
 80068d6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80068da:	0004      	.short	0x0004
 80068dc:	01180096 	.word	0x01180096
 80068e0:	01a8      	.short	0x01a8
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 80068e2:	f8df 346c 	ldr.w	r3, [pc, #1132]	; 8006d50 <MIOS32_SPI_TransferByte+0x4a4>
 80068e6:	f011 0f80 	tst.w	r1, #128	; 0x80
 80068ea:	bf0c      	ite	eq
 80068ec:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 80068f0:	2220      	movne	r2, #32
 80068f2:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 80068f4:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 80068f6:	f011 0f40 	tst.w	r1, #64	; 0x40
 80068fa:	bf0c      	ite	eq
 80068fc:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006900:	2020      	movne	r0, #32
      u8 in_data = 0;

      switch( sw_spi2_mode ) {
        case MIOS32_SPI_MODE_CLK0_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006902:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006904:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 8006906:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006908:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 800690a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 800690c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 800690e:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006910:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006912:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006916:	bf18      	it	ne
 8006918:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 800691a:	f011 0f20 	tst.w	r1, #32
 800691e:	bf0c      	ite	eq
 8006920:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006924:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006926:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006928:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 800692a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 800692c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 800692e:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006930:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006932:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006936:	bf18      	it	ne
 8006938:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 800693a:	f011 0f10 	tst.w	r1, #16
 800693e:	bf0c      	ite	eq
 8006940:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006944:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 8006946:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006948:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 800694a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 800694c:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 800694e:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006952:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006954:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006958:	bf18      	it	ne
 800695a:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 800695e:	f011 0f08 	tst.w	r1, #8
 8006962:	bf0c      	ite	eq
 8006964:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006968:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 800696a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 800696c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 800696e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006970:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006972:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006974:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006978:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 800697c:	bf18      	it	ne
 800697e:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006980:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006984:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006986:	bf0c      	ite	eq
 8006988:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 800698c:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 800698e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
 8006990:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006992:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006994:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006996:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006998:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 800699a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 800699c:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 80069a0:	bf18      	it	ne
 80069a2:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 80069a4:	f011 0f02 	tst.w	r1, #2
 80069a8:	bf0c      	ite	eq
 80069aa:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 80069ae:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069b0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069b2:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069b4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 80069b6:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 80069b8:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 80069ba:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 80069bc:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 80069c0:	bf18      	it	ne
 80069c2:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 80069c4:	f011 0f01 	tst.w	r1, #1
 80069c8:	bf0c      	ite	eq
 80069ca:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 80069ce:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069d0:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 80069d2:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 80069d4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 80069d6:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 80069d8:	6899      	ldr	r1, [r3, #8]
 80069da:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 80069de:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 80069e2:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 80069e4:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 80069e6:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 80069ea:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 80069ee:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 80069f2:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 80069f6:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_1;
 80069fa:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 80069fc:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_SCLK_1;
 80069fe:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
 8006a00:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a02:	615a      	str	r2, [r3, #20]
	  break;
 8006a04:	e19e      	b.n	8006d44 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006a06:	4bd2      	ldr	r3, [pc, #840]	; (8006d50 <MIOS32_SPI_TransferByte+0x4a4>)
 8006a08:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006a0a:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006a0e:	bf0c      	ite	eq
 8006a10:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a14:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a16:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1; // no error - SCLK_1 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_0;
	  break;

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006a1a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006a1c:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a1e:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a20:	bf0c      	ite	eq
 8006a22:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a26:	2020      	movne	r0, #32

        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006a28:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a2a:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006a2c:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a2e:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a30:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a32:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a34:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006a38:	bf18      	it	ne
 8006a3a:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006a3c:	f011 0f20 	tst.w	r1, #32
 8006a40:	bf0c      	ite	eq
 8006a42:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a46:	2020      	movne	r0, #32
 8006a48:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a4a:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006a4c:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a4e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006a50:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006a54:	bf18      	it	ne
 8006a56:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006a58:	f011 0f10 	tst.w	r1, #16
 8006a5c:	bf0c      	ite	eq
 8006a5e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a62:	2020      	movne	r0, #32
 8006a64:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a66:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006a68:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006a6c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006a6e:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006a72:	bf18      	it	ne
 8006a74:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006a78:	f011 0f08 	tst.w	r1, #8
 8006a7c:	bf0c      	ite	eq
 8006a7e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006a82:	2020      	movne	r0, #32
 8006a84:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006a86:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a88:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006a8a:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a8e:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006a92:	bf18      	it	ne
 8006a94:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006a96:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006a9a:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006a9c:	bf0c      	ite	eq
 8006a9e:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006aa2:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006aa4:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006aa6:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006aa8:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006aaa:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006aac:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006aae:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006ab2:	bf18      	it	ne
 8006ab4:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006ab6:	f011 0f02 	tst.w	r1, #2
 8006aba:	bf0c      	ite	eq
 8006abc:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ac0:	2020      	movne	r0, #32
 8006ac2:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ac4:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006ac6:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006ac8:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006aca:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006ace:	bf18      	it	ne
 8006ad0:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006ad2:	f011 0f01 	tst.w	r1, #1
 8006ad6:	bf0c      	ite	eq
 8006ad8:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006adc:	2120      	movne	r1, #32
 8006ade:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ae0:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006ae2:	689b      	ldr	r3, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006ae4:	9a01      	ldr	r2, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006ae6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006aea:	ea43 0606 	orr.w	r6, r3, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006aee:	ea46 0505 	orr.w	r5, r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006af2:	ea45 0404 	orr.w	r4, r5, r4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006af6:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006afa:	ea4c 0c02 	orr.w	ip, ip, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006afe:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006b02:	ea47 0000 	orr.w	r0, r7, r0
 8006b06:	b2c0      	uxtb	r0, r0
	  break;
 8006b08:	e11c      	b.n	8006d44 <MIOS32_SPI_TransferByte+0x498>

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006b0a:	4b91      	ldr	r3, [pc, #580]	; (8006d50 <MIOS32_SPI_TransferByte+0x4a4>)
 8006b0c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006b10:	bf0c      	ite	eq
 8006b12:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006b16:	2220      	movne	r2, #32
 8006b18:	611a      	str	r2, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006b1a:	2240      	movs	r2, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006b1c:	f011 0f40 	tst.w	r1, #64	; 0x40
 8006b20:	bf0c      	ite	eq
 8006b22:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b26:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE0:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006b28:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b2a:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b2c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006b2e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b30:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006b32:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b34:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b36:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b38:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006b3c:	bf18      	it	ne
 8006b3e:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006b40:	f011 0f20 	tst.w	r1, #32
 8006b44:	bf0c      	ite	eq
 8006b46:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b4a:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006b4c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006b4e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b50:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006b52:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b54:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b56:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006b58:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006b5c:	bf18      	it	ne
 8006b5e:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006b60:	f011 0f10 	tst.w	r1, #16
 8006b64:	bf0c      	ite	eq
 8006b66:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b6a:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006b6c:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006b6e:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b70:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006b72:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006b74:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006b78:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006b7a:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006b7e:	bf18      	it	ne
 8006b80:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006b84:	f011 0f08 	tst.w	r1, #8
 8006b88:	bf0c      	ite	eq
 8006b8a:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006b8e:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006b90:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006b92:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006b94:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006b96:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b98:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006b9a:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006b9e:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006ba2:	bf18      	it	ne
 8006ba4:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006ba6:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006baa:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006bac:	bf0c      	ite	eq
 8006bae:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006bb2:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bb4:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bb6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bb8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bba:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006bbc:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006bbe:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006bc0:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006bc2:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006bc6:	bf18      	it	ne
 8006bc8:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006bca:	f011 0f02 	tst.w	r1, #2
 8006bce:	bf0c      	ite	eq
 8006bd0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006bd4:	2020      	movne	r0, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bd6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bd8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bda:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006bdc:	6118      	str	r0, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006bde:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
 8006be0:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006be2:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006be6:	bf18      	it	ne
 8006be8:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006bea:	f011 0f01 	tst.w	r1, #1
 8006bee:	bf0c      	ite	eq
 8006bf0:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006bf4:	2120      	movne	r1, #32
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006bf6:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006bf8:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_1;
 8006bfa:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006bfc:	6119      	str	r1, [r3, #16]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006bfe:	6899      	ldr	r1, [r3, #8]
 8006c00:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c04:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006c08:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c0a:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006c0c:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006c10:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006c14:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006c18:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c1c:	ea47 0000 	orr.w	r0, r7, r0
	  MIOS32_SPI2_SET_SCLK_0;
 8006c20:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006c22:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_0;
	  MIOS32_SPI2_SET_SCLK_0;
 8006c24:	615a      	str	r2, [r3, #20]
	  MIOS32_SPI2_SET_SCLK_0; // no error - SCLK_0 doubled to stretch pulse width
 8006c26:	615a      	str	r2, [r3, #20]
 8006c28:	e07e      	b.n	8006d28 <MIOS32_SPI_TransferByte+0x47c>
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
 8006c2a:	4b49      	ldr	r3, [pc, #292]	; (8006d50 <MIOS32_SPI_TransferByte+0x4a4>)
 8006c2c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006c30:	bf0c      	ite	eq
 8006c32:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8006c36:	2220      	movne	r2, #32
 8006c38:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c3a:	2240      	movs	r2, #64	; 0x40
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006c3c:	f011 0f40 	tst.w	r1, #64	; 0x40
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
 8006c40:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006c42:	bf0c      	ite	eq
 8006c44:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c48:	2020      	movne	r0, #32
	  break;

        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_MOSI(b & 0x80); // D7
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
 8006c4a:	689e      	ldr	r6, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c4c:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
 8006c4e:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c50:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c52:	689d      	ldr	r5, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c54:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006c56:	f015 0580 	ands.w	r5, r5, #128	; 0x80
 8006c5a:	bf18      	it	ne
 8006c5c:	2502      	movne	r5, #2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
 8006c5e:	f011 0f20 	tst.w	r1, #32
 8006c62:	bf0c      	ite	eq
 8006c64:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c68:	2020      	movne	r0, #32
 8006c6a:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c6c:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006c6e:	689c      	ldr	r4, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c70:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006c72:	f014 0480 	ands.w	r4, r4, #128	; 0x80
 8006c76:	bf18      	it	ne
 8006c78:	2404      	movne	r4, #4
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
 8006c7a:	f011 0f10 	tst.w	r1, #16
 8006c7e:	bf0c      	ite	eq
 8006c80:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006c84:	2020      	movne	r0, #32
 8006c86:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006c88:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006c8a:	f8d3 c008 	ldr.w	ip, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006c8e:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006c90:	f01c 0c80 	ands.w	ip, ip, #128	; 0x80
 8006c94:	bf18      	it	ne
 8006c96:	f04f 0c08 	movne.w	ip, #8
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
 8006c9a:	f011 0f08 	tst.w	r1, #8
 8006c9e:	bf0c      	ite	eq
 8006ca0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ca4:	2020      	movne	r0, #32
 8006ca6:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ca8:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006caa:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006cac:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006cb0:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006cb4:	bf18      	it	ne
 8006cb6:	2010      	movne	r0, #16
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006cb8:	f011 0f04 	tst.w	r1, #4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006cbc:	9001      	str	r0, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006cbe:	bf0c      	ite	eq
 8006cc0:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006cc4:	2020      	movne	r0, #32
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
 8006cc6:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
 8006cc8:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006cca:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006ccc:	689f      	ldr	r7, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cce:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006cd0:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8006cd4:	bf18      	it	ne
 8006cd6:	2720      	movne	r7, #32
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
 8006cd8:	f011 0f02 	tst.w	r1, #2
 8006cdc:	bf0c      	ite	eq
 8006cde:	f44f 1000 	moveq.w	r0, #2097152	; 0x200000
 8006ce2:	2020      	movne	r0, #32
 8006ce4:	6118      	str	r0, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006ce6:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006ce8:	6898      	ldr	r0, [r3, #8]
	  MIOS32_SPI2_SET_SCLK_1;
 8006cea:	611a      	str	r2, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006cec:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8006cf0:	bf18      	it	ne
 8006cf2:	4610      	movne	r0, r2
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
 8006cf4:	f011 0f01 	tst.w	r1, #1
 8006cf8:	bf0c      	ite	eq
 8006cfa:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8006cfe:	2120      	movne	r1, #32
 8006d00:	6119      	str	r1, [r3, #16]
	  MIOS32_SPI2_SET_SCLK_0;
 8006d02:	615a      	str	r2, [r3, #20]
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006d04:	6899      	ldr	r1, [r3, #8]
 8006d06:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x01 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x40); // D6
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x02 : 0x00;
 8006d0a:	ea41 0606 	orr.w	r6, r1, r6
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x20); // D5
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x04 : 0x00;
 8006d0e:	432e      	orrs	r6, r5
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x10); // D4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
 8006d10:	ea46 0404 	orr.w	r4, r6, r4
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d14:	9901      	ldr	r1, [sp, #4]
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x08 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x08); // D3
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x10 : 0x00;
 8006d16:	ea44 0c0c 	orr.w	ip, r4, ip
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x04); // D2
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x20 : 0x00;
 8006d1a:	ea4c 0c01 	orr.w	ip, ip, r1
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x02); // D1
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x40 : 0x00;
 8006d1e:	ea4c 0707 	orr.w	r7, ip, r7
	  MIOS32_SPI2_SET_SCLK_1;
	  MIOS32_SPI2_SET_MOSI(b & 0x01); // D0
	  MIOS32_SPI2_SET_SCLK_0;
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
 8006d22:	ea47 0000 	orr.w	r0, r7, r0
 8006d26:	b2c0      	uxtb	r0, r0
	  MIOS32_SPI2_SET_SCLK_1;
 8006d28:	611a      	str	r2, [r3, #16]

        default:
	  return -3; // unsupported SPI mode
      }

      return in_data; // END of SW emulation - EXIT here!
 8006d2a:	e00b      	b.n	8006d44 <MIOS32_SPI_TransferByte+0x498>

    case 1:
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      spi_ptr = MIOS32_SPI1_PTR;
 8006d2c:	4b09      	ldr	r3, [pc, #36]	; (8006d54 <MIOS32_SPI_TransferByte+0x4a8>)
    default:
      return -2; // unsupported SPI port
  }

  // send byte
  spi_ptr->DR = b;
 8006d2e:	8199      	strh	r1, [r3, #12]

  if( spi_ptr->SR ); // dummy read due to undocumented pipelining issue :-/
 8006d30:	891a      	ldrh	r2, [r3, #8]
  // We use a bus access instead of NOPs to avoid any risk for back-to-back transactions
  // over AHB (if SPI1/SPI2 pointers are used, there is still a risk for such a scenario,
  // e.g. if DMA loads the bus!)

  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );
 8006d32:	891a      	ldrh	r2, [r3, #8]
 8006d34:	f012 0f80 	tst.w	r2, #128	; 0x80
 8006d38:	d1fb      	bne.n	8006d32 <MIOS32_SPI_TransferByte+0x486>

  // return received byte
  return spi_ptr->DR;
 8006d3a:	8998      	ldrh	r0, [r3, #12]
 8006d3c:	b280      	uxth	r0, r0
 8006d3e:	e001      	b.n	8006d44 <MIOS32_SPI_TransferByte+0x498>
	  in_data |= MIOS32_SPI2_GET_MISO ? 0x80 : 0x00;
	  MIOS32_SPI2_SET_SCLK_1;
	  break;

        default:
	  return -3; // unsupported SPI mode
 8006d40:	f06f 0002 	mvn.w	r0, #2
  // wait until SPI transfer finished
  while( spi_ptr->SR & SPI_I2S_FLAG_BSY );

  // return received byte
  return spi_ptr->DR;
}
 8006d44:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8006d46:	bf00      	nop
 8006d48:	40013000 	.word	0x40013000
 8006d4c:	20000810 	.word	0x20000810
 8006d50:	40010c00 	.word	0x40010c00
 8006d54:	40003800 	.word	0x40003800

08006d58 <MIOS32_SPI_TransferModeInit>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006d58:	b530      	push	{r4, r5, lr}
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006d5a:	2300      	movs	r3, #0
//! \return -2 if unsupported SPI port selected
//! \return -3 if invalid spi_prescaler selected
//! \return -4 if invalid spi_mode selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferModeInit(u8 spi, mios32_spi_mode_t spi_mode, mios32_spi_prescaler_t spi_prescaler)
{
 8006d5c:	b087      	sub	sp, #28
  // SPI configuration
  SPI_InitTypeDef SPI_InitStructure;
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8006d5e:	f8ad 3004 	strh.w	r3, [sp, #4]
  SPI_InitStructure.SPI_Mode          = SPI_Mode_Master;
 8006d62:	f44f 7382 	mov.w	r3, #260	; 0x104
 8006d66:	f8ad 3006 	strh.w	r3, [sp, #6]
  SPI_InitStructure.SPI_DataSize      = SPI_DataSize_8b;
 8006d6a:	2300      	movs	r3, #0
 8006d6c:	f8ad 3008 	strh.w	r3, [sp, #8]
  SPI_InitStructure.SPI_NSS           = SPI_NSS_Soft;
 8006d70:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006d74:	f8ad 300e 	strh.w	r3, [sp, #14]
  SPI_InitStructure.SPI_FirstBit      = SPI_FirstBit_MSB;
 8006d78:	2300      	movs	r3, #0
 8006d7a:	f8ad 3012 	strh.w	r3, [sp, #18]
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 8006d7e:	2307      	movs	r3, #7
 8006d80:	f8ad 3014 	strh.w	r3, [sp, #20]

  switch( spi_mode ) {
 8006d84:	2903      	cmp	r1, #3
 8006d86:	d85f      	bhi.n	8006e48 <MIOS32_SPI_TransferModeInit+0xf0>
 8006d88:	e8df f001 	tbb	[pc, r1]
 8006d8c:	0d080602 	.word	0x0d080602
    case MIOS32_SPI_MODE_CLK0_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006d90:	2300      	movs	r3, #0
 8006d92:	f8ad 300a 	strh.w	r3, [sp, #10]
 8006d96:	e00a      	b.n	8006dae <MIOS32_SPI_TransferModeInit+0x56>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK0_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8006d98:	2300      	movs	r3, #0
 8006d9a:	e005      	b.n	8006da8 <MIOS32_SPI_TransferModeInit+0x50>
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE0:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006d9c:	2302      	movs	r3, #2
 8006d9e:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8006da2:	2300      	movs	r3, #0
 8006da4:	e003      	b.n	8006dae <MIOS32_SPI_TransferModeInit+0x56>
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 8006da6:	2302      	movs	r3, #2
 8006da8:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006dac:	2301      	movs	r3, #1
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006dae:	2a07      	cmp	r2, #7
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
      break;
    case MIOS32_SPI_MODE_CLK1_PHASE1:
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 8006db0:	f8ad 300c 	strh.w	r3, [sp, #12]
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected
 8006db4:	bf88      	it	hi
 8006db6:	f06f 0002 	mvnhi.w	r0, #2
      break;
    default:
      return -4; // invalid SPI clock/phase mode
  }

  if( spi_prescaler >= 8 )
 8006dba:	d847      	bhi.n	8006e4c <MIOS32_SPI_TransferModeInit+0xf4>
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006dbc:	2801      	cmp	r0, #1
 8006dbe:	d019      	beq.n	8006df4 <MIOS32_SPI_TransferModeInit+0x9c>
 8006dc0:	d305      	bcc.n	8006dce <MIOS32_SPI_TransferModeInit+0x76>
 8006dc2:	2802      	cmp	r0, #2

      break;
#endif

    default:
      return -2; // unsupported SPI port
 8006dc4:	bf18      	it	ne
 8006dc6:	f06f 0001 	mvnne.w	r0, #1
  }

  if( spi_prescaler >= 8 )
    return -3; // invalid prescaler selected

  switch( spi ) {
 8006dca:	d13f      	bne.n	8006e4c <MIOS32_SPI_TransferModeInit+0xf4>
 8006dcc:	e02b      	b.n	8006e26 <MIOS32_SPI_TransferModeInit+0xce>
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006dce:	4c20      	ldr	r4, [pc, #128]	; (8006e50 <MIOS32_SPI_TransferModeInit+0xf8>)
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006dd0:	f002 0207 	and.w	r2, r2, #7
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006dd4:	8825      	ldrh	r5, [r4, #0]
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006dd6:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006dd8:	4620      	mov	r0, r4
 8006dda:	a901      	add	r1, sp, #4
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
 8006ddc:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);
 8006de0:	f001 ff14 	bl	8008c0c <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006de4:	8820      	ldrh	r0, [r4, #0]
  switch( spi ) {
    case 0: {
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006de6:	b2ad      	uxth	r5, r5
      // SPI1 perpipheral is located in APB2 domain and clocked at full speed
      // therefore we have to add +1 to the prescaler
      SPI_InitStructure.SPI_BaudRatePrescaler = ((u16)spi_prescaler&7) << 3;
      SPI_Init(MIOS32_SPI0_PTR, &SPI_InitStructure);

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006de8:	4045      	eors	r5, r0
 8006dea:	f015 0003 	ands.w	r0, r5, #3
 8006dee:	d02d      	beq.n	8006e4c <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006df0:	2000      	movs	r0, #0
 8006df2:	e014      	b.n	8006e1e <MIOS32_SPI_TransferModeInit+0xc6>

    case 1: {
#ifdef MIOS32_DONT_USE_SPI1
      return -1; // disabled SPI port
#else
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8006df4:	4b16      	ldr	r3, [pc, #88]	; (8006e50 <MIOS32_SPI_TransferModeInit+0xf8>)
 8006df6:	881c      	ldrh	r4, [r3, #0]
 8006df8:	b2a4      	uxth	r4, r4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
 8006dfa:	b11a      	cbz	r2, 8006e04 <MIOS32_SPI_TransferModeInit+0xac>
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006dfc:	f002 0207 	and.w	r2, r2, #7
 8006e00:	3a01      	subs	r2, #1
 8006e02:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006e04:	4813      	ldr	r0, [pc, #76]	; (8006e54 <MIOS32_SPI_TransferModeInit+0xfc>)
 8006e06:	a901      	add	r1, sp, #4

      // SPI2 perpipheral is located in APB1 domain and clocked at half speed
      if( spi_prescaler == 0 )
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
      else
	SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8006e08:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI1_PTR, &SPI_InitStructure);
 8006e0c:	f001 fefe 	bl	8008c0c <SPI_Init>

      if( (prev_cr1 ^ MIOS32_SPI0_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8006e10:	4b0f      	ldr	r3, [pc, #60]	; (8006e50 <MIOS32_SPI_TransferModeInit+0xf8>)
 8006e12:	8818      	ldrh	r0, [r3, #0]
 8006e14:	4044      	eors	r4, r0
 8006e16:	f014 0003 	ands.w	r0, r4, #3
 8006e1a:	d017      	beq.n	8006e4c <MIOS32_SPI_TransferModeInit+0xf4>
	// clock configuration has been changed - we should send a dummy byte
	// before the application activates chip select.
	// this solves a dependency between SDCard and ENC28J60 driver
	MIOS32_SPI_TransferByte(spi, 0xff);
 8006e1c:	2001      	movs	r0, #1
 8006e1e:	21ff      	movs	r1, #255	; 0xff
 8006e20:	f7ff fd44 	bl	80068ac <MIOS32_SPI_TransferByte>
 8006e24:	e00e      	b.n	8006e44 <MIOS32_SPI_TransferModeInit+0xec>
#ifdef MIOS32_DONT_USE_SPI2
      return -1; // disabled SPI port
#else
      // no clock prescaler for SW emulated SPI
      // remember mode settings
      sw_spi2_mode = spi_mode;
 8006e26:	4b0c      	ldr	r3, [pc, #48]	; (8006e58 <MIOS32_SPI_TransferModeInit+0x100>)
 8006e28:	7019      	strb	r1, [r3, #0]

      // set clock idle level
      switch( sw_spi2_mode ) {
 8006e2a:	2903      	cmp	r1, #3
 8006e2c:	d80c      	bhi.n	8006e48 <MIOS32_SPI_TransferModeInit+0xf0>
 8006e2e:	e8df f001 	tbb	[pc, r1]
 8006e32:	0202      	.short	0x0202
 8006e34:	0606      	.short	0x0606
        case MIOS32_SPI_MODE_CLK0_PHASE0:
        case MIOS32_SPI_MODE_CLK0_PHASE1:
	  MIOS32_SPI2_SET_SCLK_0;
 8006e36:	4b09      	ldr	r3, [pc, #36]	; (8006e5c <MIOS32_SPI_TransferModeInit+0x104>)
 8006e38:	2240      	movs	r2, #64	; 0x40
 8006e3a:	615a      	str	r2, [r3, #20]
 8006e3c:	e002      	b.n	8006e44 <MIOS32_SPI_TransferModeInit+0xec>
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
 8006e3e:	4b07      	ldr	r3, [pc, #28]	; (8006e5c <MIOS32_SPI_TransferModeInit+0x104>)
 8006e40:	2240      	movs	r2, #64	; 0x40
 8006e42:	611a      	str	r2, [r3, #16]

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8006e44:	2000      	movs	r0, #0
	  MIOS32_SPI2_SET_SCLK_0;
	  break;
        case MIOS32_SPI_MODE_CLK1_PHASE0:
        case MIOS32_SPI_MODE_CLK1_PHASE1:
	  MIOS32_SPI2_SET_SCLK_1;
	  break;
 8006e46:	e001      	b.n	8006e4c <MIOS32_SPI_TransferModeInit+0xf4>
        default:
	  return -4; // invalid SPI clock/phase mode
 8006e48:	f06f 0003 	mvn.w	r0, #3
    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
}
 8006e4c:	b007      	add	sp, #28
 8006e4e:	bd30      	pop	{r4, r5, pc}
 8006e50:	40013000 	.word	0x40013000
 8006e54:	40003800 	.word	0x40003800
 8006e58:	20000810 	.word	0x20000810
 8006e5c:	40010c00 	.word	0x40010c00

08006e60 <MIOS32_SPI_Init>:
//! Initializes SPI pins
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
 8006e60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006e62:	4604      	mov	r4, r0
 8006e64:	b08f      	sub	sp, #60	; 0x3c
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8006e66:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8006e6a:	2c00      	cmp	r4, #0
 8006e6c:	f040 80bb 	bne.w	8006fe6 <MIOS32_SPI_Init+0x186>
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006e70:	ad03      	add	r5, sp, #12
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006e72:	4f5e      	ldr	r7, [pc, #376]	; (8006fec <MIOS32_SPI_Init+0x18c>)
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8006e74:	4628      	mov	r0, r5
 8006e76:	f002 f874 	bl	8008f62 <DMA_StructInit>

  // disable callback function
  spi_callback[0] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006e7a:	2201      	movs	r2, #1
 8006e7c:	4621      	mov	r1, r4
  // SPI0
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI0

  // disable callback function
  spi_callback[0] = NULL;
 8006e7e:	603c      	str	r4, [r7, #0]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(0, 0, 1); // spi, rc_pin, pin_value
 8006e80:	4620      	mov	r0, r4
 8006e82:	f7ff fccb 	bl	800681c <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(0, 1, 1); // spi, rc_pin, pin_value
 8006e86:	2101      	movs	r1, #1
 8006e88:	460a      	mov	r2, r1
 8006e8a:	4620      	mov	r0, r4
 8006e8c:	f7ff fcc6 	bl	800681c <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(0, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006e90:	2103      	movs	r1, #3
 8006e92:	4620      	mov	r0, r4
 8006e94:	f7ff fc12 	bl	80066bc <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB2 == high speed)
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 8006e98:	2101      	movs	r1, #1
 8006e9a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8006e9e:	f002 fa17 	bl	80092d0 <RCC_APB2PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8006ea2:	2001      	movs	r0, #1
 8006ea4:	4601      	mov	r1, r0
 8006ea6:	f002 fa05 	bl	80092b4 <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
 8006eaa:	4851      	ldr	r0, [pc, #324]	; (8006ff0 <MIOS32_SPI_Init+0x190>)
 8006eac:	4621      	mov	r1, r4
 8006eae:	f002 f865 	bl	8008f7c <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006eb2:	4b50      	ldr	r3, [pc, #320]	; (8006ff4 <MIOS32_SPI_Init+0x194>)
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006eb4:	2680      	movs	r6, #128	; 0x80
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8006eb6:	9303      	str	r3, [sp, #12]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006eb8:	484d      	ldr	r0, [pc, #308]	; (8006ff0 <MIOS32_SPI_Init+0x190>)
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006eba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006ebe:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006ec0:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006ec2:	9301      	str	r3, [sp, #4]
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006ec4:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8006ec6:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006ec8:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006eca:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006ecc:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006ece:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006ed0:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8006ed2:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8006ed4:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8006ed6:	f002 f819 	bl	8008f0c <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
 8006eda:	4847      	ldr	r0, [pc, #284]	; (8006ff8 <MIOS32_SPI_Init+0x198>)
 8006edc:	4621      	mov	r1, r4
 8006ede:	f002 f84d 	bl	8008f7c <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006ee2:	f04f 0c10 	mov.w	ip, #16
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006ee6:	4844      	ldr	r0, [pc, #272]	; (8006ff8 <MIOS32_SPI_Init+0x198>)
 8006ee8:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006eea:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006eee:	f8cd c000 	str.w	ip, [sp]
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006ef2:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006ef4:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006ef6:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8006ef8:	f002 f808 	bl	8008f0c <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(0, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8006efc:	2206      	movs	r2, #6
 8006efe:	2103      	movs	r1, #3
 8006f00:	4620      	mov	r0, r4
 8006f02:	f7ff ff29 	bl	8006d58 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI0_PTR, ENABLE);
 8006f06:	2101      	movs	r1, #1
 8006f08:	483c      	ldr	r0, [pc, #240]	; (8006ffc <MIOS32_SPI_Init+0x19c>)
 8006f0a:	f001 feac 	bl	8008c66 <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI0_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8006f0e:	2201      	movs	r2, #1
 8006f10:	2103      	movs	r1, #3
 8006f12:	483a      	ldr	r0, [pc, #232]	; (8006ffc <MIOS32_SPI_Init+0x19c>)
 8006f14:	f001 feb4 	bl	8008c80 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI0_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8006f18:	2105      	movs	r1, #5
 8006f1a:	200c      	movs	r0, #12
 8006f1c:	f7ff fbaa 	bl	8006674 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[1] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006f20:	2001      	movs	r0, #1
 8006f22:	4621      	mov	r1, r4
 8006f24:	4602      	mov	r2, r0
  // SPI1
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI1

  // disable callback function
  spi_callback[1] = NULL;
 8006f26:	607c      	str	r4, [r7, #4]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(1, 0, 1); // spi, rc_pin, pin_value
 8006f28:	f7ff fc78 	bl	800681c <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(1, 1, 1); // spi, rc_pin, pin_value
 8006f2c:	2001      	movs	r0, #1
 8006f2e:	4602      	mov	r2, r0
 8006f30:	4601      	mov	r1, r0
 8006f32:	f7ff fc73 	bl	800681c <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(1, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006f36:	2103      	movs	r1, #3
 8006f38:	2001      	movs	r0, #1
 8006f3a:	f7ff fbbf 	bl	80066bc <MIOS32_SPI_IO_Init>

  // enable SPI peripheral clock (APB1 == slow speed)
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8006f3e:	2101      	movs	r1, #1
 8006f40:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8006f44:	f002 f9d2 	bl	80092ec <RCC_APB1PeriphClockCmd>

  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8006f48:	2001      	movs	r0, #1
 8006f4a:	4601      	mov	r1, r0
 8006f4c:	f002 f9b2 	bl	80092b4 <RCC_AHBPeriphClockCmd>

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
 8006f50:	482b      	ldr	r0, [pc, #172]	; (8007000 <MIOS32_SPI_Init+0x1a0>)
 8006f52:	4621      	mov	r1, r4
 8006f54:	f002 f812 	bl	8008f7c <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f58:	9b01      	ldr	r3, [sp, #4]
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8006f5a:	4a2a      	ldr	r2, [pc, #168]	; (8007004 <MIOS32_SPI_Init+0x1a4>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8006f5c:	4828      	ldr	r0, [pc, #160]	; (8007000 <MIOS32_SPI_Init+0x1a0>)
 8006f5e:	4629      	mov	r1, r5
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8006f60:	930c      	str	r3, [sp, #48]	; 0x30
  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  // DMA Configuration for SPI Rx Event
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8006f62:	9203      	str	r2, [sp, #12]
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006f64:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8006f66:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006f68:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006f6a:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f6c:	9608      	str	r6, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006f6e:	9409      	str	r4, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006f70:	940a      	str	r4, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8006f72:	940b      	str	r4, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8006f74:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8006f76:	f001 ffc9 	bl	8008f0c <DMA_Init>

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
 8006f7a:	4823      	ldr	r0, [pc, #140]	; (8007008 <MIOS32_SPI_Init+0x1a8>)
 8006f7c:	4621      	mov	r1, r4
 8006f7e:	f001 fffd 	bl	8008f7c <DMA_Cmd>
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006f82:	f8dd c000 	ldr.w	ip, [sp]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8006f86:	4820      	ldr	r0, [pc, #128]	; (8007008 <MIOS32_SPI_Init+0x1a8>)
 8006f88:	4629      	mov	r1, r5
  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8006f8a:	f8cd c014 	str.w	ip, [sp, #20]
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);

  // DMA Configuration for SPI Tx Event
  // (partly re-using previous DMA setup)
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
  DMA_InitStructure.DMA_MemoryBaseAddr = 0; // will be configured later
 8006f8e:	9404      	str	r4, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8006f90:	9406      	str	r4, [sp, #24]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8006f92:	9608      	str	r6, [sp, #32]
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8006f94:	f001 ffba 	bl	8008f0c <DMA_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(1, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8006f98:	2206      	movs	r2, #6
 8006f9a:	2103      	movs	r1, #3
 8006f9c:	2001      	movs	r0, #1
 8006f9e:	f7ff fedb 	bl	8006d58 <MIOS32_SPI_TransferModeInit>

  // enable SPI
  SPI_Cmd(MIOS32_SPI1_PTR, ENABLE);
 8006fa2:	2101      	movs	r1, #1
 8006fa4:	4819      	ldr	r0, [pc, #100]	; (800700c <MIOS32_SPI_Init+0x1ac>)
 8006fa6:	f001 fe5e 	bl	8008c66 <SPI_Cmd>

  // enable SPI interrupts to DMA
  SPI_I2S_DMACmd(MIOS32_SPI1_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8006faa:	2201      	movs	r2, #1
 8006fac:	2103      	movs	r1, #3
 8006fae:	4817      	ldr	r0, [pc, #92]	; (800700c <MIOS32_SPI_Init+0x1ac>)
 8006fb0:	f001 fe66 	bl	8008c80 <SPI_I2S_DMACmd>

  // Configure DMA interrupt
  MIOS32_IRQ_Install(MIOS32_SPI1_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8006fb4:	2105      	movs	r1, #5
 8006fb6:	200e      	movs	r0, #14
 8006fb8:	f7ff fb5c 	bl	8006674 <MIOS32_IRQ_Install>

  // disable callback function
  spi_callback[2] = NULL;

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 8006fbc:	2201      	movs	r2, #1
 8006fbe:	2002      	movs	r0, #2
 8006fc0:	4621      	mov	r1, r4
  // SPI2 (software emulated)
  ///////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_USE_SPI2

  // disable callback function
  spi_callback[2] = NULL;
 8006fc2:	60bc      	str	r4, [r7, #8]

  // set RC pin(s) to 1
  MIOS32_SPI_RC_PinSet(2, 0, 1); // spi, rc_pin, pin_value
 8006fc4:	f7ff fc2a 	bl	800681c <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(2, 1, 1); // spi, rc_pin, pin_value
 8006fc8:	2101      	movs	r1, #1
 8006fca:	460a      	mov	r2, r1
 8006fcc:	2002      	movs	r0, #2
 8006fce:	f7ff fc25 	bl	800681c <MIOS32_SPI_RC_PinSet>

  // IO configuration
  MIOS32_SPI_IO_Init(2, MIOS32_SPI_PIN_DRIVER_WEAK_OD);
 8006fd2:	2103      	movs	r1, #3
 8006fd4:	2002      	movs	r0, #2
 8006fd6:	f7ff fb71 	bl	80066bc <MIOS32_SPI_IO_Init>

  // initial SPI peripheral configuration
  MIOS32_SPI_TransferModeInit(2, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8006fda:	2002      	movs	r0, #2
 8006fdc:	2103      	movs	r1, #3
 8006fde:	2206      	movs	r2, #6
 8006fe0:	f7ff feba 	bl	8006d58 <MIOS32_SPI_TransferModeInit>

#endif /* MIOS32_DONT_USE_SPI2 */

  return 0; // no error
 8006fe4:	4620      	mov	r0, r4
}
 8006fe6:	b00f      	add	sp, #60	; 0x3c
 8006fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006fea:	bf00      	nop
 8006fec:	20000804 	.word	0x20000804
 8006ff0:	4002001c 	.word	0x4002001c
 8006ff4:	4001300c 	.word	0x4001300c
 8006ff8:	40020030 	.word	0x40020030
 8006ffc:	40013000 	.word	0x40013000
 8007000:	40020044 	.word	0x40020044
 8007004:	4000380c 	.word	0x4000380c
 8007008:	40020058 	.word	0x40020058
 800700c:	40003800 	.word	0x40003800

08007010 <DMA1_Channel2_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Called when callback function has been defined and SPI transfer has finished
/////////////////////////////////////////////////////////////////////////////
MIOS32_SPI0_DMA_IRQHANDLER_FUNC
{
 8007010:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI0_DMA_RX_IRQ_FLAGS);
 8007012:	20f0      	movs	r0, #240	; 0xf0
 8007014:	f001 ffc6 	bl	8008fa4 <DMA_ClearFlag>

  if( spi_callback[0] != NULL )
 8007018:	4b02      	ldr	r3, [pc, #8]	; (8007024 <DMA1_Channel2_IRQHandler+0x14>)
 800701a:	681b      	ldr	r3, [r3, #0]
 800701c:	b103      	cbz	r3, 8007020 <DMA1_Channel2_IRQHandler+0x10>
    spi_callback[0]();
 800701e:	4798      	blx	r3
}
 8007020:	bd08      	pop	{r3, pc}
 8007022:	bf00      	nop
 8007024:	20000804 	.word	0x20000804

08007028 <DMA1_Channel4_IRQHandler>:

MIOS32_SPI1_DMA_IRQHANDLER_FUNC
{
 8007028:	b508      	push	{r3, lr}
  DMA_ClearFlag(MIOS32_SPI1_DMA_RX_IRQ_FLAGS);
 800702a:	f44f 4070 	mov.w	r0, #61440	; 0xf000
 800702e:	f001 ffb9 	bl	8008fa4 <DMA_ClearFlag>

  if( spi_callback[1] != NULL )
 8007032:	4b02      	ldr	r3, [pc, #8]	; (800703c <DMA1_Channel4_IRQHandler+0x14>)
 8007034:	685b      	ldr	r3, [r3, #4]
 8007036:	b103      	cbz	r3, 800703a <DMA1_Channel4_IRQHandler+0x12>
    spi_callback[1]();
 8007038:	4798      	blx	r3
}
 800703a:	bd08      	pop	{r3, pc}
 800703c:	20000804 	.word	0x20000804

08007040 <MIOS32_BOARD_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 8007040:	b910      	cbnz	r0, 8007048 <MIOS32_BOARD_Init+0x8>
    return -1; // unsupported mode

  j5_enable_mask = 0;
 8007042:	4b03      	ldr	r3, [pc, #12]	; (8007050 <MIOS32_BOARD_Init+0x10>)
 8007044:	8018      	strh	r0, [r3, #0]

  return 0; // no error
 8007046:	e001      	b.n	800704c <MIOS32_BOARD_Init+0xc>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007048:	f04f 30ff 	mov.w	r0, #4294967295

  j5_enable_mask = 0;

  return 0; // no error
}
 800704c:	4770      	bx	lr
 800704e:	bf00      	nop
 8007050:	20000812 	.word	0x20000812

08007054 <MIOS32_BOARD_LED_Init>:
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 8007054:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8007056:	ad01      	add	r5, sp, #4
//! \return 0 if initialisation passed
//! \return -1 if no LEDs specified for board
//! \return -2 if one or more LEDs not available on board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Init(u32 leds)
{
 8007058:	4604      	mov	r4, r0
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 800705a:	4628      	mov	r0, r5
 800705c:	f001 fcc2 	bl	80089e4 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007060:	2310      	movs	r3, #16
 8007062:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007066:	2303      	movs	r3, #3

  // only one LED, connected to PD2
  if( leds & 1 ) {
 8007068:	f014 0f01 	tst.w	r4, #1
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800706c:	f88d 3006 	strb.w	r3, [sp, #6]

  // only one LED, connected to PD2
  if( leds & 1 ) {
 8007070:	d006      	beq.n	8007080 <MIOS32_BOARD_LED_Init+0x2c>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8007072:	2304      	movs	r3, #4
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 8007074:	4806      	ldr	r0, [pc, #24]	; (8007090 <MIOS32_BOARD_LED_Init+0x3c>)
 8007076:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  // only one LED, connected to PD2
  if( leds & 1 ) {
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8007078:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 800707c:	f001 fc59 	bl	8008932 <GPIO_Init>
  }

  if( leds & 0xfffffffe)
 8007080:	f034 0401 	bics.w	r4, r4, #1
    return -2; // LED doesn't exist
 8007084:	bf0c      	ite	eq
 8007086:	4620      	moveq	r0, r4
 8007088:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 800708c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 800708e:	bf00      	nop
 8007090:	40011400 	.word	0x40011400

08007094 <MIOS32_BOARD_LED_Set>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Set(u32 leds, u32 value)
{
#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( leds & 1 ) {
 8007094:	f010 0f01 	tst.w	r0, #1
 8007098:	d007      	beq.n	80070aa <MIOS32_BOARD_LED_Set+0x16>
    GPIOD->BSRR = (value&1) ? GPIO_Pin_2 : (GPIO_Pin_2 << 16);
 800709a:	f011 0f01 	tst.w	r1, #1
 800709e:	4b06      	ldr	r3, [pc, #24]	; (80070b8 <MIOS32_BOARD_LED_Set+0x24>)
 80070a0:	bf0c      	ite	eq
 80070a2:	f44f 2280 	moveq.w	r2, #262144	; 0x40000
 80070a6:	2204      	movne	r2, #4
 80070a8:	611a      	str	r2, [r3, #16]
  }

  if( leds & 0xfffffffe)
 80070aa:	f030 0001 	bics.w	r0, r0, #1
    return -2; // LED doesn't exist
 80070ae:	bf18      	it	ne
 80070b0:	f06f 0001 	mvnne.w	r0, #1

  return 0; // no error
#else
  return -1; // no LED specified for board
#endif
}
 80070b4:	4770      	bx	lr
 80070b6:	bf00      	nop
 80070b8:	40011400 	.word	0x40011400

080070bc <MIOS32_BOARD_LED_Get>:
{
  u32 values = 0;

#if defined(MIOS32_BOARD_MBHP_CORE_STM32)
  // only one LED, connected to PD2
  if( GPIOD->ODR & GPIO_Pin_2 )
 80070bc:	4b02      	ldr	r3, [pc, #8]	; (80070c8 <MIOS32_BOARD_LED_Get+0xc>)
 80070be:	68d8      	ldr	r0, [r3, #12]
//! Returns the status of all LEDs
//! \return status of all LEDs
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_BOARD_LED_Get(void)
{
  u32 values = 0;
 80070c0:	f3c0 0080 	ubfx	r0, r0, #2, #1
  if( GPIOB->ODR & GPIO_Pin_9 )
    values |= (1 << 1);
#endif

  return values;
}
 80070c4:	4770      	bx	lr
 80070c6:	bf00      	nop
 80070c8:	40011400 	.word	0x40011400

080070cc <MIOS32_BOARD_J5_PinInit>:
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 80070cc:	280b      	cmp	r0, #11
//!     <LI>MIOS32_BOARD_PIN_MODE_OUTPUT_OD: pin is used as output in open drain mode
//!   </UL>
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
 80070ce:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80070d0:	4604      	mov	r4, r0
 80070d2:	460d      	mov	r5, r1
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported
 80070d4:	bf88      	it	hi
 80070d6:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinInit(u8 pin, mios32_board_pin_mode_t mode)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 80070da:	d83a      	bhi.n	8007152 <MIOS32_BOARD_J5_PinInit+0x86>
 80070dc:	4b1d      	ldr	r3, [pc, #116]	; (8007154 <MIOS32_BOARD_J5_PinInit+0x88>)
    return -1; // pin not supported

  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
 80070de:	b941      	cbnz	r1, 80070f2 <MIOS32_BOARD_J5_PinInit+0x26>
    // don't touch
    j5_enable_mask &= ~(1 << pin);
 80070e0:	2201      	movs	r2, #1
 80070e2:	fa12 f404 	lsls.w	r4, r2, r4
 80070e6:	881a      	ldrh	r2, [r3, #0]

    // init IO mode
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
  }

  return 0; // no error
 80070e8:	4608      	mov	r0, r1
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
    // don't touch
    j5_enable_mask &= ~(1 << pin);
 80070ea:	ea22 0404 	bic.w	r4, r2, r4
 80070ee:	801c      	strh	r4, [r3, #0]
 80070f0:	e02f      	b.n	8007152 <MIOS32_BOARD_J5_PinInit+0x86>
  } else {
    // enable pin
    j5_enable_mask |= (1 << pin);
 80070f2:	2201      	movs	r2, #1
 80070f4:	40a2      	lsls	r2, r4
 80070f6:	8819      	ldrh	r1, [r3, #0]

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
 80070f8:	a801      	add	r0, sp, #4
  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
    // don't touch
    j5_enable_mask &= ~(1 << pin);
  } else {
    // enable pin
    j5_enable_mask |= (1 << pin);
 80070fa:	430a      	orrs	r2, r1
 80070fc:	801a      	strh	r2, [r3, #0]

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
 80070fe:	f001 fc71 	bl	80089e4 <GPIO_StructInit>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007102:	2303      	movs	r3, #3
 8007104:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_InitStructure.GPIO_Pin = j5_pin[pin].pin_mask;
 8007108:	4b13      	ldr	r3, [pc, #76]	; (8007158 <MIOS32_BOARD_J5_PinInit+0x8c>)

    switch( mode ) {
 800710a:	3d01      	subs	r5, #1
    j5_enable_mask |= (1 << pin);

    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Pin = j5_pin[pin].pin_mask;
 800710c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8007110:	889b      	ldrh	r3, [r3, #4]
 8007112:	f8ad 3004 	strh.w	r3, [sp, #4]

    switch( mode ) {
 8007116:	2d05      	cmp	r5, #5
 8007118:	d819      	bhi.n	800714e <MIOS32_BOARD_J5_PinInit+0x82>
 800711a:	e8df f005 	tbb	[pc, r5]
 800711e:	0503      	.short	0x0503
 8007120:	0d0b0907 	.word	0x0d0b0907
      case MIOS32_BOARD_PIN_MODE_ANALOG:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 8007124:	2300      	movs	r3, #0
 8007126:	e008      	b.n	800713a <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8007128:	2304      	movs	r3, #4
 800712a:	e006      	b.n	800713a <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT_PD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 800712c:	2328      	movs	r3, #40	; 0x28
 800712e:	e004      	b.n	800713a <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_INPUT_PU:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8007130:	2348      	movs	r3, #72	; 0x48
 8007132:	e002      	b.n	800713a <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_PP:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007134:	2310      	movs	r3, #16
 8007136:	e000      	b.n	800713a <MIOS32_BOARD_J5_PinInit+0x6e>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_OD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 8007138:	2314      	movs	r3, #20
 800713a:	f88d 3007 	strb.w	r3, [sp, #7]
    // TK: disabled since there are application which have to switch between Input/Output
    // without destroying the current pin value
#endif

    // init IO mode
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
 800713e:	4b06      	ldr	r3, [pc, #24]	; (8007158 <MIOS32_BOARD_J5_PinInit+0x8c>)
 8007140:	a901      	add	r1, sp, #4
 8007142:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 8007146:	f001 fbf4 	bl	8008932 <GPIO_Init>
  }

  return 0; // no error
 800714a:	2000      	movs	r0, #0
 800714c:	e001      	b.n	8007152 <MIOS32_BOARD_J5_PinInit+0x86>
	break;
      case MIOS32_BOARD_PIN_MODE_OUTPUT_OD:
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	break;
      default:
	return -2; // invalid pin mode
 800714e:	f06f 0001 	mvn.w	r0, #1
    GPIO_Init(j5_pin[pin].port, &GPIO_InitStructure);
  }

  return 0; // no error
#endif
}
 8007152:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8007154:	20000812 	.word	0x20000812
 8007158:	0800af00 	.word	0x0800af00

0800715c <MIOS32_BOARD_J5_PinGet>:
s32 MIOS32_BOARD_J5_PinGet(u8 pin)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 800715c:	280b      	cmp	r0, #11
    return -1; // pin not supported
 800715e:	bf88      	it	hi
 8007160:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_BOARD_J5_PinGet(u8 pin)
{
#if J5_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
 8007164:	d813      	bhi.n	800718e <MIOS32_BOARD_J5_PinGet+0x32>
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 8007166:	4b0a      	ldr	r3, [pc, #40]	; (8007190 <MIOS32_BOARD_J5_PinGet+0x34>)
 8007168:	881b      	ldrh	r3, [r3, #0]
 800716a:	4103      	asrs	r3, r0
 800716c:	f013 0f01 	tst.w	r3, #1
    return -2; // pin disabled
 8007170:	bf08      	it	eq
 8007172:	f06f 0001 	mvneq.w	r0, #1
  return -1; // MIOS32_BOARD_J5 not supported
#else
  if( pin >= J5_NUM_PINS )
    return -1; // pin not supported

  if( !(j5_enable_mask & (1 << pin)) )
 8007176:	d00a      	beq.n	800718e <MIOS32_BOARD_J5_PinGet+0x32>
    return -2; // pin disabled

  return (j5_pin[pin].port->IDR & j5_pin[pin].pin_mask) ? 1 : 0;
 8007178:	4b06      	ldr	r3, [pc, #24]	; (8007194 <MIOS32_BOARD_J5_PinGet+0x38>)
 800717a:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
 800717e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8007182:	8883      	ldrh	r3, [r0, #4]
 8007184:	6892      	ldr	r2, [r2, #8]
 8007186:	4213      	tst	r3, r2
 8007188:	bf0c      	ite	eq
 800718a:	2000      	moveq	r0, #0
 800718c:	2001      	movne	r0, #1
#endif
}
 800718e:	4770      	bx	lr
 8007190:	20000812 	.word	0x20000812
 8007194:	0800af00 	.word	0x0800af00

08007198 <MIOS32_BOARD_J15_PortInit>:
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 8007198:	2801      	cmp	r0, #1
//!   <LI>1: J15 pins are configured in Open Drain mode (perfect for 3.3V->5V levelshifting)
//! </UL>
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PortInit(u32 mode)
{
 800719a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800719c:	4606      	mov	r6, r0
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
    return -1; // unsupported mode
 800719e:	bf88      	it	hi
 80071a0:	f04f 30ff 	movhi.w	r0, #4294967295
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 80071a4:	d854      	bhi.n	8007250 <MIOS32_BOARD_J15_PortInit+0xb8>
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80071a6:	ad01      	add	r5, sp, #4
 80071a8:	4628      	mov	r0, r5
 80071aa:	f001 fc1b 	bl	80089e4 <GPIO_StructInit>

  J15_PIN_SCLK_0;
  J15_PIN_RCLK_0;
 80071ae:	4c29      	ldr	r4, [pc, #164]	; (8007254 <MIOS32_BOARD_J15_PortInit+0xbc>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 80071b0:	4829      	ldr	r0, [pc, #164]	; (8007258 <MIOS32_BOARD_J15_PortInit+0xc0>)
  J15_PIN_RCLK_0;
  J15_PIN_RW(0);
 80071b2:	4a2a      	ldr	r2, [pc, #168]	; (800725c <MIOS32_BOARD_J15_PortInit+0xc4>)
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 80071b4:	f44f 7380 	mov.w	r3, #256	; 0x100
  J15_PIN_RCLK_0;
 80071b8:	f44f 7700 	mov.w	r7, #512	; 0x200
  J15_PIN_RW(0);
 80071bc:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  J15_PIN_SCLK_0;
 80071c0:	6143      	str	r3, [r0, #20]
  J15_PIN_RCLK_0;
 80071c2:	6167      	str	r7, [r4, #20]
  J15_PIN_RW(0);
 80071c4:	6111      	str	r1, [r2, #16]
  J15_PIN_E1(0);
 80071c6:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 80071ca:	6122      	str	r2, [r4, #16]
  J15_PIN_E2(0);
 80071cc:	f5a2 0280 	sub.w	r2, r2, #4194304	; 0x400000
 80071d0:	6122      	str	r2, [r4, #16]
#ifdef MIOS32_BOARD_LCD_E4_PORT
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80071d2:	2210      	movs	r2, #16
 80071d4:	f88d 2007 	strb.w	r2, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80071d8:	4629      	mov	r1, r5
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients
 80071da:	2202      	movs	r2, #2
 80071dc:	f88d 2006 	strb.w	r2, [sp, #6]

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
 80071e0:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80071e4:	f001 fba5 	bl	8008932 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 80071e8:	4620      	mov	r0, r4
 80071ea:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
 80071ec:	f8ad 7004 	strh.w	r7, [sp, #4]
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 80071f0:	f001 fb9f 	bl	8008932 <GPIO_Init>

  // configure open-drain pins (if OD option enabled)
  if( mode )
 80071f4:	b116      	cbz	r6, 80071fc <MIOS32_BOARD_J15_PortInit+0x64>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 80071f6:	2314      	movs	r3, #20
 80071f8:	f88d 3007 	strb.w	r3, [sp, #7]

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
 80071fc:	ac02      	add	r4, sp, #8
 80071fe:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007202:	f824 3d04 	strh.w	r3, [r4, #-4]!
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);
 8007206:	4813      	ldr	r0, [pc, #76]	; (8007254 <MIOS32_BOARD_J15_PortInit+0xbc>)
 8007208:	4621      	mov	r1, r4
 800720a:	f001 fb92 	bl	8008932 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 800720e:	2380      	movs	r3, #128	; 0x80
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 8007210:	4810      	ldr	r0, [pc, #64]	; (8007254 <MIOS32_BOARD_J15_PortInit+0xbc>)
 8007212:	4621      	mov	r1, r4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 8007214:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 8007218:	f001 fb8b 	bl	8008932 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 800721c:	2340      	movs	r3, #64	; 0x40
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 800721e:	480d      	ldr	r0, [pc, #52]	; (8007254 <MIOS32_BOARD_J15_PortInit+0xbc>)
 8007220:	4621      	mov	r1, r4
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 8007222:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 8007226:	f001 fb84 	bl	8008932 <GPIO_Init>
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 800722a:	2304      	movs	r3, #4
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 800722c:	480b      	ldr	r0, [pc, #44]	; (800725c <MIOS32_BOARD_J15_PortInit+0xc4>)
 800722e:	4621      	mov	r1, r4
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 8007230:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 8007234:	f001 fb7d 	bl	8008932 <GPIO_Init>

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8007238:	2348      	movs	r3, #72	; 0x48
 800723a:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 800723e:	4805      	ldr	r0, [pc, #20]	; (8007254 <MIOS32_BOARD_J15_PortInit+0xbc>)
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 8007240:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 8007244:	4621      	mov	r1, r4
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 8007246:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 800724a:	f001 fb72 	bl	8008932 <GPIO_Init>

  return 0; // no error
 800724e:	2000      	movs	r0, #0
#endif
}
 8007250:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007252:	bf00      	nop
 8007254:	40011000 	.word	0x40011000
 8007258:	40010800 	.word	0x40010800
 800725c:	40010c00 	.word	0x40010c00

08007260 <MIOS32_BOARD_J15_DataSet>:
#else
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
 8007260:	492d      	ldr	r1, [pc, #180]	; (8007318 <MIOS32_BOARD_J15_DataSet+0xb8>)
 8007262:	f010 0f80 	tst.w	r0, #128	; 0x80
 8007266:	bf0c      	ite	eq
 8007268:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 800726c:	f44f 7380 	movne.w	r3, #256	; 0x100
 8007270:	610b      	str	r3, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 8007272:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007276:	4b29      	ldr	r3, [pc, #164]	; (800731c <MIOS32_BOARD_J15_DataSet+0xbc>)
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
 8007278:	f010 0f40 	tst.w	r0, #64	; 0x40
 800727c:	bf0c      	ite	eq
 800727e:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007282:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 8007284:	f010 0f20 	tst.w	r0, #32
  // shift in 8bit data
  // whole function takes ca. 1.5 uS @ 72MHz
  // thats acceptable for a (C)LCD, which is normaly busy after each access for ca. 20..40 uS

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
 8007288:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800728a:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x40); // D6
 800728c:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
 8007290:	bf0c      	ite	eq
 8007292:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 8007296:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 8007298:	f010 0f10 	tst.w	r0, #16

  J15_PIN_SER(data & 0x80); // D7
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
 800729c:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 800729e:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x20); // D5
 80072a0:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
 80072a4:	bf0c      	ite	eq
 80072a6:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80072aa:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 80072ac:	f010 0f08 	tst.w	r0, #8
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x40); // D6
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
 80072b0:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80072b2:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x10); // D4
 80072b4:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
 80072b8:	bf0c      	ite	eq
 80072ba:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80072be:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 80072c0:	f010 0f04 	tst.w	r0, #4
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x20); // D5
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
 80072c4:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80072c6:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x08); // D3
 80072c8:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
 80072cc:	bf0c      	ite	eq
 80072ce:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80072d2:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 80072d4:	f010 0f02 	tst.w	r0, #2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x10); // D4
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
 80072d8:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80072da:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x04); // D2
 80072dc:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x02); // D1
 80072e0:	bf0c      	ite	eq
 80072e2:	f04f 7c80 	moveq.w	ip, #16777216	; 0x1000000
 80072e6:	4694      	movne	ip, r2
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x01); // D0
 80072e8:	f010 0f01 	tst.w	r0, #1
 80072ec:	bf0c      	ite	eq
 80072ee:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 80072f2:	4610      	movne	r0, r2
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x08); // D3
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;
  J15_PIN_SER(data & 0x04); // D2
  J15_PIN_SCLK_0; // setup delay
 80072f4:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80072f6:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x02); // D1
 80072f8:	f8c1 c010 	str.w	ip, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 80072fc:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 80072fe:	611a      	str	r2, [r3, #16]
  J15_PIN_SER(data & 0x01); // D0
 8007300:	6108      	str	r0, [r1, #16]
  J15_PIN_SCLK_0; // setup delay
 8007302:	615a      	str	r2, [r3, #20]
  J15_PIN_SCLK_1;
 8007304:	611a      	str	r2, [r3, #16]

  // transfer to output register
  J15_PIN_RCLK_1;
 8007306:	f44f 7300 	mov.w	r3, #512	; 0x200
 800730a:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_0;

  return 0; // no error
#endif
}
 800730c:	2000      	movs	r0, #0
  J15_PIN_SCLK_0; // setup delay
  J15_PIN_SCLK_1;

  // transfer to output register
  J15_PIN_RCLK_1;
  J15_PIN_RCLK_1;
 800730e:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_1;
 8007310:	610b      	str	r3, [r1, #16]
  J15_PIN_RCLK_0;
 8007312:	614b      	str	r3, [r1, #20]

  return 0; // no error
#endif
}
 8007314:	4770      	bx	lr
 8007316:	bf00      	nop
 8007318:	40011000 	.word	0x40011000
 800731c:	40010800 	.word	0x40010800

08007320 <MIOS32_BOARD_J15_RS_Set>:
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 8007320:	4b04      	ldr	r3, [pc, #16]	; (8007334 <MIOS32_BOARD_J15_RS_Set+0x14>)
 8007322:	2800      	cmp	r0, #0
 8007324:	bf0c      	ite	eq
 8007326:	f04f 7080 	moveq.w	r0, #16777216	; 0x1000000
 800732a:	f44f 7080 	movne.w	r0, #256	; 0x100
 800732e:	6118      	str	r0, [r3, #16]
  J15_PIN_SCLK_0;
#endif

  return 0; // no error
#endif
}
 8007330:	2000      	movs	r0, #0
 8007332:	4770      	bx	lr
 8007334:	40011000 	.word	0x40011000

08007338 <MIOS32_BOARD_J15_RW_Set>:
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007338:	4b04      	ldr	r3, [pc, #16]	; (800734c <MIOS32_BOARD_J15_RW_Set+0x14>)
 800733a:	2800      	cmp	r0, #0
 800733c:	bf0c      	ite	eq
 800733e:	f44f 2080 	moveq.w	r0, #262144	; 0x40000
 8007342:	2004      	movne	r0, #4
 8007344:	6118      	str	r0, [r3, #16]

  return 0; // no error
#endif
}
 8007346:	2000      	movs	r0, #0
 8007348:	4770      	bx	lr
 800734a:	bf00      	nop
 800734c:	40010c00 	.word	0x40010c00

08007350 <MIOS32_BOARD_J15_E_Set>:
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 8007350:	b128      	cbz	r0, 800735e <MIOS32_BOARD_J15_E_Set+0xe>
 8007352:	2801      	cmp	r0, #1
      return 0; // no error
#endif

  }

  return -1; // pin not available
 8007354:	bf18      	it	ne
 8007356:	f04f 30ff 	movne.w	r0, #4294967295
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 800735a:	d110      	bne.n	800737e <MIOS32_BOARD_J15_E_Set+0x2e>
 800735c:	e007      	b.n	800736e <MIOS32_BOARD_J15_E_Set+0x1e>
    case 0: 
      J15_PIN_E1(e);
 800735e:	4b08      	ldr	r3, [pc, #32]	; (8007380 <MIOS32_BOARD_J15_E_Set+0x30>)
 8007360:	2900      	cmp	r1, #0
 8007362:	bf0c      	ite	eq
 8007364:	f44f 0100 	moveq.w	r1, #8388608	; 0x800000
 8007368:	2180      	movne	r1, #128	; 0x80
 800736a:	6119      	str	r1, [r3, #16]
      return 0; // no error
 800736c:	e007      	b.n	800737e <MIOS32_BOARD_J15_E_Set+0x2e>

    case 1: 
      J15_PIN_E2(e);
 800736e:	4b04      	ldr	r3, [pc, #16]	; (8007380 <MIOS32_BOARD_J15_E_Set+0x30>)
 8007370:	2900      	cmp	r1, #0
 8007372:	bf0c      	ite	eq
 8007374:	f44f 0180 	moveq.w	r1, #4194304	; 0x400000
 8007378:	2140      	movne	r1, #64	; 0x40
 800737a:	6119      	str	r1, [r3, #16]
      return 0; // no error
 800737c:	2000      	movs	r0, #0

  }

  return -1; // pin not available
#endif
}
 800737e:	4770      	bx	lr
 8007380:	40011000 	.word	0x40011000

08007384 <MIOS32_BOARD_J15_PollUnbusy>:
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 8007384:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 8007386:	4b1a      	ldr	r3, [pc, #104]	; (80073f0 <MIOS32_BOARD_J15_PollUnbusy+0x6c>)
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007388:	4f1a      	ldr	r7, [pc, #104]	; (80073f4 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 800738a:	2604      	movs	r6, #4
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 800738c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8007390:	611a      	str	r2, [r3, #16]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 8007392:	460c      	mov	r4, r1
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 8007394:	613e      	str	r6, [r7, #16]

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 8007396:	2101      	movs	r1, #1
 8007398:	9301      	str	r3, [sp, #4]
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 800739a:	4605      	mov	r5, r0

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 800739c:	f7ff ffd8 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
 80073a0:	9b01      	ldr	r3, [sp, #4]
 80073a2:	2800      	cmp	r0, #0

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 80073a4:	bfa8      	it	ge
 80073a6:	461e      	movge	r6, r3

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 80073a8:	db1f      	blt.n	80073ea <MIOS32_BOARD_J15_PollUnbusy+0x66>
 80073aa:	e012      	b.n	80073d2 <MIOS32_BOARD_J15_PollUnbusy+0x4e>
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);
 80073ac:	2101      	movs	r1, #1
 80073ae:	4628      	mov	r0, r5
 80073b0:	f7ff ffce 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
 80073b4:	210a      	movs	r1, #10
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80073b6:	4a0f      	ldr	r2, [pc, #60]	; (80073f4 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 80073b8:	2304      	movs	r3, #4
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 80073ba:	f111 31ff 	adds.w	r1, r1, #4294967295
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80073be:	6113      	str	r3, [r2, #16]
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
    MIOS32_BOARD_J15_E_Set(lcd, 1);

    // due to slow slope we should wait at least for 1 uS
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 80073c0:	d1f9      	bne.n	80073b6 <MIOS32_BOARD_J15_PollUnbusy+0x32>
      MIOS32_BOARD_J15_RW_Set(1);

    u32 busy = J15_PIN_D7_IN;
 80073c2:	68b7      	ldr	r7, [r6, #8]
    MIOS32_BOARD_J15_E_Set(lcd, 0);
 80073c4:	4628      	mov	r0, r5
 80073c6:	f7ff ffc3 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
    if( !busy )
 80073ca:	f417 5f80 	tst.w	r7, #4096	; 0x1000
 80073ce:	d002      	beq.n	80073d6 <MIOS32_BOARD_J15_PollUnbusy+0x52>
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
 80073d0:	3c01      	subs	r4, #1
 80073d2:	2c00      	cmp	r4, #0
 80073d4:	d1ea      	bne.n	80073ac <MIOS32_BOARD_J15_PollUnbusy+0x28>
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80073d6:	4b07      	ldr	r3, [pc, #28]	; (80073f4 <MIOS32_BOARD_J15_PollUnbusy+0x70>)
 80073d8:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 80073dc:	2c00      	cmp	r4, #0
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 80073de:	611a      	str	r2, [r3, #16]
  // deselect read (output buffers of 74HC595 enabled again)
  MIOS32_BOARD_J15_RW_Set(0);

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error
 80073e0:	bf14      	ite	ne
 80073e2:	2000      	movne	r0, #0
 80073e4:	f06f 0001 	mvneq.w	r0, #1
 80073e8:	e001      	b.n	80073ee <MIOS32_BOARD_J15_PollUnbusy+0x6a>
  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
    return -1; // LCD port not available
 80073ea:	f04f 30ff 	mov.w	r0, #4294967295
  if( poll_ctr == 0 )
    return -2; // timeout error

  return 0; // no error
#endif
}
 80073ee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80073f0:	40011000 	.word	0x40011000
 80073f4:	40010c00 	.word	0x40010c00

080073f8 <TIM2_IRQHandler>:
//! Interrupt handlers
//! \note don't call them directly from application
/////////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_ALLOCATE_TIM2_IRQn
TIMER0_IRQ_HANDLER
{
 80073f8:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER0_BASE, TIM_IT_Update) != RESET ) {
 80073fa:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80073fe:	2101      	movs	r1, #1
 8007400:	f001 fe59 	bl	80090b6 <TIM_GetITStatus>
 8007404:	b138      	cbz	r0, 8007416 <TIM2_IRQHandler+0x1e>
    TIM_ClearITPendingBit(TIMER0_BASE, TIM_IT_Update);
 8007406:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800740a:	2101      	movs	r1, #1
 800740c:	f001 fe5f 	bl	80090ce <TIM_ClearITPendingBit>
    timer_callback[0]();
 8007410:	4b01      	ldr	r3, [pc, #4]	; (8007418 <TIM2_IRQHandler+0x20>)
 8007412:	681b      	ldr	r3, [r3, #0]
 8007414:	4798      	blx	r3
  }
}
 8007416:	bd08      	pop	{r3, pc}
 8007418:	20000814 	.word	0x20000814

0800741c <TIM3_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM3_IRQn
TIMER1_IRQ_HANDLER
{
 800741c:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER1_BASE, TIM_IT_Update) != RESET ) {
 800741e:	4806      	ldr	r0, [pc, #24]	; (8007438 <TIM3_IRQHandler+0x1c>)
 8007420:	2101      	movs	r1, #1
 8007422:	f001 fe48 	bl	80090b6 <TIM_GetITStatus>
 8007426:	b130      	cbz	r0, 8007436 <TIM3_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER1_BASE, TIM_IT_Update);
 8007428:	4803      	ldr	r0, [pc, #12]	; (8007438 <TIM3_IRQHandler+0x1c>)
 800742a:	2101      	movs	r1, #1
 800742c:	f001 fe4f 	bl	80090ce <TIM_ClearITPendingBit>
    timer_callback[1]();
 8007430:	4b02      	ldr	r3, [pc, #8]	; (800743c <TIM3_IRQHandler+0x20>)
 8007432:	685b      	ldr	r3, [r3, #4]
 8007434:	4798      	blx	r3
  }
}
 8007436:	bd08      	pop	{r3, pc}
 8007438:	40000400 	.word	0x40000400
 800743c:	20000814 	.word	0x20000814

08007440 <TIM5_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM5_IRQn
TIMER2_IRQ_HANDLER
{
 8007440:	b508      	push	{r3, lr}
  if( TIM_GetITStatus(TIMER2_BASE, TIM_IT_Update) != RESET ) {
 8007442:	4806      	ldr	r0, [pc, #24]	; (800745c <TIM5_IRQHandler+0x1c>)
 8007444:	2101      	movs	r1, #1
 8007446:	f001 fe36 	bl	80090b6 <TIM_GetITStatus>
 800744a:	b130      	cbz	r0, 800745a <TIM5_IRQHandler+0x1a>
    TIM_ClearITPendingBit(TIMER2_BASE, TIM_IT_Update);
 800744c:	4803      	ldr	r0, [pc, #12]	; (800745c <TIM5_IRQHandler+0x1c>)
 800744e:	2101      	movs	r1, #1
 8007450:	f001 fe3d 	bl	80090ce <TIM_ClearITPendingBit>
    timer_callback[2]();
 8007454:	4b02      	ldr	r3, [pc, #8]	; (8007460 <TIM5_IRQHandler+0x20>)
 8007456:	689b      	ldr	r3, [r3, #8]
 8007458:	4798      	blx	r3
  }
}
 800745a:	bd08      	pop	{r3, pc}
 800745c:	40000c00 	.word	0x40000c00
 8007460:	20000814 	.word	0x20000814

08007464 <MIOS32_DELAY_Init>:
//!
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
 8007464:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8007466:	4604      	mov	r4, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007468:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 800746c:	b9c4      	cbnz	r4, 80074a0 <MIOS32_DELAY_Init+0x3c>
    return -1; // unsupported mode

  // enable timer clock
  if( MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM1 || MIOS32_DELAY_TIMER_RCC == RCC_APB2Periph_TIM8 )
    RCC_APB2PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);
 800746e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8007472:	2101      	movs	r1, #1
 8007474:	f001 ff2c 	bl	80092d0 <RCC_APB2PeriphClockCmd>
  else
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
 8007478:	f04f 33ff 	mov.w	r3, #4294967295
 800747c:	f8ad 3008 	strh.w	r3, [sp, #8]
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007480:	4808      	ldr	r0, [pc, #32]	; (80074a4 <MIOS32_DELAY_Init+0x40>)
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 8007482:	2347      	movs	r3, #71	; 0x47
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007484:	a901      	add	r1, sp, #4
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
 8007486:	f8ad 3004 	strh.w	r3, [sp, #4]
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800748a:	f8ad 400a 	strh.w	r4, [sp, #10]
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 800748e:	f8ad 4006 	strh.w	r4, [sp, #6]
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 8007492:	f001 fd93 	bl	8008fbc <TIM_TimeBaseInit>

  // enable counter
  TIM_Cmd(MIOS32_DELAY_TIMER, ENABLE);
 8007496:	4803      	ldr	r0, [pc, #12]	; (80074a4 <MIOS32_DELAY_Init+0x40>)
 8007498:	2101      	movs	r1, #1
 800749a:	f001 fdff 	bl	800909c <TIM_Cmd>

  return 0; // no error
 800749e:	4620      	mov	r0, r4
}
 80074a0:	b004      	add	sp, #16
 80074a2:	bd10      	pop	{r4, pc}
 80074a4:	40012c00 	.word	0x40012c00

080074a8 <MIOS32_DELAY_Wait_uS>:
//! \param[in] uS delay (1..65535 microseconds)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Wait_uS(u16 uS)
{
  u16 start = MIOS32_DELAY_TIMER->CNT;
 80074a8:	4b04      	ldr	r3, [pc, #16]	; (80074bc <MIOS32_DELAY_Wait_uS+0x14>)
 80074aa:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80074ac:	b292      	uxth	r2, r2

  // note that this even works on 16bit counter wrap-arounds
  while( (u16)(MIOS32_DELAY_TIMER->CNT - start) <= uS );
 80074ae:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 80074b0:	1a89      	subs	r1, r1, r2
 80074b2:	b289      	uxth	r1, r1
 80074b4:	4281      	cmp	r1, r0
 80074b6:	d9fa      	bls.n	80074ae <MIOS32_DELAY_Wait_uS+0x6>

  return 0; // no error
}
 80074b8:	2000      	movs	r0, #0
 80074ba:	4770      	bx	lr
 80074bc:	40012c00 	.word	0x40012c00

080074c0 <MIOS32_AIN_Init>:
//! Initializes AIN driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
{
 80074c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80074c2:	b095      	sub	sp, #84	; 0x54
  // currently only mode 0 supported
  if( mode != 0 )
 80074c4:	2800      	cmp	r0, #0
 80074c6:	f040 8104 	bne.w	80076d2 <MIOS32_AIN_Init+0x212>
  return -1; // no AIN pins selected
#else
  int i;

  // disable service prepare callback function
  service_prepare_callback = NULL;
 80074ca:	4b84      	ldr	r3, [pc, #528]	; (80076dc <MIOS32_AIN_Init+0x21c>)
 80074cc:	4e84      	ldr	r6, [pc, #528]	; (80076e0 <MIOS32_AIN_Init+0x220>)
 80074ce:	6018      	str	r0, [r3, #0]
 80074d0:	4b84      	ldr	r3, [pc, #528]	; (80076e4 <MIOS32_AIN_Init+0x224>)
/////////////////////////////////////////////////////////////////////////////
//! Initializes AIN driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
 80074d2:	f106 021e 	add.w	r2, r6, #30
  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    adc_conversion_values[i] = 0;
 80074d6:	2100      	movs	r1, #0
 80074d8:	f823 1f02 	strh.w	r1, [r3, #2]!

  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80074dc:	4293      	cmp	r3, r2
 80074de:	d1fa      	bne.n	80074d6 <MIOS32_AIN_Init+0x16>
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
    ain_pin_values[i] = 0;
 80074e0:	4981      	ldr	r1, [pc, #516]	; (80076e8 <MIOS32_AIN_Init+0x228>)
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
 80074e2:	4a82      	ldr	r2, [pc, #520]	; (80076ec <MIOS32_AIN_Init+0x22c>)

  // disable service prepare callback function
  service_prepare_callback = NULL;

  // clear arrays and variables
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80074e4:	2300      	movs	r3, #0
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
    ain_pin_values[i] = 0;
 80074e6:	2400      	movs	r4, #0
 80074e8:	52cc      	strh	r4, [r1, r3]
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
 80074ea:	52d4      	strh	r4, [r2, r3]
 80074ec:	3302      	adds	r3, #2
    adc_conversion_values[i] = 0;
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    adc_conversion_values_sum[i] = 0;
#endif
  }
  for(i=0; i<NUM_AIN_PINS; ++i) {
 80074ee:	2b20      	cmp	r3, #32
 80074f0:	d1f9      	bne.n	80074e6 <MIOS32_AIN_Init+0x26>
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
 80074f2:	4b7f      	ldr	r3, [pc, #508]	; (80076f0 <MIOS32_AIN_Init+0x230>)
  oversampling_ctr = mux_ctr = 0;


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80074f4:	ad13      	add	r5, sp, #76	; 0x4c
#if MIOS32_AIN_DEADBAND_IDLE
    ain_pin_idle_ctr[i] = 0;
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
 80074f6:	601c      	str	r4, [r3, #0]
  }
  oversampling_ctr = mux_ctr = 0;
 80074f8:	4b7e      	ldr	r3, [pc, #504]	; (80076f4 <MIOS32_AIN_Init+0x234>)


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80074fa:	4628      	mov	r0, r5
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
  }
  oversampling_ctr = mux_ctr = 0;
 80074fc:	701c      	strb	r4, [r3, #0]
 80074fe:	4b7e      	ldr	r3, [pc, #504]	; (80076f8 <MIOS32_AIN_Init+0x238>)

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 8007500:	27f0      	movs	r7, #240	; 0xf0
#endif
  }
  for(i=0; i<NUM_CHANGE_WORDS; ++i) {
    ain_pin_changed[i] = 0;
  }
  oversampling_ctr = mux_ctr = 0;
 8007502:	701c      	strb	r4, [r3, #0]


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8007504:	f001 fa6e 	bl	80089e4 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8007508:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AIN;

  // J5A.0..3 -> Channel 10..13 -> Pin C0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x000f) >> 0;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800750a:	4629      	mov	r1, r5
 800750c:	487b      	ldr	r0, [pc, #492]	; (80076fc <MIOS32_AIN_Init+0x23c>)


  // set analog pins
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800750e:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AIN;
 8007512:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f

  // J5A.0..3 -> Channel 10..13 -> Pin C0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x000f) >> 0;
 8007516:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800751a:	f001 fa0a 	bl	8008932 <GPIO_Init>

  // J5B.4..7 -> Channel 0..3 -> Pin A0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x00f0) >> 4;
 800751e:	210f      	movs	r1, #15
 8007520:	f8ad 104c 	strh.w	r1, [sp, #76]	; 0x4c
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007524:	4876      	ldr	r0, [pc, #472]	; (8007700 <MIOS32_AIN_Init+0x240>)
 8007526:	4629      	mov	r1, r5
 8007528:	f001 fa03 	bl	8008932 <GPIO_Init>

  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800752c:	4629      	mov	r1, r5
 800752e:	4873      	ldr	r0, [pc, #460]	; (80076fc <MIOS32_AIN_Init+0x23c>)
  // J5B.4..7 -> Channel 0..3 -> Pin A0..3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x00f0) >> 4;
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
 8007530:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007534:	f001 f9fd 	bl	8008932 <GPIO_Init>

  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8007538:	4629      	mov	r1, r5
 800753a:	4872      	ldr	r0, [pc, #456]	; (8007704 <MIOS32_AIN_Init+0x244>)
  // J5C.8..9 -> Channel 14..15 -> Pin C4..5
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0300) >> 4;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
 800753c:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8007540:	f001 f9f7 	bl	8008932 <GPIO_Init>

  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007544:	4629      	mov	r1, r5
 8007546:	486d      	ldr	r0, [pc, #436]	; (80076fc <MIOS32_AIN_Init+0x23c>)
  // J5C.A10..11 -> Channel 8..9 -> Pin B0..1
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0c00) >> 10;
  GPIO_Init(GPIOB, &GPIO_InitStructure);

  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
 8007548:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800754c:	f001 f9f1 	bl	8008932 <GPIO_Init>

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007550:	4629      	mov	r1, r5
 8007552:	486b      	ldr	r0, [pc, #428]	; (8007700 <MIOS32_AIN_Init+0x240>)
  // J5C.A8..11 -> Channel 10..13 -> Pin C0..C3
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
 8007554:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
 8007558:	4d6b      	ldr	r5, [pc, #428]	; (8007708 <MIOS32_AIN_Init+0x248>)
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0x0f00) >> 8;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // J16 -> Channel 4..7 -> Pin A4..7
  GPIO_InitStructure.GPIO_Pin = (MIOS32_AIN_CHANNEL_MASK & 0xf000) >> 8;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800755a:	f001 f9ea 	bl	8008932 <GPIO_Init>


  // configure MUX pins if enabled
#if MIOS32_AIN_MUX_PINS >= 0
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 800755e:	2310      	movs	r3, #16
#endif
#endif


  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 8007560:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8007564:	2101      	movs	r1, #1
  GPIO_Init(GPIOA, &GPIO_InitStructure);


  // configure MUX pins if enabled
#if MIOS32_AIN_MUX_PINS >= 0
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007566:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
#endif
#endif


  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 800756a:	f001 feb1 	bl	80092d0 <RCC_APB2PeriphClockCmd>
  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
      ADC_RegularChannelConfig(
 800756e:	f8df c19c 	ldr.w	ip, [pc, #412]	; 800770c <MIOS32_AIN_Init+0x24c>
  // enable ADC1/2 clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
 8007572:	702c      	strb	r4, [r5, #0]
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 8007574:	fa57 f304 	asrs.w	r3, r7, r4
 8007578:	f013 0f01 	tst.w	r3, #1
 800757c:	d013      	beq.n	80075a6 <MIOS32_AIN_Init+0xe6>
      ADC_RegularChannelConfig(
        (num_channels & 1) ? ADC2 : ADC1, 
 800757e:	782a      	ldrb	r2, [r5, #0]
  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
      ADC_RegularChannelConfig(
 8007580:	4863      	ldr	r0, [pc, #396]	; (8007710 <MIOS32_AIN_Init+0x250>)
 8007582:	f012 0f01 	tst.w	r2, #1
 8007586:	4b63      	ldr	r3, [pc, #396]	; (8007714 <MIOS32_AIN_Init+0x254>)
 8007588:	bf08      	it	eq
 800758a:	4660      	moveq	r0, ip
 800758c:	0852      	lsrs	r2, r2, #1
 800758e:	5d19      	ldrb	r1, [r3, r4]
 8007590:	3201      	adds	r2, #1
 8007592:	2307      	movs	r3, #7
 8007594:	f8cd c004 	str.w	ip, [sp, #4]
 8007598:	f001 fadb 	bl	8008b52 <ADC_RegularChannelConfig>
        (num_channels & 1) ? ADC2 : ADC1, 
	adc_chn_map[i], 
	(num_channels>>1)+1, 
	ADC_SampleTime_239Cycles5);
      ++num_channels;
 800759c:	782b      	ldrb	r3, [r5, #0]
 800759e:	3301      	adds	r3, #1
 80075a0:	702b      	strb	r3, [r5, #0]
 80075a2:	f8dd c004 	ldr.w	ip, [sp, #4]
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

  // map channels to conversion slots depending on the channel selection mask
  // distribute this over the two ADCs, so that channels can be converted in parallel
  num_channels = 0;
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80075a6:	3401      	adds	r4, #1
 80075a8:	2c10      	cmp	r4, #16
 80075aa:	d1e3      	bne.n	8007574 <MIOS32_AIN_Init+0xb4>
      ++num_channels;
    }
  }

  // ensure that num_used_channels is an even value to keep ADC2 in synch with ADC1
  num_used_channels = num_channels;
 80075ac:	4b56      	ldr	r3, [pc, #344]	; (8007708 <MIOS32_AIN_Init+0x248>)
 80075ae:	4a5a      	ldr	r2, [pc, #360]	; (8007718 <MIOS32_AIN_Init+0x258>)
 80075b0:	781b      	ldrb	r3, [r3, #0]
  if( num_used_channels & 1 )
 80075b2:	f013 0f01 	tst.w	r3, #1
      ++num_channels;
    }
  }

  // ensure that num_used_channels is an even value to keep ADC2 in synch with ADC1
  num_used_channels = num_channels;
 80075b6:	7013      	strb	r3, [r2, #0]
  if( num_used_channels & 1 )
 80075b8:	d001      	beq.n	80075be <MIOS32_AIN_Init+0xfe>
      ++num_used_channels;
 80075ba:	3301      	adds	r3, #1
 80075bc:	7013      	strb	r3, [r2, #0]

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
 80075be:	ad0e      	add	r5, sp, #56	; 0x38
 80075c0:	4628      	mov	r0, r5
 80075c2:	f001 fa8d 	bl	8008ae0 <ADC_StructInit>
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
 80075c6:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
 80075ca:	930e      	str	r3, [sp, #56]	; 0x38
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 80075cc:	f5a3 23c0 	sub.w	r3, r3, #393216	; 0x60000
 80075d0:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 80075d4:	9311      	str	r3, [sp, #68]	; 0x44
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80075d6:	4b50      	ldr	r3, [pc, #320]	; (8007718 <MIOS32_AIN_Init+0x258>)

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 80075d8:	2401      	movs	r4, #1
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80075da:	781b      	ldrb	r3, [r3, #0]
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 80075dc:	f44f 2260 	mov.w	r2, #917504	; 0xe0000
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80075e0:	40e3      	lsrs	r3, r4
  ADC_Init(ADC1, &ADC_InitStructure);
 80075e2:	484a      	ldr	r0, [pc, #296]	; (800770c <MIOS32_AIN_Init+0x24c>)
 80075e4:	4629      	mov	r1, r5
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 80075e6:	9210      	str	r2, [sp, #64]	; 0x40
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
 80075e8:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48

  // configure ADCs
  ADC_InitTypeDef ADC_InitStructure;
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 80075ec:	f88d 403c 	strb.w	r4, [sp, #60]	; 0x3c
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfChannel = num_used_channels >> 1;
  ADC_Init(ADC1, &ADC_InitStructure);
 80075f0:	f001 fa50 	bl	8008a94 <ADC_Init>
  ADC_Init(ADC2, &ADC_InitStructure);
 80075f4:	4846      	ldr	r0, [pc, #280]	; (8007710 <MIOS32_AIN_Init+0x250>)
 80075f6:	4629      	mov	r1, r5
 80075f8:	f001 fa4c 	bl	8008a94 <ADC_Init>

  // enable ADC2 external trigger conversion (to synch with ADC1)
  ADC_ExternalTrigConvCmd(ADC2, ENABLE);
 80075fc:	4844      	ldr	r0, [pc, #272]	; (8007710 <MIOS32_AIN_Init+0x250>)
 80075fe:	4621      	mov	r1, r4
 8007600:	f001 fafa 	bl	8008bf8 <ADC_ExternalTrigConvCmd>

  // enable ADC1->DMA request
  ADC_DMACmd(ADC1, ENABLE);
 8007604:	4841      	ldr	r0, [pc, #260]	; (800770c <MIOS32_AIN_Init+0x24c>)
 8007606:	4621      	mov	r1, r4
 8007608:	f001 fa7d 	bl	8008b06 <ADC_DMACmd>


  // ADC1 calibration
  ADC_Cmd(ADC1, ENABLE);
 800760c:	483f      	ldr	r0, [pc, #252]	; (800770c <MIOS32_AIN_Init+0x24c>)
 800760e:	4621      	mov	r1, r4
 8007610:	f001 fa6f 	bl	8008af2 <ADC_Cmd>
  ADC_ResetCalibration(ADC1);
 8007614:	483d      	ldr	r0, [pc, #244]	; (800770c <MIOS32_AIN_Init+0x24c>)
 8007616:	f001 fa80 	bl	8008b1a <ADC_ResetCalibration>
  while( ADC_GetResetCalibrationStatus(ADC1) );
 800761a:	483c      	ldr	r0, [pc, #240]	; (800770c <MIOS32_AIN_Init+0x24c>)
 800761c:	f001 fa82 	bl	8008b24 <ADC_GetResetCalibrationStatus>
 8007620:	2800      	cmp	r0, #0
 8007622:	d1fa      	bne.n	800761a <MIOS32_AIN_Init+0x15a>
  ADC_StartCalibration(ADC1);
 8007624:	4839      	ldr	r0, [pc, #228]	; (800770c <MIOS32_AIN_Init+0x24c>)
 8007626:	f001 fa81 	bl	8008b2c <ADC_StartCalibration>
  while( ADC_GetCalibrationStatus(ADC1) );
 800762a:	4838      	ldr	r0, [pc, #224]	; (800770c <MIOS32_AIN_Init+0x24c>)
 800762c:	f001 fa83 	bl	8008b36 <ADC_GetCalibrationStatus>
 8007630:	2800      	cmp	r0, #0
 8007632:	d1fa      	bne.n	800762a <MIOS32_AIN_Init+0x16a>

  // ADC2 calibration
  ADC_Cmd(ADC2, ENABLE);
 8007634:	4836      	ldr	r0, [pc, #216]	; (8007710 <MIOS32_AIN_Init+0x250>)
 8007636:	2101      	movs	r1, #1
 8007638:	f001 fa5b 	bl	8008af2 <ADC_Cmd>
  ADC_ResetCalibration(ADC2);
 800763c:	4834      	ldr	r0, [pc, #208]	; (8007710 <MIOS32_AIN_Init+0x250>)
 800763e:	f001 fa6c 	bl	8008b1a <ADC_ResetCalibration>
  while( ADC_GetResetCalibrationStatus(ADC2) );
 8007642:	4833      	ldr	r0, [pc, #204]	; (8007710 <MIOS32_AIN_Init+0x250>)
 8007644:	f001 fa6e 	bl	8008b24 <ADC_GetResetCalibrationStatus>
 8007648:	2800      	cmp	r0, #0
 800764a:	d1fa      	bne.n	8007642 <MIOS32_AIN_Init+0x182>
  ADC_StartCalibration(ADC2);
 800764c:	4830      	ldr	r0, [pc, #192]	; (8007710 <MIOS32_AIN_Init+0x250>)
 800764e:	f001 fa6d 	bl	8008b2c <ADC_StartCalibration>
  while( ADC_GetCalibrationStatus(ADC2) );
 8007652:	482f      	ldr	r0, [pc, #188]	; (8007710 <MIOS32_AIN_Init+0x250>)
 8007654:	f001 fa6f 	bl	8008b36 <ADC_GetCalibrationStatus>
 8007658:	2800      	cmp	r0, #0
 800765a:	d1fa      	bne.n	8007652 <MIOS32_AIN_Init+0x192>
 800765c:	4604      	mov	r4, r0


  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 800765e:	3001      	adds	r0, #1
 8007660:	4601      	mov	r1, r0

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8007662:	ad03      	add	r5, sp, #12
  ADC_StartCalibration(ADC2);
  while( ADC_GetCalibrationStatus(ADC2) );


  // enable DMA1 clock
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8007664:	f001 fe26 	bl	80092b4 <RCC_AHBPeriphClockCmd>

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
 8007668:	4628      	mov	r0, r5
 800766a:	f001 fc7a 	bl	8008f62 <DMA_StructInit>
  DMA_DeInit(DMA1_Channel1);
 800766e:	482b      	ldr	r0, [pc, #172]	; (800771c <MIOS32_AIN_Init+0x25c>)
 8007670:	f001 fbe2 	bl	8008e38 <DMA_DeInit>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
 8007674:	4b2a      	ldr	r3, [pc, #168]	; (8007720 <MIOS32_AIN_Init+0x260>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 8007676:	4829      	ldr	r0, [pc, #164]	; (800771c <MIOS32_AIN_Init+0x25c>)

  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
 8007678:	9303      	str	r3, [sp, #12]
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 800767a:	4b27      	ldr	r3, [pc, #156]	; (8007718 <MIOS32_AIN_Init+0x258>)
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 800767c:	4629      	mov	r1, r5
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 800767e:	781b      	ldrb	r3, [r3, #0]
  // configure DMA1 channel 1 to fetch data from ADC result register
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
 8007680:	9604      	str	r6, [sp, #16]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 8007682:	085b      	lsrs	r3, r3, #1
 8007684:	9306      	str	r3, [sp, #24]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8007686:	2380      	movs	r3, #128	; 0x80
 8007688:	9308      	str	r3, [sp, #32]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
 800768a:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 800768e:	9309      	str	r3, [sp, #36]	; 0x24
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
 8007690:	f503 63c0 	add.w	r3, r3, #1536	; 0x600
 8007694:	930a      	str	r3, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 8007696:	f5a3 63fc 	sub.w	r3, r3, #2016	; 0x7e0
 800769a:	930b      	str	r3, [sp, #44]	; 0x2c
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 800769c:	f503 53ff 	add.w	r3, r3, #8160	; 0x1fe0
 80076a0:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitTypeDef DMA_InitStructure;
  DMA_StructInit(&DMA_InitStructure);
  DMA_DeInit(DMA1_Channel1);
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR;
  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_conversion_values;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 80076a2:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 80076a4:	9407      	str	r4, [sp, #28]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 80076a6:	940d      	str	r4, [sp, #52]	; 0x34
  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 80076a8:	f001 fc30 	bl	8008f0c <DMA_Init>
  DMA_Cmd(DMA1_Channel1, ENABLE);
 80076ac:	481b      	ldr	r0, [pc, #108]	; (800771c <MIOS32_AIN_Init+0x25c>)
 80076ae:	2101      	movs	r1, #1
 80076b0:	f001 fc64 	bl	8008f7c <DMA_Cmd>

  // trigger interrupt when all conversion values have been fetched
  DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);
 80076b4:	2201      	movs	r2, #1
 80076b6:	4819      	ldr	r0, [pc, #100]	; (800771c <MIOS32_AIN_Init+0x25c>)
 80076b8:	2102      	movs	r1, #2
 80076ba:	f001 fc69 	bl	8008f90 <DMA_ITConfig>

  // Configure and enable DMA interrupt
  MIOS32_IRQ_Install(DMA1_Channel1_IRQn, MIOS32_IRQ_AIN_DMA_PRIORITY);
 80076be:	2105      	movs	r1, #5
 80076c0:	200b      	movs	r0, #11
 80076c2:	f7fe ffd7 	bl	8006674 <MIOS32_IRQ_Install>

  // finally start initial conversion
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 80076c6:	4811      	ldr	r0, [pc, #68]	; (800770c <MIOS32_AIN_Init+0x24c>)
 80076c8:	2101      	movs	r1, #1
 80076ca:	f001 fa38 	bl	8008b3e <ADC_SoftwareStartConvCmd>

  return 0;
 80076ce:	4620      	mov	r0, r4
 80076d0:	e001      	b.n	80076d6 <MIOS32_AIN_Init+0x216>
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 80076d2:	f04f 30ff 	mov.w	r0, #4294967295
  // finally start initial conversion
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0;
#endif
}
 80076d6:	b015      	add	sp, #84	; 0x54
 80076d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80076da:	bf00      	nop
 80076dc:	2000088c 	.word	0x2000088c
 80076e0:	20000844 	.word	0x20000844
 80076e4:	20000842 	.word	0x20000842
 80076e8:	20000820 	.word	0x20000820
 80076ec:	20000868 	.word	0x20000868
 80076f0:	20000894 	.word	0x20000894
 80076f4:	20000864 	.word	0x20000864
 80076f8:	20000840 	.word	0x20000840
 80076fc:	40011000 	.word	0x40011000
 8007700:	40010800 	.word	0x40010800
 8007704:	40010c00 	.word	0x40010c00
 8007708:	20000888 	.word	0x20000888
 800770c:	40012400 	.word	0x40012400
 8007710:	40012800 	.word	0x40012800
 8007714:	0800af60 	.word	0x0800af60
 8007718:	20000890 	.word	0x20000890
 800771c:	40020008 	.word	0x40020008
 8007720:	4001244c 	.word	0x4001244c

08007724 <MIOS32_AIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Handler(void *_callback)
{
 8007724:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007726:	4607      	mov	r7, r0
  // no callback function?
  if( _callback == NULL )
    return -1;
 8007728:	f04f 30ff 	mov.w	r0, #4294967295
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_Handler(void *_callback)
{
  // no callback function?
  if( _callback == NULL )
 800772c:	2f00      	cmp	r7, #0
 800772e:	d03e      	beq.n	80077ae <MIOS32_AIN_Handler+0x8a>
#else
  int chn, mux;
  void (*callback)(s32 pin, u16 value) = _callback;

  // exit if scan hasn't been finished yet
  if( mux_ctr || oversampling_ctr )
 8007730:	4b1f      	ldr	r3, [pc, #124]	; (80077b0 <MIOS32_AIN_Handler+0x8c>)
 8007732:	7818      	ldrb	r0, [r3, #0]
 8007734:	2800      	cmp	r0, #0
 8007736:	d139      	bne.n	80077ac <MIOS32_AIN_Handler+0x88>
 8007738:	4b1e      	ldr	r3, [pc, #120]	; (80077b4 <MIOS32_AIN_Handler+0x90>)
 800773a:	781c      	ldrb	r4, [r3, #0]
 800773c:	2c00      	cmp	r4, #0
 800773e:	d136      	bne.n	80077ae <MIOS32_AIN_Handler+0x8a>
    return 0;

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
 8007740:	4e1d      	ldr	r6, [pc, #116]	; (80077b8 <MIOS32_AIN_Handler+0x94>)
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
 8007742:	4d1e      	ldr	r5, [pc, #120]	; (80077bc <MIOS32_AIN_Handler+0x98>)
 8007744:	e025      	b.n	8007792 <MIOS32_AIN_Handler+0x6e>

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
 8007746:	2001      	movs	r0, #1
 8007748:	f004 021f 	and.w	r2, r4, #31
 800774c:	fa10 f202 	lsls.w	r2, r0, r2
      if( ain_pin_changed[pin >> 5] & mask ) {
 8007750:	0963      	lsrs	r3, r4, #5
 8007752:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 8007756:	420a      	tst	r2, r1
 8007758:	d01a      	beq.n	8007790 <MIOS32_AIN_Handler+0x6c>
	MIOS32_IRQ_Disable();
 800775a:	9201      	str	r2, [sp, #4]
 800775c:	9300      	str	r3, [sp, #0]
 800775e:	f7fe ff61 	bl	8006624 <MIOS32_IRQ_Disable>
	u32 pin_value = ain_pin_values[pin];
	ain_pin_changed[pin>>5] &= ~mask;
 8007762:	9b00      	ldr	r3, [sp, #0]
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
 8007764:	4816      	ldr	r0, [pc, #88]	; (80077c0 <MIOS32_AIN_Handler+0x9c>)
	ain_pin_changed[pin>>5] &= ~mask;
 8007766:	9a01      	ldr	r2, [sp, #4]
    for(chn=0; chn<num_channels; ++chn) {
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
 8007768:	f830 1014 	ldrh.w	r1, [r0, r4, lsl #1]
	ain_pin_changed[pin>>5] &= ~mask;
 800776c:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
	MIOS32_IRQ_Enable();
 8007770:	9101      	str	r1, [sp, #4]
      u32 pin = mux * num_used_channels + chn;
      u32 mask = 1 << (pin & 0x1f);
      if( ain_pin_changed[pin >> 5] & mask ) {
	MIOS32_IRQ_Disable();
	u32 pin_value = ain_pin_values[pin];
	ain_pin_changed[pin>>5] &= ~mask;
 8007772:	ea20 0202 	bic.w	r2, r0, r2
 8007776:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
	MIOS32_IRQ_Enable();
 800777a:	f7fe ff69 	bl	8006650 <MIOS32_IRQ_Enable>

	// call application hook
	// note that due to dual conversion approach, we have to convert the pin number
	// if an uneven number number of channels selected
	u8 app_pin = (num_channels & 1) ? (pin>>1) : pin;
 800777e:	7833      	ldrb	r3, [r6, #0]
 8007780:	9901      	ldr	r1, [sp, #4]
 8007782:	f013 0f01 	tst.w	r3, #1
 8007786:	bf14      	ite	ne
 8007788:	f3c4 0047 	ubfxne	r0, r4, #1, #8
 800778c:	b2e0      	uxtbeq	r0, r4
	callback(app_pin, pin_value);
 800778e:	47b8      	blx	r7
  if( mux_ctr || oversampling_ctr )
    return 0;

  // check for changed AIN conversion values
  for(mux=0; mux<(1 << MIOS32_AIN_MUX_PINS); ++mux) {
    for(chn=0; chn<num_channels; ++chn) {
 8007790:	3401      	adds	r4, #1
 8007792:	7833      	ldrb	r3, [r6, #0]
 8007794:	429c      	cmp	r4, r3
 8007796:	dbd6      	blt.n	8007746 <MIOS32_AIN_Handler+0x22>
    }
  }

  // execute optional "service prepare" callback function
  // skip scan if it returns a value >= 1
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
 8007798:	4b0a      	ldr	r3, [pc, #40]	; (80077c4 <MIOS32_AIN_Handler+0xa0>)
 800779a:	681b      	ldr	r3, [r3, #0]
 800779c:	b113      	cbz	r3, 80077a4 <MIOS32_AIN_Handler+0x80>
 800779e:	4798      	blx	r3
 80077a0:	2800      	cmp	r0, #0
 80077a2:	dc03      	bgt.n	80077ac <MIOS32_AIN_Handler+0x88>
    return 0; // scan skipped - no error

  // start next scan
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 80077a4:	4808      	ldr	r0, [pc, #32]	; (80077c8 <MIOS32_AIN_Handler+0xa4>)
 80077a6:	2101      	movs	r1, #1
 80077a8:	f001 f9c9 	bl	8008b3e <ADC_SoftwareStartConvCmd>
  }

  // execute optional "service prepare" callback function
  // skip scan if it returns a value >= 1
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
    return 0; // scan skipped - no error
 80077ac:	2000      	movs	r0, #0
  // start next scan
  ADC_SoftwareStartConvCmd(ADC1, ENABLE);

  return 0; // no error
#endif
}
 80077ae:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80077b0:	20000864 	.word	0x20000864
 80077b4:	20000840 	.word	0x20000840
 80077b8:	20000888 	.word	0x20000888
 80077bc:	20000894 	.word	0x20000894
 80077c0:	20000820 	.word	0x20000820
 80077c4:	2000088c 	.word	0x2000088c
 80077c8:	40012400 	.word	0x40012400

080077cc <DMA1_Channel1_IRQHandler>:
//! DMA channel interrupt is triggered when all ADC channels have been converted
//! \note shouldn't be called directly from application
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_AIN_CHANNEL_MASK
void DMA1_Channel1_IRQHandler(void)
{
 80077cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  int i;
  u16 *src_ptr, *dst_ptr;

  // clear the pending flag(s)
  DMA_ClearFlag(DMA1_FLAG_TC1 | DMA1_FLAG_TE1 | DMA1_FLAG_HT1 | DMA1_FLAG_GL1);
 80077ce:	200f      	movs	r0, #15
//! DMA channel interrupt is triggered when all ADC channels have been converted
//! \note shouldn't be called directly from application
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_AIN_CHANNEL_MASK
void DMA1_Channel1_IRQHandler(void)
{
 80077d0:	b089      	sub	sp, #36	; 0x24
  int i;
  u16 *src_ptr, *dst_ptr;

  // clear the pending flag(s)
  DMA_ClearFlag(DMA1_FLAG_TC1 | DMA1_FLAG_TE1 | DMA1_FLAG_HT1 | DMA1_FLAG_GL1);
 80077d2:	f001 fbe7 	bl	8008fa4 <DMA_ClearFlag>
    oversampling_ctr = 0;
#endif

  // whenever we reached the last sample:
  // copy conversion values to ain_pin_values if difference > deadband
  if( oversampling_ctr == 0 ) {
 80077d6:	4b2f      	ldr	r3, [pc, #188]	; (8007894 <DMA1_Channel1_IRQHandler+0xc8>)
 80077d8:	7818      	ldrb	r0, [r3, #0]
 80077da:	2800      	cmp	r0, #0
 80077dc:	d14d      	bne.n	800787a <DMA1_Channel1_IRQHandler+0xae>
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80077de:	4b2e      	ldr	r3, [pc, #184]	; (8007898 <DMA1_Channel1_IRQHandler+0xcc>)
 80077e0:	4a2e      	ldr	r2, [pc, #184]	; (800789c <DMA1_Channel1_IRQHandler+0xd0>)
 80077e2:	781b      	ldrb	r3, [r3, #0]
 80077e4:	7812      	ldrb	r2, [r2, #0]

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80077e6:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 80078a0 <DMA1_Channel1_IRQHandler+0xd4>
  if( oversampling_ctr == 0 ) {
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80077ea:	435a      	muls	r2, r3

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80077ec:	f89c c000 	ldrb.w	ip, [ip]
 80077f0:	4c2c      	ldr	r4, [pc, #176]	; (80078a4 <DMA1_Channel1_IRQHandler+0xd8>)
  if( oversampling_ctr == 0 ) {
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
 80077f2:	b2d2      	uxtb	r2, r2

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 80077f4:	f8cd c01c 	str.w	ip, [sp, #28]
 80077f8:	9405      	str	r4, [sp, #20]
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    src_ptr = (u16 *)adc_conversion_values_sum;
#else
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 80077fa:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 80078a8 <DMA1_Channel1_IRQHandler+0xdc>

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 80077fe:	4c2b      	ldr	r4, [pc, #172]	; (80078ac <DMA1_Channel1_IRQHandler+0xe0>)
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
    u16 ain_deltas[NUM_CHANNELS_MAX];
    u16 *ain_deltas_ptr = (u16 *)ain_deltas;
#endif
    u8 pin_offset = num_used_channels * mux_ctr;
    u8 bit_offset = pin_offset & 0x1f;
 8007800:	f002 031f 	and.w	r3, r2, #31
    u8 word_offset = pin_offset >> 5;
 8007804:	0951      	lsrs	r1, r2, #5
#if MIOS32_AIN_OVERSAMPLING_RATE >= 2
    src_ptr = (u16 *)adc_conversion_values_sum;
#else
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 8007806:	0052      	lsls	r2, r2, #1
 8007808:	4494      	add	ip, r2
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
#endif
	*dst_ptr = *src_ptr;
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 800780a:	4d29      	ldr	r5, [pc, #164]	; (80078b0 <DMA1_Channel1_IRQHandler+0xe4>)
    src_ptr = (u16 *)adc_conversion_values;
#endif
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 800780c:	18a2      	adds	r2, r4, r2
#endif

    for(i=0; i<num_channels; ++i) {
 800780e:	e031      	b.n	8007874 <DMA1_Channel1_IRQHandler+0xa8>
#if MIOS32_AIN_DEADBAND_IDLE
      u16 deadband = *idle_ctr_ptr ? (MIOS32_AIN_DEADBAND) : (MIOS32_AIN_DEADBAND_IDLE);
 8007810:	f832 4b02 	ldrh.w	r4, [r2], #2
 8007814:	2c00      	cmp	r4, #0
 8007816:	bf0c      	ite	eq
 8007818:	267f      	moveq	r6, #127	; 0x7f
 800781a:	261f      	movne	r6, #31
 800781c:	9606      	str	r6, [sp, #24]

      // takeover new value if difference to old value is outside the deadband
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
 800781e:	9e05      	ldr	r6, [sp, #20]
 8007820:	f836 7f02 	ldrh.w	r7, [r6, #2]!
 8007824:	9701      	str	r7, [sp, #4]
 8007826:	9605      	str	r6, [sp, #20]
 8007828:	f83c 7b02 	ldrh.w	r7, [ip], #2
 800782c:	9e01      	ldr	r6, [sp, #4]
 800782e:	1bf7      	subs	r7, r6, r7
 8007830:	ea87 76e7 	eor.w	r6, r7, r7, asr #31
 8007834:	eba6 76e7 	sub.w	r6, r6, r7, asr #31
 8007838:	9f06      	ldr	r7, [sp, #24]
 800783a:	42be      	cmp	r6, r7
 800783c:	dd0e      	ble.n	800785c <DMA1_Channel1_IRQHandler+0x90>
#endif
	*dst_ptr = *src_ptr;
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 800783e:	2701      	movs	r7, #1
 8007840:	fa17 f603 	lsls.w	r6, r7, r3
#if MIOS32_MF_NUM && !defined(MIOS32_DONT_USE_MF)
      if( (*ain_deltas_ptr++ = abs(*src_ptr - *dst_ptr)) > deadband ) {
#else
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
#endif
	*dst_ptr = *src_ptr;
 8007844:	9c01      	ldr	r4, [sp, #4]
 8007846:	f82c 4c02 	strh.w	r4, [ip, #-2]
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 800784a:	f855 4021 	ldr.w	r4, [r5, r1, lsl #2]
 800784e:	ea46 0404 	orr.w	r4, r6, r4
 8007852:	f845 4021 	str.w	r4, [r5, r1, lsl #2]
#if MIOS32_AIN_DEADBAND_IDLE
	*idle_ctr_ptr = MIOS32_AIN_IDLE_CTR;
 8007856:	f640 34b8 	movw	r4, #3000	; 0xbb8
 800785a:	e001      	b.n	8007860 <DMA1_Channel1_IRQHandler+0x94>
#endif
      } else {
#if MIOS32_AIN_DEADBAND_IDLE
	if( *idle_ctr_ptr )
 800785c:	b114      	cbz	r4, 8007864 <DMA1_Channel1_IRQHandler+0x98>
	  *idle_ctr_ptr -= 1;
 800785e:	3c01      	subs	r4, #1
 8007860:	f822 4c02 	strh.w	r4, [r2, #-2]
#if MIOS32_AIN_DEADBAND_IDLE
      ++idle_ctr_ptr;
#endif

      // switch to next bit/word offset for "changed" flags
      if( ++bit_offset >= 32 ) {
 8007864:	3301      	adds	r3, #1
 8007866:	b2db      	uxtb	r3, r3
 8007868:	2b20      	cmp	r3, #32
 800786a:	d102      	bne.n	8007872 <DMA1_Channel1_IRQHandler+0xa6>
	bit_offset = 0;
	++word_offset;
 800786c:	3101      	adds	r1, #1
 800786e:	b2c9      	uxtb	r1, r1
      ++idle_ctr_ptr;
#endif

      // switch to next bit/word offset for "changed" flags
      if( ++bit_offset >= 32 ) {
	bit_offset = 0;
 8007870:	2300      	movs	r3, #0

#if MIOS32_AIN_DEADBAND_IDLE
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
#endif

    for(i=0; i<num_channels; ++i) {
 8007872:	3001      	adds	r0, #1
 8007874:	9e07      	ldr	r6, [sp, #28]
 8007876:	42b0      	cmp	r0, r6
 8007878:	dbca      	blt.n	8007810 <DMA1_Channel1_IRQHandler+0x44>
    // starting conversion of new selected channels
  }
#endif

  // request next conversion as long as oversampling/mux counter haven't reached the end
  if( mux_ctr || oversampling_ctr )
 800787a:	4b07      	ldr	r3, [pc, #28]	; (8007898 <DMA1_Channel1_IRQHandler+0xcc>)
 800787c:	781b      	ldrb	r3, [r3, #0]
 800787e:	b913      	cbnz	r3, 8007886 <DMA1_Channel1_IRQHandler+0xba>
 8007880:	4b04      	ldr	r3, [pc, #16]	; (8007894 <DMA1_Channel1_IRQHandler+0xc8>)
 8007882:	781b      	ldrb	r3, [r3, #0]
 8007884:	b11b      	cbz	r3, 800788e <DMA1_Channel1_IRQHandler+0xc2>
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 8007886:	480b      	ldr	r0, [pc, #44]	; (80078b4 <DMA1_Channel1_IRQHandler+0xe8>)
 8007888:	2101      	movs	r1, #1
 800788a:	f001 f958 	bl	8008b3e <ADC_SoftwareStartConvCmd>
}
 800788e:	b009      	add	sp, #36	; 0x24
 8007890:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007892:	bf00      	nop
 8007894:	20000840 	.word	0x20000840
 8007898:	20000864 	.word	0x20000864
 800789c:	20000890 	.word	0x20000890
 80078a0:	20000888 	.word	0x20000888
 80078a4:	20000842 	.word	0x20000842
 80078a8:	20000820 	.word	0x20000820
 80078ac:	20000868 	.word	0x20000868
 80078b0:	20000894 	.word	0x20000894
 80078b4:	40012400 	.word	0x40012400

080078b8 <MIOS32_USB_CB_SetDeviceAddress>:
}

// update the device state to addressed
static void MIOS32_USB_CB_SetDeviceAddress (void)
{
  bDeviceState = ADDRESSED;
 80078b8:	4b01      	ldr	r3, [pc, #4]	; (80078c0 <MIOS32_USB_CB_SetDeviceAddress+0x8>)
 80078ba:	2204      	movs	r2, #4
 80078bc:	601a      	str	r2, [r3, #0]
}
 80078be:	4770      	bx	lr
 80078c0:	20000898 	.word	0x20000898

080078c4 <MIOS32_USB_CB_Status_In>:
static void MIOS32_USB_CB_Status_In(void)
{
#ifdef MIOS32_USE_USB_COM
  MIOS32_USB_COM_CB_StatusIn();
#endif
}
 80078c4:	4770      	bx	lr

080078c6 <MIOS32_USB_CB_Status_Out>:

// status OUT routine
static void MIOS32_USB_CB_Status_Out(void)
{
}
 80078c6:	4770      	bx	lr

080078c8 <MIOS32_USB_CB_Data_Setup>:
  RESULT res;
  if( (res=MIOS32_USB_COM_CB_Data_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif
  return USB_UNSUPPORT;
}
 80078c8:	2002      	movs	r0, #2
 80078ca:	4770      	bx	lr

080078cc <MIOS32_USB_CB_NoData_Setup>:
  if( (res=MIOS32_USB_COM_CB_NoData_Setup(RequestNo)) != USB_UNSUPPORT )
    return res;
#endif

  return USB_UNSUPPORT;
}
 80078cc:	2002      	movs	r0, #2
 80078ce:	4770      	bx	lr

080078d0 <MIOS32_USB_CB_Get_Interface_Setting>:
}

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
 80078d0:	b921      	cbnz	r1, 80078dc <MIOS32_USB_CB_Get_Interface_Setting+0xc>
    return USB_UNSUPPORT;
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
 80078d2:	2801      	cmp	r0, #1
 80078d4:	bf8c      	ite	hi
 80078d6:	2002      	movhi	r0, #2
 80078d8:	2000      	movls	r0, #0
 80078da:	e000      	b.n	80078de <MIOS32_USB_CB_Get_Interface_Setting+0xe>

// test the interface and the alternate setting according to the supported one.
static RESULT MIOS32_USB_CB_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
{
  if( AlternateSetting > 0 ) {
    return USB_UNSUPPORT;
 80078dc:	2002      	movs	r0, #2
  } else if( Interface >= MIOS32_USB_NUM_INTERFACES ) {
    return USB_UNSUPPORT;
  }

  return USB_SUCCESS;
}
 80078de:	4770      	bx	lr

080078e0 <MIOS32_USB_CB_SetConfiguration>:
  bDeviceState = ATTACHED;
}

// update the device state to configured.
static void MIOS32_USB_CB_SetConfiguration(void)
{
 80078e0:	b508      	push	{r3, lr}
  if (pInformation->Current_Configuration != 0) {
 80078e2:	4b05      	ldr	r3, [pc, #20]	; (80078f8 <MIOS32_USB_CB_SetConfiguration+0x18>)
 80078e4:	681b      	ldr	r3, [r3, #0]
 80078e6:	7a9b      	ldrb	r3, [r3, #10]
 80078e8:	b12b      	cbz	r3, 80078f6 <MIOS32_USB_CB_SetConfiguration+0x16>
#ifndef MIOS32_DONT_USE_USB_MIDI
    // propagate connection state to USB MIDI driver
    MIOS32_USB_MIDI_ChangeConnectionState(1); // connected
 80078ea:	2001      	movs	r0, #1
 80078ec:	f000 fa92 	bl	8007e14 <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
    // propagate connection state to USB COM driver
    MIOS32_USB_COM_ChangeConnectionState(1); // connected
#endif

    bDeviceState = CONFIGURED;
 80078f0:	4b02      	ldr	r3, [pc, #8]	; (80078fc <MIOS32_USB_CB_SetConfiguration+0x1c>)
 80078f2:	2205      	movs	r2, #5
 80078f4:	601a      	str	r2, [r3, #0]
  }
}
 80078f6:	bd08      	pop	{r3, pc}
 80078f8:	20003794 	.word	0x20003794
 80078fc:	20000898 	.word	0x20000898

08007900 <MIOS32_USB_CB_GetStringDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 8007900:	b570      	push	{r4, r5, r6, lr}
 8007902:	b0c4      	sub	sp, #272	; 0x110
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 8007904:	493f      	ldr	r1, [pc, #252]	; (8007a04 <MIOS32_USB_CB_GetStringDescriptor+0x104>)
 8007906:	220c      	movs	r2, #12
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the string descriptors according to the needed index
static u8 *MIOS32_USB_CB_GetStringDescriptor(u16 Length)
{
 8007908:	4604      	mov	r4, r0
  const u8 vendor_str[] = MIOS32_USB_VENDOR_STR;
 800790a:	a83d      	add	r0, sp, #244	; 0xf4
 800790c:	f002 fd86 	bl	800a41c <memcpy>
  const u8 product_str[] = MIOS32_USB_PRODUCT_STR;
 8007910:	a842      	add	r0, sp, #264	; 0x108
 8007912:	493d      	ldr	r1, [pc, #244]	; (8007a08 <MIOS32_USB_CB_GetStringDescriptor+0x108>)
 8007914:	2207      	movs	r2, #7
 8007916:	f002 fd81 	bl	800a41c <memcpy>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 800791a:	4b3c      	ldr	r3, [pc, #240]	; (8007a0c <MIOS32_USB_CB_GetStringDescriptor+0x10c>)
 800791c:	681b      	ldr	r3, [r3, #0]
 800791e:	78db      	ldrb	r3, [r3, #3]
 8007920:	2b03      	cmp	r3, #3
 8007922:	d86c      	bhi.n	80079fe <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 8007924:	e8df f003 	tbb	[pc, r3]
 8007928:	40020a12 	.word	0x40020a12
 800792c:	a941      	add	r1, sp, #260	; 0x104
 800792e:	3103      	adds	r1, #3
 8007930:	f10d 0206 	add.w	r2, sp, #6
 8007934:	2302      	movs	r3, #2

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 8007936:	f04f 0c00 	mov.w	ip, #0
 800793a:	e027      	b.n	800798c <MIOS32_USB_CB_GetStringDescriptor+0x8c>

  u8 buffer[200];
  u16 len;
  int i;

  switch( pInformation->USBwValue0 ) {
 800793c:	f10d 01f3 	add.w	r1, sp, #243	; 0xf3
 8007940:	f10d 0206 	add.w	r2, sp, #6
 8007944:	2302      	movs	r3, #2

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 8007946:	f04f 0c00 	mov.w	ip, #0
 800794a:	e00b      	b.n	8007964 <MIOS32_USB_CB_GetStringDescriptor+0x64>
  int i;

  switch( pInformation->USBwValue0 ) {
    case 0: // Language
      // buffer[0] and [1] initialized below
      buffer[2] = 0x09;        // CharSet
 800794c:	aa01      	add	r2, sp, #4
 800794e:	2309      	movs	r3, #9
 8007950:	7093      	strb	r3, [r2, #2]
      buffer[3] = 0x04;        // U.S.
 8007952:	2304      	movs	r3, #4
 8007954:	70d3      	strb	r3, [r2, #3]
      len = 4;
      break;
 8007956:	e046      	b.n	80079e6 <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
	buffer[len++] = 0;
 8007958:	3302      	adds	r3, #2
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = vendor_str[i];
 800795a:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 800795e:	f802 cc01 	strb.w	ip, [r2, #-1]
 8007962:	b29b      	uxth	r3, r3
      len = 4;
      break;

    case 1: // Vendor
      // buffer[0] and [1] initialized below
      for(i=0, len=2; vendor_str[i] != '\0' && len<200; ++i) {
 8007964:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007968:	3202      	adds	r2, #2
 800796a:	1e05      	subs	r5, r0, #0
 800796c:	bf18      	it	ne
 800796e:	2501      	movne	r5, #1
 8007970:	2bc7      	cmp	r3, #199	; 0xc7
 8007972:	bf8c      	ite	hi
 8007974:	2500      	movhi	r5, #0
 8007976:	f005 0501 	andls.w	r5, r5, #1
 800797a:	2d00      	cmp	r5, #0
 800797c:	d1ec      	bne.n	8007958 <MIOS32_USB_CB_GetStringDescriptor+0x58>
 800797e:	e032      	b.n	80079e6 <MIOS32_USB_CB_GetStringDescriptor+0xe6>

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
	buffer[len++] = 0;
 8007980:	3302      	adds	r3, #2
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
	buffer[len++] = product_str[i];
 8007982:	f802 0c02 	strb.w	r0, [r2, #-2]
	buffer[len++] = 0;
 8007986:	f802 cc01 	strb.w	ip, [r2, #-1]
 800798a:	b29b      	uxth	r3, r3
      }
      break;

    case 2: // Product
      // buffer[0] and [1] initialized below
      for(i=0, len=2; product_str[i] != '\0' && len<200; ++i) {
 800798c:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8007990:	3202      	adds	r2, #2
 8007992:	1e05      	subs	r5, r0, #0
 8007994:	bf18      	it	ne
 8007996:	2501      	movne	r5, #1
 8007998:	2bc7      	cmp	r3, #199	; 0xc7
 800799a:	bf8c      	ite	hi
 800799c:	2500      	movhi	r5, #0
 800799e:	f005 0501 	andls.w	r5, r5, #1
 80079a2:	2d00      	cmp	r5, #0
 80079a4:	d1ec      	bne.n	8007980 <MIOS32_USB_CB_GetStringDescriptor+0x80>
 80079a6:	e01e      	b.n	80079e6 <MIOS32_USB_CB_GetStringDescriptor+0xe6>
      }
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
 80079a8:	ad33      	add	r5, sp, #204	; 0xcc
 80079aa:	4628      	mov	r0, r5
 80079ac:	f7fe fd2e 	bl	800640c <MIOS32_SYS_SerialNumberGet>
 80079b0:	2800      	cmp	r0, #0
 80079b2:	db24      	blt.n	80079fe <MIOS32_USB_CB_GetStringDescriptor+0xfe>
 80079b4:	3d01      	subs	r5, #1
 80079b6:	f10d 0206 	add.w	r2, sp, #6
 80079ba:	2302      	movs	r3, #2
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
 80079bc:	2000      	movs	r0, #0
 80079be:	e005      	b.n	80079cc <MIOS32_USB_CB_GetStringDescriptor+0xcc>
 80079c0:	3302      	adds	r3, #2

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
 80079c2:	f802 1c02 	strb.w	r1, [r2, #-2]
	    buffer[len++] = 0;
 80079c6:	f802 0c01 	strb.w	r0, [r2, #-1]
 80079ca:	b29b      	uxth	r3, r3
      break;

    case 3: { // Serial Number
        u8 serial_number_str[40];
	if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
 80079cc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80079d0:	3202      	adds	r2, #2
 80079d2:	1e0e      	subs	r6, r1, #0
 80079d4:	bf18      	it	ne
 80079d6:	2601      	movne	r6, #1
 80079d8:	2bc7      	cmp	r3, #199	; 0xc7
 80079da:	bf8c      	ite	hi
 80079dc:	2600      	movhi	r6, #0
 80079de:	f006 0601 	andls.w	r6, r6, #1
 80079e2:	2e00      	cmp	r6, #0
 80079e4:	d1ec      	bne.n	80079c0 <MIOS32_USB_CB_GetStringDescriptor+0xc0>
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 80079e6:	aa01      	add	r2, sp, #4
  buffer[1] = DSCR_STRING; // Descriptor Type
 80079e8:	2103      	movs	r1, #3
 80079ea:	7051      	strb	r1, [r2, #1]
      break;
    default: // string ID not supported
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
 80079ec:	7013      	strb	r3, [r2, #0]
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
 80079ee:	4620      	mov	r0, r4
 80079f0:	a940      	add	r1, sp, #256	; 0x100
      return NULL;
  }

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
 80079f2:	9240      	str	r2, [sp, #256]	; 0x100
 80079f4:	f8ad 3104 	strh.w	r3, [sp, #260]	; 0x104
  return Standard_GetDescriptorData(Length, &desc);
 80079f8:	f001 ff6e 	bl	80098d8 <Standard_GetDescriptorData>
 80079fc:	e000      	b.n	8007a00 <MIOS32_USB_CB_GetStringDescriptor+0x100>
	  for(i=0, len=2; serial_number_str[i] != '\0' && len<200; ++i) {
	    buffer[len++] = serial_number_str[i];
	    buffer[len++] = 0;
	  }
	} else
	  return NULL;
 80079fe:	2000      	movs	r0, #0

  buffer[0] = len; // Descriptor Length
  buffer[1] = DSCR_STRING; // Descriptor Type
  ONE_DESCRIPTOR desc = {(u8 *)buffer, len};
  return Standard_GetDescriptorData(Length, &desc);
}
 8007a00:	b044      	add	sp, #272	; 0x110
 8007a02:	bd70      	pop	{r4, r5, r6, pc}
 8007a04:	0800afd8 	.word	0x0800afd8
 8007a08:	0800ae0f 	.word	0x0800ae0f
 8007a0c:	20003794 	.word	0x20003794

08007a10 <MIOS32_USB_CB_GetConfigDescriptor>:
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 8007a10:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 8007a12:	4905      	ldr	r1, [pc, #20]	; (8007a28 <MIOS32_USB_CB_GetConfigDescriptor+0x18>)
  return Standard_GetDescriptorData(Length, &desc);
}

// gets the configuration descriptor.
static u8 *MIOS32_USB_CB_GetConfigDescriptor(u16 Length)
{
 8007a14:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_ConfigDescriptor, MIOS32_USB_SIZ_CONFIG_DESC};
 8007a16:	466b      	mov	r3, sp
 8007a18:	c903      	ldmia	r1!, {r0, r1}
 8007a1a:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 8007a1e:	4610      	mov	r0, r2
 8007a20:	4669      	mov	r1, sp
 8007a22:	f001 ff59 	bl	80098d8 <Standard_GetDescriptorData>
}
 8007a26:	bd0e      	pop	{r1, r2, r3, pc}
 8007a28:	0800afec 	.word	0x0800afec

08007a2c <MIOS32_USB_CB_GetDeviceDescriptor>:
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 8007a2c:	b507      	push	{r0, r1, r2, lr}
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 8007a2e:	4905      	ldr	r1, [pc, #20]	; (8007a44 <MIOS32_USB_CB_GetDeviceDescriptor+0x18>)
  return USB_UNSUPPORT;
}

// gets the device descriptor.
static u8 *MIOS32_USB_CB_GetDeviceDescriptor(u16 Length)
{
 8007a30:	4602      	mov	r2, r0
  ONE_DESCRIPTOR desc = {(u8 *)MIOS32_USB_DeviceDescriptor, MIOS32_USB_SIZ_DEVICE_DESC};
 8007a32:	466b      	mov	r3, sp
 8007a34:	c903      	ldmia	r1!, {r0, r1}
 8007a36:	e883 0003 	stmia.w	r3, {r0, r1}
  return Standard_GetDescriptorData(Length, &desc);
 8007a3a:	4610      	mov	r0, r2
 8007a3c:	4669      	mov	r1, sp
 8007a3e:	f001 ff4b 	bl	80098d8 <Standard_GetDescriptorData>
}
 8007a42:	bd0e      	pop	{r1, r2, r3, pc}
 8007a44:	0800afe4 	.word	0x0800afe4

08007a48 <MIOS32_USB_CB_Reset>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
 8007a48:	b538      	push	{r3, r4, r5, lr}
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 8007a4a:	4b27      	ldr	r3, [pc, #156]	; (8007ae8 <MIOS32_USB_CB_Reset+0xa0>)
 8007a4c:	2400      	movs	r4, #0
 8007a4e:	681b      	ldr	r3, [r3, #0]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007a50:	2580      	movs	r5, #128	; 0x80

// reset routine
static void MIOS32_USB_CB_Reset(void)
{
  // Set MIOS32 Device as not configured
  pInformation->Current_Configuration = 0;
 8007a52:	729c      	strb	r4, [r3, #10]

  // Current Feature initialization
  pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007a54:	725d      	strb	r5, [r3, #9]

  // Set MIOS32 Device with the default Interface
  pInformation->Current_Interface = 0;
 8007a56:	72dc      	strb	r4, [r3, #11]

#ifdef STM32F10X_CL   
  // EP0 is already configured in DFU_Init() by USB_SIL_Init() function
#else 
  SetBTABLE(MIOS32_USB_BTABLE_ADDRESS);
 8007a58:	4620      	mov	r0, r4
 8007a5a:	f002 faab 	bl	8009fb4 <SetBTABLE>

  // Initialize Endpoint 0
  SetEPType(ENDP0, EP_CONTROL);
 8007a5e:	4620      	mov	r0, r4
 8007a60:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007a64:	f002 fab0 	bl	8009fc8 <SetEPType>
  SetEPTxStatus(ENDP0, EP_TX_STALL);
 8007a68:	4620      	mov	r0, r4
 8007a6a:	2110      	movs	r1, #16
 8007a6c:	f002 fac4 	bl	8009ff8 <SetEPTxStatus>
  SetEPRxAddr(ENDP0, MIOS32_USB_ENDP0_RXADDR);
 8007a70:	4620      	mov	r0, r4
 8007a72:	2140      	movs	r1, #64	; 0x40
 8007a74:	f002 fb48 	bl	800a108 <SetEPRxAddr>
  SetEPTxAddr(ENDP0, MIOS32_USB_ENDP0_TXADDR);
 8007a78:	4629      	mov	r1, r5
 8007a7a:	4620      	mov	r0, r4
 8007a7c:	f002 fb34 	bl	800a0e8 <SetEPTxAddr>
  Clear_Status_Out(ENDP0);
 8007a80:	4620      	mov	r0, r4
 8007a82:	f002 faf9 	bl	800a078 <Clear_Status_Out>
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 8007a86:	4b19      	ldr	r3, [pc, #100]	; (8007aec <MIOS32_USB_CB_Reset+0xa4>)
 8007a88:	4620      	mov	r0, r4
 8007a8a:	681b      	ldr	r3, [r3, #0]
 8007a8c:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8007a90:	f002 fb74 	bl	800a17c <SetEPRxCount>
  SetEPRxValid(ENDP0);
 8007a94:	4620      	mov	r0, r4
 8007a96:	f002 fadd 	bl	800a054 <SetEPRxValid>
  
  // Init EP1 OUT
  OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
# else
  // Initialize Endpoint 1
  SetEPType(ENDP1, EP_BULK);
 8007a9a:	2001      	movs	r0, #1
 8007a9c:	4621      	mov	r1, r4
 8007a9e:	f002 fa93 	bl	8009fc8 <SetEPType>

  SetEPTxAddr(ENDP1, MIOS32_USB_ENDP1_TXADDR);
 8007aa2:	2001      	movs	r0, #1
 8007aa4:	21c0      	movs	r1, #192	; 0xc0
 8007aa6:	f002 fb1f 	bl	800a0e8 <SetEPTxAddr>
  SetEPTxCount(ENDP1, MIOS32_USB_MIDI_DATA_OUT_SIZE);
 8007aaa:	2001      	movs	r0, #1
 8007aac:	2140      	movs	r1, #64	; 0x40
 8007aae:	f002 fb57 	bl	800a160 <SetEPTxCount>
  SetEPTxStatus(ENDP1, EP_TX_NAK);
 8007ab2:	2001      	movs	r0, #1
 8007ab4:	2120      	movs	r1, #32
 8007ab6:	f002 fa9f 	bl	8009ff8 <SetEPTxStatus>

  SetEPRxAddr(ENDP1, MIOS32_USB_ENDP1_RXADDR);
 8007aba:	2001      	movs	r0, #1
 8007abc:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007ac0:	f002 fb22 	bl	800a108 <SetEPRxAddr>
  SetEPRxCount(ENDP1, MIOS32_USB_MIDI_DATA_IN_SIZE);
 8007ac4:	2140      	movs	r1, #64	; 0x40
 8007ac6:	2001      	movs	r0, #1
 8007ac8:	f002 fb58 	bl	800a17c <SetEPRxCount>
  SetEPRxValid(ENDP1);
 8007acc:	2001      	movs	r0, #1
 8007ace:	f002 fac1 	bl	800a054 <SetEPRxValid>
# endif
#endif

  // Set this device to response on default address
#ifndef STM32F10X_CL   
  SetDeviceAddress(0);
 8007ad2:	4620      	mov	r0, r4
 8007ad4:	f002 f932 	bl	8009d3c <SetDeviceAddress>
#endif

#ifndef MIOS32_DONT_USE_USB_MIDI
  // propagate connection state to USB MIDI driver
  MIOS32_USB_MIDI_ChangeConnectionState(0); // not connected
 8007ad8:	4620      	mov	r0, r4
 8007ada:	f000 f99b 	bl	8007e14 <MIOS32_USB_MIDI_ChangeConnectionState>
#ifdef MIOS32_USE_USB_COM
  // propagate connection state to USB COM driver
  MIOS32_USB_COM_ChangeConnectionState(0); // not connected
#endif

  bDeviceState = ATTACHED;
 8007ade:	4b04      	ldr	r3, [pc, #16]	; (8007af0 <MIOS32_USB_CB_Reset+0xa8>)
 8007ae0:	2201      	movs	r2, #1
 8007ae2:	601a      	str	r2, [r3, #0]
}
 8007ae4:	bd38      	pop	{r3, r4, r5, pc}
 8007ae6:	bf00      	nop
 8007ae8:	20003794 	.word	0x20003794
 8007aec:	2000378c 	.word	0x2000378c
 8007af0:	20000898 	.word	0x20000898

08007af4 <USB_LP_CAN1_RX0_IRQHandler>:
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  u16 wIstr = _GetISTR();
 8007af4:	4b0d      	ldr	r3, [pc, #52]	; (8007b2c <USB_LP_CAN1_RX0_IRQHandler+0x38>)
  }
  return retval;
}
#else
void USB_LP_CAN1_RX0_IRQHandler(void)
{
 8007af6:	b510      	push	{r4, lr}
  u16 wIstr = _GetISTR();
 8007af8:	681c      	ldr	r4, [r3, #0]
 8007afa:	b2a4      	uxth	r4, r4

  if( wIstr & ISTR_RESET ) {
 8007afc:	f414 6f80 	tst.w	r4, #1024	; 0x400
 8007b00:	d006      	beq.n	8007b10 <USB_LP_CAN1_RX0_IRQHandler+0x1c>
    _SetISTR((u16)CLR_RESET);
 8007b02:	f64f 32ff 	movw	r2, #64511	; 0xfbff
 8007b06:	601a      	str	r2, [r3, #0]
    pProperty->Reset();
 8007b08:	4b09      	ldr	r3, [pc, #36]	; (8007b30 <USB_LP_CAN1_RX0_IRQHandler+0x3c>)
 8007b0a:	681b      	ldr	r3, [r3, #0]
 8007b0c:	685b      	ldr	r3, [r3, #4]
 8007b0e:	4798      	blx	r3
  }

  if( wIstr & ISTR_SOF ) {
 8007b10:	f414 7f00 	tst.w	r4, #512	; 0x200
    _SetISTR((u16)CLR_SOF);
 8007b14:	bf1e      	ittt	ne
 8007b16:	4b05      	ldrne	r3, [pc, #20]	; (8007b2c <USB_LP_CAN1_RX0_IRQHandler+0x38>)
 8007b18:	f64f 52ff 	movwne	r2, #65023	; 0xfdff
 8007b1c:	601a      	strne	r2, [r3, #0]
  }

  if( wIstr & ISTR_CTR ) {
 8007b1e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8007b22:	d001      	beq.n	8007b28 <USB_LP_CAN1_RX0_IRQHandler+0x34>
    // servicing of the endpoint correct transfer interrupt
    // clear of the CTR flag into the sub
    CTR_LP();
 8007b24:	f002 f964 	bl	8009df0 <CTR_LP>
  }
}
 8007b28:	bd10      	pop	{r4, pc}
 8007b2a:	bf00      	nop
 8007b2c:	40005c44 	.word	0x40005c44
 8007b30:	2000378c 	.word	0x2000378c

08007b34 <MIOS32_USB_IsInitialized>:
//! This function is used by the bootloader to avoid a reconnection, it isn't
//! relevant for typical applications!
//! \return 1 if USB already initialized, 0 if not initialized
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_IsInitialized(void)
{
 8007b34:	b508      	push	{r3, lr}
  // we assume that initialisation has been done when B-Session valid flag is set
  __IO USB_OTG_GREGS *GREGS = (USB_OTG_GREGS *)(USB_OTG_FS_BASE_ADDR + USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  return (GREGS->GOTGCTL & (1 << 19));
#else
  // we assume that initialisation has been done when endpoint 0 contains a value
  return GetEPType(ENDP0) ? 1 : 0;
 8007b36:	2000      	movs	r0, #0
 8007b38:	f002 fa55 	bl	8009fe6 <GetEPType>
 8007b3c:	3800      	subs	r0, #0
 8007b3e:	bf18      	it	ne
 8007b40:	2001      	movne	r0, #1
#endif
}
 8007b42:	bd08      	pop	{r3, pc}

08007b44 <MIOS32_USB_Init>:
//!   </UL>
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_Init(u32 mode)
{
 8007b44:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007b46:	4604      	mov	r4, r0
  u32 delay;

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8007b48:	a801      	add	r0, sp, #4
 8007b4a:	f000 ff4b 	bl	80089e4 <GPIO_StructInit>

  // currently only mode 0..2 supported
  if( mode >= 3 )
 8007b4e:	2c02      	cmp	r4, #2
    return -1; // unsupported mode
 8007b50:	bf88      	it	hi
 8007b52:	f04f 30ff 	movhi.w	r0, #4294967295

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);

  // currently only mode 0..2 supported
  if( mode >= 3 )
 8007b56:	d877      	bhi.n	8007c48 <MIOS32_USB_Init+0x104>
    return -1; // unsupported mode

  // clear all USB interrupt requests
#ifdef STM32F10X_CL
#else
  MIOS32_IRQ_Disable();
 8007b58:	f7fe fd64 	bl	8006624 <MIOS32_IRQ_Disable>
  _SetCNTR(0); // Interrupt Mask
 8007b5c:	4b3b      	ldr	r3, [pc, #236]	; (8007c4c <MIOS32_USB_Init+0x108>)
 8007b5e:	2200      	movs	r2, #0
 8007b60:	601a      	str	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 8007b62:	f7fe fd75 	bl	8006650 <MIOS32_IRQ_Enable>
#endif

  // if mode != 2: install MIOS32 hooks
  // a local driver can install it's own hooks and call MIOS32_USB_Init(2) to force re-enumeration
  if( mode != 2 ) {
 8007b66:	2c02      	cmp	r4, #2
 8007b68:	d013      	beq.n	8007b92 <MIOS32_USB_Init+0x4e>
    pInformation = &My_Device_Info; // Note: usually no need to duplicate this for external drivers
 8007b6a:	4a39      	ldr	r2, [pc, #228]	; (8007c50 <MIOS32_USB_Init+0x10c>)
 8007b6c:	4b39      	ldr	r3, [pc, #228]	; (8007c54 <MIOS32_USB_Init+0x110>)
 8007b6e:	601a      	str	r2, [r3, #0]

    // following hooks/pointers should be replaced by external drivers
    memcpy(&Device_Table, (DEVICE *)&My_Device_Table, sizeof(Device_Table));
 8007b70:	4b39      	ldr	r3, [pc, #228]	; (8007c58 <MIOS32_USB_Init+0x114>)
 8007b72:	2205      	movs	r2, #5
 8007b74:	701a      	strb	r2, [r3, #0]
 8007b76:	2201      	movs	r2, #1
 8007b78:	705a      	strb	r2, [r3, #1]
    pProperty = (DEVICE_PROP *)&My_Device_Property;
 8007b7a:	4a38      	ldr	r2, [pc, #224]	; (8007c5c <MIOS32_USB_Init+0x118>)
 8007b7c:	4b38      	ldr	r3, [pc, #224]	; (8007c60 <MIOS32_USB_Init+0x11c>)
 8007b7e:	601a      	str	r2, [r3, #0]
    pUser_Standard_Requests = (USER_STANDARD_REQUESTS *)&My_User_Standard_Requests;
 8007b80:	4a38      	ldr	r2, [pc, #224]	; (8007c64 <MIOS32_USB_Init+0x120>)
 8007b82:	4b39      	ldr	r3, [pc, #228]	; (8007c68 <MIOS32_USB_Init+0x124>)
 8007b84:	601a      	str	r2, [r3, #0]

#ifndef MIOS32_DONT_USE_USB_MIDI
    pEpInt_IN[0]  = MIOS32_USB_MIDI_EP1_IN_Callback;  // IN  EP1
 8007b86:	4a39      	ldr	r2, [pc, #228]	; (8007c6c <MIOS32_USB_Init+0x128>)
 8007b88:	4b39      	ldr	r3, [pc, #228]	; (8007c70 <MIOS32_USB_Init+0x12c>)
 8007b8a:	601a      	str	r2, [r3, #0]
    pEpInt_OUT[0] = MIOS32_USB_MIDI_EP1_OUT_Callback; // OUT EP1
 8007b8c:	4a39      	ldr	r2, [pc, #228]	; (8007c74 <MIOS32_USB_Init+0x130>)
 8007b8e:	4b3a      	ldr	r3, [pc, #232]	; (8007c78 <MIOS32_USB_Init+0x134>)
 8007b90:	601a      	str	r2, [r3, #0]
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 8007b92:	4d30      	ldr	r5, [pc, #192]	; (8007c54 <MIOS32_USB_Init+0x110>)
#endif
  }

  // change connection state to disconnected
#ifndef MIOS32_DONT_USE_USB_MIDI
  MIOS32_USB_MIDI_ChangeConnectionState(0);
 8007b94:	2000      	movs	r0, #0
 8007b96:	f000 f93d 	bl	8007e14 <MIOS32_USB_MIDI_ChangeConnectionState>
#endif

  // we don't use USB_Init() anymore for more flexibility
  // e.g. changing USB driver during runtime via MIOS32_USB_Init(2)

  pInformation->ControlState = 2;
 8007b9a:	682b      	ldr	r3, [r5, #0]
 8007b9c:	2202      	movs	r2, #2
 8007b9e:	721a      	strb	r2, [r3, #8]
  pInformation->Current_Configuration = 0;
 8007ba0:	2200      	movs	r2, #0
 8007ba2:	729a      	strb	r2, [r3, #10]

  // if mode == 0: don't initialize USB if not required (important for BSL)
  if( mode == 0 && MIOS32_USB_IsInitialized() ) {
 8007ba4:	b99c      	cbnz	r4, 8007bce <MIOS32_USB_Init+0x8a>
 8007ba6:	f7ff ffc5 	bl	8007b34 <MIOS32_USB_IsInitialized>
 8007baa:	b180      	cbz	r0, 8007bce <MIOS32_USB_Init+0x8a>
    // Init EP1 OUT again
    OTG_DEV_EP_Init(EP1_OUT, OTG_DEV_EP_TYPE_BULK, MIOS32_USB_MIDI_DATA_OUT_SIZE);
#else
#ifndef MIOS32_DONT_USE_USB_MIDI
    // release ENDP1 Rx/Tx
    SetEPTxStatus(ENDP1, EP_TX_NAK);
 8007bac:	2001      	movs	r0, #1
 8007bae:	2120      	movs	r1, #32
 8007bb0:	f002 fa22 	bl	8009ff8 <SetEPTxStatus>
    SetEPRxValid(ENDP1);
 8007bb4:	2001      	movs	r0, #1
 8007bb6:	f002 fa4d 	bl	800a054 <SetEPRxValid>
#endif
#endif

    pInformation->Current_Feature = MIOS32_USB_ConfigDescriptor[7];
 8007bba:	682b      	ldr	r3, [r5, #0]
 8007bbc:	2280      	movs	r2, #128	; 0x80
 8007bbe:	725a      	strb	r2, [r3, #9]
    pInformation->Current_Configuration = 1;
 8007bc0:	2201      	movs	r2, #1
 8007bc2:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 8007bc4:	4b28      	ldr	r3, [pc, #160]	; (8007c68 <MIOS32_USB_Init+0x124>)
 8007bc6:	681b      	ldr	r3, [r3, #0]
 8007bc8:	685b      	ldr	r3, [r3, #4]
 8007bca:	4798      	blx	r3
 8007bcc:	e02d      	b.n	8007c2a <MIOS32_USB_Init+0xe6>
    
    // connect device
    USB_DevConnect();
#else
    // force USB reset and power-down (this will also release the USB pins for direct GPIO control)
    _SetCNTR(CNTR_FRES | CNTR_PDWN);
 8007bce:	4a1f      	ldr	r2, [pc, #124]	; (8007c4c <MIOS32_USB_Init+0x108>)
 8007bd0:	2303      	movs	r3, #3
 8007bd2:	6013      	str	r3, [r2, #0]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8007bd4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8007bd8:	f8ad 2004 	strh.w	r2, [sp, #4]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007bdc:	a901      	add	r1, sp, #4
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007bde:	2210      	movs	r2, #16
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007be0:	4826      	ldr	r0, [pc, #152]	; (8007c7c <MIOS32_USB_Init+0x138>)
#else
    // using a "dirty" method to force a re-enumeration:
    // force DPM (Pin PA12) low for ca. 10 mS before USB Tranceiver will be enabled
    // this overrules the external Pull-Up at PA12, and at least Windows & MacOS will enumerate again
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8007be2:	f88d 2007 	strb.w	r2, [sp, #7]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007be6:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007bea:	f000 fea2 	bl	8008932 <GPIO_Init>
 8007bee:	4b24      	ldr	r3, [pc, #144]	; (8007c80 <MIOS32_USB_Init+0x13c>)

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 8007bf0:	4922      	ldr	r1, [pc, #136]	; (8007c7c <MIOS32_USB_Init+0x138>)
 8007bf2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 8007bf6:	f113 33ff 	adds.w	r3, r3, #4294967295
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
 8007bfa:	614a      	str	r2, [r1, #20]
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
 8007bfc:	d1fb      	bne.n	8007bf6 <MIOS32_USB_Init+0xb2>
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 8007bfe:	4a13      	ldr	r2, [pc, #76]	; (8007c4c <MIOS32_USB_Init+0x108>)
 8007c00:	2102      	movs	r1, #2
 8007c02:	6011      	str	r1, [r2, #0]

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 8007c04:	4a1d      	ldr	r2, [pc, #116]	; (8007c7c <MIOS32_USB_Init+0x138>)
    for(delay=0; delay<200000; ++delay) // produces a delay of ca. 50 mS @ 72 MHz (measured with scope)
      GPIOA->BRR = GPIO_Pin_12; // force pin to 0 (without this dummy code, an "empty" for loop could be removed by the compiler)
#endif

    // release power-down, still hold reset
    _SetCNTR(CNTR_PDWN);
 8007c06:	200a      	movs	r0, #10

    // according to the reference manual, we have to wait at least for tSTARTUP = 1 uS before releasing reset
    for(delay=0; delay<10; ++delay) GPIOA->BRR = 0; // should be more than sufficient - add some dummy code here to ensure that the compiler doesn't optimize the empty for loop away
 8007c08:	f110 30ff 	adds.w	r0, r0, #4294967295
 8007c0c:	6153      	str	r3, [r2, #20]
 8007c0e:	d1fb      	bne.n	8007c08 <MIOS32_USB_Init+0xc4>

    // CNTR_FRES = 0
    _SetCNTR(0);
 8007c10:	4b0e      	ldr	r3, [pc, #56]	; (8007c4c <MIOS32_USB_Init+0x108>)
 8007c12:	6018      	str	r0, [r3, #0]

    // Clear pending interrupts
    _SetISTR(0);
 8007c14:	3304      	adds	r3, #4
 8007c16:	6018      	str	r0, [r3, #0]

    // Configure USB clock
    // USBCLK = PLLCLK / 1.5
    RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
 8007c18:	f001 fada 	bl	80091d0 <RCC_USBCLKConfig>
    // Enable USB clock
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
 8007c1c:	2101      	movs	r1, #1
 8007c1e:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8007c22:	f001 fb63 	bl	80092ec <RCC_APB1PeriphClockCmd>
#endif /* STM32F10X_CL */

  }

  // don't set interrupt mask on custom driver installation
  if( mode != 2 ) {
 8007c26:	2c02      	cmp	r4, #2
 8007c28:	d006      	beq.n	8007c38 <MIOS32_USB_Init+0xf4>
#ifdef STM32F10X_CL
    OTGD_FS_EnableGlobalInt();
#else
    // clear pending interrupts (again)
    _SetISTR(0);
 8007c2a:	4b16      	ldr	r3, [pc, #88]	; (8007c84 <MIOS32_USB_Init+0x140>)
 8007c2c:	2200      	movs	r2, #0
 8007c2e:	601a      	str	r2, [r3, #0]

    // set interrupts mask
    _SetCNTR(IMR_MSK); // Interrupt mask
 8007c30:	f502 4204 	add.w	r2, r2, #33792	; 0x8400
 8007c34:	3b04      	subs	r3, #4
 8007c36:	601a      	str	r2, [r3, #0]
#endif
  }

  bDeviceState = UNCONNECTED;
 8007c38:	4b13      	ldr	r3, [pc, #76]	; (8007c88 <MIOS32_USB_Init+0x144>)
 8007c3a:	2400      	movs	r4, #0
 8007c3c:	601c      	str	r4, [r3, #0]
#ifdef STM32F10X_CL
  // Enable the USB interrupts
  MIOS32_IRQ_Install(OTG_FS_IRQn, MIOS32_IRQ_USB_PRIORITY);
#else
  // enable USB interrupts (unfortunately shared with CAN Rx0, as either CAN or USB can be used, but not at the same time)
  MIOS32_IRQ_Install(USB_LP_CAN1_RX0_IRQn, MIOS32_IRQ_USB_PRIORITY);
 8007c3e:	2014      	movs	r0, #20
 8007c40:	2108      	movs	r1, #8
 8007c42:	f7fe fd17 	bl	8006674 <MIOS32_IRQ_Install>
#endif

  return 0; // no error
 8007c46:	4620      	mov	r0, r4
}
 8007c48:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8007c4a:	bf00      	nop
 8007c4c:	40005c40 	.word	0x40005c40
 8007c50:	2000089c 	.word	0x2000089c
 8007c54:	20003794 	.word	0x20003794
 8007c58:	20003798 	.word	0x20003798
 8007c5c:	0800afa8 	.word	0x0800afa8
 8007c60:	2000378c 	.word	0x2000378c
 8007c64:	0800af70 	.word	0x0800af70
 8007c68:	20003790 	.word	0x20003790
 8007c6c:	08007f89 	.word	0x08007f89
 8007c70:	2000000c 	.word	0x2000000c
 8007c74:	08007f9d 	.word	0x08007f9d
 8007c78:	20000028 	.word	0x20000028
 8007c7c:	40010800 	.word	0x40010800
 8007c80:	00030d40 	.word	0x00030d40
 8007c84:	40005c44 	.word	0x40005c44
 8007c88:	20000898 	.word	0x20000898

08007c8c <MIOS32_USB_MIDI_RxBufferHandler>:

/////////////////////////////////////////////////////////////////////////////
// This handler receives new packages if the Tx buffer is not full
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_RxBufferHandler(void)
{
 8007c8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  s16 count;

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 8007c8e:	f7fe fcc9 	bl	8006624 <MIOS32_IRQ_Disable>

      OTGD_FS_EPStartXfer(ep);
    }
  }
#else
  if( rx_buffer_new_data && (count=GetEPRxCount(ENDP1)>>2) ) {
 8007c92:	4b23      	ldr	r3, [pc, #140]	; (8007d20 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 8007c94:	781b      	ldrb	r3, [r3, #0]
 8007c96:	2b00      	cmp	r3, #0
 8007c98:	d03f      	beq.n	8007d1a <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007c9a:	2001      	movs	r0, #1
 8007c9c:	f002 fa8e 	bl	800a1bc <GetEPRxCount>
 8007ca0:	f3c0 058f 	ubfx	r5, r0, #2, #16
 8007ca4:	2d00      	cmp	r5, #0
 8007ca6:	d038      	beq.n	8007d1a <MIOS32_USB_MIDI_RxBufferHandler+0x8e>

    // check if buffer is free
    if( count < (MIOS32_USB_MIDI_RX_BUFFER_SIZE-rx_buffer_size) ) {
 8007ca8:	4b1e      	ldr	r3, [pc, #120]	; (8007d24 <MIOS32_USB_MIDI_RxBufferHandler+0x98>)
 8007caa:	b229      	sxth	r1, r5
 8007cac:	881a      	ldrh	r2, [r3, #0]
 8007cae:	b292      	uxth	r2, r2
 8007cb0:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
 8007cb4:	4291      	cmp	r1, r2
 8007cb6:	da30      	bge.n	8007d1a <MIOS32_USB_MIDI_RxBufferHandler+0x8e>
 8007cb8:	4e1b      	ldr	r6, [pc, #108]	; (8007d28 <MIOS32_USB_MIDI_RxBufferHandler+0x9c>)
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007cba:	4c1c      	ldr	r4, [pc, #112]	; (8007d2c <MIOS32_USB_MIDI_RxBufferHandler+0xa0>)
 8007cbc:	4a1c      	ldr	r2, [pc, #112]	; (8007d30 <MIOS32_USB_MIDI_RxBufferHandler+0xa4>)
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007cbe:	f836 1c08 	ldrh.w	r1, [r6, #-8]
 8007cc2:	f836 7c04 	ldrh.w	r7, [r6, #-4]

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8007cc6:	9201      	str	r2, [sp, #4]
      // this operation should be atomic
      do {
	u16 pl = *pma_addr++;
	u16 ph = *pma_addr++;
	mios32_midi_package_t package;
	package.ALL = (ph << 16) | pl;
 8007cc8:	ea41 4707 	orr.w	r7, r1, r7, lsl #16

	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8007ccc:	f3c7 1003 	ubfx	r0, r7, #4, #4
 8007cd0:	3010      	adds	r0, #16
 8007cd2:	4639      	mov	r1, r7
 8007cd4:	9300      	str	r3, [sp, #0]
 8007cd6:	f7fe f911 	bl	8005efc <MIOS32_MIDI_SendPackageToRxCallback>
 8007cda:	9a01      	ldr	r2, [sp, #4]
 8007cdc:	9b00      	ldr	r3, [sp, #0]
 8007cde:	b980      	cbnz	r0, 8007d02 <MIOS32_USB_MIDI_RxBufferHandler+0x76>
	  rx_buffer[rx_buffer_head] = package.ALL;
 8007ce0:	8821      	ldrh	r1, [r4, #0]
 8007ce2:	b289      	uxth	r1, r1
 8007ce4:	f842 7021 	str.w	r7, [r2, r1, lsl #2]

	  if( ++rx_buffer_head >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8007ce8:	8821      	ldrh	r1, [r4, #0]
 8007cea:	3101      	adds	r1, #1
 8007cec:	b289      	uxth	r1, r1
 8007cee:	8021      	strh	r1, [r4, #0]
 8007cf0:	8821      	ldrh	r1, [r4, #0]
 8007cf2:	b289      	uxth	r1, r1
 8007cf4:	293f      	cmp	r1, #63	; 0x3f
	    rx_buffer_head = 0;
 8007cf6:	bf88      	it	hi
 8007cf8:	8020      	strhhi	r0, [r4, #0]
	  ++rx_buffer_size;
 8007cfa:	8819      	ldrh	r1, [r3, #0]
 8007cfc:	3101      	adds	r1, #1
 8007cfe:	b289      	uxth	r1, r1
 8007d00:	8019      	strh	r1, [r3, #0]
	}
      } while( --count > 0 );
 8007d02:	3d01      	subs	r5, #1
 8007d04:	b2ad      	uxth	r5, r5
 8007d06:	b229      	sxth	r1, r5
 8007d08:	3608      	adds	r6, #8
 8007d0a:	2900      	cmp	r1, #0
 8007d0c:	dcd7      	bgt.n	8007cbe <MIOS32_USB_MIDI_RxBufferHandler+0x32>

      // notify, that data has been put into buffer
      rx_buffer_new_data = 0;
 8007d0e:	4b04      	ldr	r3, [pc, #16]	; (8007d20 <MIOS32_USB_MIDI_RxBufferHandler+0x94>)
 8007d10:	2200      	movs	r2, #0
 8007d12:	701a      	strb	r2, [r3, #0]

      // release OUT pipe
      SetEPRxValid(ENDP1);
 8007d14:	2001      	movs	r0, #1
 8007d16:	f002 f99d 	bl	800a054 <SetEPRxValid>
    }
  }
#endif
  MIOS32_IRQ_Enable();
 8007d1a:	f7fe fc99 	bl	8006650 <MIOS32_IRQ_Enable>
}
 8007d1e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007d20:	20000ac0 	.word	0x20000ac0
 8007d24:	200008b8 	.word	0x200008b8
 8007d28:	40006208 	.word	0x40006208
 8007d2c:	20000ac2 	.word	0x20000ac2
 8007d30:	200009c0 	.word	0x200009c0

08007d34 <MIOS32_USB_MIDI_TxBufferHandler>:
/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
{
 8007d34:	b510      	push	{r4, lr}
  //   - last transfer finished
  //   - new packages are in the buffer
  //   - the device is configured

  // atomic operation to avoid conflict with other interrupts
  MIOS32_IRQ_Disable();
 8007d36:	f7fe fc75 	bl	8006624 <MIOS32_IRQ_Disable>
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
	tx_buffer_tail = 0;
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
 8007d3a:	4b2c      	ldr	r3, [pc, #176]	; (8007dec <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
 8007d3c:	781b      	ldrb	r3, [r3, #0]
 8007d3e:	2b00      	cmp	r3, #0
 8007d40:	d150      	bne.n	8007de4 <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 8007d42:	4b2b      	ldr	r3, [pc, #172]	; (8007df0 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)
 8007d44:	881a      	ldrh	r2, [r3, #0]
 8007d46:	b292      	uxth	r2, r2
 8007d48:	2a00      	cmp	r2, #0
 8007d4a:	d04b      	beq.n	8007de4 <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
 8007d4c:	4a29      	ldr	r2, [pc, #164]	; (8007df4 <MIOS32_USB_MIDI_TxBufferHandler+0xc0>)
 8007d4e:	7812      	ldrb	r2, [r2, #0]
 8007d50:	2a00      	cmp	r2, #0
 8007d52:	d047      	beq.n	8007de4 <MIOS32_USB_MIDI_TxBufferHandler+0xb0>
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8007d54:	881a      	ldrh	r2, [r3, #0]
 8007d56:	b292      	uxth	r2, r2
 8007d58:	2a10      	cmp	r2, #16
 8007d5a:	bf98      	it	ls
 8007d5c:	881c      	ldrhls	r4, [r3, #0]

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007d5e:	4b23      	ldr	r3, [pc, #140]	; (8007dec <MIOS32_USB_MIDI_TxBufferHandler+0xb8>)
    } while( --count );
  }
#else
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8007d60:	bf94      	ite	ls
 8007d62:	b2a4      	uxthls	r4, r4
 8007d64:	2410      	movhi	r4, #16

    // notify that new package is sent
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007d66:	b2a4      	uxth	r4, r4
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007d68:	2001      	movs	r0, #1

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007d6a:	00a1      	lsls	r1, r4, #2
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
    u32 *pma_addr = (u32 *)(PMAAddr + (MIOS32_USB_ENDP1_TXADDR<<1));
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;

    // notify that new package is sent
    tx_buffer_busy = 1;
 8007d6c:	7018      	strb	r0, [r3, #0]

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);
 8007d6e:	b289      	uxth	r1, r1
 8007d70:	f002 f9f6 	bl	800a160 <SetEPTxCount>

    tx_buffer_size -= count;
 8007d74:	4b1e      	ldr	r3, [pc, #120]	; (8007df0 <MIOS32_USB_MIDI_TxBufferHandler+0xbc>)

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007d76:	4920      	ldr	r1, [pc, #128]	; (8007df8 <MIOS32_USB_MIDI_TxBufferHandler+0xc4>)
    tx_buffer_busy = 1;

    // send to IN pipe
    SetEPTxCount(ENDP1, 4*count);

    tx_buffer_size -= count;
 8007d78:	881a      	ldrh	r2, [r3, #0]
 8007d7a:	1b12      	subs	r2, r2, r4
 8007d7c:	b292      	uxth	r2, r2
 8007d7e:	801a      	strh	r2, [r3, #0]

/////////////////////////////////////////////////////////////////////////////
// This handler sends the new packages through the IN pipe if the buffer 
// is not empty
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_USB_MIDI_TxBufferHandler(void)
 8007d80:	3c01      	subs	r4, #1
 8007d82:	4b1e      	ldr	r3, [pc, #120]	; (8007dfc <MIOS32_USB_MIDI_TxBufferHandler+0xc8>)
 8007d84:	b2a4      	uxth	r4, r4
 8007d86:	18e3      	adds	r3, r4, r3
 8007d88:	00d8      	lsls	r0, r3, #3
 8007d8a:	4a1d      	ldr	r2, [pc, #116]	; (8007e00 <MIOS32_USB_MIDI_TxBufferHandler+0xcc>)

    tx_buffer_size -= count;

    // copy into PMA buffer (16bit word with, only 32bit addressable)
    do {
      *pma_addr++ = tx_buffer[tx_buffer_tail] & 0xffff;
 8007d8c:	4b1d      	ldr	r3, [pc, #116]	; (8007e04 <MIOS32_USB_MIDI_TxBufferHandler+0xd0>)
 8007d8e:	f8b3 c000 	ldrh.w	ip, [r3]
 8007d92:	fa1f fc8c 	uxth.w	ip, ip
 8007d96:	f831 c02c 	ldrh.w	ip, [r1, ip, lsl #2]
 8007d9a:	f842 cc08 	str.w	ip, [r2, #-8]
      *pma_addr++ = (tx_buffer[tx_buffer_tail]>>16) & 0xffff;
 8007d9e:	f8b3 c000 	ldrh.w	ip, [r3]
 8007da2:	fa1f fc8c 	uxth.w	ip, ip
 8007da6:	f851 c02c 	ldr.w	ip, [r1, ip, lsl #2]
 8007daa:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8007dae:	f842 cc04 	str.w	ip, [r2, #-4]
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007db2:	f8b3 c000 	ldrh.w	ip, [r3]
 8007db6:	f10c 0c01 	add.w	ip, ip, #1
 8007dba:	fa1f fc8c 	uxth.w	ip, ip
 8007dbe:	f8a3 c000 	strh.w	ip, [r3]
 8007dc2:	f8b3 c000 	ldrh.w	ip, [r3]
 8007dc6:	fa1f fc8c 	uxth.w	ip, ip
 8007dca:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
	tx_buffer_tail = 0;
 8007dce:	bf84      	itt	hi
 8007dd0:	f04f 0c00 	movhi.w	ip, #0
 8007dd4:	f8a3 c000 	strhhi.w	ip, [r3]
 8007dd8:	3208      	adds	r2, #8
    } while( --count );
 8007dda:	4282      	cmp	r2, r0
 8007ddc:	d1d7      	bne.n	8007d8e <MIOS32_USB_MIDI_TxBufferHandler+0x5a>

    // send buffer
    SetEPTxValid(ENDP1);
 8007dde:	2001      	movs	r0, #1
 8007de0:	f002 f926 	bl	800a030 <SetEPTxValid>
  }
#endif
  MIOS32_IRQ_Enable();
 8007de4:	f7fe fc34 	bl	8006650 <MIOS32_IRQ_Enable>
}
 8007de8:	bd10      	pop	{r4, pc}
 8007dea:	bf00      	nop
 8007dec:	200009bc 	.word	0x200009bc
 8007df0:	20000ac4 	.word	0x20000ac4
 8007df4:	20000aca 	.word	0x20000aca
 8007df8:	200008bc 	.word	0x200008bc
 8007dfc:	08000c32 	.word	0x08000c32
 8007e00:	40006188 	.word	0x40006188
 8007e04:	20000ac6 	.word	0x20000ac6

08007e08 <MIOS32_USB_MIDI_Init>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 8007e08:	2800      	cmp	r0, #0
 8007e0a:	bf14      	ite	ne
 8007e0c:	f04f 30ff 	movne.w	r0, #4294967295
 8007e10:	2000      	moveq	r0, #0

  return 0; // no error
}
 8007e12:	4770      	bx	lr

08007e14 <MIOS32_USB_MIDI_ChangeConnectionState>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_ChangeConnectionState(u8 connected)
{
  // in all cases: re-initialize USB MIDI driver
  // clear buffer counters and busy/wait signals again (e.g., so that no invalid data will be sent out)
  rx_buffer_tail = rx_buffer_head = rx_buffer_size = 0;
 8007e14:	4a10      	ldr	r2, [pc, #64]	; (8007e58 <MIOS32_USB_MIDI_ChangeConnectionState+0x44>)
 8007e16:	2300      	movs	r3, #0
 8007e18:	8013      	strh	r3, [r2, #0]
 8007e1a:	8811      	ldrh	r1, [r2, #0]
 8007e1c:	4a0f      	ldr	r2, [pc, #60]	; (8007e5c <MIOS32_USB_MIDI_ChangeConnectionState+0x48>)
 8007e1e:	b289      	uxth	r1, r1
 8007e20:	8011      	strh	r1, [r2, #0]
 8007e22:	8811      	ldrh	r1, [r2, #0]
 8007e24:	4a0e      	ldr	r2, [pc, #56]	; (8007e60 <MIOS32_USB_MIDI_ChangeConnectionState+0x4c>)
 8007e26:	b289      	uxth	r1, r1
 8007e28:	8011      	strh	r1, [r2, #0]
  rx_buffer_new_data = 0; // no data received yet
 8007e2a:	4a0e      	ldr	r2, [pc, #56]	; (8007e64 <MIOS32_USB_MIDI_ChangeConnectionState+0x50>)
 8007e2c:	7013      	strb	r3, [r2, #0]
  tx_buffer_tail = tx_buffer_head = tx_buffer_size = 0;
 8007e2e:	4a0e      	ldr	r2, [pc, #56]	; (8007e68 <MIOS32_USB_MIDI_ChangeConnectionState+0x54>)
 8007e30:	8013      	strh	r3, [r2, #0]
 8007e32:	8811      	ldrh	r1, [r2, #0]
 8007e34:	4a0d      	ldr	r2, [pc, #52]	; (8007e6c <MIOS32_USB_MIDI_ChangeConnectionState+0x58>)
 8007e36:	b289      	uxth	r1, r1
 8007e38:	8011      	strh	r1, [r2, #0]
 8007e3a:	8811      	ldrh	r1, [r2, #0]
 8007e3c:	4a0c      	ldr	r2, [pc, #48]	; (8007e70 <MIOS32_USB_MIDI_ChangeConnectionState+0x5c>)
 8007e3e:	b289      	uxth	r1, r1
 8007e40:	8011      	strh	r1, [r2, #0]
 8007e42:	490c      	ldr	r1, [pc, #48]	; (8007e74 <MIOS32_USB_MIDI_ChangeConnectionState+0x60>)
 8007e44:	4a0c      	ldr	r2, [pc, #48]	; (8007e78 <MIOS32_USB_MIDI_ChangeConnectionState+0x64>)

  if( connected ) {
 8007e46:	b110      	cbz	r0, 8007e4e <MIOS32_USB_MIDI_ChangeConnectionState+0x3a>
    transfer_possible = 1;
 8007e48:	2001      	movs	r0, #1
 8007e4a:	7008      	strb	r0, [r1, #0]
 8007e4c:	e001      	b.n	8007e52 <MIOS32_USB_MIDI_ChangeConnectionState+0x3e>
    tx_buffer_busy = 0; // buffer not busy anymore
  } else {
    // cable disconnected: disable transfers
    transfer_possible = 0;
 8007e4e:	700b      	strb	r3, [r1, #0]
    tx_buffer_busy = 1; // buffer busy
 8007e50:	2301      	movs	r3, #1
 8007e52:	7013      	strb	r3, [r2, #0]
  }

  return 0; // no error
}
 8007e54:	2000      	movs	r0, #0
 8007e56:	4770      	bx	lr
 8007e58:	200008b8 	.word	0x200008b8
 8007e5c:	20000ac2 	.word	0x20000ac2
 8007e60:	200008ba 	.word	0x200008ba
 8007e64:	20000ac0 	.word	0x20000ac0
 8007e68:	20000ac4 	.word	0x20000ac4
 8007e6c:	20000acc 	.word	0x20000acc
 8007e70:	20000ac6 	.word	0x20000ac6
 8007e74:	20000aca 	.word	0x20000aca
 8007e78:	200009bc 	.word	0x200009bc

08007e7c <MIOS32_USB_MIDI_PackageSend_NonBlocking>:
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007e7c:	b538      	push	{r3, r4, r5, lr}
  // device available?
  if( !transfer_possible )
 8007e7e:	4d17      	ldr	r5, [pc, #92]	; (8007edc <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x60>)
//! \return -2: buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
 8007e80:	4604      	mov	r4, r0
  // device available?
  if( !transfer_possible )
 8007e82:	782b      	ldrb	r3, [r5, #0]
    return -1;
 8007e84:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend_NonBlocking(mios32_midi_package_t package)
{
  // device available?
  if( !transfer_possible )
 8007e88:	b33b      	cbz	r3, 8007eda <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    return -1;

  // buffer full?
  if( tx_buffer_size >= (MIOS32_USB_MIDI_TX_BUFFER_SIZE-1) ) {
 8007e8a:	4b15      	ldr	r3, [pc, #84]	; (8007ee0 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007e8c:	881b      	ldrh	r3, [r3, #0]
 8007e8e:	b29b      	uxth	r3, r3
 8007e90:	2b3e      	cmp	r3, #62	; 0x3e
 8007e92:	d909      	bls.n	8007ea8 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x2c>
    // call USB handler, so that we are able to get the buffer free again on next execution
    // (this call simplifies polling loops!)
    MIOS32_USB_MIDI_TxBufferHandler();
 8007e94:	f7ff ff4e 	bl	8007d34 <MIOS32_USB_MIDI_TxBufferHandler>

    // device still available?
    // (ensures that polling loop terminates if cable has been disconnected)
    if( !transfer_possible )
 8007e98:	782b      	ldrb	r3, [r5, #0]
 8007e9a:	2b00      	cmp	r3, #0
      return -1;
 8007e9c:	bf14      	ite	ne
 8007e9e:	f06f 0001 	mvnne.w	r0, #1
 8007ea2:	f04f 30ff 	moveq.w	r0, #4294967295
 8007ea6:	e018      	b.n	8007eda <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x5e>
    // notify that buffer was full (request retry)
    return -2;
  }

  // put package into buffer - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007ea8:	f7fe fbbc 	bl	8006624 <MIOS32_IRQ_Disable>
  tx_buffer[tx_buffer_head++] = package.ALL;
 8007eac:	4b0d      	ldr	r3, [pc, #52]	; (8007ee4 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x68>)
 8007eae:	490e      	ldr	r1, [pc, #56]	; (8007ee8 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x6c>)
 8007eb0:	881a      	ldrh	r2, [r3, #0]
 8007eb2:	b292      	uxth	r2, r2
 8007eb4:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
 8007eb8:	3201      	adds	r2, #1
 8007eba:	b292      	uxth	r2, r2
 8007ebc:	801a      	strh	r2, [r3, #0]
  if( tx_buffer_head >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8007ebe:	881a      	ldrh	r2, [r3, #0]
 8007ec0:	b292      	uxth	r2, r2
 8007ec2:	2a3f      	cmp	r2, #63	; 0x3f
 8007ec4:	d901      	bls.n	8007eca <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x4e>
    tx_buffer_head = 0;
 8007ec6:	2200      	movs	r2, #0
 8007ec8:	801a      	strh	r2, [r3, #0]
  ++tx_buffer_size;
 8007eca:	4b05      	ldr	r3, [pc, #20]	; (8007ee0 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8007ecc:	881a      	ldrh	r2, [r3, #0]
 8007ece:	3201      	adds	r2, #1
 8007ed0:	b292      	uxth	r2, r2
 8007ed2:	801a      	strh	r2, [r3, #0]
  MIOS32_IRQ_Enable();
 8007ed4:	f7fe fbbc 	bl	8006650 <MIOS32_IRQ_Enable>

  return 0;
 8007ed8:	2000      	movs	r0, #0
}
 8007eda:	bd38      	pop	{r3, r4, r5, pc}
 8007edc:	20000aca 	.word	0x20000aca
 8007ee0:	20000ac4 	.word	0x20000ac4
 8007ee4:	20000acc 	.word	0x20000acc
 8007ee8:	200008bc 	.word	0x200008bc

08007eec <MIOS32_USB_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: USB not connected
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageSend(mios32_midi_package_t package)
{
 8007eec:	b570      	push	{r4, r5, r6, lr}
 8007eee:	4606      	mov	r6, r0
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
    if( timeout_ctr >= 10000 )
 8007ef0:	4c0a      	ldr	r4, [pc, #40]	; (8007f1c <MIOS32_USB_MIDI_PackageSend+0x30>)
 8007ef2:	f242 750f 	movw	r5, #9999	; 0x270f
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8007ef6:	e004      	b.n	8007f02 <MIOS32_USB_MIDI_PackageSend+0x16>
    if( timeout_ctr >= 10000 )
 8007ef8:	8823      	ldrh	r3, [r4, #0]
 8007efa:	42ab      	cmp	r3, r5
 8007efc:	d80c      	bhi.n	8007f18 <MIOS32_USB_MIDI_PackageSend+0x2c>
      break;
    ++timeout_ctr;
 8007efe:	3301      	adds	r3, #1
 8007f00:	8023      	strh	r3, [r4, #0]
  // was successfull (MIDI port will be used by host), timeout value is
  // reset again

  s32 error;

  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8007f02:	4630      	mov	r0, r6
 8007f04:	f7ff ffba 	bl	8007e7c <MIOS32_USB_MIDI_PackageSend_NonBlocking>
 8007f08:	f110 0f02 	cmn.w	r0, #2
 8007f0c:	d0f4      	beq.n	8007ef8 <MIOS32_USB_MIDI_PackageSend+0xc>
    if( timeout_ctr >= 10000 )
      break;
    ++timeout_ctr;
  }

  if( error >= 0 ) // no error: reset timeout counter
 8007f0e:	2800      	cmp	r0, #0
 8007f10:	db02      	blt.n	8007f18 <MIOS32_USB_MIDI_PackageSend+0x2c>
    timeout_ctr = 0;
 8007f12:	4b02      	ldr	r3, [pc, #8]	; (8007f1c <MIOS32_USB_MIDI_PackageSend+0x30>)
 8007f14:	2200      	movs	r2, #0
 8007f16:	801a      	strh	r2, [r3, #0]

  return error;
}
 8007f18:	bd70      	pop	{r4, r5, r6, pc}
 8007f1a:	bf00      	nop
 8007f1c:	20000ac8 	.word	0x20000ac8

08007f20 <MIOS32_USB_MIDI_PackageReceive>:
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8007f20:	4b12      	ldr	r3, [pc, #72]	; (8007f6c <MIOS32_USB_MIDI_PackageReceive+0x4c>)
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 8007f22:	b510      	push	{r4, lr}
  // package received?
  if( !rx_buffer_size )
 8007f24:	881b      	ldrh	r3, [r3, #0]
//! \return -1 if no package in buffer
//! \return >= 0: number of packages which are still in the buffer
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
 8007f26:	4604      	mov	r4, r0
  // package received?
  if( !rx_buffer_size )
 8007f28:	b29b      	uxth	r3, r3
    return -1;
 8007f2a:	f04f 30ff 	mov.w	r0, #4294967295
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_PackageReceive(mios32_midi_package_t *package)
{
  // package received?
  if( !rx_buffer_size )
 8007f2e:	b1db      	cbz	r3, 8007f68 <MIOS32_USB_MIDI_PackageReceive+0x48>
    return -1;

  // get package - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8007f30:	f7fe fb78 	bl	8006624 <MIOS32_IRQ_Disable>
  package->ALL = rx_buffer[rx_buffer_tail];
 8007f34:	4b0e      	ldr	r3, [pc, #56]	; (8007f70 <MIOS32_USB_MIDI_PackageReceive+0x50>)
 8007f36:	4a0f      	ldr	r2, [pc, #60]	; (8007f74 <MIOS32_USB_MIDI_PackageReceive+0x54>)
 8007f38:	8819      	ldrh	r1, [r3, #0]
 8007f3a:	b289      	uxth	r1, r1
 8007f3c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8007f40:	6022      	str	r2, [r4, #0]
  if( ++rx_buffer_tail >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8007f42:	881a      	ldrh	r2, [r3, #0]
 8007f44:	3201      	adds	r2, #1
 8007f46:	b292      	uxth	r2, r2
 8007f48:	801a      	strh	r2, [r3, #0]
 8007f4a:	881a      	ldrh	r2, [r3, #0]
 8007f4c:	b292      	uxth	r2, r2
 8007f4e:	2a3f      	cmp	r2, #63	; 0x3f
 8007f50:	d901      	bls.n	8007f56 <MIOS32_USB_MIDI_PackageReceive+0x36>
    rx_buffer_tail = 0;
 8007f52:	2200      	movs	r2, #0
 8007f54:	801a      	strh	r2, [r3, #0]
  --rx_buffer_size;
 8007f56:	4c05      	ldr	r4, [pc, #20]	; (8007f6c <MIOS32_USB_MIDI_PackageReceive+0x4c>)
 8007f58:	8823      	ldrh	r3, [r4, #0]
 8007f5a:	3b01      	subs	r3, #1
 8007f5c:	b29b      	uxth	r3, r3
 8007f5e:	8023      	strh	r3, [r4, #0]
  MIOS32_IRQ_Enable();
 8007f60:	f7fe fb76 	bl	8006650 <MIOS32_IRQ_Enable>

  return rx_buffer_size;
 8007f64:	8820      	ldrh	r0, [r4, #0]
 8007f66:	b280      	uxth	r0, r0
}
 8007f68:	bd10      	pop	{r4, pc}
 8007f6a:	bf00      	nop
 8007f6c:	200008b8 	.word	0x200008b8
 8007f70:	200008ba 	.word	0x200008ba
 8007f74:	200009c0 	.word	0x200009c0

08007f78 <MIOS32_USB_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_MIDI_Periodic_mS(void)
{
 8007f78:	b508      	push	{r3, lr}
  // check for received packages
  MIOS32_USB_MIDI_RxBufferHandler();
 8007f7a:	f7ff fe87 	bl	8007c8c <MIOS32_USB_MIDI_RxBufferHandler>

  // check for packages which should be transmitted
  MIOS32_USB_MIDI_TxBufferHandler();
 8007f7e:	f7ff fed9 	bl	8007d34 <MIOS32_USB_MIDI_TxBufferHandler>

  return 0;
}
 8007f82:	2000      	movs	r0, #0
 8007f84:	bd08      	pop	{r3, pc}
	...

08007f88 <MIOS32_USB_MIDI_EP1_IN_Callback>:
//! Called by STM32 USB driver to check for IN streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_IN_Callback(u8 bEP, u8 bEPStatus)
{
 8007f88:	b508      	push	{r3, lr}
  // package has been sent
  tx_buffer_busy = 0;
 8007f8a:	4b03      	ldr	r3, [pc, #12]	; (8007f98 <MIOS32_USB_MIDI_EP1_IN_Callback+0x10>)
 8007f8c:	2200      	movs	r2, #0
 8007f8e:	701a      	strb	r2, [r3, #0]
  
  // check for next package
  MIOS32_USB_MIDI_TxBufferHandler();
 8007f90:	f7ff fed0 	bl	8007d34 <MIOS32_USB_MIDI_TxBufferHandler>
}
 8007f94:	bd08      	pop	{r3, pc}
 8007f96:	bf00      	nop
 8007f98:	200009bc 	.word	0x200009bc

08007f9c <MIOS32_USB_MIDI_EP1_OUT_Callback>:
//! Called by STM32 USB driver to check for OUT streams
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
//! \note also: bEP, bEPStatus only relevant for LPC17xx port
/////////////////////////////////////////////////////////////////////////////
void MIOS32_USB_MIDI_EP1_OUT_Callback(u8 bEP, u8 bEPStatus)
{
 8007f9c:	b508      	push	{r3, lr}
  // put package into buffer
  rx_buffer_new_data = 1;
 8007f9e:	4b03      	ldr	r3, [pc, #12]	; (8007fac <MIOS32_USB_MIDI_EP1_OUT_Callback+0x10>)
 8007fa0:	2201      	movs	r2, #1
 8007fa2:	701a      	strb	r2, [r3, #0]
  MIOS32_USB_MIDI_RxBufferHandler();
 8007fa4:	f7ff fe72 	bl	8007c8c <MIOS32_USB_MIDI_RxBufferHandler>
}
 8007fa8:	bd08      	pop	{r3, pc}
 8007faa:	bf00      	nop
 8007fac:	20000ac0 	.word	0x20000ac0

08007fb0 <MIOS32_UART_BaudrateSet>:
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 8007fb0:	b530      	push	{r4, r5, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007fb2:	2801      	cmp	r0, #1
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 8007fb4:	4604      	mov	r4, r0
 8007fb6:	b085      	sub	sp, #20
 8007fb8:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1;
 8007fba:	bf88      	it	hi
 8007fbc:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8007fc0:	d81a      	bhi.n	8007ff8 <MIOS32_UART_BaudrateSet+0x48>
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8007fc2:	f04f 0300 	mov.w	r3, #0
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 8007fc6:	a904      	add	r1, sp, #16
  if( uart >= MIOS32_UART_NUM )
    return -1;

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8007fc8:	f8ad 3004 	strh.w	r3, [sp, #4]
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8007fcc:	f8ad 3006 	strh.w	r3, [sp, #6]
  USART_InitStructure.USART_Parity = USART_Parity_No;
 8007fd0:	f8ad 3008 	strh.w	r3, [sp, #8]
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8007fd4:	f8ad 300c 	strh.w	r3, [sp, #12]
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;
 8007fd8:	f841 5d10 	str.w	r5, [r1, #-16]!
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8007fdc:	f04f 030c 	mov.w	r3, #12

  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
 8007fe0:	bf14      	ite	ne
 8007fe2:	4806      	ldrne	r0, [pc, #24]	; (8007ffc <MIOS32_UART_BaudrateSet+0x4c>)
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 8007fe4:	4806      	ldreq	r0, [pc, #24]	; (8008000 <MIOS32_UART_BaudrateSet+0x50>)
 8007fe6:	4669      	mov	r1, sp
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8007fe8:	f8ad 300a 	strh.w	r3, [sp, #10]
  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
#if MIOS32_UART_NUM >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 8007fec:	f000 fe54 	bl	8008c98 <USART_Init>
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 8007ff0:	4b04      	ldr	r3, [pc, #16]	; (8008004 <MIOS32_UART_BaudrateSet+0x54>)

  return 0;
 8007ff2:	2000      	movs	r0, #0
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 8007ff4:	f843 5024 	str.w	r5, [r3, r4, lsl #2]

  return 0;
#endif
}
 8007ff8:	b005      	add	sp, #20
 8007ffa:	bd30      	pop	{r4, r5, pc}
 8007ffc:	40013800 	.word	0x40013800
 8008000:	40004800 	.word	0x40004800
 8008004:	20000be4 	.word	0x20000be4

08008008 <MIOS32_UART_Init>:
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_Init(u32 mode)
{
 8008008:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800800a:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800800c:	f04f 30ff 	mov.w	r0, #4294967295
s32 MIOS32_UART_Init(u32 mode)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  // currently only mode 0 supported
  if( mode != 0 )
 8008010:	2c00      	cmp	r4, #0
 8008012:	f040 8086 	bne.w	8008122 <MIOS32_UART_Init+0x11a>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 8008016:	ad01      	add	r5, sp, #4
#else

  // map UART pins
  MIOS32_UART0_REMAP_FUNC;
#if MIOS32_UART_NUM >= 2
  MIOS32_UART1_REMAP_FUNC;
 8008018:	2101      	movs	r1, #1
 800801a:	4842      	ldr	r0, [pc, #264]	; (8008124 <MIOS32_UART_Init+0x11c>)
 800801c:	f000 fcea 	bl	80089f4 <GPIO_PinRemapConfig>
#if MIOS32_UART_NUM >= 3
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
 8008020:	4628      	mov	r0, r5
 8008022:	f000 fcdf 	bl	80089e4 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8008026:	2302      	movs	r3, #2
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8008028:	4629      	mov	r1, r5
  MIOS32_UART2_REMAP_FUNC;
#endif

  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800802a:	f88d 3006 	strb.w	r3, [sp, #6]

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 800802e:	261c      	movs	r6, #28
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 8008030:	f44f 7300 	mov.w	r3, #512	; 0x200
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8008034:	483c      	ldr	r0, [pc, #240]	; (8008128 <MIOS32_UART_Init+0x120>)
  // configure UART pins
  GPIO_StructInit(&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;

  // outputs as open-drain
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 8008036:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART0_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 800803a:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 800803e:	f000 fc78 	bl	8008932 <GPIO_Init>

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 8008042:	f44f 6380 	mov.w	r3, #1024	; 0x400
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 8008046:	4629      	mov	r1, r5
 8008048:	4838      	ldr	r0, [pc, #224]	; (800812c <MIOS32_UART_Init+0x124>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);

#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 800804a:	f8ad 3004 	strh.w	r3, [sp, #4]
#if MIOS32_UART1_TX_OD
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 800804e:	f88d 6007 	strb.w	r6, [sp, #7]
#else
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
#endif
  GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 8008052:	f000 fc6e 	bl	8008932 <GPIO_Init>
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8008056:	2348      	movs	r3, #72	; 0x48
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8008058:	4629      	mov	r1, r5
#endif
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800805a:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 800805e:	4832      	ldr	r0, [pc, #200]	; (8008128 <MIOS32_UART_Init+0x120>)
  GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
#endif

  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
 8008060:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8008064:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8008068:	f000 fc63 	bl	8008932 <GPIO_Init>
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 800806c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 8008070:	4629      	mov	r1, r5
 8008072:	482e      	ldr	r0, [pc, #184]	; (800812c <MIOS32_UART_Init+0x124>)
  // inputs with internal pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
  GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
#if MIOS32_UART_NUM >= 2
  GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 8008074:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_Init(MIOS32_UART1_RX_PORT, &GPIO_InitStructure);
 8008078:	f000 fc5b 	bl	8008932 <GPIO_Init>
  GPIO_Init(MIOS32_UART2_RX_PORT, &GPIO_InitStructure);
#endif

  // enable all USART clocks
  // TODO: more generic approach for different UART selections
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 800807c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8008080:	2101      	movs	r1, #1
 8008082:	f001 f925 	bl	80092d0 <RCC_APB2PeriphClockCmd>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 | RCC_APB1Periph_USART3, ENABLE);
 8008086:	f44f 20c0 	mov.w	r0, #393216	; 0x60000
 800808a:	2101      	movs	r1, #1
 800808c:	f001 f92e 	bl	80092ec <RCC_APB1PeriphClockCmd>

  // USART configuration
  MIOS32_UART_BaudrateSet(0, MIOS32_UART0_BAUDRATE);
 8008090:	f647 2112 	movw	r1, #31250	; 0x7a12
 8008094:	4620      	mov	r0, r4
 8008096:	f7ff ff8b 	bl	8007fb0 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=2
  MIOS32_UART_BaudrateSet(1, MIOS32_UART1_BAUDRATE);
 800809a:	f647 2112 	movw	r1, #31250	; 0x7a12
 800809e:	2001      	movs	r0, #1
 80080a0:	f7ff ff86 	bl	8007fb0 <MIOS32_UART_BaudrateSet>
#if MIOS32_UART_NUM >=3
  MIOS32_UART_BaudrateSet(2, MIOS32_UART2_BAUDRATE);
#endif

  // configure and enable UART interrupts
  MIOS32_IRQ_Install(MIOS32_UART0_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 80080a4:	2104      	movs	r1, #4
 80080a6:	2025      	movs	r0, #37	; 0x25
 80080a8:	f7fe fae4 	bl	8006674 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART0, USART_IT_RXNE, ENABLE);
 80080ac:	2201      	movs	r2, #1
 80080ae:	4820      	ldr	r0, [pc, #128]	; (8008130 <MIOS32_UART_Init+0x128>)
 80080b0:	f240 5125 	movw	r1, #1317	; 0x525
 80080b4:	f000 fe59 	bl	8008d6a <USART_ITConfig>

#if MIOS32_UART_NUM >= 2
  MIOS32_IRQ_Install(MIOS32_UART1_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 80080b8:	2104      	movs	r1, #4
 80080ba:	2027      	movs	r0, #39	; 0x27
 80080bc:	f7fe fada 	bl	8006674 <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART1, USART_IT_RXNE, ENABLE);
 80080c0:	481c      	ldr	r0, [pc, #112]	; (8008134 <MIOS32_UART_Init+0x12c>)
 80080c2:	f240 5125 	movw	r1, #1317	; 0x525
 80080c6:	2201      	movs	r2, #1
 80080c8:	f000 fe4f 	bl	8008d6a <USART_ITConfig>
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80080cc:	481a      	ldr	r0, [pc, #104]	; (8008138 <MIOS32_UART_Init+0x130>)
 80080ce:	491b      	ldr	r1, [pc, #108]	; (800813c <MIOS32_UART_Init+0x134>)
 80080d0:	7004      	strb	r4, [r0, #0]
 80080d2:	7803      	ldrb	r3, [r0, #0]
 80080d4:	f8df e068 	ldr.w	lr, [pc, #104]	; 8008140 <MIOS32_UART_Init+0x138>
 80080d8:	700b      	strb	r3, [r1, #0]
 80080da:	780b      	ldrb	r3, [r1, #0]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80080dc:	4a19      	ldr	r2, [pc, #100]	; (8008144 <MIOS32_UART_Init+0x13c>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80080de:	f88e 3000 	strb.w	r3, [lr]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 80080e2:	7014      	strb	r4, [r2, #0]
 80080e4:	f892 c000 	ldrb.w	ip, [r2]
 80080e8:	4b17      	ldr	r3, [pc, #92]	; (8008148 <MIOS32_UART_Init+0x140>)
 80080ea:	f883 c000 	strb.w	ip, [r3]
 80080ee:	781d      	ldrb	r5, [r3, #0]
 80080f0:	f8df c058 	ldr.w	ip, [pc, #88]	; 800814c <MIOS32_UART_Init+0x144>
 80080f4:	f88c 5000 	strb.w	r5, [ip]
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 80080f8:	7044      	strb	r4, [r0, #1]
 80080fa:	7840      	ldrb	r0, [r0, #1]
 80080fc:	7048      	strb	r0, [r1, #1]
 80080fe:	7849      	ldrb	r1, [r1, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 8008100:	480b      	ldr	r0, [pc, #44]	; (8008130 <MIOS32_UART_Init+0x128>)
#endif

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
 8008102:	f88e 1001 	strb.w	r1, [lr, #1]
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 8008106:	7054      	strb	r4, [r2, #1]
 8008108:	7852      	ldrb	r2, [r2, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 800810a:	2101      	movs	r1, #1

  // clear buffer counters
  int i;
  for(i=0; i<MIOS32_UART_NUM; ++i) {
    rx_buffer_tail[i] = rx_buffer_head[i] = rx_buffer_size[i] = 0;
    tx_buffer_tail[i] = tx_buffer_head[i] = tx_buffer_size[i] = 0;
 800810c:	705a      	strb	r2, [r3, #1]
 800810e:	785b      	ldrb	r3, [r3, #1]
 8008110:	f88c 3001 	strb.w	r3, [ip, #1]
  }

  // enable UARTs
  USART_Cmd(MIOS32_UART0, ENABLE);
 8008114:	f000 fe1c 	bl	8008d50 <USART_Cmd>
#if MIOS32_UART_NUM >= 2
  USART_Cmd(MIOS32_UART1, ENABLE);
 8008118:	4806      	ldr	r0, [pc, #24]	; (8008134 <MIOS32_UART_Init+0x12c>)
 800811a:	2101      	movs	r1, #1
 800811c:	f000 fe18 	bl	8008d50 <USART_Cmd>
#endif
#if MIOS32_UART_NUM >= 3
  USART_Cmd(MIOS32_UART2, ENABLE);
#endif

  return 0; // no error
 8008120:	4620      	mov	r0, r4
#endif
}
 8008122:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 8008124:	00140010 	.word	0x00140010
 8008128:	40010800 	.word	0x40010800
 800812c:	40011000 	.word	0x40011000
 8008130:	40013800 	.word	0x40013800
 8008134:	40004800 	.word	0x40004800
 8008138:	20000ad4 	.word	0x20000ad4
 800813c:	20000bdc 	.word	0x20000bdc
 8008140:	20000ad8 	.word	0x20000ad8
 8008144:	20000be0 	.word	0x20000be0
 8008148:	20000bec 	.word	0x20000bec
 800814c:	20000ad0 	.word	0x20000ad0

08008150 <MIOS32_UART_RxBufferGet>:
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008150:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: number of received bytes
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
 8008152:	b538      	push	{r3, r4, r5, lr}
 8008154:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 8008156:	bf88      	it	hi
 8008158:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 800815c:	d81d      	bhi.n	800819a <MIOS32_UART_RxBufferGet+0x4a>
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 800815e:	4b0f      	ldr	r3, [pc, #60]	; (800819c <MIOS32_UART_RxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 8008160:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 8008164:	5d1b      	ldrb	r3, [r3, r4]
 8008166:	b1c3      	cbz	r3, 800819a <MIOS32_UART_RxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8008168:	f7fe fa5c 	bl	8006624 <MIOS32_IRQ_Disable>
  u8 b = rx_buffer[uart][rx_buffer_tail[uart]];
 800816c:	4b0c      	ldr	r3, [pc, #48]	; (80081a0 <MIOS32_UART_RxBufferGet+0x50>)
 800816e:	490d      	ldr	r1, [pc, #52]	; (80081a4 <MIOS32_UART_RxBufferGet+0x54>)
 8008170:	5d1a      	ldrb	r2, [r3, r4]
 8008172:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 8008176:	5c8d      	ldrb	r5, [r1, r2]
  if( ++rx_buffer_tail[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8008178:	5d1a      	ldrb	r2, [r3, r4]
 800817a:	3201      	adds	r2, #1
 800817c:	b2d2      	uxtb	r2, r2
 800817e:	551a      	strb	r2, [r3, r4]
 8008180:	5d1a      	ldrb	r2, [r3, r4]
 8008182:	2a3f      	cmp	r2, #63	; 0x3f
 8008184:	d901      	bls.n	800818a <MIOS32_UART_RxBufferGet+0x3a>
    rx_buffer_tail[uart] = 0;
 8008186:	2200      	movs	r2, #0
 8008188:	551a      	strb	r2, [r3, r4]
  --rx_buffer_size[uart];
 800818a:	4b04      	ldr	r3, [pc, #16]	; (800819c <MIOS32_UART_RxBufferGet+0x4c>)
 800818c:	5d1a      	ldrb	r2, [r3, r4]
 800818e:	3a01      	subs	r2, #1
 8008190:	b2d2      	uxtb	r2, r2
 8008192:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 8008194:	f7fe fa5c 	bl	8006650 <MIOS32_IRQ_Enable>

  return b; // return received byte
 8008198:	4628      	mov	r0, r5
#endif
}
 800819a:	bd38      	pop	{r3, r4, r5, pc}
 800819c:	20000ad4 	.word	0x20000ad4
 80081a0:	20000ad8 	.word	0x20000ad8
 80081a4:	20000b5c 	.word	0x20000b5c

080081a8 <MIOS32_UART_RxBufferPut>:
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80081a8:	2801      	cmp	r0, #1
//! \return -1 if UART not available
//! \return -2 if buffer full (retry)
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
 80081aa:	b538      	push	{r3, r4, r5, lr}
 80081ac:	4604      	mov	r4, r0
 80081ae:	460d      	mov	r5, r1
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 80081b0:	bf88      	it	hi
 80081b2:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 80081b6:	d81f      	bhi.n	80081f8 <MIOS32_UART_RxBufferPut+0x50>
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 80081b8:	4b10      	ldr	r3, [pc, #64]	; (80081fc <MIOS32_UART_RxBufferPut+0x54>)
 80081ba:	5d1b      	ldrb	r3, [r3, r4]
 80081bc:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full (retry)
 80081be:	bf88      	it	hi
 80081c0:	f06f 0001 	mvnhi.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 80081c4:	d818      	bhi.n	80081f8 <MIOS32_UART_RxBufferPut+0x50>
    return -2; // buffer full (retry)

  // copy received byte into receive buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 80081c6:	f7fe fa2d 	bl	8006624 <MIOS32_IRQ_Disable>
  rx_buffer[uart][rx_buffer_head[uart]] = b;
 80081ca:	4b0d      	ldr	r3, [pc, #52]	; (8008200 <MIOS32_UART_RxBufferPut+0x58>)
 80081cc:	490d      	ldr	r1, [pc, #52]	; (8008204 <MIOS32_UART_RxBufferPut+0x5c>)
 80081ce:	5d1a      	ldrb	r2, [r3, r4]
 80081d0:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 80081d4:	548d      	strb	r5, [r1, r2]
  if( ++rx_buffer_head[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 80081d6:	5d1a      	ldrb	r2, [r3, r4]
 80081d8:	3201      	adds	r2, #1
 80081da:	b2d2      	uxtb	r2, r2
 80081dc:	551a      	strb	r2, [r3, r4]
 80081de:	5d1a      	ldrb	r2, [r3, r4]
 80081e0:	2a3f      	cmp	r2, #63	; 0x3f
 80081e2:	d901      	bls.n	80081e8 <MIOS32_UART_RxBufferPut+0x40>
    rx_buffer_head[uart] = 0;
 80081e4:	2200      	movs	r2, #0
 80081e6:	551a      	strb	r2, [r3, r4]
  ++rx_buffer_size[uart];
 80081e8:	4b04      	ldr	r3, [pc, #16]	; (80081fc <MIOS32_UART_RxBufferPut+0x54>)
 80081ea:	5d1a      	ldrb	r2, [r3, r4]
 80081ec:	3201      	adds	r2, #1
 80081ee:	b2d2      	uxtb	r2, r2
 80081f0:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 80081f2:	f7fe fa2d 	bl	8006650 <MIOS32_IRQ_Enable>

  return 0; // no error
 80081f6:	2000      	movs	r0, #0
#endif
}
 80081f8:	bd38      	pop	{r3, r4, r5, pc}
 80081fa:	bf00      	nop
 80081fc:	20000ad4 	.word	0x20000ad4
 8008200:	20000bdc 	.word	0x20000bdc
 8008204:	20000b5c 	.word	0x20000b5c

08008208 <MIOS32_UART_TxBufferGet>:
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008208:	2801      	cmp	r0, #1
//! \return -2 if no new byte available
//! \return >= 0: transmitted byte
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
 800820a:	b538      	push	{r3, r4, r5, lr}
 800820c:	4604      	mov	r4, r0
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 800820e:	bf88      	it	hi
 8008210:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008214:	d81d      	bhi.n	8008252 <MIOS32_UART_TxBufferGet+0x4a>
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 8008216:	4b0f      	ldr	r3, [pc, #60]	; (8008254 <MIOS32_UART_TxBufferGet+0x4c>)
    return -2; // nothing new in buffer
 8008218:	f06f 0001 	mvn.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 800821c:	5d1b      	ldrb	r3, [r3, r4]
 800821e:	b1c3      	cbz	r3, 8008252 <MIOS32_UART_TxBufferGet+0x4a>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8008220:	f7fe fa00 	bl	8006624 <MIOS32_IRQ_Disable>
  u8 b = tx_buffer[uart][tx_buffer_tail[uart]];
 8008224:	4b0c      	ldr	r3, [pc, #48]	; (8008258 <MIOS32_UART_TxBufferGet+0x50>)
 8008226:	490d      	ldr	r1, [pc, #52]	; (800825c <MIOS32_UART_TxBufferGet+0x54>)
 8008228:	5d1a      	ldrb	r2, [r3, r4]
 800822a:	eb02 1284 	add.w	r2, r2, r4, lsl #6
 800822e:	5c8d      	ldrb	r5, [r1, r2]
  if( ++tx_buffer_tail[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 8008230:	5d1a      	ldrb	r2, [r3, r4]
 8008232:	3201      	adds	r2, #1
 8008234:	b2d2      	uxtb	r2, r2
 8008236:	551a      	strb	r2, [r3, r4]
 8008238:	5d1a      	ldrb	r2, [r3, r4]
 800823a:	2a3f      	cmp	r2, #63	; 0x3f
 800823c:	d901      	bls.n	8008242 <MIOS32_UART_TxBufferGet+0x3a>
    tx_buffer_tail[uart] = 0;
 800823e:	2200      	movs	r2, #0
 8008240:	551a      	strb	r2, [r3, r4]
  --tx_buffer_size[uart];
 8008242:	4b04      	ldr	r3, [pc, #16]	; (8008254 <MIOS32_UART_TxBufferGet+0x4c>)
 8008244:	5d1a      	ldrb	r2, [r3, r4]
 8008246:	3a01      	subs	r2, #1
 8008248:	b2d2      	uxtb	r2, r2
 800824a:	551a      	strb	r2, [r3, r4]
  MIOS32_IRQ_Enable();
 800824c:	f7fe fa00 	bl	8006650 <MIOS32_IRQ_Enable>

  return b; // return transmitted byte
 8008250:	4628      	mov	r0, r5
#endif
}
 8008252:	bd38      	pop	{r3, r4, r5, pc}
 8008254:	20000be0 	.word	0x20000be0
 8008258:	20000ad0 	.word	0x20000ad0
 800825c:	20000adc 	.word	0x20000adc

08008260 <MIOS32_UART_TxBufferPutMore_NonBlocking>:
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 8008260:	b5f0      	push	{r4, r5, r6, r7, lr}
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008262:	2801      	cmp	r0, #1
//! \return -2 if buffer full or cannot get all requested bytes (retry)
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
 8008264:	4604      	mov	r4, r0
 8008266:	b087      	sub	sp, #28
 8008268:	460d      	mov	r5, r1
 800826a:	4617      	mov	r7, r2
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available
 800826c:	bf88      	it	hi
 800826e:	f04f 30ff 	movhi.w	r0, #4294967295
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
#if MIOS32_UART_NUM == 0
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
 8008272:	d852      	bhi.n	800831a <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 8008274:	4e2a      	ldr	r6, [pc, #168]	; (8008320 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc0>)
 8008276:	5d33      	ldrb	r3, [r6, r4]
 8008278:	18d3      	adds	r3, r2, r3
 800827a:	2b3f      	cmp	r3, #63	; 0x3f
    return -2; // buffer full or cannot get all requested bytes (retry)
 800827c:	bfc8      	it	gt
 800827e:	f06f 0001 	mvngt.w	r0, #1
  return -1; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 8008282:	dc4a      	bgt.n	800831a <MIOS32_UART_TxBufferPutMore_NonBlocking+0xba>
    return -2; // buffer full or cannot get all requested bytes (retry)

  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 8008284:	f7fe f9ce 	bl	8006624 <MIOS32_IRQ_Disable>

  u16 i;
  for(i=0; i<len; ++i) {
 8008288:	2200      	movs	r2, #0
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 800828a:	4b26      	ldr	r3, [pc, #152]	; (8008324 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc4>)

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 800828c:	4826      	ldr	r0, [pc, #152]	; (8008328 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xc8>)
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 800828e:	4927      	ldr	r1, [pc, #156]	; (800832c <MIOS32_UART_TxBufferPutMore_NonBlocking+0xcc>)
 8008290:	9701      	str	r7, [sp, #4]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 8008292:	e03c      	b.n	800830e <MIOS32_UART_TxBufferPutMore_NonBlocking+0xae>
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 8008294:	f813 c004 	ldrb.w	ip, [r3, r4]
 8008298:	f815 7b01 	ldrb.w	r7, [r5], #1
 800829c:	f8df e090 	ldr.w	lr, [pc, #144]	; 8008330 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xd0>
 80082a0:	eb0c 1c84 	add.w	ip, ip, r4, lsl #6
 80082a4:	f80e 700c 	strb.w	r7, [lr, ip]

    if( ++tx_buffer_head[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 80082a8:	f813 c004 	ldrb.w	ip, [r3, r4]
 80082ac:	f10c 0c01 	add.w	ip, ip, #1
 80082b0:	fa5f fc8c 	uxtb.w	ip, ip
 80082b4:	f803 c004 	strb.w	ip, [r3, r4]
 80082b8:	f813 c004 	ldrb.w	ip, [r3, r4]
 80082bc:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
      tx_buffer_head[uart] = 0;
 80082c0:	bf84      	itt	hi
 80082c2:	f04f 0c00 	movhi.w	ip, #0
 80082c6:	f803 c004 	strbhi.w	ip, [r3, r4]

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
 80082ca:	f816 c004 	ldrb.w	ip, [r6, r4]
 80082ce:	f10c 0c01 	add.w	ip, ip, #1
 80082d2:	fa5f fc8c 	uxtb.w	ip, ip
 80082d6:	f806 c004 	strb.w	ip, [r6, r4]
 80082da:	f816 c004 	ldrb.w	ip, [r6, r4]
 80082de:	f1bc 0f01 	cmp.w	ip, #1
 80082e2:	d112      	bne.n	800830a <MIOS32_UART_TxBufferPutMore_NonBlocking+0xaa>
      switch( uart ) {
 80082e4:	2c01      	cmp	r4, #1
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80082e6:	bf15      	itete	ne
 80082e8:	f8b1 c00c 	ldrhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80082ec:	f8b0 c00c 	ldrheq.w	ip, [r0, #12]
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80082f0:	fa1f fc8c 	uxthne.w	ip, ip
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80082f4:	fa1f fc8c 	uxtheq.w	ip, ip
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80082f8:	bf15      	itete	ne
 80082fa:	f04c 0c80 	orrne.w	ip, ip, #128	; 0x80
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 80082fe:	f04c 0c80 	orreq.w	ip, ip, #128	; 0x80
      tx_buffer_head[uart] = 0;

    // enable Tx interrupt if buffer was empty
    if( ++tx_buffer_size[uart] == 1 ) {
      switch( uart ) {
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008302:	f8a1 c00c 	strhne.w	ip, [r1, #12]
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8008306:	f8a0 c00c 	strheq.w	ip, [r0, #12]
  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();

  u16 i;
  for(i=0; i<len; ++i) {
 800830a:	3201      	adds	r2, #1
 800830c:	b292      	uxth	r2, r2
 800830e:	9f01      	ldr	r7, [sp, #4]
 8008310:	42ba      	cmp	r2, r7
 8008312:	d3bf      	bcc.n	8008294 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x34>
        default: MIOS32_IRQ_Enable(); return -3; // uart not supported by routine (yet)
      }
    }
  }

  MIOS32_IRQ_Enable();
 8008314:	f7fe f99c 	bl	8006650 <MIOS32_IRQ_Enable>

  return 0; // no error
 8008318:	2000      	movs	r0, #0
#endif
}
 800831a:	b007      	add	sp, #28
 800831c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800831e:	bf00      	nop
 8008320:	20000be0 	.word	0x20000be0
 8008324:	20000bec 	.word	0x20000bec
 8008328:	40004800 	.word	0x40004800
 800832c:	40013800 	.word	0x40013800
 8008330:	20000adc 	.word	0x20000adc

08008334 <MIOS32_UART_TxBufferPutMore>:
//! \return -1 if UART not available
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore(u8 uart, u8 *buffer, u16 len)
{
 8008334:	b570      	push	{r4, r5, r6, lr}
 8008336:	4605      	mov	r5, r0
 8008338:	460c      	mov	r4, r1
 800833a:	4616      	mov	r6, r2
  s32 error;

  while( (error=MIOS32_UART_TxBufferPutMore_NonBlocking(uart, buffer, len)) == -2 );
 800833c:	4628      	mov	r0, r5
 800833e:	4621      	mov	r1, r4
 8008340:	4632      	mov	r2, r6
 8008342:	f7ff ff8d 	bl	8008260 <MIOS32_UART_TxBufferPutMore_NonBlocking>
 8008346:	f110 0f02 	cmn.w	r0, #2
 800834a:	d0f7      	beq.n	800833c <MIOS32_UART_TxBufferPutMore+0x8>

  return error;
}
 800834c:	bd70      	pop	{r4, r5, r6, pc}
	...

08008350 <USART1_IRQHandler>:
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8008350:	4b14      	ldr	r3, [pc, #80]	; (80083a4 <USART1_IRQHandler+0x54>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
 8008352:	b510      	push	{r4, lr}
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8008354:	881a      	ldrh	r2, [r3, #0]
 8008356:	f012 0f20 	tst.w	r2, #32
 800835a:	d009      	beq.n	8008370 <USART1_IRQHandler+0x20>
    u8 b = MIOS32_UART0->DR;
 800835c:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 800835e:	2020      	movs	r0, #32
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART0->DR;
 8008360:	b2e4      	uxtb	r4, r4

#if MIOS32_UART0_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART0, b);
 8008362:	4621      	mov	r1, r4
 8008364:	f7fd fdc0 	bl	8005ee8 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(0, b) < 0 ) {
 8008368:	b910      	cbnz	r0, 8008370 <USART1_IRQHandler+0x20>
 800836a:	4621      	mov	r1, r4
 800836c:	f7ff ff1c 	bl	80081a8 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
 8008370:	4c0c      	ldr	r4, [pc, #48]	; (80083a4 <USART1_IRQHandler+0x54>)
 8008372:	8823      	ldrh	r3, [r4, #0]
 8008374:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008378:	d013      	beq.n	80083a2 <USART1_IRQHandler+0x52>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 800837a:	4b0b      	ldr	r3, [pc, #44]	; (80083a8 <USART1_IRQHandler+0x58>)
 800837c:	781b      	ldrb	r3, [r3, #0]
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
 800837e:	b153      	cbz	r3, 8008396 <USART1_IRQHandler+0x46>
      s32 b = MIOS32_UART_TxBufferGet(0);
 8008380:	2000      	movs	r0, #0
 8008382:	f7ff ff41 	bl	8008208 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 8008386:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
      } else {
	MIOS32_UART0->DR = b;
 8008388:	bfa4      	itt	ge
 800838a:	b280      	uxthge	r0, r0
 800838c:	80a0      	strhge	r0, [r4, #4]
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(0);
      if( b < 0 ) {
 800838e:	da08      	bge.n	80083a2 <USART1_IRQHandler+0x52>
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
 8008390:	23ff      	movs	r3, #255	; 0xff
 8008392:	80a3      	strh	r3, [r4, #4]
 8008394:	e005      	b.n	80083a2 <USART1_IRQHandler+0x52>
      } else {
	MIOS32_UART0->DR = b;
      }
    } else {
      MIOS32_UART0->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 8008396:	89a3      	ldrh	r3, [r4, #12]
 8008398:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800839c:	041b      	lsls	r3, r3, #16
 800839e:	0c1b      	lsrs	r3, r3, #16
 80083a0:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 80083a2:	bd10      	pop	{r4, pc}
 80083a4:	40013800 	.word	0x40013800
 80083a8:	20000be0 	.word	0x20000be0

080083ac <USART3_IRQHandler>:
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 80083ac:	4b15      	ldr	r3, [pc, #84]	; (8008404 <USART3_IRQHandler+0x58>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
 80083ae:	b510      	push	{r4, lr}
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 80083b0:	881a      	ldrh	r2, [r3, #0]
 80083b2:	f012 0f20 	tst.w	r2, #32
 80083b6:	d00a      	beq.n	80083ce <USART3_IRQHandler+0x22>
    u8 b = MIOS32_UART1->DR;
 80083b8:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 80083ba:	2021      	movs	r0, #33	; 0x21
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART1->DR;
 80083bc:	b2e4      	uxtb	r4, r4

#if MIOS32_UART1_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART1, b);
 80083be:	4621      	mov	r1, r4
 80083c0:	f7fd fd92 	bl	8005ee8 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(1, b) < 0 ) {
 80083c4:	b918      	cbnz	r0, 80083ce <USART3_IRQHandler+0x22>
 80083c6:	3001      	adds	r0, #1
 80083c8:	4621      	mov	r1, r4
 80083ca:	f7ff feed 	bl	80081a8 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
 80083ce:	4c0d      	ldr	r4, [pc, #52]	; (8008404 <USART3_IRQHandler+0x58>)
 80083d0:	8823      	ldrh	r3, [r4, #0]
 80083d2:	f013 0f80 	tst.w	r3, #128	; 0x80
 80083d6:	d013      	beq.n	8008400 <USART3_IRQHandler+0x54>
  return 0; // no UART available
#else
  if( uart >= MIOS32_UART_NUM )
    return 0;
  else
    return tx_buffer_size[uart];
 80083d8:	4b0b      	ldr	r3, [pc, #44]	; (8008408 <USART3_IRQHandler+0x5c>)
 80083da:	785b      	ldrb	r3, [r3, #1]
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
 80083dc:	b153      	cbz	r3, 80083f4 <USART3_IRQHandler+0x48>
      s32 b = MIOS32_UART_TxBufferGet(1);
 80083de:	2001      	movs	r0, #1
 80083e0:	f7ff ff12 	bl	8008208 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 80083e4:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
      } else {
	MIOS32_UART1->DR = b;
 80083e6:	bfa4      	itt	ge
 80083e8:	b280      	uxthge	r0, r0
 80083ea:	80a0      	strhge	r0, [r4, #4]
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
      s32 b = MIOS32_UART_TxBufferGet(1);
      if( b < 0 ) {
 80083ec:	da08      	bge.n	8008400 <USART3_IRQHandler+0x54>
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
 80083ee:	23ff      	movs	r3, #255	; 0xff
 80083f0:	80a3      	strh	r3, [r4, #4]
 80083f2:	e005      	b.n	8008400 <USART3_IRQHandler+0x54>
      } else {
	MIOS32_UART1->DR = b;
      }
    } else {
      MIOS32_UART1->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 80083f4:	89a3      	ldrh	r3, [r4, #12]
 80083f6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80083fa:	041b      	lsls	r3, r3, #16
 80083fc:	0c1b      	lsrs	r3, r3, #16
 80083fe:	81a3      	strh	r3, [r4, #12]
    }
  }
}
 8008400:	bd10      	pop	{r4, pc}
 8008402:	bf00      	nop
 8008404:	40004800 	.word	0x40004800
 8008408:	20000be0 	.word	0x20000be0

0800840c <USART2_IRQHandler>:
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 800840c:	4b0e      	ldr	r3, [pc, #56]	; (8008448 <USART2_IRQHandler+0x3c>)
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
 800840e:	b510      	push	{r4, lr}
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
 8008410:	881a      	ldrh	r2, [r3, #0]
 8008412:	f012 0f20 	tst.w	r2, #32
 8008416:	d00a      	beq.n	800842e <USART2_IRQHandler+0x22>
    u8 b = MIOS32_UART2->DR;
 8008418:	889c      	ldrh	r4, [r3, #4]

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 800841a:	2022      	movs	r0, #34	; 0x22
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_UART_NUM >= 2
MIOS32_UART2_IRQHANDLER_FUNC
{
  if( MIOS32_UART2->SR & (1 << 5) ) { // check if RXNE flag is set
    u8 b = MIOS32_UART2->DR;
 800841c:	b2e4      	uxtb	r4, r4

#if MIOS32_UART2_ASSIGNMENT == 1
    s32 status = MIOS32_MIDI_SendByteToRxCallback(UART2, b);
 800841e:	4621      	mov	r1, r4
 8008420:	f7fd fd62 	bl	8005ee8 <MIOS32_MIDI_SendByteToRxCallback>
#else
    s32 status = 0;
#endif

    if( status == 0 && MIOS32_UART_RxBufferPut(2, b) < 0 ) {
 8008424:	b918      	cbnz	r0, 800842e <USART2_IRQHandler+0x22>
 8008426:	3002      	adds	r0, #2
 8008428:	4621      	mov	r1, r4
 800842a:	f7ff febd 	bl	80081a8 <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART2->SR & (1 << 7) ) { // check if TXE flag is set
 800842e:	4a06      	ldr	r2, [pc, #24]	; (8008448 <USART2_IRQHandler+0x3c>)
 8008430:	8813      	ldrh	r3, [r2, #0]
 8008432:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008436:	d005      	beq.n	8008444 <USART2_IRQHandler+0x38>
	MIOS32_UART2->DR = 0xff;
      } else {
	MIOS32_UART2->DR = b;
      }
    } else {
      MIOS32_UART2->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 8008438:	8993      	ldrh	r3, [r2, #12]
 800843a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800843e:	041b      	lsls	r3, r3, #16
 8008440:	0c1b      	lsrs	r3, r3, #16
 8008442:	8193      	strh	r3, [r2, #12]
    }
  }
}
 8008444:	bd10      	pop	{r4, pc}
 8008446:	bf00      	nop
 8008448:	40004400 	.word	0x40004400

0800844c <I2C2_EV_IRQHandler>:
/////////////////////////////////////////////////////////////////////////////
// interrupt vectors
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
 800844c:	b570      	push	{r4, r5, r6, lr}
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 800844e:	4c68      	ldr	r4, [pc, #416]	; (80085f0 <I2C2_EV_IRQHandler+0x1a4>)
 8008450:	6820      	ldr	r0, [r4, #0]
 8008452:	f000 fce4 	bl	8008e1e <I2C_GetLastEvent>
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 8008456:	4b67      	ldr	r3, [pc, #412]	; (80085f4 <I2C2_EV_IRQHandler+0x1a8>)
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8008458:	4605      	mov	r5, r0
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != NULL ){
 800845a:	ea00 0303 	and.w	r3, r0, r3
 800845e:	2b00      	cmp	r3, #0
 8008460:	d033      	beq.n	80084ca <I2C2_EV_IRQHandler+0x7e>
 8008462:	68e3      	ldr	r3, [r4, #12]
 8008464:	2b00      	cmp	r3, #0
 8008466:	d030      	beq.n	80084ca <I2C2_EV_IRQHandler+0x7e>
    // get received data
    b = I2C_ReceiveData(iicx->base);
 8008468:	6820      	ldr	r0, [r4, #0]
 800846a:	f000 fccd 	bl	8008e08 <I2C_ReceiveData>

    // failsave: still place in buffer?
    if( iicx->buffer_ix < iicx->buffer_len )
 800846e:	8a62      	ldrh	r2, [r4, #18]
 8008470:	8a23      	ldrh	r3, [r4, #16]
 8008472:	b292      	uxth	r2, r2
 8008474:	b29b      	uxth	r3, r3
 8008476:	429a      	cmp	r2, r3
 8008478:	d206      	bcs.n	8008488 <I2C2_EV_IRQHandler+0x3c>
      iicx->rx_buffer_ptr[iicx->buffer_ix++] = b;
 800847a:	8a63      	ldrh	r3, [r4, #18]
 800847c:	68e2      	ldr	r2, [r4, #12]
 800847e:	b29b      	uxth	r3, r3
 8008480:	54d0      	strb	r0, [r2, r3]
 8008482:	3301      	adds	r3, #1
 8008484:	b29b      	uxth	r3, r3
 8008486:	8263      	strh	r3, [r4, #18]

    // last byte received, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8008488:	4b59      	ldr	r3, [pc, #356]	; (80085f0 <I2C2_EV_IRQHandler+0x1a4>)
 800848a:	695a      	ldr	r2, [r3, #20]
 800848c:	f012 0f02 	tst.w	r2, #2
 8008490:	d13e      	bne.n	8008510 <I2C2_EV_IRQHandler+0xc4>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    }
 
    // request NAK and stop condition before receiving last data
    if( (iicx->buffer_ix >= iicx->buffer_len-1) || (iicx->transfer_state.ABORT_IF_FIRST_BYTE_0 && iicx->buffer_ix == 1 && b == 0x00) ) {
 8008492:	8a59      	ldrh	r1, [r3, #18]
 8008494:	8a1a      	ldrh	r2, [r3, #16]
 8008496:	b289      	uxth	r1, r1
 8008498:	b292      	uxth	r2, r2
 800849a:	3a01      	subs	r2, #1
 800849c:	4291      	cmp	r1, r2
 800849e:	da0c      	bge.n	80084ba <I2C2_EV_IRQHandler+0x6e>
 80084a0:	695a      	ldr	r2, [r3, #20]
 80084a2:	f012 0f04 	tst.w	r2, #4
 80084a6:	f000 80a1 	beq.w	80085ec <I2C2_EV_IRQHandler+0x1a0>
 80084aa:	8a5b      	ldrh	r3, [r3, #18]
 80084ac:	b29b      	uxth	r3, r3
 80084ae:	2b01      	cmp	r3, #1
 80084b0:	f040 809c 	bne.w	80085ec <I2C2_EV_IRQHandler+0x1a0>
 80084b4:	2800      	cmp	r0, #0
 80084b6:	f040 8099 	bne.w	80085ec <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80084ba:	4c4d      	ldr	r4, [pc, #308]	; (80085f0 <I2C2_EV_IRQHandler+0x1a4>)
 80084bc:	2100      	movs	r1, #0
 80084be:	6820      	ldr	r0, [r4, #0]
 80084c0:	f000 fc88 	bl	8008dd4 <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80084c4:	6820      	ldr	r0, [r4, #0]
 80084c6:	2101      	movs	r1, #1
 80084c8:	e011      	b.n	80084ee <I2C2_EV_IRQHandler+0xa2>
  }

  // ADDR set, TRA flag not set (indicates transmitter/receiver mode).
  // ADDR will be cleared by a read of SR1 followed by a read of SR2 (done by I2C_GetLastEvent)
  // If transmitter mode is selected (TRA set), we go on, TXE will be catched to send the first byte
  if( (event & I2C_FLAG_ADDR) && !(event & I2C_FLAG_TRA) ){
 80084ca:	4b4b      	ldr	r3, [pc, #300]	; (80085f8 <I2C2_EV_IRQHandler+0x1ac>)
 80084cc:	ea05 0303 	and.w	r3, r5, r3
 80084d0:	b1a3      	cbz	r3, 80084fc <I2C2_EV_IRQHandler+0xb0>
 80084d2:	f415 2180 	ands.w	r1, r5, #262144	; 0x40000
 80084d6:	d111      	bne.n	80084fc <I2C2_EV_IRQHandler+0xb0>
    // address sent (receiver mode), receiving first byte - check if we already have to request NAK/Stop
    if( iicx->buffer_len == 1 ) {
 80084d8:	4c45      	ldr	r4, [pc, #276]	; (80085f0 <I2C2_EV_IRQHandler+0x1a4>)
 80084da:	8a25      	ldrh	r5, [r4, #16]
 80084dc:	b2ad      	uxth	r5, r5
 80084de:	2d01      	cmp	r5, #1
 80084e0:	f040 8084 	bne.w	80085ec <I2C2_EV_IRQHandler+0x1a0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80084e4:	6820      	ldr	r0, [r4, #0]
 80084e6:	f000 fc75 	bl	8008dd4 <I2C_AcknowledgeConfig>
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80084ea:	6820      	ldr	r0, [r4, #0]
 80084ec:	4629      	mov	r1, r5
 80084ee:	f000 fc64 	bl	8008dba <I2C_GenerateSTOP>
      iicx->transfer_state.STOP_REQUESTED = 1;
 80084f2:	6963      	ldr	r3, [r4, #20]
 80084f4:	f043 0302 	orr.w	r3, r3, #2
 80084f8:	6163      	str	r3, [r4, #20]
 80084fa:	e077      	b.n	80085ec <I2C2_EV_IRQHandler+0x1a0>

  // TxE set, will be cleared by writing DR, or after START or STOP was generated
  // This handling also applies for BTF, as TXE will alway be set if BTF is.
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  if( event & I2C_FLAG_TXE ){
 80084fc:	4a3f      	ldr	r2, [pc, #252]	; (80085fc <I2C2_EV_IRQHandler+0x1b0>)
 80084fe:	ea05 0202 	and.w	r2, r5, r2
 8008502:	2a00      	cmp	r2, #0
 8008504:	d03e      	beq.n	8008584 <I2C2_EV_IRQHandler+0x138>

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8008506:	4b3a      	ldr	r3, [pc, #232]	; (80085f0 <I2C2_EV_IRQHandler+0x1a4>)
 8008508:	695a      	ldr	r2, [r3, #20]
 800850a:	f012 0f02 	tst.w	r2, #2
 800850e:	d007      	beq.n	8008520 <I2C2_EV_IRQHandler+0xd4>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008510:	695a      	ldr	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008512:	6818      	ldr	r0, [r3, #0]
  if( event & I2C_FLAG_TXE ){

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008514:	f36f 0200 	bfc	r2, #0, #1
 8008518:	615a      	str	r2, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 800851a:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 800851e:	e02f      	b.n	8008580 <I2C2_EV_IRQHandler+0x134>
      return;
    }

    if( iicx->buffer_ix < iicx->buffer_len ) {
 8008520:	8a59      	ldrh	r1, [r3, #18]
 8008522:	8a1a      	ldrh	r2, [r3, #16]
 8008524:	b289      	uxth	r1, r1
 8008526:	b292      	uxth	r2, r2
 8008528:	4291      	cmp	r1, r2
 800852a:	d20b      	bcs.n	8008544 <I2C2_EV_IRQHandler+0xf8>
      // checking tx_buffer_ptr for NULL is a failsafe measure.
      I2C_SendData(iicx->base, (iicx->tx_buffer_ptr == NULL) ? 0 : iicx->tx_buffer_ptr[iicx->buffer_ix++]);
 800852c:	6899      	ldr	r1, [r3, #8]
 800852e:	6818      	ldr	r0, [r3, #0]
 8008530:	b129      	cbz	r1, 800853e <I2C2_EV_IRQHandler+0xf2>
 8008532:	8a5a      	ldrh	r2, [r3, #18]
 8008534:	b292      	uxth	r2, r2
 8008536:	5c89      	ldrb	r1, [r1, r2]
 8008538:	3201      	adds	r2, #1
 800853a:	b292      	uxth	r2, r2
 800853c:	825a      	strh	r2, [r3, #18]
 800853e:	f000 fc61 	bl	8008e04 <I2C_SendData>
 8008542:	e053      	b.n	80085ec <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 

    // peripheral is transfering last byte, request stop condition /
    // on write-without-stop transfer-type, request start condition instead
    if( !iicx->transfer_state.WRITE_WITHOUT_STOP )
 8008544:	695a      	ldr	r2, [r3, #20]
 8008546:	f012 0f08 	tst.w	r2, #8
 800854a:	d104      	bne.n	8008556 <I2C2_EV_IRQHandler+0x10a>
      I2C_GenerateSTOP(iicx->base, ENABLE);
 800854c:	6818      	ldr	r0, [r3, #0]
 800854e:	2101      	movs	r1, #1
 8008550:	f000 fc33 	bl	8008dba <I2C_GenerateSTOP>
 8008554:	e003      	b.n	800855e <I2C2_EV_IRQHandler+0x112>
    else
      I2C_GenerateSTART(iicx->base, ENABLE);
 8008556:	6818      	ldr	r0, [r3, #0]
 8008558:	2101      	movs	r1, #1
 800855a:	f000 fc21 	bl	8008da0 <I2C_GenerateSTART>
    iicx->transfer_state.STOP_REQUESTED = 1;
 800855e:	4b24      	ldr	r3, [pc, #144]	; (80085f0 <I2C2_EV_IRQHandler+0x1a4>)
 8008560:	695a      	ldr	r2, [r3, #20]
 8008562:	f042 0202 	orr.w	r2, r2, #2
 8008566:	615a      	str	r2, [r3, #20]

    if( iicx->buffer_len == 0 ) {
 8008568:	8a1a      	ldrh	r2, [r3, #16]
 800856a:	b292      	uxth	r2, r2
 800856c:	b92a      	cbnz	r2, 800857a <I2C2_EV_IRQHandler+0x12e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800856e:	6959      	ldr	r1, [r3, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008570:	6818      	ldr	r0, [r3, #0]
      I2C_GenerateSTART(iicx->base, ENABLE);
    iicx->transfer_state.STOP_REQUESTED = 1;

    if( iicx->buffer_len == 0 ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008572:	f362 0100 	bfi	r1, r2, #0, #1
 8008576:	6159      	str	r1, [r3, #20]
 8008578:	e012      	b.n	80085a0 <I2C2_EV_IRQHandler+0x154>
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
    } else {
      // Disable the I2C_IT_BUF interrupt after sending the last buffer data 
      // (last EV8) to not allow a new interrupt just with TxE - only BTF will generate it
      // if this is not done, BUSY will be cleared before the transfer is finished
      I2C_ITConfig(iicx->base, I2C_IT_BUF, DISABLE);
 800857a:	6818      	ldr	r0, [r3, #0]
 800857c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008580:	2200      	movs	r2, #0
 8008582:	e00f      	b.n	80085a4 <I2C2_EV_IRQHandler+0x158>
    }
  return;
  }

  // SB set, cleared by reading SR1 (done by I2C_GetLastEvent) followed by writing DR register
  if( event & I2C_FLAG_SB ){
 8008584:	4e1e      	ldr	r6, [pc, #120]	; (8008600 <I2C2_EV_IRQHandler+0x1b4>)
 8008586:	4c1a      	ldr	r4, [pc, #104]	; (80085f0 <I2C2_EV_IRQHandler+0x1a4>)
 8008588:	ea05 0606 	and.w	r6, r5, r6
 800858c:	b1a6      	cbz	r6, 80085b8 <I2C2_EV_IRQHandler+0x16c>
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
 800858e:	6963      	ldr	r3, [r4, #20]
 8008590:	f013 0f02 	tst.w	r3, #2
 8008594:	d009      	beq.n	80085aa <I2C2_EV_IRQHandler+0x15e>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8008596:	6963      	ldr	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008598:	6820      	ldr	r0, [r4, #0]
  if( event & I2C_FLAG_SB ){
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 800859a:	f362 0300 	bfi	r3, r2, #0, #1
 800859e:	6163      	str	r3, [r4, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80085a0:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 80085a4:	f000 fc23 	bl	8008dee <I2C_ITConfig>
 80085a8:	e020      	b.n	80085ec <I2C2_EV_IRQHandler+0x1a0>
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
      (iicx->iic_address & 1)
 80085aa:	7921      	ldrb	r1, [r4, #4]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
      return;
    } 
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address, 
 80085ac:	6820      	ldr	r0, [r4, #0]
 80085ae:	f001 0201 	and.w	r2, r1, #1
 80085b2:	f000 fc2c 	bl	8008e0e <I2C_Send7bitAddress>
 80085b6:	e019      	b.n	80085ec <I2C2_EV_IRQHandler+0x1a0>
  }

  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80085b8:	4632      	mov	r2, r6
 80085ba:	6820      	ldr	r0, [r4, #0]
 80085bc:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 80085c0:	f000 fc15 	bl	8008dee <I2C_ITConfig>
  // notify error
  MIOS32_IIC_unexpected_event = event;
 80085c4:	4b0f      	ldr	r3, [pc, #60]	; (8008604 <I2C2_EV_IRQHandler+0x1b8>)
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80085c6:	4631      	mov	r1, r6
  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
 80085c8:	601d      	str	r5, [r3, #0]
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
 80085ca:	f06f 0307 	mvn.w	r3, #7
 80085ce:	61a3      	str	r3, [r4, #24]
  iicx->transfer_state.BUSY = 0;
 80085d0:	6963      	ldr	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80085d2:	6820      	ldr	r0, [r4, #0]
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
  // notify error
  MIOS32_IIC_unexpected_event = event;
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
  iicx->transfer_state.BUSY = 0;
 80085d4:	f366 0300 	bfi	r3, r6, #0, #1
 80085d8:	6163      	str	r3, [r4, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80085da:	f000 fbfb 	bl	8008dd4 <I2C_AcknowledgeConfig>
  b = I2C_ReceiveData(iicx->base);
 80085de:	6820      	ldr	r0, [r4, #0]
 80085e0:	f000 fc12 	bl	8008e08 <I2C_ReceiveData>
  I2C_GenerateSTOP(iicx->base, ENABLE);
 80085e4:	6820      	ldr	r0, [r4, #0]
 80085e6:	2101      	movs	r1, #1
 80085e8:	f000 fbe7 	bl	8008dba <I2C_GenerateSTOP>
/////////////////////////////////////////////////////////////////////////////

void I2C2_EV_IRQHandler(void)
{
  EV_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 80085ec:	bd70      	pop	{r4, r5, r6, pc}
 80085ee:	bf00      	nop
 80085f0:	20000bf0 	.word	0x20000bf0
 80085f4:	10000040 	.word	0x10000040
 80085f8:	10000002 	.word	0x10000002
 80085fc:	10000080 	.word	0x10000080
 8008600:	10000001 	.word	0x10000001
 8008604:	2000379c 	.word	0x2000379c

08008608 <I2C2_ER_IRQHandler>:

void I2C2_ER_IRQHandler(void)
{
 8008608:	b538      	push	{r3, r4, r5, lr}
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 800860a:	4d1c      	ldr	r5, [pc, #112]	; (800867c <I2C2_ER_IRQHandler+0x74>)
 800860c:	6828      	ldr	r0, [r5, #0]
 800860e:	f000 fc06 	bl	8008e1e <I2C_GetLastEvent>
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 8008612:	4b1b      	ldr	r3, [pc, #108]	; (8008680 <I2C2_ER_IRQHandler+0x78>)
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8008614:	4604      	mov	r4, r0
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 8008616:	ea00 0303 	and.w	r3, r0, r3
 800861a:	b133      	cbz	r3, 800862a <I2C2_ER_IRQHandler+0x22>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_BERR);
 800861c:	6828      	ldr	r0, [r5, #0]
 800861e:	4919      	ldr	r1, [pc, #100]	; (8008684 <I2C2_ER_IRQHandler+0x7c>)
 8008620:	f000 fc05 	bl	8008e2e <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_BUS;
 8008624:	f06f 0305 	mvn.w	r3, #5
 8008628:	61ab      	str	r3, [r5, #24]
  }

  // arbitration lost
  if( event & I2C_FLAG_ARLO ) {
 800862a:	4b17      	ldr	r3, [pc, #92]	; (8008688 <I2C2_ER_IRQHandler+0x80>)
 800862c:	ea04 0303 	and.w	r3, r4, r3
 8008630:	b13b      	cbz	r3, 8008642 <I2C2_ER_IRQHandler+0x3a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_ARLO);
 8008632:	4d12      	ldr	r5, [pc, #72]	; (800867c <I2C2_ER_IRQHandler+0x74>)
 8008634:	4915      	ldr	r1, [pc, #84]	; (800868c <I2C2_ER_IRQHandler+0x84>)
 8008636:	6828      	ldr	r0, [r5, #0]
 8008638:	f000 fbf9 	bl	8008e2e <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_ARBITRATION_LOST;
 800863c:	f06f 0304 	mvn.w	r3, #4
 8008640:	61ab      	str	r3, [r5, #24]
  }

  // no acknowledge received from slave (e.g. slave not connected)
  if( event & I2C_FLAG_AF ) {
 8008642:	4b13      	ldr	r3, [pc, #76]	; (8008690 <I2C2_ER_IRQHandler+0x88>)
 8008644:	ea04 0303 	and.w	r3, r4, r3
 8008648:	b15b      	cbz	r3, 8008662 <I2C2_ER_IRQHandler+0x5a>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_AF);
 800864a:	4c0c      	ldr	r4, [pc, #48]	; (800867c <I2C2_ER_IRQHandler+0x74>)
 800864c:	4911      	ldr	r1, [pc, #68]	; (8008694 <I2C2_ER_IRQHandler+0x8c>)
 800864e:	6820      	ldr	r0, [r4, #0]
 8008650:	f000 fbed 	bl	8008e2e <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_SLAVE_NOT_CONNECTED;
 8008654:	f06f 0306 	mvn.w	r3, #6
 8008658:	61a3      	str	r3, [r4, #24]
    // send stop condition to release bus
    I2C_GenerateSTOP(iicx->base, ENABLE);
 800865a:	6820      	ldr	r0, [r4, #0]
 800865c:	2101      	movs	r1, #1
 800865e:	f000 fbac 	bl	8008dba <I2C_GenerateSTOP>
  }

  // disable interrupts
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8008662:	4c06      	ldr	r4, [pc, #24]	; (800867c <I2C2_ER_IRQHandler+0x74>)
 8008664:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8008668:	6820      	ldr	r0, [r4, #0]
 800866a:	2200      	movs	r2, #0
 800866c:	f000 fbbf 	bl	8008dee <I2C_ITConfig>

  // notify that transfer has finished (due to the error)
  iicx->transfer_state.BUSY = 0;
 8008670:	6963      	ldr	r3, [r4, #20]
 8008672:	f36f 0300 	bfc	r3, #0, #1
 8008676:	6163      	str	r3, [r4, #20]
}

void I2C2_ER_IRQHandler(void)
{
  ER_IRQHandler((iic_rec_t *)&iic_rec[0]);
}
 8008678:	bd38      	pop	{r3, r4, r5, pc}
 800867a:	bf00      	nop
 800867c:	20000bf0 	.word	0x20000bf0
 8008680:	10000100 	.word	0x10000100
 8008684:	01000100 	.word	0x01000100
 8008688:	10000200 	.word	0x10000200
 800868c:	01000200 	.word	0x01000200
 8008690:	10000400 	.word	0x10000400
 8008694:	01000400 	.word	0x01000400

08008698 <printchar>:

#include <stdarg.h>
#include <mios32.h>

static void printchar(char **str, int c)
{
 8008698:	b508      	push	{r3, lr}
  //	extern int putchar(int c);
	
	if (str) {
 800869a:	b128      	cbz	r0, 80086a8 <printchar+0x10>
		**str = c;
 800869c:	6803      	ldr	r3, [r0, #0]
 800869e:	7019      	strb	r1, [r3, #0]
		++(*str);
 80086a0:	6803      	ldr	r3, [r0, #0]
 80086a2:	3301      	adds	r3, #1
 80086a4:	6003      	str	r3, [r0, #0]
 80086a6:	e003      	b.n	80086b0 <printchar+0x18>
	}
#ifndef MIOS32_DONT_USE_COM
	else MIOS32_COM_SendChar(1, c); // (void)putchar(c);
 80086a8:	b2c9      	uxtb	r1, r1
 80086aa:	2001      	movs	r0, #1
 80086ac:	f7fd fc82 	bl	8005fb4 <MIOS32_COM_SendChar>
#endif
}
 80086b0:	bd08      	pop	{r3, pc}

080086b2 <prints>:

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 80086b2:	2a00      	cmp	r2, #0

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 80086b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80086b6:	468c      	mov	ip, r1
 80086b8:	4604      	mov	r4, r0
 80086ba:	4615      	mov	r5, r2
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 80086bc:	dd10      	ble.n	80086e0 <prints+0x2e>
 80086be:	2200      	movs	r2, #0
 80086c0:	e000      	b.n	80086c4 <prints+0x12>
		register int len = 0;
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
 80086c2:	3201      	adds	r2, #1
 80086c4:	f81c 1002 	ldrb.w	r1, [ip, r2]
 80086c8:	2900      	cmp	r1, #0
 80086ca:	d1fa      	bne.n	80086c2 <prints+0x10>
		if (len >= width) width = 0;
 80086cc:	42aa      	cmp	r2, r5
 80086ce:	bfac      	ite	ge
 80086d0:	460d      	movge	r5, r1
		else width -= len;
 80086d2:	1aad      	sublt	r5, r5, r2
		if (pad & PAD_ZERO) padchar = '0';
 80086d4:	f013 0f02 	tst.w	r3, #2
 80086d8:	bf0c      	ite	eq
 80086da:	2720      	moveq	r7, #32
 80086dc:	2730      	movne	r7, #48	; 0x30
 80086de:	e000      	b.n	80086e2 <prints+0x30>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 80086e0:	2720      	movs	r7, #32
		for (ptr = string; *ptr; ++ptr) ++len;
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
 80086e2:	f013 0601 	ands.w	r6, r3, #1
 80086e6:	d10d      	bne.n	8008704 <prints+0x52>
 80086e8:	e009      	b.n	80086fe <prints+0x4c>
		for ( ; width > 0; --width) {
			printchar (out, padchar);
 80086ea:	4620      	mov	r0, r4
 80086ec:	4639      	mov	r1, r7
 80086ee:	f8cd c004 	str.w	ip, [sp, #4]
 80086f2:	f7ff ffd1 	bl	8008698 <printchar>
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80086f6:	f8dd c004 	ldr.w	ip, [sp, #4]
			printchar (out, padchar);
			++pc;
 80086fa:	3601      	adds	r6, #1
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 80086fc:	3d01      	subs	r5, #1
 80086fe:	2d00      	cmp	r5, #0
 8008700:	dcf3      	bgt.n	80086ea <prints+0x38>
 8008702:	e000      	b.n	8008706 <prints+0x54>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
	register int pc = 0, padchar = ' ';
 8008704:	2600      	movs	r6, #0
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
 8008706:	4663      	mov	r3, ip
 8008708:	e005      	b.n	8008716 <prints+0x64>
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
 800870a:	4620      	mov	r0, r4
 800870c:	9301      	str	r3, [sp, #4]
 800870e:	f7ff ffc3 	bl	8008698 <printchar>
		++pc;
 8008712:	9b01      	ldr	r3, [sp, #4]
 8008714:	3601      	adds	r6, #1
		for ( ; width > 0; --width) {
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
 8008716:	f813 1b01 	ldrb.w	r1, [r3], #1
 800871a:	2900      	cmp	r1, #0
 800871c:	d1f5      	bne.n	800870a <prints+0x58>
 800871e:	e005      	b.n	800872c <prints+0x7a>
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
		printchar (out, padchar);
 8008720:	4620      	mov	r0, r4
 8008722:	4639      	mov	r1, r7
 8008724:	f7ff ffb8 	bl	8008698 <printchar>
		++pc;
 8008728:	3601      	adds	r6, #1
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
 800872a:	3d01      	subs	r5, #1
 800872c:	2d00      	cmp	r5, #0
 800872e:	dcf7      	bgt.n	8008720 <prints+0x6e>
		printchar (out, padchar);
		++pc;
	}

	return pc;
}
 8008730:	4630      	mov	r0, r6
 8008732:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08008734 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 8008734:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008736:	b087      	sub	sp, #28
 8008738:	4604      	mov	r4, r0
 800873a:	461d      	mov	r5, r3
 800873c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800873e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
	register unsigned int u = i;
 8008740:	4608      	mov	r0, r1

	if (i == 0) {
 8008742:	b951      	cbnz	r1, 800875a <printi+0x26>
		print_buf[0] = '0';
 8008744:	2230      	movs	r2, #48	; 0x30
 8008746:	f88d 200c 	strb.w	r2, [sp, #12]
		print_buf[1] = '\0';
 800874a:	f88d 100d 	strb.w	r1, [sp, #13]
		return prints (out, print_buf, width, pad);
 800874e:	4620      	mov	r0, r4
 8008750:	a903      	add	r1, sp, #12
 8008752:	4632      	mov	r2, r6
 8008754:	f7ff ffad 	bl	80086b2 <prints>
 8008758:	e043      	b.n	80087e2 <printi+0xae>
	}

	if (sg && b == 10 && i < 0) {
 800875a:	2a0a      	cmp	r2, #10
 800875c:	bf14      	ite	ne
 800875e:	2100      	movne	r1, #0
 8008760:	2101      	moveq	r1, #1
 8008762:	2d00      	cmp	r5, #0
 8008764:	bf0c      	ite	eq
 8008766:	2500      	moveq	r5, #0
 8008768:	f001 0501 	andne.w	r5, r1, #1
 800876c:	b12d      	cbz	r5, 800877a <printi+0x46>
 800876e:	2800      	cmp	r0, #0
 8008770:	da02      	bge.n	8008778 <printi+0x44>
		neg = 1;
		u = -i;
 8008772:	4240      	negs	r0, r0
		print_buf[1] = '\0';
		return prints (out, print_buf, width, pad);
	}

	if (sg && b == 10 && i < 0) {
		neg = 1;
 8008774:	2501      	movs	r5, #1
 8008776:	e000      	b.n	800877a <printi+0x46>

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 8008778:	2500      	movs	r5, #0
	*s = '\0';

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 800877a:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
		neg = 1;
		u = -i;
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';
 800877e:	a906      	add	r1, sp, #24
 8008780:	f04f 0c00 	mov.w	ip, #0
 8008784:	f801 cd01 	strb.w	ip, [r1, #-1]!

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 8008788:	f1ae 0e3a 	sub.w	lr, lr, #58	; 0x3a
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 800878c:	e00d      	b.n	80087aa <printi+0x76>
		t = u % b;
 800878e:	fbb0 fcf2 	udiv	ip, r0, r2
 8008792:	fb02 0c1c 	mls	ip, r2, ip, r0
		if( t >= 10 )
 8008796:	f1bc 0f09 	cmp.w	ip, #9
			t += letbase - '0' - 10;
 800879a:	bfc8      	it	gt
 800879c:	44f4      	addgt	ip, lr
		*--s = t + '0';
 800879e:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80087a2:	f801 cd01 	strb.w	ip, [r1, #-1]!
		u /= b;
 80087a6:	fbb0 f0f2 	udiv	r0, r0, r2
 80087aa:	460f      	mov	r7, r1
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
 80087ac:	2800      	cmp	r0, #0
 80087ae:	d1ee      	bne.n	800878e <printi+0x5a>
			t += letbase - '0' - 10;
		*--s = t + '0';
		u /= b;
	}

	if (neg) {
 80087b0:	b18d      	cbz	r5, 80087d6 <printi+0xa2>
		if( width && (pad & PAD_ZERO) ) {
 80087b2:	b15e      	cbz	r6, 80087cc <printi+0x98>
 80087b4:	f013 0f02 	tst.w	r3, #2
 80087b8:	d008      	beq.n	80087cc <printi+0x98>
			printchar (out, '-');
 80087ba:	4620      	mov	r0, r4
 80087bc:	212d      	movs	r1, #45	; 0x2d
 80087be:	9301      	str	r3, [sp, #4]
			++pc;
			--width;
 80087c0:	3e01      	subs	r6, #1
		u /= b;
	}

	if (neg) {
		if( width && (pad & PAD_ZERO) ) {
			printchar (out, '-');
 80087c2:	f7ff ff69 	bl	8008698 <printchar>
			++pc;
 80087c6:	2501      	movs	r5, #1
			--width;
 80087c8:	9b01      	ldr	r3, [sp, #4]
 80087ca:	e004      	b.n	80087d6 <printi+0xa2>
		}
		else {
			*--s = '-';
 80087cc:	222d      	movs	r2, #45	; 0x2d
 80087ce:	1e4f      	subs	r7, r1, #1
 80087d0:	f801 2c01 	strb.w	r2, [r1, #-1]

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 80087d4:	2500      	movs	r5, #0
		else {
			*--s = '-';
		}
	}

	return pc + prints (out, s, width, pad);
 80087d6:	4620      	mov	r0, r4
 80087d8:	4639      	mov	r1, r7
 80087da:	4632      	mov	r2, r6
 80087dc:	f7ff ff69 	bl	80086b2 <prints>
 80087e0:	1940      	adds	r0, r0, r5
}
 80087e2:	b007      	add	sp, #28
 80087e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080087e8 <print>:

static int print( char **out, const char *format, va_list args )
{
 80087e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80087ea:	b089      	sub	sp, #36	; 0x24
 80087ec:	4606      	mov	r6, r0
 80087ee:	460d      	mov	r5, r1
 80087f0:	9205      	str	r2, [sp, #20]
	register int width, pad;
	register int pc = 0;
 80087f2:	2400      	movs	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
 80087f4:	e07a      	b.n	80088ec <print+0x104>
		if (*format == '%') {
 80087f6:	2b25      	cmp	r3, #37	; 0x25
 80087f8:	d172      	bne.n	80088e0 <print+0xf8>
			++format;
			width = pad = 0;
			if (*format == '\0') break;
 80087fa:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80087fe:	2b00      	cmp	r3, #0
 8008800:	d077      	beq.n	80088f2 <print+0x10a>
			if (*format == '%') goto out;
 8008802:	2b25      	cmp	r3, #37	; 0x25
 8008804:	d06c      	beq.n	80088e0 <print+0xf8>
			if (*format == '-') {
 8008806:	2b2d      	cmp	r3, #45	; 0x2d
 8008808:	d102      	bne.n	8008810 <print+0x28>
				++format;
 800880a:	3501      	adds	r5, #1
				pad = PAD_RIGHT;
 800880c:	2301      	movs	r3, #1
 800880e:	e003      	b.n	8008818 <print+0x30>
	char scr[2];

	for (; *format != 0; ++format) {
		if (*format == '%') {
			++format;
			width = pad = 0;
 8008810:	2300      	movs	r3, #0
 8008812:	e001      	b.n	8008818 <print+0x30>
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
 8008814:	f043 0302 	orr.w	r3, r3, #2
 8008818:	462f      	mov	r7, r5
			if (*format == '%') goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
 800881a:	f815 2b01 	ldrb.w	r2, [r5], #1
 800881e:	2a30      	cmp	r2, #48	; 0x30
 8008820:	d0f8      	beq.n	8008814 <print+0x2c>
 8008822:	2200      	movs	r2, #0
 8008824:	e002      	b.n	800882c <print+0x44>
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
				width *= 10;
				width += *format - '0';
 8008826:	200a      	movs	r0, #10
 8008828:	fb00 c202 	mla	r2, r0, r2, ip
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 800882c:	7839      	ldrb	r1, [r7, #0]
				width *= 10;
				width += *format - '0';
 800882e:	463d      	mov	r5, r7
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 8008830:	f1a1 0c30 	sub.w	ip, r1, #48	; 0x30
 8008834:	fa5f f08c 	uxtb.w	r0, ip
 8008838:	3701      	adds	r7, #1
 800883a:	2809      	cmp	r0, #9
 800883c:	d9f3      	bls.n	8008826 <print+0x3e>
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
 800883e:	2973      	cmp	r1, #115	; 0x73
 8008840:	d109      	bne.n	8008856 <print+0x6e>
				register char *s = (char *)va_arg( args, int );
 8008842:	9905      	ldr	r1, [sp, #20]
 8008844:	1d08      	adds	r0, r1, #4
 8008846:	9005      	str	r0, [sp, #20]
 8008848:	6809      	ldr	r1, [r1, #0]
				pc += prints (out, s?s:"(null)", width, pad);
 800884a:	482d      	ldr	r0, [pc, #180]	; (8008900 <print+0x118>)
 800884c:	2900      	cmp	r1, #0
 800884e:	bf08      	it	eq
 8008850:	4601      	moveq	r1, r0
 8008852:	4630      	mov	r0, r6
 8008854:	e041      	b.n	80088da <print+0xf2>
				continue;
			}
			if( *format == 'd' ) {
 8008856:	2964      	cmp	r1, #100	; 0x64
 8008858:	d10e      	bne.n	8008878 <print+0x90>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 800885a:	9905      	ldr	r1, [sp, #20]
 800885c:	9301      	str	r3, [sp, #4]
 800885e:	2361      	movs	r3, #97	; 0x61
 8008860:	9200      	str	r2, [sp, #0]
 8008862:	9302      	str	r3, [sp, #8]
 8008864:	1d08      	adds	r0, r1, #4
 8008866:	6809      	ldr	r1, [r1, #0]
 8008868:	9005      	str	r0, [sp, #20]
 800886a:	220a      	movs	r2, #10
 800886c:	4630      	mov	r0, r6
 800886e:	2301      	movs	r3, #1
 8008870:	f7ff ff60 	bl	8008734 <printi>
 8008874:	1824      	adds	r4, r4, r0
				continue;
 8008876:	e038      	b.n	80088ea <print+0x102>
			}
			if( *format == 'x' ) {
 8008878:	2978      	cmp	r1, #120	; 0x78
 800887a:	d106      	bne.n	800888a <print+0xa2>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 800887c:	9905      	ldr	r1, [sp, #20]
 800887e:	9301      	str	r3, [sp, #4]
 8008880:	1d08      	adds	r0, r1, #4
 8008882:	9005      	str	r0, [sp, #20]
 8008884:	9200      	str	r2, [sp, #0]
 8008886:	2361      	movs	r3, #97	; 0x61
 8008888:	e007      	b.n	800889a <print+0xb2>
				continue;
			}
			if( *format == 'X' ) {
 800888a:	2958      	cmp	r1, #88	; 0x58
 800888c:	d10a      	bne.n	80088a4 <print+0xbc>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 800888e:	9905      	ldr	r1, [sp, #20]
 8008890:	9301      	str	r3, [sp, #4]
 8008892:	1d08      	adds	r0, r1, #4
 8008894:	9005      	str	r0, [sp, #20]
 8008896:	9200      	str	r2, [sp, #0]
 8008898:	2341      	movs	r3, #65	; 0x41
 800889a:	9302      	str	r3, [sp, #8]
 800889c:	4630      	mov	r0, r6
 800889e:	6809      	ldr	r1, [r1, #0]
 80088a0:	2210      	movs	r2, #16
 80088a2:	e00b      	b.n	80088bc <print+0xd4>
				continue;
			}
			if( *format == 'u' ) {
 80088a4:	2975      	cmp	r1, #117	; 0x75
 80088a6:	d10b      	bne.n	80088c0 <print+0xd8>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 80088a8:	9905      	ldr	r1, [sp, #20]
 80088aa:	9301      	str	r3, [sp, #4]
 80088ac:	2361      	movs	r3, #97	; 0x61
 80088ae:	9200      	str	r2, [sp, #0]
 80088b0:	9302      	str	r3, [sp, #8]
 80088b2:	1d08      	adds	r0, r1, #4
 80088b4:	6809      	ldr	r1, [r1, #0]
 80088b6:	9005      	str	r0, [sp, #20]
 80088b8:	220a      	movs	r2, #10
 80088ba:	4630      	mov	r0, r6
 80088bc:	2300      	movs	r3, #0
 80088be:	e7d7      	b.n	8008870 <print+0x88>
				continue;
			}
			if( *format == 'c' ) {
 80088c0:	2963      	cmp	r1, #99	; 0x63
 80088c2:	d112      	bne.n	80088ea <print+0x102>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
 80088c4:	9905      	ldr	r1, [sp, #20]
 80088c6:	1d08      	adds	r0, r1, #4
 80088c8:	6809      	ldr	r1, [r1, #0]
 80088ca:	9005      	str	r0, [sp, #20]
 80088cc:	f88d 101c 	strb.w	r1, [sp, #28]
				scr[1] = '\0';
 80088d0:	2100      	movs	r1, #0
 80088d2:	f88d 101d 	strb.w	r1, [sp, #29]
				pc += prints (out, scr, width, pad);
 80088d6:	4630      	mov	r0, r6
 80088d8:	a907      	add	r1, sp, #28
 80088da:	f7ff feea 	bl	80086b2 <prints>
 80088de:	e7c9      	b.n	8008874 <print+0x8c>
				continue;
			}
		}
		else {
		out:
			printchar (out, *format);
 80088e0:	7829      	ldrb	r1, [r5, #0]
 80088e2:	4630      	mov	r0, r6
 80088e4:	f7ff fed8 	bl	8008698 <printchar>
			++pc;
 80088e8:	3401      	adds	r4, #1
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
 80088ea:	3501      	adds	r5, #1
 80088ec:	782b      	ldrb	r3, [r5, #0]
 80088ee:	2b00      	cmp	r3, #0
 80088f0:	d181      	bne.n	80087f6 <print+0xe>
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
 80088f2:	b116      	cbz	r6, 80088fa <print+0x112>
 80088f4:	6833      	ldr	r3, [r6, #0]
 80088f6:	2200      	movs	r2, #0
 80088f8:	701a      	strb	r2, [r3, #0]
	va_end( args );
	return pc;
}
 80088fa:	4620      	mov	r0, r4
 80088fc:	b009      	add	sp, #36	; 0x24
 80088fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008900:	0800b05c 	.word	0x0800b05c

08008904 <sprintf>:
{
  return print( 0, format, args );
}

int sprintf(char *out, const char *format, ...)
{
 8008904:	b40e      	push	{r1, r2, r3}
 8008906:	b50f      	push	{r0, r1, r2, r3, lr}
 8008908:	aa05      	add	r2, sp, #20
 800890a:	f852 1b04 	ldr.w	r1, [r2], #4
 800890e:	9001      	str	r0, [sp, #4]
        va_list args;
        
        va_start( args, format );
        return print( &out, format, args );
 8008910:	a801      	add	r0, sp, #4

int sprintf(char *out, const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
 8008912:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 8008914:	f7ff ff68 	bl	80087e8 <print>
}
 8008918:	b004      	add	sp, #16
 800891a:	f85d eb04 	ldr.w	lr, [sp], #4
 800891e:	b003      	add	sp, #12
 8008920:	4770      	bx	lr

08008922 <vsprintf>:

// TK: added for alternative parameter passing
int vsprintf(char *out, const char *format, va_list args)
{
 8008922:	b507      	push	{r0, r1, r2, lr}
 8008924:	4603      	mov	r3, r0
  char *_out;
  _out = out;
 8008926:	a802      	add	r0, sp, #8
 8008928:	f840 3d04 	str.w	r3, [r0, #-4]!
  return print( &_out, format, args );
 800892c:	f7ff ff5c 	bl	80087e8 <print>
}
 8008930:	bd0e      	pop	{r1, r2, r3, pc}

08008932 <GPIO_Init>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8008932:	78cb      	ldrb	r3, [r1, #3]
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8008934:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8008936:	f013 0f10 	tst.w	r3, #16
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 800893a:	f003 020f 	and.w	r2, r3, #15
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 800893e:	880f      	ldrh	r7, [r1, #0]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8008940:	bf1c      	itt	ne
 8008942:	788b      	ldrbne	r3, [r1, #2]
 8008944:	431a      	orrne	r2, r3
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8008946:	f017 0fff 	tst.w	r7, #255	; 0xff
 800894a:	d022      	beq.n	8008992 <GPIO_Init+0x60>
  {
    tmpreg = GPIOx->CRL;
 800894c:	f8d0 c000 	ldr.w	ip, [r0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008950:	2300      	movs	r3, #0
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008952:	9701      	str	r7, [sp, #4]
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
 8008954:	2401      	movs	r4, #1
 8008956:	fa14 f503 	lsls.w	r5, r4, r3
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800895a:	9e01      	ldr	r6, [sp, #4]
 800895c:	ea05 0406 	and.w	r4, r5, r6
      if (currentpin == pos)
 8008960:	42ac      	cmp	r4, r5
 8008962:	d111      	bne.n	8008988 <GPIO_Init+0x56>
      {
        pos = pinpos << 2;
 8008964:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8008966:	270f      	movs	r7, #15
 8008968:	fa17 f506 	lsls.w	r5, r7, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800896c:	fa12 f606 	lsls.w	r6, r2, r6
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8008970:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008974:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8008976:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800897a:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 800897c:	bf08      	it	eq
 800897e:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8008980:	d002      	beq.n	8008988 <GPIO_Init+0x56>
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8008982:	2d48      	cmp	r5, #72	; 0x48
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8008984:	bf08      	it	eq
 8008986:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8008988:	3301      	adds	r3, #1
 800898a:	2b08      	cmp	r3, #8
 800898c:	d1e2      	bne.n	8008954 <GPIO_Init+0x22>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 800898e:	f8c0 c000 	str.w	ip, [r0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8008992:	880f      	ldrh	r7, [r1, #0]
 8008994:	2fff      	cmp	r7, #255	; 0xff
 8008996:	d924      	bls.n	80089e2 <GPIO_Init+0xb0>
  {
    tmpreg = GPIOx->CRH;
 8008998:	f8d0 c004 	ldr.w	ip, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800899c:	2300      	movs	r3, #0
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 800899e:	9201      	str	r2, [sp, #4]
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80089a0:	2201      	movs	r2, #1
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
 80089a2:	f103 0508 	add.w	r5, r3, #8
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80089a6:	fa12 f505 	lsls.w	r5, r2, r5
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 80089aa:	ea05 0407 	and.w	r4, r5, r7
      if (currentpin == pos)
 80089ae:	42ac      	cmp	r4, r5
 80089b0:	d112      	bne.n	80089d8 <GPIO_Init+0xa6>
      {
        pos = pinpos << 2;
 80089b2:	009e      	lsls	r6, r3, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 80089b4:	320e      	adds	r2, #14
 80089b6:	fa12 f506 	lsls.w	r5, r2, r6
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80089ba:	9a01      	ldr	r2, [sp, #4]
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80089bc:	ea2c 0c05 	bic.w	ip, ip, r5
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80089c0:	fa12 f606 	lsls.w	r6, r2, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80089c4:	78cd      	ldrb	r5, [r1, #3]
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80089c6:	ea4c 0c06 	orr.w	ip, ip, r6
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80089ca:	2d28      	cmp	r5, #40	; 0x28
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80089cc:	bf08      	it	eq
 80089ce:	6144      	streq	r4, [r0, #20]
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80089d0:	d002      	beq.n	80089d8 <GPIO_Init+0xa6>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80089d2:	2d48      	cmp	r5, #72	; 0x48
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80089d4:	bf08      	it	eq
 80089d6:	6104      	streq	r4, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80089d8:	3301      	adds	r3, #1
 80089da:	2b08      	cmp	r3, #8
 80089dc:	d1e0      	bne.n	80089a0 <GPIO_Init+0x6e>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 80089de:	f8c0 c004 	str.w	ip, [r0, #4]
  }
}
 80089e2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080089e4 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 80089e4:	f04f 33ff 	mov.w	r3, #4294967295
 80089e8:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 80089ea:	2302      	movs	r3, #2
 80089ec:	7083      	strb	r3, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 80089ee:	18db      	adds	r3, r3, r3
 80089f0:	70c3      	strb	r3, [r0, #3]
}
 80089f2:	4770      	bx	lr

080089f4 <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 80089f4:	2800      	cmp	r0, #0
  {
    tmpreg = AFIO->MAPR2;
 80089f6:	bfb4      	ite	lt
 80089f8:	4b1a      	ldrlt	r3, [pc, #104]	; (8008a64 <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    tmpreg = AFIO->MAPR;
 80089fa:	4b1a      	ldrge	r3, [pc, #104]	; (8008a64 <GPIO_PinRemapConfig+0x70>)
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80089fc:	f400 1c40 	and.w	ip, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 8008a00:	bfb4      	ite	lt
 8008a02:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 8008a04:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008a06:	f5bc 1f40 	cmp.w	ip, #3145728	; 0x300000
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 8008a0a:	b510      	push	{r4, lr}
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 8008a0c:	b282      	uxth	r2, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8008a0e:	d10a      	bne.n	8008a26 <GPIO_PinRemapConfig+0x32>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8008a10:	f8df c050 	ldr.w	ip, [pc, #80]	; 8008a64 <GPIO_PinRemapConfig+0x70>
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8008a14:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8008a18:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8008a1c:	f024 6470 	bic.w	r4, r4, #251658240	; 0xf000000
 8008a20:	f8cc 4004 	str.w	r4, [ip, #4]
 8008a24:	e012      	b.n	8008a4c <GPIO_PinRemapConfig+0x58>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8008a26:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008a2a:	bf02      	ittt	eq
 8008a2c:	ea4f 5c50 	moveq.w	ip, r0, lsr #21
 8008a30:	ea4f 1c0c 	moveq.w	ip, ip, lsl #4
 8008a34:	fa02 fc0c 	lsleq.w	ip, r2, ip
  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8008a38:	d004      	beq.n	8008a44 <GPIO_PinRemapConfig+0x50>
  else
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 8008a3a:	f3c0 4c03 	ubfx	ip, r0, #16, #4
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 8008a3e:	2403      	movs	r4, #3
 8008a40:	fa04 fc0c 	lsl.w	ip, r4, ip
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008a44:	ea23 030c 	bic.w	r3, r3, ip
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8008a48:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  }

  if (NewState != DISABLE)
 8008a4c:	b119      	cbz	r1, 8008a56 <GPIO_PinRemapConfig+0x62>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 8008a4e:	0d41      	lsrs	r1, r0, #21
 8008a50:	0109      	lsls	r1, r1, #4
 8008a52:	408a      	lsls	r2, r1
 8008a54:	4313      	orrs	r3, r2
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8008a56:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 8008a58:	bfb5      	itete	lt
 8008a5a:	4a02      	ldrlt	r2, [pc, #8]	; (8008a64 <GPIO_PinRemapConfig+0x70>)
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008a5c:	4a01      	ldrge	r2, [pc, #4]	; (8008a64 <GPIO_PinRemapConfig+0x70>)
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    AFIO->MAPR2 = tmpreg;
 8008a5e:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8008a60:	6053      	strge	r3, [r2, #4]
  }  
}
 8008a62:	bd10      	pop	{r4, pc}
 8008a64:	40010000 	.word	0x40010000

08008a68 <FLASH_SetLatency>:
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 8008a68:	4b03      	ldr	r3, [pc, #12]	; (8008a78 <FLASH_SetLatency+0x10>)
 8008a6a:	681a      	ldr	r2, [r3, #0]
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8008a6c:	f002 0238 	and.w	r2, r2, #56	; 0x38
  tmpreg |= FLASH_Latency;
 8008a70:	4310      	orrs	r0, r2
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8008a72:	6018      	str	r0, [r3, #0]
}
 8008a74:	4770      	bx	lr
 8008a76:	bf00      	nop
 8008a78:	40022000 	.word	0x40022000

08008a7c <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 8008a7c:	4b04      	ldr	r3, [pc, #16]	; (8008a90 <FLASH_PrefetchBufferCmd+0x14>)
 8008a7e:	681a      	ldr	r2, [r3, #0]
 8008a80:	f022 0210 	bic.w	r2, r2, #16
 8008a84:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 8008a86:	681a      	ldr	r2, [r3, #0]
 8008a88:	4310      	orrs	r0, r2
 8008a8a:	6018      	str	r0, [r3, #0]
}
 8008a8c:	4770      	bx	lr
 8008a8e:	bf00      	nop
 8008a90:	40022000 	.word	0x40022000

08008a94 <ADC_Init>:
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8008a94:	6843      	ldr	r3, [r0, #4]
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
 8008a96:	680a      	ldr	r2, [r1, #0]

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
 8008a98:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8008a9c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
 8008aa0:	4313      	orrs	r3, r2
 8008aa2:	790a      	ldrb	r2, [r1, #4]
 8008aa4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8008aa8:	6043      	str	r3, [r0, #4]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008aaa:	688a      	ldr	r2, [r1, #8]
 8008aac:	68cb      	ldr	r3, [r1, #12]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8008aae:	f8d0 c008 	ldr.w	ip, [r0, #8]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008ab2:	431a      	orrs	r2, r3

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  /* Clear CONT, ALIGN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_Mask;
 8008ab4:	4b09      	ldr	r3, [pc, #36]	; (8008adc <ADC_Init+0x48>)
 8008ab6:	ea0c 0303 	and.w	r3, ip, r3
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008aba:	ea42 0303 	orr.w	r3, r2, r3
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8008abe:	794a      	ldrb	r2, [r1, #5]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8008ac0:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8008ac4:	6083      	str	r3, [r0, #8]
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 8008ac6:	7c0b      	ldrb	r3, [r1, #16]
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8008ac8:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 8008aca:	3b01      	subs	r3, #1

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
 8008acc:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
 8008ad0:	b2db      	uxtb	r3, r3
 8008ad2:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8008ad6:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8008ad8:	4770      	bx	lr
 8008ada:	bf00      	nop
 8008adc:	fff1f7fd 	.word	0xfff1f7fd

08008ae0 <ADC_StructInit>:
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
 8008ae0:	2300      	movs	r3, #0
 8008ae2:	6003      	str	r3, [r0, #0]
  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8008ae4:	7103      	strb	r3, [r0, #4]
  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8008ae6:	7143      	strb	r3, [r0, #5]
  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 8008ae8:	6083      	str	r3, [r0, #8]
  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8008aea:	60c3      	str	r3, [r0, #12]
  /* Initialize the ADC_NbrOfChannel member */
  ADC_InitStruct->ADC_NbrOfChannel = 1;
 8008aec:	3301      	adds	r3, #1
 8008aee:	7403      	strb	r3, [r0, #16]
}
 8008af0:	4770      	bx	lr

08008af2 <ADC_Cmd>:
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008af2:	b119      	cbz	r1, 8008afc <ADC_Cmd+0xa>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
 8008af4:	6883      	ldr	r3, [r0, #8]
 8008af6:	f043 0301 	orr.w	r3, r3, #1
 8008afa:	e002      	b.n	8008b02 <ADC_Cmd+0x10>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
 8008afc:	6883      	ldr	r3, [r0, #8]
 8008afe:	f023 0301 	bic.w	r3, r3, #1
 8008b02:	6083      	str	r3, [r0, #8]
  }
}
 8008b04:	4770      	bx	lr

08008b06 <ADC_DMACmd>:
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008b06:	b119      	cbz	r1, 8008b10 <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
 8008b08:	6883      	ldr	r3, [r0, #8]
 8008b0a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008b0e:	e002      	b.n	8008b16 <ADC_DMACmd+0x10>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
 8008b10:	6883      	ldr	r3, [r0, #8]
 8008b12:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008b16:	6083      	str	r3, [r0, #8]
  }
}
 8008b18:	4770      	bx	lr

08008b1a <ADC_ResetCalibration>:
void ADC_ResetCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
 8008b1a:	6883      	ldr	r3, [r0, #8]
 8008b1c:	f043 0308 	orr.w	r3, r3, #8
 8008b20:	6083      	str	r3, [r0, #8]
}
 8008b22:	4770      	bx	lr

08008b24 <ADC_GetResetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
 8008b24:	6880      	ldr	r0, [r0, #8]
 8008b26:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    /* RSTCAL bit is reset */
    bitstatus = RESET;
  }
  /* Return the RSTCAL bit status */
  return  bitstatus;
}
 8008b2a:	4770      	bx	lr

08008b2c <ADC_StartCalibration>:
void ADC_StartCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
 8008b2c:	6883      	ldr	r3, [r0, #8]
 8008b2e:	f043 0304 	orr.w	r3, r3, #4
 8008b32:	6083      	str	r3, [r0, #8]
}
 8008b34:	4770      	bx	lr

08008b36 <ADC_GetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
 8008b36:	6880      	ldr	r0, [r0, #8]
 8008b38:	f3c0 0080 	ubfx	r0, r0, #2, #1
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
 8008b3c:	4770      	bx	lr

08008b3e <ADC_SoftwareStartConvCmd>:
void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008b3e:	b119      	cbz	r1, 8008b48 <ADC_SoftwareStartConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
 8008b40:	6883      	ldr	r3, [r0, #8]
 8008b42:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 8008b46:	e002      	b.n	8008b4e <ADC_SoftwareStartConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
 8008b48:	6883      	ldr	r3, [r0, #8]
 8008b4a:	f423 03a0 	bic.w	r3, r3, #5242880	; 0x500000
 8008b4e:	6083      	str	r3, [r0, #8]
  }
}
 8008b50:	4770      	bx	lr

08008b52 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8008b52:	2909      	cmp	r1, #9
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8008b54:	b530      	push	{r4, r5, lr}
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8008b56:	d912      	bls.n	8008b7e <ADC_RegularChannelConfig+0x2c>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
 8008b58:	f04f 0c03 	mov.w	ip, #3
 8008b5c:	fb0c fc01 	mul.w	ip, ip, r1
 8008b60:	2407      	movs	r4, #7
 8008b62:	f1ac 0c1e 	sub.w	ip, ip, #30
 8008b66:	fa04 f40c 	lsl.w	r4, r4, ip
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8008b6a:	fa03 f30c 	lsl.w	r3, r3, ip
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8008b6e:	68c5      	ldr	r5, [r0, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 8008b70:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 8008b74:	ea44 0c03 	orr.w	ip, r4, r3
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8008b78:	f8c0 c00c 	str.w	ip, [r0, #12]
 8008b7c:	e00e      	b.n	8008b9c <ADC_RegularChannelConfig+0x4a>
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 8008b7e:	f04f 0c03 	mov.w	ip, #3
 8008b82:	fb0c fc01 	mul.w	ip, ip, r1
 8008b86:	2407      	movs	r4, #7
 8008b88:	fa04 f40c 	lsl.w	r4, r4, ip
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8008b8c:	fa03 fc0c 	lsl.w	ip, r3, ip
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8008b90:	6905      	ldr	r5, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 8008b92:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 8008b96:	ea44 030c 	orr.w	r3, r4, ip
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8008b9a:	6103      	str	r3, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8008b9c:	2a06      	cmp	r2, #6
 8008b9e:	d80d      	bhi.n	8008bbc <ADC_RegularChannelConfig+0x6a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
 8008ba0:	2305      	movs	r3, #5
 8008ba2:	3a01      	subs	r2, #1
 8008ba4:	435a      	muls	r2, r3
 8008ba6:	331a      	adds	r3, #26
 8008ba8:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8008baa:	4091      	lsls	r1, r2
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8008bac:	f8d0 c034 	ldr.w	ip, [r0, #52]	; 0x34
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008bb0:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008bb4:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8008bb8:	6342      	str	r2, [r0, #52]	; 0x34
 8008bba:	e01c      	b.n	8008bf6 <ADC_RegularChannelConfig+0xa4>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 8008bbc:	2a0c      	cmp	r2, #12
 8008bbe:	d80d      	bhi.n	8008bdc <ADC_RegularChannelConfig+0x8a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
 8008bc0:	2305      	movs	r3, #5
 8008bc2:	435a      	muls	r2, r3
 8008bc4:	331a      	adds	r3, #26
 8008bc6:	3a23      	subs	r2, #35	; 0x23
 8008bc8:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8008bca:	4091      	lsls	r1, r2
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8008bcc:	f8d0 c030 	ldr.w	ip, [r0, #48]	; 0x30
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008bd0:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008bd4:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8008bd8:	6302      	str	r2, [r0, #48]	; 0x30
 8008bda:	e00c      	b.n	8008bf6 <ADC_RegularChannelConfig+0xa4>
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
 8008bdc:	2305      	movs	r3, #5
 8008bde:	435a      	muls	r2, r3
 8008be0:	331a      	adds	r3, #26
 8008be2:	3a41      	subs	r2, #65	; 0x41
 8008be4:	4093      	lsls	r3, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8008be6:	4091      	lsls	r1, r2
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8008be8:	f8d0 c02c 	ldr.w	ip, [r0, #44]	; 0x2c
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8008bec:	ea2c 0303 	bic.w	r3, ip, r3
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8008bf0:	ea43 0201 	orr.w	r2, r3, r1
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8008bf4:	62c2      	str	r2, [r0, #44]	; 0x2c
  }
}
 8008bf6:	bd30      	pop	{r4, r5, pc}

08008bf8 <ADC_ExternalTrigConvCmd>:
void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008bf8:	b119      	cbz	r1, 8008c02 <ADC_ExternalTrigConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event */
    ADCx->CR2 |= CR2_EXTTRIG_Set;
 8008bfa:	6883      	ldr	r3, [r0, #8]
 8008bfc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008c00:	e002      	b.n	8008c08 <ADC_ExternalTrigConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event */
    ADCx->CR2 &= CR2_EXTTRIG_Reset;
 8008c02:	6883      	ldr	r3, [r0, #8]
 8008c04:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8008c08:	6083      	str	r3, [r0, #8]
  }
}
 8008c0a:	4770      	bx	lr

08008c0c <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008c0c:	f8b1 c002 	ldrh.w	ip, [r1, #2]
 8008c10:	880b      	ldrh	r3, [r1, #0]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8008c12:	8802      	ldrh	r2, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008c14:	ea4c 0303 	orr.w	r3, ip, r3
 8008c18:	f8b1 c004 	ldrh.w	ip, [r1, #4]

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008c1c:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8008c20:	ea43 030c 	orr.w	r3, r3, ip
 8008c24:	f8b1 c006 	ldrh.w	ip, [r1, #6]
 8008c28:	ea43 030c 	orr.w	r3, r3, ip
 8008c2c:	f8b1 c008 	ldrh.w	ip, [r1, #8]
 8008c30:	ea43 030c 	orr.w	r3, r3, ip
 8008c34:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 8008c38:	ea43 030c 	orr.w	r3, r3, ip
 8008c3c:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
 8008c40:	ea43 030c 	orr.w	r3, r3, ip
 8008c44:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
 8008c48:	ea43 030c 	orr.w	r3, r3, ip
 8008c4c:	ea42 0303 	orr.w	r3, r2, r3
 8008c50:	b29b      	uxth	r3, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8008c52:	8003      	strh	r3, [r0, #0]
  
  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= SPI_Mode_Select;		
 8008c54:	8b83      	ldrh	r3, [r0, #28]
 8008c56:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8008c5a:	041b      	lsls	r3, r3, #16
 8008c5c:	0c1b      	lsrs	r3, r3, #16
 8008c5e:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8008c60:	8a0b      	ldrh	r3, [r1, #16]
 8008c62:	8203      	strh	r3, [r0, #16]
}
 8008c64:	4770      	bx	lr

08008c66 <SPI_Cmd>:
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008c66:	b121      	cbz	r1, 8008c72 <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 8008c68:	8803      	ldrh	r3, [r0, #0]
 8008c6a:	b29b      	uxth	r3, r3
 8008c6c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008c70:	e004      	b.n	8008c7c <SPI_Cmd+0x16>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= CR1_SPE_Reset;
 8008c72:	8803      	ldrh	r3, [r0, #0]
 8008c74:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8008c78:	041b      	lsls	r3, r3, #16
 8008c7a:	0c1b      	lsrs	r3, r3, #16
 8008c7c:	8003      	strh	r3, [r0, #0]
  }
}
 8008c7e:	4770      	bx	lr

08008c80 <SPI_I2S_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
 8008c80:	b11a      	cbz	r2, 8008c8a <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8008c82:	8883      	ldrh	r3, [r0, #4]
 8008c84:	b29b      	uxth	r3, r3
 8008c86:	4319      	orrs	r1, r3
 8008c88:	e003      	b.n	8008c92 <SPI_I2S_DMACmd+0x12>
  }
  else
  {
    /* Disable the selected SPI/I2S DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8008c8a:	8883      	ldrh	r3, [r0, #4]
 8008c8c:	b29b      	uxth	r3, r3
 8008c8e:	ea23 0101 	bic.w	r1, r3, r1
 8008c92:	8081      	strh	r1, [r0, #4]
  }
}
 8008c94:	4770      	bx	lr
	...

08008c98 <USART_Init>:
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8008c98:	8a03      	ldrh	r3, [r0, #16]
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8008c9a:	88ca      	ldrh	r2, [r1, #6]
  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 8008c9c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8008ca0:	041b      	lsls	r3, r3, #16
 8008ca2:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8008ca4:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008ca6:	b530      	push	{r4, r5, lr}
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8008ca8:	8203      	strh	r3, [r0, #16]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008caa:	460d      	mov	r5, r1
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8008cac:	8983      	ldrh	r3, [r0, #12]
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008cae:	8909      	ldrh	r1, [r1, #8]
 8008cb0:	88aa      	ldrh	r2, [r5, #4]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008cb2:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008cb6:	ea41 0202 	orr.w	r2, r1, r2
 8008cba:	8969      	ldrh	r1, [r5, #10]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008cbc:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008cc0:	430a      	orrs	r2, r1
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8008cc2:	041b      	lsls	r3, r3, #16
 8008cc4:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8008cc6:	b292      	uxth	r2, r2
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8008cc8:	ea42 0303 	orr.w	r3, r2, r3
 8008ccc:	8183      	strh	r3, [r0, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8008cce:	8a83      	ldrh	r3, [r0, #20]
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8008cd0:	89aa      	ldrh	r2, [r5, #12]
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8008cd2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008cd6:	041b      	lsls	r3, r3, #16
 8008cd8:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8008cda:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008cdc:	b087      	sub	sp, #28
 8008cde:	4604      	mov	r4, r0
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8008ce0:	8283      	strh	r3, [r0, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8008ce2:	a801      	add	r0, sp, #4
 8008ce4:	f000 fa92 	bl	800920c <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 8008ce8:	4b18      	ldr	r3, [pc, #96]	; (8008d4c <USART_Init+0xb4>)
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008cea:	89a2      	ldrh	r2, [r4, #12]
  USARTx->CR3 = (uint16_t)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
 8008cec:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008cee:	b212      	sxth	r2, r2
/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8008cf0:	bf0c      	ite	eq
 8008cf2:	9b04      	ldreq	r3, [sp, #16]
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8008cf4:	9b03      	ldrne	r3, [sp, #12]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008cf6:	2a00      	cmp	r2, #0
 8008cf8:	682a      	ldr	r2, [r5, #0]
 8008cfa:	da03      	bge.n	8008d04 <USART_Init+0x6c>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8008cfc:	2119      	movs	r1, #25
 8008cfe:	4359      	muls	r1, r3
 8008d00:	0052      	lsls	r2, r2, #1
 8008d02:	e002      	b.n	8008d0a <USART_Init+0x72>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8008d04:	2119      	movs	r1, #25
 8008d06:	4359      	muls	r1, r3
 8008d08:	0092      	lsls	r2, r2, #2
  }
  tmpreg = (integerdivider / 100) << 4;
 8008d0a:	2364      	movs	r3, #100	; 0x64
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8008d0c:	fbb1 f1f2 	udiv	r1, r1, r2
  }
  tmpreg = (integerdivider / 100) << 4;
 8008d10:	fbb1 f2f3 	udiv	r2, r1, r3
 8008d14:	0112      	lsls	r2, r2, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8008d16:	0910      	lsrs	r0, r2, #4
 8008d18:	fb03 1110 	mls	r1, r3, r0, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8008d1c:	89a0      	ldrh	r0, [r4, #12]
 8008d1e:	b200      	sxth	r0, r0
 8008d20:	2800      	cmp	r0, #0
 8008d22:	da06      	bge.n	8008d32 <USART_Init+0x9a>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8008d24:	00c9      	lsls	r1, r1, #3
 8008d26:	3132      	adds	r1, #50	; 0x32
 8008d28:	fbb1 f3f3 	udiv	r3, r1, r3
 8008d2c:	f003 0307 	and.w	r3, r3, #7
 8008d30:	e005      	b.n	8008d3e <USART_Init+0xa6>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8008d32:	0109      	lsls	r1, r1, #4
 8008d34:	3132      	adds	r1, #50	; 0x32
 8008d36:	fbb1 f3f3 	udiv	r3, r1, r3
 8008d3a:	f003 030f 	and.w	r3, r3, #15
 8008d3e:	ea43 0202 	orr.w	r2, r3, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 8008d42:	b292      	uxth	r2, r2
 8008d44:	8122      	strh	r2, [r4, #8]
}
 8008d46:	b007      	add	sp, #28
 8008d48:	bd30      	pop	{r4, r5, pc}
 8008d4a:	bf00      	nop
 8008d4c:	40013800 	.word	0x40013800

08008d50 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008d50:	b121      	cbz	r1, 8008d5c <USART_Cmd+0xc>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8008d52:	8983      	ldrh	r3, [r0, #12]
 8008d54:	b29b      	uxth	r3, r3
 8008d56:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8008d5a:	e004      	b.n	8008d66 <USART_Cmd+0x16>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 8008d5c:	8983      	ldrh	r3, [r0, #12]
 8008d5e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008d62:	041b      	lsls	r3, r3, #16
 8008d64:	0c1b      	lsrs	r3, r3, #16
 8008d66:	8183      	strh	r3, [r0, #12]
  }
}
 8008d68:	4770      	bx	lr

08008d6a <USART_ITConfig>:
  }   
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8008d6a:	f3c1 1342 	ubfx	r3, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8008d6e:	f04f 0c01 	mov.w	ip, #1

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
 8008d72:	f001 011f 	and.w	r1, r1, #31
  itmask = (((uint32_t)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8008d76:	4563      	cmp	r3, ip
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8008d78:	fa0c f101 	lsl.w	r1, ip, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8008d7c:	d101      	bne.n	8008d82 <USART_ITConfig+0x18>
  {
    usartxbase += 0x0C;
 8008d7e:	300c      	adds	r0, #12
 8008d80:	e004      	b.n	8008d8c <USART_ITConfig+0x22>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8008d82:	2b02      	cmp	r3, #2
 8008d84:	d101      	bne.n	8008d8a <USART_ITConfig+0x20>
  {
    usartxbase += 0x10;
 8008d86:	3010      	adds	r0, #16
 8008d88:	e000      	b.n	8008d8c <USART_ITConfig+0x22>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8008d8a:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
 8008d8c:	b11a      	cbz	r2, 8008d96 <USART_ITConfig+0x2c>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8008d8e:	6803      	ldr	r3, [r0, #0]
 8008d90:	ea43 0101 	orr.w	r1, r3, r1
 8008d94:	e002      	b.n	8008d9c <USART_ITConfig+0x32>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8008d96:	6803      	ldr	r3, [r0, #0]
 8008d98:	ea23 0101 	bic.w	r1, r3, r1
 8008d9c:	6001      	str	r1, [r0, #0]
  }
}
 8008d9e:	4770      	bx	lr

08008da0 <I2C_GenerateSTART>:
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008da0:	b121      	cbz	r1, 8008dac <I2C_GenerateSTART+0xc>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 8008da2:	8803      	ldrh	r3, [r0, #0]
 8008da4:	b29b      	uxth	r3, r3
 8008da6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008daa:	e004      	b.n	8008db6 <I2C_GenerateSTART+0x16>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
 8008dac:	8803      	ldrh	r3, [r0, #0]
 8008dae:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008db2:	041b      	lsls	r3, r3, #16
 8008db4:	0c1b      	lsrs	r3, r3, #16
 8008db6:	8003      	strh	r3, [r0, #0]
  }
}
 8008db8:	4770      	bx	lr

08008dba <I2C_GenerateSTOP>:
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008dba:	b121      	cbz	r1, 8008dc6 <I2C_GenerateSTOP+0xc>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 8008dbc:	8803      	ldrh	r3, [r0, #0]
 8008dbe:	b29b      	uxth	r3, r3
 8008dc0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008dc4:	e004      	b.n	8008dd0 <I2C_GenerateSTOP+0x16>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
 8008dc6:	8803      	ldrh	r3, [r0, #0]
 8008dc8:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8008dcc:	041b      	lsls	r3, r3, #16
 8008dce:	0c1b      	lsrs	r3, r3, #16
 8008dd0:	8003      	strh	r3, [r0, #0]
  }
}
 8008dd2:	4770      	bx	lr

08008dd4 <I2C_AcknowledgeConfig>:
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008dd4:	b121      	cbz	r1, 8008de0 <I2C_AcknowledgeConfig+0xc>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8008dd6:	8803      	ldrh	r3, [r0, #0]
 8008dd8:	b29b      	uxth	r3, r3
 8008dda:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008dde:	e004      	b.n	8008dea <I2C_AcknowledgeConfig+0x16>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
 8008de0:	8803      	ldrh	r3, [r0, #0]
 8008de2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008de6:	041b      	lsls	r3, r3, #16
 8008de8:	0c1b      	lsrs	r3, r3, #16
 8008dea:	8003      	strh	r3, [r0, #0]
  }
}
 8008dec:	4770      	bx	lr

08008dee <I2C_ITConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8008dee:	b11a      	cbz	r2, 8008df8 <I2C_ITConfig+0xa>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8008df0:	8883      	ldrh	r3, [r0, #4]
 8008df2:	b29b      	uxth	r3, r3
 8008df4:	4319      	orrs	r1, r3
 8008df6:	e003      	b.n	8008e00 <I2C_ITConfig+0x12>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8008df8:	8883      	ldrh	r3, [r0, #4]
 8008dfa:	b29b      	uxth	r3, r3
 8008dfc:	ea23 0101 	bic.w	r1, r3, r1
 8008e00:	8081      	strh	r1, [r0, #4]
  }
}
 8008e02:	4770      	bx	lr

08008e04 <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8008e04:	8201      	strh	r1, [r0, #16]
}
 8008e06:	4770      	bx	lr

08008e08 <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8008e08:	8a00      	ldrh	r0, [r0, #16]
 8008e0a:	b2c0      	uxtb	r0, r0
}
 8008e0c:	4770      	bx	lr

08008e0e <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 8008e0e:	b112      	cbz	r2, 8008e16 <I2C_Send7bitAddress+0x8>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 8008e10:	f041 0101 	orr.w	r1, r1, #1
 8008e14:	e001      	b.n	8008e1a <I2C_Send7bitAddress+0xc>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 8008e16:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 8008e1a:	8201      	strh	r1, [r0, #16]
}
 8008e1c:	4770      	bx	lr

08008e1e <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8008e1e:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 8008e20:	8b00      	ldrh	r0, [r0, #24]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8008e22:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 8008e24:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8008e28:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

  /* Return status */
  return lastevent;
}
 8008e2c:	4770      	bx	lr

08008e2e <I2C_ClearITPendingBit>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_Mask;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8008e2e:	43c9      	mvns	r1, r1
 8008e30:	b289      	uxth	r1, r1
 8008e32:	8281      	strh	r1, [r0, #20]
}
 8008e34:	4770      	bx	lr
	...

08008e38 <DMA_DeInit>:
void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 8008e38:	6803      	ldr	r3, [r0, #0]
 8008e3a:	f023 0301 	bic.w	r3, r3, #1
 8008e3e:	6003      	str	r3, [r0, #0]
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8008e40:	2300      	movs	r3, #0
 8008e42:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8008e44:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8008e46:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 8008e48:	60c3      	str	r3, [r0, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8008e4a:	4b24      	ldr	r3, [pc, #144]	; (8008edc <DMA_DeInit+0xa4>)
 8008e4c:	4298      	cmp	r0, r3
 8008e4e:	d01e      	beq.n	8008e8e <DMA_DeInit+0x56>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8008e50:	4b23      	ldr	r3, [pc, #140]	; (8008ee0 <DMA_DeInit+0xa8>)
 8008e52:	4298      	cmp	r0, r3
 8008e54:	d023      	beq.n	8008e9e <DMA_DeInit+0x66>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8008e56:	4b23      	ldr	r3, [pc, #140]	; (8008ee4 <DMA_DeInit+0xac>)
 8008e58:	4298      	cmp	r0, r3
 8008e5a:	d028      	beq.n	8008eae <DMA_DeInit+0x76>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8008e5c:	4b22      	ldr	r3, [pc, #136]	; (8008ee8 <DMA_DeInit+0xb0>)
 8008e5e:	4298      	cmp	r0, r3
 8008e60:	d02d      	beq.n	8008ebe <DMA_DeInit+0x86>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8008e62:	4b22      	ldr	r3, [pc, #136]	; (8008eec <DMA_DeInit+0xb4>)
 8008e64:	4298      	cmp	r0, r3
 8008e66:	d032      	beq.n	8008ece <DMA_DeInit+0x96>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8008e68:	4b21      	ldr	r3, [pc, #132]	; (8008ef0 <DMA_DeInit+0xb8>)
 8008e6a:	4298      	cmp	r0, r3
 8008e6c:	d104      	bne.n	8008e78 <DMA_DeInit+0x40>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 8008e6e:	3b6c      	subs	r3, #108	; 0x6c
 8008e70:	685a      	ldr	r2, [r3, #4]
 8008e72:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8008e76:	e02e      	b.n	8008ed6 <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8008e78:	4b1e      	ldr	r3, [pc, #120]	; (8008ef4 <DMA_DeInit+0xbc>)
 8008e7a:	4298      	cmp	r0, r3
 8008e7c:	d104      	bne.n	8008e88 <DMA_DeInit+0x50>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8008e7e:	3b80      	subs	r3, #128	; 0x80
 8008e80:	685a      	ldr	r2, [r3, #4]
 8008e82:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 8008e86:	e026      	b.n	8008ed6 <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8008e88:	4b1b      	ldr	r3, [pc, #108]	; (8008ef8 <DMA_DeInit+0xc0>)
 8008e8a:	4298      	cmp	r0, r3
 8008e8c:	d104      	bne.n	8008e98 <DMA_DeInit+0x60>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8008e8e:	3b08      	subs	r3, #8
 8008e90:	685a      	ldr	r2, [r3, #4]
 8008e92:	f042 020f 	orr.w	r2, r2, #15
 8008e96:	e01e      	b.n	8008ed6 <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8008e98:	4b18      	ldr	r3, [pc, #96]	; (8008efc <DMA_DeInit+0xc4>)
 8008e9a:	4298      	cmp	r0, r3
 8008e9c:	d104      	bne.n	8008ea8 <DMA_DeInit+0x70>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 8008e9e:	3b1c      	subs	r3, #28
 8008ea0:	685a      	ldr	r2, [r3, #4]
 8008ea2:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 8008ea6:	e016      	b.n	8008ed6 <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 8008ea8:	4b15      	ldr	r3, [pc, #84]	; (8008f00 <DMA_DeInit+0xc8>)
 8008eaa:	4298      	cmp	r0, r3
 8008eac:	d104      	bne.n	8008eb8 <DMA_DeInit+0x80>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 8008eae:	3b30      	subs	r3, #48	; 0x30
 8008eb0:	685a      	ldr	r2, [r3, #4]
 8008eb2:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 8008eb6:	e00e      	b.n	8008ed6 <DMA_DeInit+0x9e>
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 8008eb8:	4b12      	ldr	r3, [pc, #72]	; (8008f04 <DMA_DeInit+0xcc>)
 8008eba:	4298      	cmp	r0, r3
 8008ebc:	d104      	bne.n	8008ec8 <DMA_DeInit+0x90>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8008ebe:	3b44      	subs	r3, #68	; 0x44
 8008ec0:	685a      	ldr	r2, [r3, #4]
 8008ec2:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 8008ec6:	e006      	b.n	8008ed6 <DMA_DeInit+0x9e>
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8008ec8:	4b0f      	ldr	r3, [pc, #60]	; (8008f08 <DMA_DeInit+0xd0>)
 8008eca:	4298      	cmp	r0, r3
 8008ecc:	d104      	bne.n	8008ed8 <DMA_DeInit+0xa0>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 8008ece:	3b58      	subs	r3, #88	; 0x58
 8008ed0:	685a      	ldr	r2, [r3, #4]
 8008ed2:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 8008ed6:	605a      	str	r2, [r3, #4]
    }
  }
}
 8008ed8:	4770      	bx	lr
 8008eda:	bf00      	nop
 8008edc:	40020008 	.word	0x40020008
 8008ee0:	4002001c 	.word	0x4002001c
 8008ee4:	40020030 	.word	0x40020030
 8008ee8:	40020044 	.word	0x40020044
 8008eec:	40020058 	.word	0x40020058
 8008ef0:	4002006c 	.word	0x4002006c
 8008ef4:	40020080 	.word	0x40020080
 8008ef8:	40020408 	.word	0x40020408
 8008efc:	4002041c 	.word	0x4002041c
 8008f00:	40020430 	.word	0x40020430
 8008f04:	40020444 	.word	0x40020444
 8008f08:	40020458 	.word	0x40020458

08008f0c <DMA_Init>:
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008f0c:	f8d1 c020 	ldr.w	ip, [r1, #32]
 8008f10:	688b      	ldr	r3, [r1, #8]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 8008f12:	6802      	ldr	r2, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008f14:	ea4c 0303 	orr.w	r3, ip, r3
 8008f18:	f8d1 c010 	ldr.w	ip, [r1, #16]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8008f1c:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008f20:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8008f24:	f8d1 c014 	ldr.w	ip, [r1, #20]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8008f28:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8008f2c:	ea43 030c 	orr.w	r3, r3, ip
 8008f30:	f8d1 c018 	ldr.w	ip, [r1, #24]
 8008f34:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8008f38:	f8d1 c01c 	ldr.w	ip, [r1, #28]
 8008f3c:	ea43 030c 	orr.w	r3, r3, ip
 8008f40:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
 8008f44:	ea43 030c 	orr.w	r3, r3, ip
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8008f48:	f8d1 c028 	ldr.w	ip, [r1, #40]	; 0x28
 8008f4c:	ea43 030c 	orr.w	r3, r3, ip
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8008f50:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8008f52:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8008f54:	68cb      	ldr	r3, [r1, #12]
 8008f56:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8008f58:	680b      	ldr	r3, [r1, #0]
 8008f5a:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8008f5c:	684b      	ldr	r3, [r1, #4]
 8008f5e:	60c3      	str	r3, [r0, #12]
}
 8008f60:	4770      	bx	lr

08008f62 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8008f62:	2300      	movs	r3, #0
 8008f64:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 8008f66:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 8008f68:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8008f6a:	60c3      	str	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8008f6c:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8008f6e:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8008f70:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8008f72:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8008f74:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8008f76:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 8008f78:	6283      	str	r3, [r0, #40]	; 0x28
}
 8008f7a:	4770      	bx	lr

08008f7c <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008f7c:	b119      	cbz	r1, 8008f86 <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= CCR_ENABLE_Set;
 8008f7e:	6803      	ldr	r3, [r0, #0]
 8008f80:	f043 0301 	orr.w	r3, r3, #1
 8008f84:	e002      	b.n	8008f8c <DMA_Cmd+0x10>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 8008f86:	6803      	ldr	r3, [r0, #0]
 8008f88:	f023 0301 	bic.w	r3, r3, #1
 8008f8c:	6003      	str	r3, [r0, #0]
  }
}
 8008f8e:	4770      	bx	lr

08008f90 <DMA_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f90:	b112      	cbz	r2, 8008f98 <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8008f92:	6803      	ldr	r3, [r0, #0]
 8008f94:	4319      	orrs	r1, r3
 8008f96:	e002      	b.n	8008f9e <DMA_ITConfig+0xe>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 8008f98:	6803      	ldr	r3, [r0, #0]
 8008f9a:	ea23 0101 	bic.w	r1, r3, r1
 8008f9e:	6001      	str	r1, [r0, #0]
  }
}
 8008fa0:	4770      	bx	lr
	...

08008fa4 <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
  /* Calculate the used DMA */

  if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8008fa4:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
  {
    /* Clear the selected DMA flags */
    DMA2->IFCR = DMA_FLAG;
 8008fa8:	bf14      	ite	ne
 8008faa:	4b02      	ldrne	r3, [pc, #8]	; (8008fb4 <DMA_ClearFlag+0x10>)
  }
  else
  {
    /* Clear the selected DMA flags */
    DMA1->IFCR = DMA_FLAG;
 8008fac:	4b02      	ldreq	r3, [pc, #8]	; (8008fb8 <DMA_ClearFlag+0x14>)
 8008fae:	6058      	str	r0, [r3, #4]
  }
}
 8008fb0:	4770      	bx	lr
 8008fb2:	bf00      	nop
 8008fb4:	40020400 	.word	0x40020400
 8008fb8:	40020000 	.word	0x40020000

08008fbc <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8008fbc:	4a2d      	ldr	r2, [pc, #180]	; (8009074 <TIM_TimeBaseInit+0xb8>)
 8008fbe:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 8009078 <TIM_TimeBaseInit+0xbc>
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8008fc2:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8008fc4:	4290      	cmp	r0, r2
 8008fc6:	bf14      	ite	ne
 8008fc8:	2200      	movne	r2, #0
 8008fca:	2201      	moveq	r2, #1
 8008fcc:	4560      	cmp	r0, ip
 8008fce:	bf08      	it	eq
 8008fd0:	f042 0201 	orreq.w	r2, r2, #1
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
  *   structure that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8008fd4:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8008fd6:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8008fd8:	b9ca      	cbnz	r2, 800900e <TIM_TimeBaseInit+0x52>
 8008fda:	4c28      	ldr	r4, [pc, #160]	; (800907c <TIM_TimeBaseInit+0xc0>)
 8008fdc:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8008fe0:	bf14      	ite	ne
 8008fe2:	f04f 0c00 	movne.w	ip, #0
 8008fe6:	f04f 0c01 	moveq.w	ip, #1
 8008fea:	42a0      	cmp	r0, r4
 8008fec:	bf14      	ite	ne
 8008fee:	4664      	movne	r4, ip
 8008ff0:	f04c 0401 	orreq.w	r4, ip, #1
 8008ff4:	b95c      	cbnz	r4, 800900e <TIM_TimeBaseInit+0x52>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8008ff6:	4c22      	ldr	r4, [pc, #136]	; (8009080 <TIM_TimeBaseInit+0xc4>)
 8008ff8:	f8df c088 	ldr.w	ip, [pc, #136]	; 8009084 <TIM_TimeBaseInit+0xc8>
 8008ffc:	42a0      	cmp	r0, r4
 8008ffe:	bf14      	ite	ne
 8009000:	2400      	movne	r4, #0
 8009002:	2401      	moveq	r4, #1
 8009004:	4560      	cmp	r0, ip
 8009006:	bf08      	it	eq
 8009008:	f044 0401 	orreq.w	r4, r4, #1
 800900c:	b12c      	cbz	r4, 800901a <TIM_TimeBaseInit+0x5e>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800900e:	f8b1 c002 	ldrh.w	ip, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 8009012:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8009016:	ea43 030c 	orr.w	r3, r3, ip
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 800901a:	4c1b      	ldr	r4, [pc, #108]	; (8009088 <TIM_TimeBaseInit+0xcc>)
 800901c:	f8df c06c 	ldr.w	ip, [pc, #108]	; 800908c <TIM_TimeBaseInit+0xd0>
 8009020:	1b04      	subs	r4, r0, r4
 8009022:	bf18      	it	ne
 8009024:	2401      	movne	r4, #1
 8009026:	4560      	cmp	r0, ip
 8009028:	bf0c      	ite	eq
 800902a:	2400      	moveq	r4, #0
 800902c:	f004 0401 	andne.w	r4, r4, #1
 8009030:	b134      	cbz	r4, 8009040 <TIM_TimeBaseInit+0x84>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 8009032:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8009036:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 800903a:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800903c:	ea43 030c 	orr.w	r3, r3, ip
  }

  TIMx->CR1 = tmpcr1;
 8009040:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8009042:	888b      	ldrh	r3, [r1, #4]
 8009044:	8583      	strh	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8009046:	880b      	ldrh	r3, [r1, #0]
 8009048:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 800904a:	b96a      	cbnz	r2, 8009068 <TIM_TimeBaseInit+0xac>
 800904c:	4b10      	ldr	r3, [pc, #64]	; (8009090 <TIM_TimeBaseInit+0xd4>)
 800904e:	4a11      	ldr	r2, [pc, #68]	; (8009094 <TIM_TimeBaseInit+0xd8>)
 8009050:	4298      	cmp	r0, r3
 8009052:	bf14      	ite	ne
 8009054:	2300      	movne	r3, #0
 8009056:	2301      	moveq	r3, #1
 8009058:	4290      	cmp	r0, r2
 800905a:	bf08      	it	eq
 800905c:	f043 0301 	orreq.w	r3, r3, #1
 8009060:	b913      	cbnz	r3, 8009068 <TIM_TimeBaseInit+0xac>
 8009062:	4b0d      	ldr	r3, [pc, #52]	; (8009098 <TIM_TimeBaseInit+0xdc>)
 8009064:	4298      	cmp	r0, r3
 8009066:	d101      	bne.n	800906c <TIM_TimeBaseInit+0xb0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8009068:	7a0b      	ldrb	r3, [r1, #8]
 800906a:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 800906c:	2301      	movs	r3, #1
 800906e:	8283      	strh	r3, [r0, #20]
}
 8009070:	bd10      	pop	{r4, pc}
 8009072:	bf00      	nop
 8009074:	40012c00 	.word	0x40012c00
 8009078:	40013400 	.word	0x40013400
 800907c:	40000400 	.word	0x40000400
 8009080:	40000800 	.word	0x40000800
 8009084:	40000c00 	.word	0x40000c00
 8009088:	40001000 	.word	0x40001000
 800908c:	40001400 	.word	0x40001400
 8009090:	40014000 	.word	0x40014000
 8009094:	40014400 	.word	0x40014400
 8009098:	40014800 	.word	0x40014800

0800909c <TIM_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800909c:	b121      	cbz	r1, 80090a8 <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 800909e:	8803      	ldrh	r3, [r0, #0]
 80090a0:	b29b      	uxth	r3, r3
 80090a2:	f043 0301 	orr.w	r3, r3, #1
 80090a6:	e004      	b.n	80090b2 <TIM_Cmd+0x16>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 80090a8:	8803      	ldrh	r3, [r0, #0]
 80090aa:	f023 0301 	bic.w	r3, r3, #1
 80090ae:	041b      	lsls	r3, r3, #16
 80090b0:	0c1b      	lsrs	r3, r3, #16
 80090b2:	8003      	strh	r3, [r0, #0]
  }
}
 80090b4:	4770      	bx	lr

080090b6 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 80090b6:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 80090b8:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80090ba:	4211      	tst	r1, r2
 80090bc:	bf0c      	ite	eq
 80090be:	2000      	moveq	r0, #0
 80090c0:	2001      	movne	r0, #1
 80090c2:	4219      	tst	r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 80090c4:	bf0c      	ite	eq
 80090c6:	2000      	moveq	r0, #0
 80090c8:	f000 0001 	andne.w	r0, r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80090cc:	4770      	bx	lr

080090ce <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 80090ce:	43c9      	mvns	r1, r1
 80090d0:	b289      	uxth	r1, r1
 80090d2:	8201      	strh	r1, [r0, #16]
}
 80090d4:	4770      	bx	lr
	...

080090d8 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80090d8:	4b0d      	ldr	r3, [pc, #52]	; (8009110 <RCC_DeInit+0x38>)
 80090da:	681a      	ldr	r2, [r3, #0]
 80090dc:	f042 0201 	orr.w	r2, r2, #1
 80090e0:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 80090e2:	6859      	ldr	r1, [r3, #4]
 80090e4:	4a0b      	ldr	r2, [pc, #44]	; (8009114 <RCC_DeInit+0x3c>)
 80090e6:	ea01 0202 	and.w	r2, r1, r2
 80090ea:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80090ec:	681a      	ldr	r2, [r3, #0]
 80090ee:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80090f2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80090f6:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80090f8:	681a      	ldr	r2, [r3, #0]
 80090fa:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80090fe:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8009100:	685a      	ldr	r2, [r3, #4]
 8009102:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8009106:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8009108:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 800910c:	609a      	str	r2, [r3, #8]
#endif /* STM32F10X_CL */

}
 800910e:	4770      	bx	lr
 8009110:	40021000 	.word	0x40021000
 8009114:	f8ff0000 	.word	0xf8ff0000

08009118 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8009118:	4b0c      	ldr	r3, [pc, #48]	; (800914c <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 800911a:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 800911e:	681a      	ldr	r2, [r3, #0]
 8009120:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009124:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 8009126:	681a      	ldr	r2, [r3, #0]
 8009128:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800912c:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 800912e:	d003      	beq.n	8009138 <RCC_HSEConfig+0x20>
 8009130:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8009134:	d108      	bne.n	8009148 <RCC_HSEConfig+0x30>
 8009136:	e003      	b.n	8009140 <RCC_HSEConfig+0x28>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 8009138:	681a      	ldr	r2, [r3, #0]
 800913a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800913e:	e002      	b.n	8009146 <RCC_HSEConfig+0x2e>
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 8009140:	681a      	ldr	r2, [r3, #0]
 8009142:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8009146:	601a      	str	r2, [r3, #0]
      break;
      
    default:
      break;
  }
}
 8009148:	4770      	bx	lr
 800914a:	bf00      	nop
 800914c:	40021000 	.word	0x40021000

08009150 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8009150:	4b03      	ldr	r3, [pc, #12]	; (8009160 <RCC_PLLConfig+0x10>)
 8009152:	685a      	ldr	r2, [r3, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 8009154:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8009158:	4310      	orrs	r0, r2
 800915a:	4308      	orrs	r0, r1
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800915c:	6058      	str	r0, [r3, #4]
}
 800915e:	4770      	bx	lr
 8009160:	40021000 	.word	0x40021000

08009164 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8009164:	4b01      	ldr	r3, [pc, #4]	; (800916c <RCC_PLLCmd+0x8>)
 8009166:	6018      	str	r0, [r3, #0]
}
 8009168:	4770      	bx	lr
 800916a:	bf00      	nop
 800916c:	42420060 	.word	0x42420060

08009170 <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8009170:	4b03      	ldr	r3, [pc, #12]	; (8009180 <RCC_SYSCLKConfig+0x10>)
 8009172:	685a      	ldr	r2, [r3, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 8009174:	f022 0203 	bic.w	r2, r2, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8009178:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800917a:	6058      	str	r0, [r3, #4]
}
 800917c:	4770      	bx	lr
 800917e:	bf00      	nop
 8009180:	40021000 	.word	0x40021000

08009184 <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8009184:	4b02      	ldr	r3, [pc, #8]	; (8009190 <RCC_GetSYSCLKSource+0xc>)
 8009186:	6858      	ldr	r0, [r3, #4]
 8009188:	f000 000c 	and.w	r0, r0, #12
}
 800918c:	4770      	bx	lr
 800918e:	bf00      	nop
 8009190:	40021000 	.word	0x40021000

08009194 <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8009194:	4b03      	ldr	r3, [pc, #12]	; (80091a4 <RCC_HCLKConfig+0x10>)
 8009196:	685a      	ldr	r2, [r3, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8009198:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 800919c:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800919e:	6058      	str	r0, [r3, #4]
}
 80091a0:	4770      	bx	lr
 80091a2:	bf00      	nop
 80091a4:	40021000 	.word	0x40021000

080091a8 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80091a8:	4b03      	ldr	r3, [pc, #12]	; (80091b8 <RCC_PCLK1Config+0x10>)
 80091aa:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 80091ac:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80091b0:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80091b2:	6058      	str	r0, [r3, #4]
}
 80091b4:	4770      	bx	lr
 80091b6:	bf00      	nop
 80091b8:	40021000 	.word	0x40021000

080091bc <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80091bc:	4b03      	ldr	r3, [pc, #12]	; (80091cc <RCC_PCLK2Config+0x10>)
 80091be:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 80091c0:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80091c4:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80091c8:	6058      	str	r0, [r3, #4]
}
 80091ca:	4770      	bx	lr
 80091cc:	40021000 	.word	0x40021000

080091d0 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 80091d0:	4b01      	ldr	r3, [pc, #4]	; (80091d8 <RCC_USBCLKConfig+0x8>)
 80091d2:	6018      	str	r0, [r3, #0]
}
 80091d4:	4770      	bx	lr
 80091d6:	bf00      	nop
 80091d8:	424200d8 	.word	0x424200d8

080091dc <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 80091dc:	4b03      	ldr	r3, [pc, #12]	; (80091ec <RCC_ADCCLKConfig+0x10>)
 80091de:	685a      	ldr	r2, [r3, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 80091e0:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 80091e4:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80091e6:	6058      	str	r0, [r3, #4]
}
 80091e8:	4770      	bx	lr
 80091ea:	bf00      	nop
 80091ec:	40021000 	.word	0x40021000

080091f0 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 80091f0:	4b02      	ldr	r3, [pc, #8]	; (80091fc <RCC_RTCCLKConfig+0xc>)
 80091f2:	6a1a      	ldr	r2, [r3, #32]
 80091f4:	4310      	orrs	r0, r2
 80091f6:	6218      	str	r0, [r3, #32]
}
 80091f8:	4770      	bx	lr
 80091fa:	bf00      	nop
 80091fc:	40021000 	.word	0x40021000

08009200 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8009200:	4b01      	ldr	r3, [pc, #4]	; (8009208 <RCC_RTCCLKCmd+0x8>)
 8009202:	6018      	str	r0, [r3, #0]
}
 8009204:	4770      	bx	lr
 8009206:	bf00      	nop
 8009208:	4242043c 	.word	0x4242043c

0800920c <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 800920c:	4b22      	ldr	r3, [pc, #136]	; (8009298 <RCC_GetClocksFreq+0x8c>)
 800920e:	685a      	ldr	r2, [r3, #4]
 8009210:	f002 020c 	and.w	r2, r2, #12
  
  switch (tmp)
 8009214:	2a04      	cmp	r2, #4
 8009216:	d002      	beq.n	800921e <RCC_GetClocksFreq+0x12>
 8009218:	2a08      	cmp	r2, #8
 800921a:	d115      	bne.n	8009248 <RCC_GetClocksFreq+0x3c>
 800921c:	e001      	b.n	8009222 <RCC_GetClocksFreq+0x16>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
 800921e:	4b1f      	ldr	r3, [pc, #124]	; (800929c <RCC_GetClocksFreq+0x90>)
 8009220:	e013      	b.n	800924a <RCC_GetClocksFreq+0x3e>
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8009222:	685a      	ldr	r2, [r3, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8009224:	6859      	ldr	r1, [r3, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8009226:	f3c2 4283 	ubfx	r2, r2, #18, #4
 800922a:	3202      	adds	r2, #2
      
      if (pllsource == 0x00)
 800922c:	f411 3f80 	tst.w	r1, #65536	; 0x10000
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
 8009230:	bf08      	it	eq
 8009232:	4b1b      	ldreq	r3, [pc, #108]	; (80092a0 <RCC_GetClocksFreq+0x94>)
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
      
      if (pllsource == 0x00)
 8009234:	d005      	beq.n	8009242 <RCC_GetClocksFreq+0x36>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8009236:	685b      	ldr	r3, [r3, #4]
 8009238:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 800923c:	bf14      	ite	ne
 800923e:	4b19      	ldrne	r3, [pc, #100]	; (80092a4 <RCC_GetClocksFreq+0x98>)
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 8009240:	4b16      	ldreq	r3, [pc, #88]	; (800929c <RCC_GetClocksFreq+0x90>)
 8009242:	435a      	muls	r2, r3
 8009244:	6002      	str	r2, [r0, #0]
 8009246:	e001      	b.n	800924c <RCC_GetClocksFreq+0x40>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 8009248:	4b17      	ldr	r3, [pc, #92]	; (80092a8 <RCC_GetClocksFreq+0x9c>)
 800924a:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 800924c:	4b12      	ldr	r3, [pc, #72]	; (8009298 <RCC_GetClocksFreq+0x8c>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 800924e:	4917      	ldr	r1, [pc, #92]	; (80092ac <RCC_GetClocksFreq+0xa0>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8009250:	685a      	ldr	r2, [r3, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8009252:	f8d0 c000 	ldr.w	ip, [r0]
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
  tmp = tmp >> 4;
 8009256:	f3c2 1203 	ubfx	r2, r2, #4, #4
  presc = APBAHBPrescTable[tmp];
 800925a:	5c8a      	ldrb	r2, [r1, r2]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800925c:	fa2c f202 	lsr.w	r2, ip, r2
 8009260:	6042      	str	r2, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8009262:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 8;
 8009266:	f3cc 2c02 	ubfx	ip, ip, #8, #3
  presc = APBAHBPrescTable[tmp];
 800926a:	f811 c00c 	ldrb.w	ip, [r1, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800926e:	fa22 fc0c 	lsr.w	ip, r2, ip
 8009272:	f8c0 c008 	str.w	ip, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8009276:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 11;
 800927a:	f3cc 2cc2 	ubfx	ip, ip, #11, #3
  presc = APBAHBPrescTable[tmp];
 800927e:	f811 100c 	ldrb.w	r1, [r1, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8009282:	40ca      	lsrs	r2, r1
 8009284:	60c2      	str	r2, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8009286:	685b      	ldr	r3, [r3, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
 8009288:	4909      	ldr	r1, [pc, #36]	; (80092b0 <RCC_GetClocksFreq+0xa4>)
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
 800928a:	f3c3 3381 	ubfx	r3, r3, #14, #2
  presc = ADCPrescTable[tmp];
 800928e:	5ccb      	ldrb	r3, [r1, r3]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8009290:	fbb2 f2f3 	udiv	r2, r2, r3
 8009294:	6102      	str	r2, [r0, #16]
}
 8009296:	4770      	bx	lr
 8009298:	40021000 	.word	0x40021000
 800929c:	00b71b00 	.word	0x00b71b00
 80092a0:	003d0900 	.word	0x003d0900
 80092a4:	005b8d80 	.word	0x005b8d80
 80092a8:	007a1200 	.word	0x007a1200
 80092ac:	20000048 	.word	0x20000048
 80092b0:	20000044 	.word	0x20000044

080092b4 <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80092b4:	b119      	cbz	r1, 80092be <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80092b6:	4b05      	ldr	r3, [pc, #20]	; (80092cc <RCC_AHBPeriphClockCmd+0x18>)
 80092b8:	695a      	ldr	r2, [r3, #20]
 80092ba:	4310      	orrs	r0, r2
 80092bc:	e003      	b.n	80092c6 <RCC_AHBPeriphClockCmd+0x12>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80092be:	4b03      	ldr	r3, [pc, #12]	; (80092cc <RCC_AHBPeriphClockCmd+0x18>)
 80092c0:	695a      	ldr	r2, [r3, #20]
 80092c2:	ea22 0000 	bic.w	r0, r2, r0
 80092c6:	6158      	str	r0, [r3, #20]
  }
}
 80092c8:	4770      	bx	lr
 80092ca:	bf00      	nop
 80092cc:	40021000 	.word	0x40021000

080092d0 <RCC_APB2PeriphClockCmd>:
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80092d0:	b119      	cbz	r1, 80092da <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80092d2:	4b05      	ldr	r3, [pc, #20]	; (80092e8 <RCC_APB2PeriphClockCmd+0x18>)
 80092d4:	699a      	ldr	r2, [r3, #24]
 80092d6:	4310      	orrs	r0, r2
 80092d8:	e003      	b.n	80092e2 <RCC_APB2PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80092da:	4b03      	ldr	r3, [pc, #12]	; (80092e8 <RCC_APB2PeriphClockCmd+0x18>)
 80092dc:	699a      	ldr	r2, [r3, #24]
 80092de:	ea22 0000 	bic.w	r0, r2, r0
 80092e2:	6198      	str	r0, [r3, #24]
  }
}
 80092e4:	4770      	bx	lr
 80092e6:	bf00      	nop
 80092e8:	40021000 	.word	0x40021000

080092ec <RCC_APB1PeriphClockCmd>:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80092ec:	b119      	cbz	r1, 80092f6 <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80092ee:	4b05      	ldr	r3, [pc, #20]	; (8009304 <RCC_APB1PeriphClockCmd+0x18>)
 80092f0:	69da      	ldr	r2, [r3, #28]
 80092f2:	4310      	orrs	r0, r2
 80092f4:	e003      	b.n	80092fe <RCC_APB1PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80092f6:	4b03      	ldr	r3, [pc, #12]	; (8009304 <RCC_APB1PeriphClockCmd+0x18>)
 80092f8:	69da      	ldr	r2, [r3, #28]
 80092fa:	ea22 0000 	bic.w	r0, r2, r0
 80092fe:	61d8      	str	r0, [r3, #28]
  }
}
 8009300:	4770      	bx	lr
 8009302:	bf00      	nop
 8009304:	40021000 	.word	0x40021000

08009308 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009308:	b119      	cbz	r1, 8009312 <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800930a:	4b05      	ldr	r3, [pc, #20]	; (8009320 <RCC_APB2PeriphResetCmd+0x18>)
 800930c:	68da      	ldr	r2, [r3, #12]
 800930e:	4310      	orrs	r0, r2
 8009310:	e003      	b.n	800931a <RCC_APB2PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8009312:	4b03      	ldr	r3, [pc, #12]	; (8009320 <RCC_APB2PeriphResetCmd+0x18>)
 8009314:	68da      	ldr	r2, [r3, #12]
 8009316:	ea22 0000 	bic.w	r0, r2, r0
 800931a:	60d8      	str	r0, [r3, #12]
  }
}
 800931c:	4770      	bx	lr
 800931e:	bf00      	nop
 8009320:	40021000 	.word	0x40021000

08009324 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009324:	b119      	cbz	r1, 800932e <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8009326:	4b05      	ldr	r3, [pc, #20]	; (800933c <RCC_APB1PeriphResetCmd+0x18>)
 8009328:	691a      	ldr	r2, [r3, #16]
 800932a:	4310      	orrs	r0, r2
 800932c:	e003      	b.n	8009336 <RCC_APB1PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 800932e:	4b03      	ldr	r3, [pc, #12]	; (800933c <RCC_APB1PeriphResetCmd+0x18>)
 8009330:	691a      	ldr	r2, [r3, #16]
 8009332:	ea22 0000 	bic.w	r0, r2, r0
 8009336:	6118      	str	r0, [r3, #16]
  }
}
 8009338:	4770      	bx	lr
 800933a:	bf00      	nop
 800933c:	40021000 	.word	0x40021000

08009340 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8009340:	4b01      	ldr	r3, [pc, #4]	; (8009348 <RCC_BackupResetCmd+0x8>)
 8009342:	6018      	str	r0, [r3, #0]
}
 8009344:	4770      	bx	lr
 8009346:	bf00      	nop
 8009348:	42420440 	.word	0x42420440

0800934c <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 800934c:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 800934e:	2b01      	cmp	r3, #1
  {
    statusreg = RCC->CR;
 8009350:	bf04      	itt	eq
 8009352:	4b08      	ldreq	r3, [pc, #32]	; (8009374 <RCC_GetFlagStatus+0x28>)
 8009354:	681b      	ldreq	r3, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
 8009356:	d005      	beq.n	8009364 <RCC_GetFlagStatus+0x18>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8009358:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 800935a:	bf0b      	itete	eq
 800935c:	4b05      	ldreq	r3, [pc, #20]	; (8009374 <RCC_GetFlagStatus+0x28>)
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800935e:	4b05      	ldrne	r3, [pc, #20]	; (8009374 <RCC_GetFlagStatus+0x28>)
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 8009360:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8009362:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 8009364:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8009368:	fa33 f000 	lsrs.w	r0, r3, r0
  {
    statusreg = RCC->BDCR;
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800936c:	f000 0001 	and.w	r0, r0, #1
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8009370:	4770      	bx	lr
 8009372:	bf00      	nop
 8009374:	40021000 	.word	0x40021000

08009378 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8009378:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 800937a:	2300      	movs	r3, #0
 800937c:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 800937e:	2031      	movs	r0, #49	; 0x31
 8009380:	f7ff ffe4 	bl	800934c <RCC_GetFlagStatus>
    StartUpCounter++;  
 8009384:	9b01      	ldr	r3, [sp, #4]
 8009386:	3301      	adds	r3, #1
 8009388:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
 800938a:	9b01      	ldr	r3, [sp, #4]
 800938c:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8009390:	d001      	beq.n	8009396 <RCC_WaitForHSEStartUp+0x1e>
 8009392:	2800      	cmp	r0, #0
 8009394:	d0f3      	beq.n	800937e <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8009396:	2031      	movs	r0, #49	; 0x31
 8009398:	f7ff ffd8 	bl	800934c <RCC_GetFlagStatus>
 800939c:	3800      	subs	r0, #0
 800939e:	bf18      	it	ne
 80093a0:	2001      	movne	r0, #1
  else
  {
    status = ERROR;
  }  
  return (status);
}
 80093a2:	bd0e      	pop	{r1, r2, r3, pc}

080093a4 <RTC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80093a4:	b121      	cbz	r1, 80093b0 <RTC_ITConfig+0xc>
  {
    RTC->CRH |= RTC_IT;
 80093a6:	4b06      	ldr	r3, [pc, #24]	; (80093c0 <RTC_ITConfig+0x1c>)
 80093a8:	881a      	ldrh	r2, [r3, #0]
 80093aa:	b292      	uxth	r2, r2
 80093ac:	4310      	orrs	r0, r2
 80093ae:	e004      	b.n	80093ba <RTC_ITConfig+0x16>
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
 80093b0:	4b03      	ldr	r3, [pc, #12]	; (80093c0 <RTC_ITConfig+0x1c>)
 80093b2:	881a      	ldrh	r2, [r3, #0]
 80093b4:	b292      	uxth	r2, r2
 80093b6:	ea22 0000 	bic.w	r0, r2, r0
 80093ba:	8018      	strh	r0, [r3, #0]
  }
}
 80093bc:	4770      	bx	lr
 80093be:	bf00      	nop
 80093c0:	40002800 	.word	0x40002800

080093c4 <RTC_EnterConfigMode>:
  * @retval None
  */
void RTC_EnterConfigMode(void)
{
  /* Set the CNF flag to enter in the Configuration Mode */
  RTC->CRL |= CRL_CNF_Set;
 80093c4:	4b03      	ldr	r3, [pc, #12]	; (80093d4 <RTC_EnterConfigMode+0x10>)
 80093c6:	889a      	ldrh	r2, [r3, #4]
 80093c8:	b292      	uxth	r2, r2
 80093ca:	f042 0210 	orr.w	r2, r2, #16
 80093ce:	809a      	strh	r2, [r3, #4]
}
 80093d0:	4770      	bx	lr
 80093d2:	bf00      	nop
 80093d4:	40002800 	.word	0x40002800

080093d8 <RTC_ExitConfigMode>:
  * @retval None
  */
void RTC_ExitConfigMode(void)
{
  /* Reset the CNF flag to exit from the Configuration Mode */
  RTC->CRL &= CRL_CNF_Reset;
 80093d8:	4a03      	ldr	r2, [pc, #12]	; (80093e8 <RTC_ExitConfigMode+0x10>)
 80093da:	8893      	ldrh	r3, [r2, #4]
 80093dc:	f023 0310 	bic.w	r3, r3, #16
 80093e0:	041b      	lsls	r3, r3, #16
 80093e2:	0c1b      	lsrs	r3, r3, #16
 80093e4:	8093      	strh	r3, [r2, #4]
}
 80093e6:	4770      	bx	lr
 80093e8:	40002800 	.word	0x40002800

080093ec <RTC_SetCounter>:
  * @brief  Sets the RTC counter value.
  * @param  CounterValue: RTC counter new value.
  * @retval None
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
 80093ec:	b510      	push	{r4, lr}
 80093ee:	4604      	mov	r4, r0
  RTC_EnterConfigMode();
 80093f0:	f7ff ffe8 	bl	80093c4 <RTC_EnterConfigMode>
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 80093f4:	4b03      	ldr	r3, [pc, #12]	; (8009404 <RTC_SetCounter+0x18>)
 80093f6:	0c22      	lsrs	r2, r4, #16
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 80093f8:	b2a4      	uxth	r4, r4
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
  RTC_EnterConfigMode();
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 80093fa:	831a      	strh	r2, [r3, #24]
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_Mask);
 80093fc:	839c      	strh	r4, [r3, #28]
  RTC_ExitConfigMode();
 80093fe:	f7ff ffeb 	bl	80093d8 <RTC_ExitConfigMode>
}
 8009402:	bd10      	pop	{r4, pc}
 8009404:	40002800 	.word	0x40002800

08009408 <RTC_SetPrescaler>:
  * @brief  Sets the RTC prescaler value.
  * @param  PrescalerValue: RTC prescaler new value.
  * @retval None
  */
void RTC_SetPrescaler(uint32_t PrescalerValue)
{
 8009408:	b510      	push	{r4, lr}
 800940a:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
 800940c:	f7ff ffda 	bl	80093c4 <RTC_EnterConfigMode>
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 8009410:	4b04      	ldr	r3, [pc, #16]	; (8009424 <RTC_SetPrescaler+0x1c>)
 8009412:	f3c4 4203 	ubfx	r2, r4, #16, #4
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 8009416:	b2a4      	uxth	r4, r4
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
 8009418:	811a      	strh	r2, [r3, #8]
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
 800941a:	819c      	strh	r4, [r3, #12]
  RTC_ExitConfigMode();
 800941c:	f7ff ffdc 	bl	80093d8 <RTC_ExitConfigMode>
}
 8009420:	bd10      	pop	{r4, pc}
 8009422:	bf00      	nop
 8009424:	40002800 	.word	0x40002800

08009428 <RTC_WaitForLastTask>:
  * @retval None
  */
void RTC_WaitForLastTask(void)
{
  /* Loop until RTOFF flag is set */
  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
 8009428:	4b02      	ldr	r3, [pc, #8]	; (8009434 <RTC_WaitForLastTask+0xc>)
 800942a:	889a      	ldrh	r2, [r3, #4]
 800942c:	f012 0f20 	tst.w	r2, #32
 8009430:	d0fb      	beq.n	800942a <RTC_WaitForLastTask+0x2>
  {
  }
}
 8009432:	4770      	bx	lr
 8009434:	40002800 	.word	0x40002800

08009438 <RTC_WaitForSynchro>:
  * @retval None
  */
void RTC_WaitForSynchro(void)
{
  /* Clear RSF flag */
  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
 8009438:	4a05      	ldr	r2, [pc, #20]	; (8009450 <RTC_WaitForSynchro+0x18>)
 800943a:	8893      	ldrh	r3, [r2, #4]
 800943c:	f023 0308 	bic.w	r3, r3, #8
 8009440:	041b      	lsls	r3, r3, #16
 8009442:	0c1b      	lsrs	r3, r3, #16
 8009444:	8093      	strh	r3, [r2, #4]
  /* Loop until RSF flag is set */
  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
 8009446:	8893      	ldrh	r3, [r2, #4]
 8009448:	f013 0f08 	tst.w	r3, #8
 800944c:	d0fb      	beq.n	8009446 <RTC_WaitForSynchro+0xe>
  {
  }
}
 800944e:	4770      	bx	lr
 8009450:	40002800 	.word	0x40002800

08009454 <BKP_DeInit>:
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
  RCC_BackupResetCmd(ENABLE);
 8009454:	2001      	movs	r0, #1
  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
 8009456:	b508      	push	{r3, lr}
  RCC_BackupResetCmd(ENABLE);
 8009458:	f7ff ff72 	bl	8009340 <RCC_BackupResetCmd>
  RCC_BackupResetCmd(DISABLE);
 800945c:	2000      	movs	r0, #0
 800945e:	f7ff ff6f 	bl	8009340 <RCC_BackupResetCmd>
}
 8009462:	bd08      	pop	{r3, pc}

08009464 <PWR_BackupAccessCmd>:
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 8009464:	4b01      	ldr	r3, [pc, #4]	; (800946c <PWR_BackupAccessCmd+0x8>)
 8009466:	6018      	str	r0, [r3, #0]
}
 8009468:	4770      	bx	lr
 800946a:	bf00      	nop
 800946c:	420e0020 	.word	0x420e0020

08009470 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8009470:	f040 60be 	orr.w	r0, r0, #99614720	; 0x5f00000
 8009474:	4b02      	ldr	r3, [pc, #8]	; (8009480 <NVIC_PriorityGroupConfig+0x10>)
 8009476:	f440 2020 	orr.w	r0, r0, #655360	; 0xa0000
 800947a:	60d8      	str	r0, [r3, #12]
}
 800947c:	4770      	bx	lr
 800947e:	bf00      	nop
 8009480:	e000ed00 	.word	0xe000ed00

08009484 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8009484:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8009488:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 800948c:	4b02      	ldr	r3, [pc, #8]	; (8009498 <NVIC_SetVectorTable+0x14>)
 800948e:	ea41 0000 	orr.w	r0, r1, r0
 8009492:	6098      	str	r0, [r3, #8]
}
 8009494:	4770      	bx	lr
 8009496:	bf00      	nop
 8009498:	e000ed00 	.word	0xe000ed00

0800949c <SysTick_CLKSourceConfig>:
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 800949c:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 800949e:	bf0b      	itete	eq
 80094a0:	4b05      	ldreq	r3, [pc, #20]	; (80094b8 <SysTick_CLKSourceConfig+0x1c>)
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80094a2:	4b05      	ldrne	r3, [pc, #20]	; (80094b8 <SysTick_CLKSourceConfig+0x1c>)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80094a4:	681a      	ldreq	r2, [r3, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80094a6:	681a      	ldrne	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80094a8:	bf0c      	ite	eq
 80094aa:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80094ae:	f022 0204 	bicne.w	r2, r2, #4
 80094b2:	601a      	str	r2, [r3, #0]
  }
}
 80094b4:	4770      	bx	lr
 80094b6:	bf00      	nop
 80094b8:	e000e010 	.word	0xe000e010

080094bc <Standard_GetConfiguration>:
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetConfiguration(uint16_t Length)
{
 80094bc:	b510      	push	{r4, lr}
 80094be:	4c06      	ldr	r4, [pc, #24]	; (80094d8 <Standard_GetConfiguration+0x1c>)
  if (Length == 0)
 80094c0:	b918      	cbnz	r0, 80094ca <Standard_GetConfiguration+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 80094c2:	6823      	ldr	r3, [r4, #0]
 80094c4:	2201      	movs	r2, #1
 80094c6:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_Configuration);
    return 0;
 80094c8:	e005      	b.n	80094d6 <Standard_GetConfiguration+0x1a>
  }
  pUser_Standard_Requests->User_GetConfiguration();
 80094ca:	4b04      	ldr	r3, [pc, #16]	; (80094dc <Standard_GetConfiguration+0x20>)
 80094cc:	681b      	ldr	r3, [r3, #0]
 80094ce:	681b      	ldr	r3, [r3, #0]
 80094d0:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_Configuration;
 80094d2:	6820      	ldr	r0, [r4, #0]
 80094d4:	300a      	adds	r0, #10
}
 80094d6:	bd10      	pop	{r4, pc}
 80094d8:	20003794 	.word	0x20003794
 80094dc:	20003790 	.word	0x20003790

080094e0 <Standard_GetInterface>:
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetInterface(uint16_t Length)
{
 80094e0:	b510      	push	{r4, lr}
 80094e2:	4c06      	ldr	r4, [pc, #24]	; (80094fc <Standard_GetInterface+0x1c>)
  if (Length == 0)
 80094e4:	b918      	cbnz	r0, 80094ee <Standard_GetInterface+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 80094e6:	6823      	ldr	r3, [r4, #0]
 80094e8:	2201      	movs	r2, #1
 80094ea:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
 80094ec:	e005      	b.n	80094fa <Standard_GetInterface+0x1a>
  }
  pUser_Standard_Requests->User_GetInterface();
 80094ee:	4b04      	ldr	r3, [pc, #16]	; (8009500 <Standard_GetInterface+0x20>)
 80094f0:	681b      	ldr	r3, [r3, #0]
 80094f2:	689b      	ldr	r3, [r3, #8]
 80094f4:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_AlternateSetting;
 80094f6:	6820      	ldr	r0, [r4, #0]
 80094f8:	300c      	adds	r0, #12
}
 80094fa:	bd10      	pop	{r4, pc}
 80094fc:	20003794 	.word	0x20003794
 8009500:	20003790 	.word	0x20003790

08009504 <Standard_GetStatus>:
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
uint8_t *Standard_GetStatus(uint16_t Length)
{
 8009504:	b508      	push	{r3, lr}
 8009506:	4b27      	ldr	r3, [pc, #156]	; (80095a4 <Standard_GetStatus+0xa0>)
  if (Length == 0)
 8009508:	b918      	cbnz	r0, 8009512 <Standard_GetStatus+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
 800950a:	681b      	ldr	r3, [r3, #0]
 800950c:	2202      	movs	r2, #2
 800950e:	821a      	strh	r2, [r3, #16]
    return 0;
 8009510:	e047      	b.n	80095a2 <Standard_GetStatus+0x9e>
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 8009512:	4825      	ldr	r0, [pc, #148]	; (80095a8 <Standard_GetStatus+0xa4>)
 8009514:	2200      	movs	r2, #0

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009516:	681b      	ldr	r3, [r3, #0]
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 8009518:	8002      	strh	r2, [r0, #0]

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 800951a:	781a      	ldrb	r2, [r3, #0]
 800951c:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009520:	d115      	bne.n	800954e <Standard_GetStatus+0x4a>
  {
    /*Get Device Status */
    uint8_t Feature = pInformation->Current_Feature;

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
 8009522:	7a5b      	ldrb	r3, [r3, #9]
 8009524:	7802      	ldrb	r2, [r0, #0]
 8009526:	f013 0f20 	tst.w	r3, #32
    {
      SetBit(StatusInfo0, 1);
 800952a:	bf14      	ite	ne
 800952c:	f042 0202 	orrne.w	r2, r2, #2
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 8009530:	f022 0202 	biceq.w	r2, r2, #2
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
 8009534:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009538:	4b1b      	ldr	r3, [pc, #108]	; (80095a8 <Standard_GetStatus+0xa4>)
    {
      SetBit(StatusInfo0, 1);
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 800953a:	7002      	strb	r2, [r0, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 800953c:	bf15      	itete	ne
 800953e:	781a      	ldrbne	r2, [r3, #0]
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 8009540:	781a      	ldrbeq	r2, [r3, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
    {
      SetBit(StatusInfo0, 0);
 8009542:	f042 0201 	orrne.w	r2, r2, #1
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 8009546:	f022 0201 	biceq.w	r2, r2, #1
 800954a:	701a      	strb	r2, [r3, #0]
 800954c:	e022      	b.n	8009594 <Standard_GetStatus+0x90>
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 800954e:	2a01      	cmp	r2, #1
 8009550:	d027      	beq.n	80095a2 <Standard_GetStatus+0x9e>
  {
    return (uint8_t *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009552:	2a02      	cmp	r2, #2
 8009554:	d124      	bne.n	80095a0 <Standard_GetStatus+0x9c>
  {
    uint8_t Related_Endpoint;
    uint8_t wIndex0 = pInformation->USBwIndex0;
 8009556:	795a      	ldrb	r2, [r3, #5]

    Related_Endpoint = (wIndex0 & 0x0f);
 8009558:	f002 030f 	and.w	r3, r2, #15
    if (ValBit(wIndex0, 7))
 800955c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009560:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8009564:	d008      	beq.n	8009578 <Standard_GetStatus+0x74>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
 8009566:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800956a:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 800956e:	681b      	ldr	r3, [r3, #0]
 8009570:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8009574:	2b10      	cmp	r3, #16
 8009576:	e008      	b.n	800958a <Standard_GetStatus+0x86>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 8009578:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800957c:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009580:	681b      	ldr	r3, [r3, #0]
 8009582:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8009586:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
      {
        SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
 800958a:	bf02      	ittt	eq
 800958c:	7803      	ldrbeq	r3, [r0, #0]
 800958e:	f043 0301 	orreq.w	r3, r3, #1
 8009592:	7003      	strbeq	r3, [r0, #0]
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
 8009594:	4b05      	ldr	r3, [pc, #20]	; (80095ac <Standard_GetStatus+0xa8>)
 8009596:	681b      	ldr	r3, [r3, #0]
 8009598:	691b      	ldr	r3, [r3, #16]
 800959a:	4798      	blx	r3
  return (uint8_t *)&StatusInfo;
 800959c:	4802      	ldr	r0, [pc, #8]	; (80095a8 <Standard_GetStatus+0xa4>)
 800959e:	e000      	b.n	80095a2 <Standard_GetStatus+0x9e>
    }

  }
  else
  {
    return NULL;
 80095a0:	2000      	movs	r0, #0
  }
  pUser_Standard_Requests->User_GetStatus();
  return (uint8_t *)&StatusInfo;
}
 80095a2:	bd08      	pop	{r3, pc}
 80095a4:	20003794 	.word	0x20003794
 80095a8:	200037a0 	.word	0x200037a0
 80095ac:	20003790 	.word	0x20003790

080095b0 <DataStageIn>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
 80095b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 80095b2:	4b27      	ldr	r3, [pc, #156]	; (8009650 <DataStageIn+0xa0>)
 80095b4:	681c      	ldr	r4, [r3, #0]
  uint32_t save_wLength = pEPinfo->Usb_wLength;
 80095b6:	8a23      	ldrh	r3, [r4, #16]
  uint32_t ControlState = pInformation->ControlState;
 80095b8:	7a26      	ldrb	r6, [r4, #8]

  uint8_t *DataBuffer;
  uint32_t Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
 80095ba:	f1d3 0201 	rsbs	r2, r3, #1
 80095be:	bf38      	it	cc
 80095c0:	2200      	movcc	r2, #0
 80095c2:	2e04      	cmp	r6, #4
 80095c4:	bf14      	ite	ne
 80095c6:	2600      	movne	r6, #0
 80095c8:	f002 0601 	andeq.w	r6, r2, #1
 80095cc:	b1ae      	cbz	r6, 80095fa <DataStageIn+0x4a>
  {
    if(Data_Mul_MaxPacketSize == TRUE)
 80095ce:	4921      	ldr	r1, [pc, #132]	; (8009654 <DataStageIn+0xa4>)
 80095d0:	4a21      	ldr	r2, [pc, #132]	; (8009658 <DataStageIn+0xa8>)
 80095d2:	780b      	ldrb	r3, [r1, #0]
 80095d4:	2b01      	cmp	r3, #1
 80095d6:	d10c      	bne.n	80095f2 <DataStageIn+0x42>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 80095d8:	4b20      	ldr	r3, [pc, #128]	; (800965c <DataStageIn+0xac>)
      ControlState = LAST_IN_DATA;
 80095da:	2704      	movs	r7, #4
  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 80095dc:	6818      	ldr	r0, [r3, #0]
 80095de:	4b20      	ldr	r3, [pc, #128]	; (8009660 <DataStageIn+0xb0>)
 80095e0:	b280      	uxth	r0, r0
 80095e2:	18c3      	adds	r3, r0, r3
 80095e4:	005b      	lsls	r3, r3, #1
 80095e6:	2000      	movs	r0, #0
 80095e8:	6018      	str	r0, [r3, #0]
 80095ea:	2330      	movs	r3, #48	; 0x30
 80095ec:	8013      	strh	r3, [r2, #0]
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
 80095ee:	7008      	strb	r0, [r1, #0]
 80095f0:	e02a      	b.n	8009648 <DataStageIn+0x98>
    #ifdef STM32F10X_CL      
      PCD_EP_Read (ENDP0, 0, 0);
    #endif  /* STM32F10X_CL */ 
    
    #ifndef STM32F10X_CL 
      vSetEPTxStatus(EP_TX_STALL);
 80095f2:	2310      	movs	r3, #16
 80095f4:	8013      	strh	r3, [r2, #0]
      Data_Mul_MaxPacketSize = FALSE;
    }
    else 
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
 80095f6:	2707      	movs	r7, #7
 80095f8:	e026      	b.n	8009648 <DataStageIn+0x98>
    }
    
    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
 80095fa:	8aa5      	ldrh	r5, [r4, #20]
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
 80095fc:	42ab      	cmp	r3, r5
 80095fe:	bf8c      	ite	hi
 8009600:	2702      	movhi	r7, #2
 8009602:	2704      	movls	r7, #4
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
 8009604:	429d      	cmp	r5, r3
 8009606:	bf28      	it	cs
 8009608:	461d      	movcs	r5, r3
 800960a:	4628      	mov	r0, r5
 800960c:	69a3      	ldr	r3, [r4, #24]
 800960e:	4798      	blx	r3
 8009610:	4603      	mov	r3, r0

#ifdef STM32F10X_CL
  PCD_EP_Write (ENDP0, DataBuffer, Length);
#else   
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
 8009612:	4630      	mov	r0, r6
 8009614:	9301      	str	r3, [sp, #4]
 8009616:	f000 fd87 	bl	800a128 <GetEPTxAddr>
 800961a:	9b01      	ldr	r3, [sp, #4]
 800961c:	462a      	mov	r2, r5
 800961e:	4601      	mov	r1, r0
 8009620:	4618      	mov	r0, r3
 8009622:	f000 fca1 	bl	8009f68 <UserToPMABufferCopy>
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);
 8009626:	4629      	mov	r1, r5
 8009628:	4630      	mov	r0, r6
 800962a:	f000 fd99 	bl	800a160 <SetEPTxCount>

  pEPinfo->Usb_wLength -= Length;
 800962e:	8a23      	ldrh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);
 8009630:	2230      	movs	r2, #48	; 0x30
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
 8009632:	1b5b      	subs	r3, r3, r5
 8009634:	8223      	strh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
 8009636:	8a63      	ldrh	r3, [r4, #18]
 8009638:	18ed      	adds	r5, r5, r3
  vSetEPTxStatus(EP_TX_VALID);
 800963a:	4b07      	ldr	r3, [pc, #28]	; (8009658 <DataStageIn+0xa8>)
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
 800963c:	8265      	strh	r5, [r4, #18]
  vSetEPTxStatus(EP_TX_VALID);
 800963e:	801a      	strh	r2, [r3, #0]

  USB_StatusOut();/* Expect the host to abort the data IN stage */
 8009640:	4b08      	ldr	r3, [pc, #32]	; (8009664 <DataStageIn+0xb4>)
 8009642:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8009646:	801a      	strh	r2, [r3, #0]

Expect_Status_Out:
  pInformation->ControlState = ControlState;
 8009648:	4b01      	ldr	r3, [pc, #4]	; (8009650 <DataStageIn+0xa0>)
 800964a:	681b      	ldr	r3, [r3, #0]
 800964c:	721f      	strb	r7, [r3, #8]
}
 800964e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009650:	20003794 	.word	0x20003794
 8009654:	20000c14 	.word	0x20000c14
 8009658:	200037a4 	.word	0x200037a4
 800965c:	40005c50 	.word	0x40005c50
 8009660:	20003002 	.word	0x20003002
 8009664:	200037a2 	.word	0x200037a2

08009668 <Standard_SetConfiguration>:
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
 8009668:	b510      	push	{r4, lr}

  if ((pInformation->USBwValue0 <=
 800966a:	4b0a      	ldr	r3, [pc, #40]	; (8009694 <Standard_SetConfiguration+0x2c>)
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 800966c:	490a      	ldr	r1, [pc, #40]	; (8009698 <Standard_SetConfiguration+0x30>)
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
 800966e:	681b      	ldr	r3, [r3, #0]
 8009670:	7849      	ldrb	r1, [r1, #1]
 8009672:	78da      	ldrb	r2, [r3, #3]
 8009674:	4291      	cmp	r1, r2
 8009676:	d30a      	bcc.n	800968e <Standard_SetConfiguration+0x26>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 8009678:	7899      	ldrb	r1, [r3, #2]
 800967a:	b941      	cbnz	r1, 800968e <Standard_SetConfiguration+0x26>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
 800967c:	889c      	ldrh	r4, [r3, #4]
 800967e:	b934      	cbnz	r4, 800968e <Standard_SetConfiguration+0x26>
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
 8009680:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 8009682:	4b06      	ldr	r3, [pc, #24]	; (800969c <Standard_SetConfiguration+0x34>)
 8009684:	681b      	ldr	r3, [r3, #0]
 8009686:	685b      	ldr	r3, [r3, #4]
 8009688:	4798      	blx	r3
    return USB_SUCCESS;
 800968a:	4620      	mov	r0, r4
 800968c:	e000      	b.n	8009690 <Standard_SetConfiguration+0x28>
  }
  else
  {
    return USB_UNSUPPORT;
 800968e:	2002      	movs	r0, #2
  }
}
 8009690:	bd10      	pop	{r4, pc}
 8009692:	bf00      	nop
 8009694:	20003794 	.word	0x20003794
 8009698:	20003798 	.word	0x20003798
 800969c:	20003790 	.word	0x20003790

080096a0 <Standard_SetInterface>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
 80096a0:	b538      	push	{r3, r4, r5, lr}
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
 80096a2:	4a0e      	ldr	r2, [pc, #56]	; (80096dc <Standard_SetInterface+0x3c>)
 80096a4:	4c0e      	ldr	r4, [pc, #56]	; (80096e0 <Standard_SetInterface+0x40>)
 80096a6:	6812      	ldr	r2, [r2, #0]
 80096a8:	6823      	ldr	r3, [r4, #0]
 80096aa:	7958      	ldrb	r0, [r3, #5]
 80096ac:	78d9      	ldrb	r1, [r3, #3]
 80096ae:	6993      	ldr	r3, [r2, #24]
 80096b0:	4798      	blx	r3

  if (pInformation->Current_Configuration != 0)
 80096b2:	6823      	ldr	r3, [r4, #0]
 80096b4:	7a9a      	ldrb	r2, [r3, #10]
 80096b6:	b17a      	cbz	r2, 80096d8 <Standard_SetInterface+0x38>
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
 80096b8:	b970      	cbnz	r0, 80096d8 <Standard_SetInterface+0x38>
 80096ba:	791a      	ldrb	r2, [r3, #4]
 80096bc:	b962      	cbnz	r2, 80096d8 <Standard_SetInterface+0x38>
        || (pInformation->USBwValue1 != 0))
 80096be:	789d      	ldrb	r5, [r3, #2]
 80096c0:	b955      	cbnz	r5, 80096d8 <Standard_SetInterface+0x38>
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
 80096c2:	4b08      	ldr	r3, [pc, #32]	; (80096e4 <Standard_SetInterface+0x44>)
 80096c4:	681b      	ldr	r3, [r3, #0]
 80096c6:	68db      	ldr	r3, [r3, #12]
 80096c8:	4798      	blx	r3
      pInformation->Current_Interface = pInformation->USBwIndex0;
 80096ca:	6823      	ldr	r3, [r4, #0]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
 80096cc:	4628      	mov	r0, r5
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
 80096ce:	795a      	ldrb	r2, [r3, #5]
 80096d0:	72da      	strb	r2, [r3, #11]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
 80096d2:	78da      	ldrb	r2, [r3, #3]
 80096d4:	731a      	strb	r2, [r3, #12]
      return USB_SUCCESS;
 80096d6:	e000      	b.n	80096da <Standard_SetInterface+0x3a>
  if (pInformation->Current_Configuration != 0)
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
        || (pInformation->USBwValue1 != 0))
    {
      return  USB_UNSUPPORT;
 80096d8:	2002      	movs	r0, #2
    }

  }

  return USB_UNSUPPORT;
}
 80096da:	bd38      	pop	{r3, r4, r5, pc}
 80096dc:	2000378c 	.word	0x2000378c
 80096e0:	20003794 	.word	0x20003794
 80096e4:	20003790 	.word	0x20003790

080096e8 <Standard_ClearFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
 80096e8:	b510      	push	{r4, lr}
  uint32_t     Type_Rec = Type_Recipient;
 80096ea:	4b3f      	ldr	r3, [pc, #252]	; (80097e8 <Standard_ClearFeature+0x100>)
 80096ec:	681b      	ldr	r3, [r3, #0]
 80096ee:	7818      	ldrb	r0, [r3, #0]
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80096f0:	f010 007f 	ands.w	r0, r0, #127	; 0x7f
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
 80096f4:	bf02      	ittt	eq
 80096f6:	7a5a      	ldrbeq	r2, [r3, #9]
 80096f8:	f022 0220 	biceq.w	r2, r2, #32
 80096fc:	725a      	strbeq	r2, [r3, #9]
{
  uint32_t     Type_Rec = Type_Recipient;
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80096fe:	d072      	beq.n	80097e6 <Standard_ClearFeature+0xfe>
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009700:	2802      	cmp	r0, #2
 8009702:	d16f      	bne.n	80097e4 <Standard_ClearFeature+0xfc>
    DEVICE* pDev;
    uint32_t Related_Endpoint;
    uint32_t wIndex0;
    uint32_t rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
 8009704:	885a      	ldrh	r2, [r3, #2]
 8009706:	2a00      	cmp	r2, #0
 8009708:	d16d      	bne.n	80097e6 <Standard_ClearFeature+0xfe>
        || (pInformation->USBwIndex1 != 0))
 800970a:	791a      	ldrb	r2, [r3, #4]
 800970c:	2a00      	cmp	r2, #0
 800970e:	d16a      	bne.n	80097e6 <Standard_ClearFeature+0xfe>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
 8009710:	795a      	ldrb	r2, [r3, #5]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 8009712:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 80097ec <Standard_ClearFeature+0x104>
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
 8009716:	f022 0080 	bic.w	r0, r2, #128	; 0x80
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
 800971a:	f012 0f80 	tst.w	r2, #128	; 0x80
 800971e:	ea4f 0480 	mov.w	r4, r0, lsl #2
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8009722:	bf15      	itete	ne
 8009724:	f104 4480 	addne.w	r4, r4, #1073741824	; 0x40000000
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009728:	f104 4480 	addeq.w	r4, r4, #1073741824	; 0x40000000

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 800972c:	f504 44b8 	addne.w	r4, r4, #23552	; 0x5c00
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009730:	f504 44b8 	addeq.w	r4, r4, #23552	; 0x5c00

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8009734:	bf14      	ite	ne
 8009736:	6821      	ldrne	r1, [r4, #0]
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009738:	6821      	ldreq	r1, [r4, #0]
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 800973a:	f89c c000 	ldrb.w	ip, [ip]

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 800973e:	bf14      	ite	ne
 8009740:	f001 0130 	andne.w	r1, r1, #48	; 0x30
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8009744:	f401 5140 	andeq.w	r1, r1, #12288	; 0x3000
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 8009748:	4560      	cmp	r0, ip
 800974a:	bf34      	ite	cc
 800974c:	f04f 0c00 	movcc.w	ip, #0
 8009750:	f04f 0c01 	movcs.w	ip, #1
 8009754:	2900      	cmp	r1, #0
 8009756:	bf14      	ite	ne
 8009758:	4661      	movne	r1, ip
 800975a:	f04c 0101 	orreq.w	r1, ip, #1
 800975e:	2900      	cmp	r1, #0
 8009760:	d140      	bne.n	80097e4 <Standard_ClearFeature+0xfc>
        || (pInformation->Current_Configuration == 0))
 8009762:	7a9b      	ldrb	r3, [r3, #10]
 8009764:	2b00      	cmp	r3, #0
 8009766:	d03d      	beq.n	80097e4 <Standard_ClearFeature+0xfc>
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
 8009768:	f012 0f80 	tst.w	r2, #128	; 0x80
 800976c:	ea4f 0480 	mov.w	r4, r0, lsl #2
 8009770:	d011      	beq.n	8009796 <Standard_ClearFeature+0xae>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
 8009772:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8009776:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 800977a:	6823      	ldr	r3, [r4, #0]
 800977c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8009780:	2b10      	cmp	r3, #16
 8009782:	d129      	bne.n	80097d8 <Standard_ClearFeature+0xf0>
      {
      #ifndef STM32F10X_CL
        ClearDTOG_TX(Related_Endpoint);
 8009784:	b2c4      	uxtb	r4, r0
 8009786:	4620      	mov	r0, r4
 8009788:	f000 fc9a 	bl	800a0c0 <ClearDTOG_TX>
      #endif /* STM32F10X_CL */
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
 800978c:	4620      	mov	r0, r4
 800978e:	2130      	movs	r1, #48	; 0x30
 8009790:	f000 fc32 	bl	8009ff8 <SetEPTxStatus>
 8009794:	e020      	b.n	80097d8 <Standard_ClearFeature+0xf0>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 8009796:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 800979a:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 800979e:	6823      	ldr	r3, [r4, #0]
 80097a0:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80097a4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80097a8:	d116      	bne.n	80097d8 <Standard_ClearFeature+0xf0>
      {
        if (Related_Endpoint == ENDP0)
 80097aa:	b930      	cbnz	r0, 80097ba <Standard_ClearFeature+0xd2>
        {
          /* After clear the STALL, enable the default endpoint receiver */
//          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
          SetEPRxCount(Related_Endpoint, pProperty->MaxPacketSize);
 80097ac:	4b10      	ldr	r3, [pc, #64]	; (80097f0 <Standard_ClearFeature+0x108>)
 80097ae:	681b      	ldr	r3, [r3, #0]
 80097b0:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 80097b4:	f000 fce2 	bl	800a17c <SetEPRxCount>
 80097b8:	e002      	b.n	80097c0 <Standard_ClearFeature+0xd8>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
        #ifndef STM32F10X_CL
          ClearDTOG_RX(Related_Endpoint);
 80097ba:	b2c0      	uxtb	r0, r0
 80097bc:	f000 fc6c 	bl	800a098 <ClearDTOG_RX>
        #endif /* STM32F10X_CL */
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 80097c0:	6822      	ldr	r2, [r4, #0]
 80097c2:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 80097c6:	ea02 0303 	and.w	r3, r2, r3
 80097ca:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 80097ce:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80097d2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80097d6:	6023      	str	r3, [r4, #0]
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
 80097d8:	4b06      	ldr	r3, [pc, #24]	; (80097f4 <Standard_ClearFeature+0x10c>)
 80097da:	681b      	ldr	r3, [r3, #0]
 80097dc:	695b      	ldr	r3, [r3, #20]
 80097de:	4798      	blx	r3
    return USB_SUCCESS;
 80097e0:	2000      	movs	r0, #0
 80097e2:	e000      	b.n	80097e6 <Standard_ClearFeature+0xfe>
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
        || (pInformation->Current_Configuration == 0))
    {
      return USB_UNSUPPORT;
 80097e4:	2002      	movs	r0, #2
    pUser_Standard_Requests->User_ClearFeature();
    return USB_SUCCESS;
  }

  return USB_UNSUPPORT;
}
 80097e6:	bd10      	pop	{r4, pc}
 80097e8:	20003794 	.word	0x20003794
 80097ec:	20003798 	.word	0x20003798
 80097f0:	2000378c 	.word	0x2000378c
 80097f4:	20003790 	.word	0x20003790

080097f8 <Standard_SetEndPointFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
 80097f8:	b508      	push	{r3, lr}
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 80097fa:	4b2b      	ldr	r3, [pc, #172]	; (80098a8 <Standard_SetEndPointFeature+0xb0>)
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 80097fc:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 80098ac <Standard_SetEndPointFeature+0xb4>
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 8009800:	6818      	ldr	r0, [r3, #0]
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 8009802:	f89c c000 	ldrb.w	ip, [ip]
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 8009806:	7941      	ldrb	r1, [r0, #5]
  rEP = wIndex0 & ~0x80;
 8009808:	f021 0280 	bic.w	r2, r1, #128	; 0x80
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
 800980c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009810:	ea4f 0382 	mov.w	r3, r2, lsl #2
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 8009814:	bf15      	itete	ne
 8009816:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 800981a:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 800981e:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009822:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 8009826:	bf15      	itete	ne
 8009828:	681b      	ldrne	r3, [r3, #0]
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 800982a:	681b      	ldreq	r3, [r3, #0]

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 800982c:	f003 0330 	andne.w	r3, r3, #48	; 0x30
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 8009830:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 8009834:	4562      	cmp	r2, ip
 8009836:	d235      	bcs.n	80098a4 <Standard_SetEndPointFeature+0xac>
      || pInformation->USBwValue != 0 || Status == 0
 8009838:	f8b0 c002 	ldrh.w	ip, [r0, #2]
 800983c:	f1bc 0c00 	subs.w	ip, ip, #0
 8009840:	bf18      	it	ne
 8009842:	f04f 0c01 	movne.w	ip, #1
 8009846:	2b00      	cmp	r3, #0
 8009848:	bf14      	ite	ne
 800984a:	4663      	movne	r3, ip
 800984c:	f04c 0301 	orreq.w	r3, ip, #1
 8009850:	bb43      	cbnz	r3, 80098a4 <Standard_SetEndPointFeature+0xac>
      || pInformation->Current_Configuration == 0)
 8009852:	7a83      	ldrb	r3, [r0, #10]
 8009854:	b333      	cbz	r3, 80098a4 <Standard_SetEndPointFeature+0xac>
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
 8009856:	f011 0f80 	tst.w	r1, #128	; 0x80
 800985a:	ea4f 0382 	mov.w	r3, r2, lsl #2
 800985e:	d00b      	beq.n	8009878 <Standard_SetEndPointFeature+0x80>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
 8009860:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009864:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009868:	6819      	ldr	r1, [r3, #0]
 800986a:	f648 72bf 	movw	r2, #36799	; 0x8fbf
 800986e:	ea01 0202 	and.w	r2, r1, r2
 8009872:	f082 0210 	eor.w	r2, r2, #16
 8009876:	e00a      	b.n	800988e <Standard_SetEndPointFeature+0x96>
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
 8009878:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800987c:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8009880:	6819      	ldr	r1, [r3, #0]
 8009882:	f64b 728f 	movw	r2, #49039	; 0xbf8f
 8009886:	ea01 0202 	and.w	r2, r1, r2
 800988a:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 800988e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009892:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009896:	601a      	str	r2, [r3, #0]
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
 8009898:	4b05      	ldr	r3, [pc, #20]	; (80098b0 <Standard_SetEndPointFeature+0xb8>)
 800989a:	681b      	ldr	r3, [r3, #0]
 800989c:	699b      	ldr	r3, [r3, #24]
 800989e:	4798      	blx	r3
  return USB_SUCCESS;
 80098a0:	2000      	movs	r0, #0
 80098a2:	e000      	b.n	80098a6 <Standard_SetEndPointFeature+0xae>

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
 80098a4:	2002      	movs	r0, #2
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
 80098a6:	bd08      	pop	{r3, pc}
 80098a8:	20003794 	.word	0x20003794
 80098ac:	20003798 	.word	0x20003798
 80098b0:	20003790 	.word	0x20003790

080098b4 <Standard_SetDeviceFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
 80098b4:	b508      	push	{r3, lr}
  SetBit(pInformation->Current_Feature, 5);
 80098b6:	4b06      	ldr	r3, [pc, #24]	; (80098d0 <Standard_SetDeviceFeature+0x1c>)
 80098b8:	681b      	ldr	r3, [r3, #0]
 80098ba:	7a5a      	ldrb	r2, [r3, #9]
 80098bc:	f042 0220 	orr.w	r2, r2, #32
 80098c0:	725a      	strb	r2, [r3, #9]
  pUser_Standard_Requests->User_SetDeviceFeature();
 80098c2:	4b04      	ldr	r3, [pc, #16]	; (80098d4 <Standard_SetDeviceFeature+0x20>)
 80098c4:	681b      	ldr	r3, [r3, #0]
 80098c6:	69db      	ldr	r3, [r3, #28]
 80098c8:	4798      	blx	r3
  return USB_SUCCESS;
}
 80098ca:	2000      	movs	r0, #0
 80098cc:	bd08      	pop	{r3, pc}
 80098ce:	bf00      	nop
 80098d0:	20003794 	.word	0x20003794
 80098d4:	20003790 	.word	0x20003790

080098d8 <Standard_GetDescriptorData>:
*******************************************************************************/
uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
{
  uint32_t  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
 80098d8:	4b05      	ldr	r3, [pc, #20]	; (80098f0 <Standard_GetDescriptorData+0x18>)
 80098da:	681a      	ldr	r2, [r3, #0]
 80098dc:	8a53      	ldrh	r3, [r2, #18]
  if (Length == 0)
 80098de:	b918      	cbnz	r0, 80098e8 <Standard_GetDescriptorData+0x10>
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
 80098e0:	8889      	ldrh	r1, [r1, #4]
 80098e2:	1acb      	subs	r3, r1, r3
 80098e4:	8213      	strh	r3, [r2, #16]
    return 0;
 80098e6:	e001      	b.n	80098ec <Standard_GetDescriptorData+0x14>
  }

  return pDesc->Descriptor + wOffset;
 80098e8:	6808      	ldr	r0, [r1, #0]
 80098ea:	18c0      	adds	r0, r0, r3
}
 80098ec:	4770      	bx	lr
 80098ee:	bf00      	nop
 80098f0:	20003794 	.word	0x20003794

080098f4 <Post0_Process>:
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
uint8_t Post0_Process(void)
{
 80098f4:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
#endif /* STM32F10X_CL */
      
//  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
// TK: we should reference MaxPacketSize() via pointer!
  SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 80098f6:	4b0c      	ldr	r3, [pc, #48]	; (8009928 <Post0_Process+0x34>)
 80098f8:	2000      	movs	r0, #0
 80098fa:	681b      	ldr	r3, [r3, #0]
 80098fc:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8009900:	f000 fc3c 	bl	800a17c <SetEPRxCount>

  if (pInformation->ControlState == STALLED)
 8009904:	4b09      	ldr	r3, [pc, #36]	; (800992c <Post0_Process+0x38>)
 8009906:	681b      	ldr	r3, [r3, #0]
 8009908:	7a18      	ldrb	r0, [r3, #8]
 800990a:	2808      	cmp	r0, #8
 800990c:	d106      	bne.n	800991c <Post0_Process+0x28>
  {
    vSetEPRxStatus(EP_RX_STALL);
 800990e:	4b08      	ldr	r3, [pc, #32]	; (8009930 <Post0_Process+0x3c>)
 8009910:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009914:	801a      	strh	r2, [r3, #0]
    vSetEPTxStatus(EP_TX_STALL);
 8009916:	4b07      	ldr	r3, [pc, #28]	; (8009934 <Post0_Process+0x40>)
 8009918:	2210      	movs	r2, #16
 800991a:	801a      	strh	r2, [r3, #0]
 800991c:	2809      	cmp	r0, #9
 800991e:	bf14      	ite	ne
 8009920:	2000      	movne	r0, #0
 8009922:	2001      	moveq	r0, #1
    OTGD_FS_EP0StartXfer(ep);    
  }  
#endif /* STM32F10X_CL */

  return (pInformation->ControlState == PAUSE);
}
 8009924:	bd08      	pop	{r3, pc}
 8009926:	bf00      	nop
 8009928:	2000378c 	.word	0x2000378c
 800992c:	20003794 	.word	0x20003794
 8009930:	200037a2 	.word	0x200037a2
 8009934:	200037a4 	.word	0x200037a4

08009938 <Out0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Out0_Process(void)
{
 8009938:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t ControlState = pInformation->ControlState;
 800993a:	4b38      	ldr	r3, [pc, #224]	; (8009a1c <Out0_Process+0xe4>)
 800993c:	681c      	ldr	r4, [r3, #0]
 800993e:	7a23      	ldrb	r3, [r4, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8009940:	2b02      	cmp	r3, #2
 8009942:	bf14      	ite	ne
 8009944:	2600      	movne	r6, #0
 8009946:	2601      	moveq	r6, #1
 8009948:	2b04      	cmp	r3, #4
 800994a:	bf08      	it	eq
 800994c:	f046 0601 	orreq.w	r6, r6, #1
 8009950:	2e00      	cmp	r6, #0
 8009952:	d15b      	bne.n	8009a0c <Out0_Process+0xd4>
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
 8009954:	2b03      	cmp	r3, #3
 8009956:	bf14      	ite	ne
 8009958:	2200      	movne	r2, #0
 800995a:	2201      	moveq	r2, #1
 800995c:	2b05      	cmp	r3, #5
 800995e:	bf08      	it	eq
 8009960:	f042 0201 	orreq.w	r2, r2, #1
 8009964:	2a00      	cmp	r2, #0
 8009966:	d04b      	beq.n	8009a00 <Out0_Process+0xc8>
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
 8009968:	69a3      	ldr	r3, [r4, #24]
void DataStageOut(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;
 800996a:	8a22      	ldrh	r2, [r4, #16]

  if (pEPinfo->CopyData && save_rLength)
 800996c:	1e19      	subs	r1, r3, #0
 800996e:	bf18      	it	ne
 8009970:	2101      	movne	r1, #1
 8009972:	2a00      	cmp	r2, #0
 8009974:	bf0c      	ite	eq
 8009976:	2100      	moveq	r1, #0
 8009978:	f001 0101 	andne.w	r1, r1, #1
 800997c:	b1a1      	cbz	r1, 80099a8 <Out0_Process+0x70>
  {
    uint8_t *Buffer;
    uint32_t Length;

    Length = pEPinfo->PacketSize;
 800997e:	8aa5      	ldrh	r5, [r4, #20]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 8009980:	4295      	cmp	r5, r2
 8009982:	bf28      	it	cs
 8009984:	4615      	movcs	r5, r2
 8009986:	4628      	mov	r0, r5
 8009988:	4798      	blx	r3
    pEPinfo->Usb_rLength -= Length;
 800998a:	8a23      	ldrh	r3, [r4, #16]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 800998c:	4607      	mov	r7, r0
    pEPinfo->Usb_rLength -= Length;
 800998e:	1b5b      	subs	r3, r3, r5
 8009990:	8223      	strh	r3, [r4, #16]
    pEPinfo->Usb_rOffset += Length;
 8009992:	8a63      	ldrh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 8009994:	4630      	mov	r0, r6
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    pEPinfo->Usb_rLength -= Length;
    pEPinfo->Usb_rOffset += Length;
 8009996:	18eb      	adds	r3, r5, r3
 8009998:	8263      	strh	r3, [r4, #18]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 800999a:	f000 fbd3 	bl	800a144 <GetEPRxAddr>
 800999e:	462a      	mov	r2, r5
 80099a0:	4601      	mov	r1, r0
 80099a2:	4638      	mov	r0, r7
 80099a4:	f000 faf6 	bl	8009f94 <PMAToUserBufferCopy>
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
 80099a8:	8a23      	ldrh	r3, [r4, #16]
 80099aa:	b153      	cbz	r3, 80099c2 <Out0_Process+0x8a>
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 80099ac:	4b1c      	ldr	r3, [pc, #112]	; (8009a20 <Out0_Process+0xe8>)
 80099ae:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    SetEPTxCount(ENDP0, 0);
 80099b2:	2000      	movs	r0, #0
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 80099b4:	801a      	strh	r2, [r3, #0]
    SetEPTxCount(ENDP0, 0);
 80099b6:	4601      	mov	r1, r0
 80099b8:	f000 fbd2 	bl	800a160 <SetEPTxCount>
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 80099bc:	4b19      	ldr	r3, [pc, #100]	; (8009a24 <Out0_Process+0xec>)
 80099be:	2230      	movs	r2, #48	; 0x30
 80099c0:	801a      	strh	r2, [r3, #0]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
 80099c2:	8a23      	ldrh	r3, [r4, #16]
 80099c4:	8aa2      	ldrh	r2, [r4, #20]
 80099c6:	429a      	cmp	r2, r3
 80099c8:	d803      	bhi.n	80099d2 <Out0_Process+0x9a>
  {
    pInformation->ControlState = OUT_DATA;
 80099ca:	4b14      	ldr	r3, [pc, #80]	; (8009a1c <Out0_Process+0xe4>)
 80099cc:	2203      	movs	r2, #3
 80099ce:	681b      	ldr	r3, [r3, #0]
 80099d0:	e003      	b.n	80099da <Out0_Process+0xa2>
 80099d2:	4a12      	ldr	r2, [pc, #72]	; (8009a1c <Out0_Process+0xe4>)
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
 80099d4:	b11b      	cbz	r3, 80099de <Out0_Process+0xa6>
    {
      pInformation->ControlState = LAST_OUT_DATA;
 80099d6:	6813      	ldr	r3, [r2, #0]
 80099d8:	2205      	movs	r2, #5
 80099da:	721a      	strb	r2, [r3, #8]
 80099dc:	e00c      	b.n	80099f8 <Out0_Process+0xc0>
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
 80099de:	6812      	ldr	r2, [r2, #0]
 80099e0:	2106      	movs	r1, #6
 80099e2:	7211      	strb	r1, [r2, #8]
      USB_StatusIn();
 80099e4:	4a10      	ldr	r2, [pc, #64]	; (8009a28 <Out0_Process+0xf0>)
 80099e6:	6811      	ldr	r1, [r2, #0]
 80099e8:	4a10      	ldr	r2, [pc, #64]	; (8009a2c <Out0_Process+0xf4>)
 80099ea:	b289      	uxth	r1, r1
 80099ec:	188a      	adds	r2, r1, r2
 80099ee:	0052      	lsls	r2, r2, #1
 80099f0:	6013      	str	r3, [r2, #0]
 80099f2:	4b0c      	ldr	r3, [pc, #48]	; (8009a24 <Out0_Process+0xec>)
 80099f4:	2230      	movs	r2, #48	; 0x30
 80099f6:	801a      	strh	r2, [r3, #0]
    ControlState = STALLED;
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
 80099f8:	4b08      	ldr	r3, [pc, #32]	; (8009a1c <Out0_Process+0xe4>)
 80099fa:	681b      	ldr	r3, [r3, #0]
 80099fc:	7a1b      	ldrb	r3, [r3, #8]
 80099fe:	e006      	b.n	8009a0e <Out0_Process+0xd6>
  }

  else if (ControlState == WAIT_STATUS_OUT)
 8009a00:	2b07      	cmp	r3, #7
 8009a02:	d103      	bne.n	8009a0c <Out0_Process+0xd4>
  {
    (*pProperty->Process_Status_OUT)();
 8009a04:	4b0a      	ldr	r3, [pc, #40]	; (8009a30 <Out0_Process+0xf8>)
 8009a06:	681b      	ldr	r3, [r3, #0]
 8009a08:	68db      	ldr	r3, [r3, #12]
 8009a0a:	4798      	blx	r3


  /* Unexpect state, STALL the endpoint */
  else
  {
    ControlState = STALLED;
 8009a0c:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 8009a0e:	4a03      	ldr	r2, [pc, #12]	; (8009a1c <Out0_Process+0xe4>)
 8009a10:	6812      	ldr	r2, [r2, #0]
 8009a12:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 8009a14:	f7ff ff6e 	bl	80098f4 <Post0_Process>
}
 8009a18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009a1a:	bf00      	nop
 8009a1c:	20003794 	.word	0x20003794
 8009a20:	200037a2 	.word	0x200037a2
 8009a24:	200037a4 	.word	0x200037a4
 8009a28:	40005c50 	.word	0x40005c50
 8009a2c:	20003002 	.word	0x20003002
 8009a30:	2000378c 	.word	0x2000378c

08009a34 <Setup0_Process>:
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009a34:	4bb5      	ldr	r3, [pc, #724]	; (8009d0c <Setup0_Process+0x2d8>)
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Setup0_Process(void)
{
 8009a36:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009a38:	681a      	ldr	r2, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009a3a:	4eb5      	ldr	r6, [pc, #724]	; (8009d10 <Setup0_Process+0x2dc>)
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009a3c:	4bb5      	ldr	r3, [pc, #724]	; (8009d14 <Setup0_Process+0x2e0>)
 8009a3e:	b292      	uxth	r2, r2
 8009a40:	18d3      	adds	r3, r2, r3
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009a42:	6835      	ldr	r5, [r6, #0]
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009a44:	005b      	lsls	r3, r3, #1
 8009a46:	681f      	ldr	r7, [r3, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8009a48:	7a2b      	ldrb	r3, [r5, #8]
 8009a4a:	2b09      	cmp	r3, #9
 8009a4c:	d01a      	beq.n	8009a84 <Setup0_Process+0x50>
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8009a4e:	b2bf      	uxth	r7, r7
 8009a50:	f107 5700 	add.w	r7, r7, #536870912	; 0x20000000
 8009a54:	f507 5740 	add.w	r7, r7, #12288	; 0x3000
 8009a58:	007f      	lsls	r7, r7, #1
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
 8009a5a:	463c      	mov	r4, r7
 8009a5c:	f814 3b01 	ldrb.w	r3, [r4], #1
 8009a60:	702b      	strb	r3, [r5, #0]
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 8009a62:	787b      	ldrb	r3, [r7, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 8009a64:	370a      	adds	r7, #10
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 8009a66:	706b      	strb	r3, [r5, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
 8009a68:	f8b4 0003 	ldrh.w	r0, [r4, #3]
 8009a6c:	f000 fbb6 	bl	800a1dc <ByteSwap>
 8009a70:	8068      	strh	r0, [r5, #2]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 8009a72:	f8b4 0007 	ldrh.w	r0, [r4, #7]
 8009a76:	6835      	ldr	r5, [r6, #0]
 8009a78:	f000 fbb0 	bl	800a1dc <ByteSwap>
 8009a7c:	80a8      	strh	r0, [r5, #4]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength */
 8009a7e:	6833      	ldr	r3, [r6, #0]
 8009a80:	887f      	ldrh	r7, [r7, #2]
 8009a82:	80df      	strh	r7, [r3, #6]
  }

  pInformation->ControlState = SETTING_UP;
 8009a84:	4ca2      	ldr	r4, [pc, #648]	; (8009d10 <Setup0_Process+0x2dc>)
 8009a86:	2201      	movs	r2, #1
 8009a88:	6823      	ldr	r3, [r4, #0]
 8009a8a:	721a      	strb	r2, [r3, #8]
  if (pInformation->USBwLength == 0)
 8009a8c:	88da      	ldrh	r2, [r3, #6]
 8009a8e:	785d      	ldrb	r5, [r3, #1]
 8009a90:	2a00      	cmp	r2, #0
 8009a92:	d161      	bne.n	8009b58 <Setup0_Process+0x124>
{
  RESULT Result = USB_UNSUPPORT;
  uint32_t RequestNo = pInformation->USBbRequest;
  uint32_t ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009a94:	781a      	ldrb	r2, [r3, #0]
 8009a96:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009a9a:	d12e      	bne.n	8009afa <Setup0_Process+0xc6>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
 8009a9c:	2d09      	cmp	r5, #9
 8009a9e:	d102      	bne.n	8009aa6 <Setup0_Process+0x72>
    {
      Result = Standard_SetConfiguration();
 8009aa0:	f7ff fde2 	bl	8009668 <Standard_SetConfiguration>
 8009aa4:	e03b      	b.n	8009b1e <Setup0_Process+0xea>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
 8009aa6:	2d05      	cmp	r5, #5
 8009aa8:	d10d      	bne.n	8009ac6 <Setup0_Process+0x92>
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
 8009aaa:	f993 2003 	ldrsb.w	r2, [r3, #3]
 8009aae:	2a00      	cmp	r2, #0
 8009ab0:	db4d      	blt.n	8009b4e <Setup0_Process+0x11a>
 8009ab2:	789a      	ldrb	r2, [r3, #2]
 8009ab4:	2a00      	cmp	r2, #0
 8009ab6:	d14a      	bne.n	8009b4e <Setup0_Process+0x11a>
          || (pInformation->USBwIndex != 0)
 8009ab8:	889a      	ldrh	r2, [r3, #4]
 8009aba:	2a00      	cmp	r2, #0
 8009abc:	d147      	bne.n	8009b4e <Setup0_Process+0x11a>
          || (pInformation->Current_Configuration != 0))
 8009abe:	7a9b      	ldrb	r3, [r3, #10]
 8009ac0:	2b00      	cmp	r3, #0
 8009ac2:	d035      	beq.n	8009b30 <Setup0_Process+0xfc>
 8009ac4:	e043      	b.n	8009b4e <Setup0_Process+0x11a>
         SetDeviceAddress(pInformation->USBwValue0);
      #endif  /* STM32F10X_CL */
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
 8009ac6:	2d03      	cmp	r5, #3
 8009ac8:	d10b      	bne.n	8009ae2 <Setup0_Process+0xae>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
 8009aca:	78da      	ldrb	r2, [r3, #3]
 8009acc:	2a01      	cmp	r2, #1
 8009ace:	d127      	bne.n	8009b20 <Setup0_Process+0xec>
          && (pInformation->USBwIndex == 0)
 8009ad0:	889a      	ldrh	r2, [r3, #4]
 8009ad2:	bb2a      	cbnz	r2, 8009b20 <Setup0_Process+0xec>
          && (ValBit(pInformation->Current_Feature, 5)))
 8009ad4:	7a5b      	ldrb	r3, [r3, #9]
 8009ad6:	f013 0f20 	tst.w	r3, #32
 8009ada:	d021      	beq.n	8009b20 <Setup0_Process+0xec>
      {
        Result = Standard_SetDeviceFeature();
 8009adc:	f7ff feea 	bl	80098b4 <Standard_SetDeviceFeature>
 8009ae0:	e01d      	b.n	8009b1e <Setup0_Process+0xea>
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
 8009ae2:	2d01      	cmp	r5, #1
 8009ae4:	d11c      	bne.n	8009b20 <Setup0_Process+0xec>
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
 8009ae6:	78da      	ldrb	r2, [r3, #3]
 8009ae8:	2a01      	cmp	r2, #1
 8009aea:	d119      	bne.n	8009b20 <Setup0_Process+0xec>
          && pInformation->USBwIndex == 0
 8009aec:	889a      	ldrh	r2, [r3, #4]
 8009aee:	b9ba      	cbnz	r2, 8009b20 <Setup0_Process+0xec>
          && ValBit(pInformation->Current_Feature, 5))
 8009af0:	7a5b      	ldrb	r3, [r3, #9]
 8009af2:	f013 0f20 	tst.w	r3, #32
 8009af6:	d013      	beq.n	8009b20 <Setup0_Process+0xec>
 8009af8:	e00a      	b.n	8009b10 <Setup0_Process+0xdc>
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009afa:	2a01      	cmp	r2, #1
 8009afc:	d104      	bne.n	8009b08 <Setup0_Process+0xd4>
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
 8009afe:	2d0b      	cmp	r5, #11
 8009b00:	d10e      	bne.n	8009b20 <Setup0_Process+0xec>
    {
      Result = Standard_SetInterface();
 8009b02:	f7ff fdcd 	bl	80096a0 <Standard_SetInterface>
 8009b06:	e00a      	b.n	8009b1e <Setup0_Process+0xea>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009b08:	2a02      	cmp	r2, #2
 8009b0a:	d109      	bne.n	8009b20 <Setup0_Process+0xec>
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
 8009b0c:	2d01      	cmp	r5, #1
 8009b0e:	d102      	bne.n	8009b16 <Setup0_Process+0xe2>
    {
      Result = Standard_ClearFeature();
 8009b10:	f7ff fdea 	bl	80096e8 <Standard_ClearFeature>
 8009b14:	e003      	b.n	8009b1e <Setup0_Process+0xea>
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
 8009b16:	2d03      	cmp	r5, #3
 8009b18:	d102      	bne.n	8009b20 <Setup0_Process+0xec>
    {
      Result = Standard_SetEndPointFeature();
 8009b1a:	f7ff fe6d 	bl	80097f8 <Standard_SetEndPointFeature>
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
 8009b1e:	b138      	cbz	r0, 8009b30 <Setup0_Process+0xfc>
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
 8009b20:	4b7d      	ldr	r3, [pc, #500]	; (8009d18 <Setup0_Process+0x2e4>)
 8009b22:	4628      	mov	r0, r5
 8009b24:	681b      	ldr	r3, [r3, #0]
 8009b26:	695b      	ldr	r3, [r3, #20]
 8009b28:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 8009b2a:	2803      	cmp	r0, #3
 8009b2c:	d00d      	beq.n	8009b4a <Setup0_Process+0x116>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
 8009b2e:	b970      	cbnz	r0, 8009b4e <Setup0_Process+0x11a>
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
 8009b30:	4b76      	ldr	r3, [pc, #472]	; (8009d0c <Setup0_Process+0x2d8>)
 8009b32:	2130      	movs	r1, #48	; 0x30
 8009b34:	681a      	ldr	r2, [r3, #0]
 8009b36:	4b79      	ldr	r3, [pc, #484]	; (8009d1c <Setup0_Process+0x2e8>)
 8009b38:	b292      	uxth	r2, r2
 8009b3a:	18d3      	adds	r3, r2, r3
 8009b3c:	005b      	lsls	r3, r3, #1
 8009b3e:	2200      	movs	r2, #0
 8009b40:	601a      	str	r2, [r3, #0]
 8009b42:	4b77      	ldr	r3, [pc, #476]	; (8009d20 <Setup0_Process+0x2ec>)
 8009b44:	8019      	strh	r1, [r3, #0]
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
 8009b46:	2306      	movs	r3, #6
 8009b48:	e002      	b.n	8009b50 <Setup0_Process+0x11c>
  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    if (Result == USB_NOT_READY)
    {
      ControlState = PAUSE;
 8009b4a:	2309      	movs	r3, #9
 8009b4c:	e000      	b.n	8009b50 <Setup0_Process+0x11c>
    }
  }

  if (Result != USB_SUCCESS)
  {
    ControlState = STALLED;
 8009b4e:	2308      	movs	r3, #8
  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
 8009b50:	4a6f      	ldr	r2, [pc, #444]	; (8009d10 <Setup0_Process+0x2dc>)
 8009b52:	6812      	ldr	r2, [r2, #0]
 8009b54:	7213      	strb	r3, [r2, #8]
 8009b56:	e0d6      	b.n	8009d06 <Setup0_Process+0x2d2>

  CopyRoutine = NULL;
  wOffset = 0;

  /*GET DESCRIPTOR*/
  if (Request_No == GET_DESCRIPTOR)
 8009b58:	2d06      	cmp	r5, #6
 8009b5a:	d117      	bne.n	8009b8c <Setup0_Process+0x158>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009b5c:	781a      	ldrb	r2, [r3, #0]
 8009b5e:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 8009b62:	f040 808a 	bne.w	8009c7a <Setup0_Process+0x246>
    {
      uint8_t wValue1 = pInformation->USBwValue1;
 8009b66:	789b      	ldrb	r3, [r3, #2]
      if (wValue1 == DEVICE_DESCRIPTOR)
 8009b68:	2b01      	cmp	r3, #1
 8009b6a:	d103      	bne.n	8009b74 <Setup0_Process+0x140>
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
 8009b6c:	4b6a      	ldr	r3, [pc, #424]	; (8009d18 <Setup0_Process+0x2e4>)
 8009b6e:	681b      	ldr	r3, [r3, #0]
 8009b70:	69db      	ldr	r3, [r3, #28]
 8009b72:	e079      	b.n	8009c68 <Setup0_Process+0x234>
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
 8009b74:	2b02      	cmp	r3, #2
 8009b76:	d103      	bne.n	8009b80 <Setup0_Process+0x14c>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
 8009b78:	4b67      	ldr	r3, [pc, #412]	; (8009d18 <Setup0_Process+0x2e4>)
 8009b7a:	681b      	ldr	r3, [r3, #0]
 8009b7c:	6a1b      	ldr	r3, [r3, #32]
 8009b7e:	e073      	b.n	8009c68 <Setup0_Process+0x234>
      }
      else if (wValue1 == STRING_DESCRIPTOR)
 8009b80:	2b03      	cmp	r3, #3
 8009b82:	d17a      	bne.n	8009c7a <Setup0_Process+0x246>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
 8009b84:	4b64      	ldr	r3, [pc, #400]	; (8009d18 <Setup0_Process+0x2e4>)
 8009b86:	681b      	ldr	r3, [r3, #0]
 8009b88:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009b8a:	e06d      	b.n	8009c68 <Setup0_Process+0x234>
      }  /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
 8009b8c:	2d00      	cmp	r5, #0
 8009b8e:	d147      	bne.n	8009c20 <Setup0_Process+0x1ec>
 8009b90:	8859      	ldrh	r1, [r3, #2]
 8009b92:	2900      	cmp	r1, #0
 8009b94:	d171      	bne.n	8009c7a <Setup0_Process+0x246>
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
 8009b96:	685a      	ldr	r2, [r3, #4]
 8009b98:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8009b9c:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 8009ba0:	d16b      	bne.n	8009c7a <Setup0_Process+0x246>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009ba2:	781a      	ldrb	r2, [r3, #0]
 8009ba4:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
 8009ba8:	d103      	bne.n	8009bb2 <Setup0_Process+0x17e>
        && (pInformation->USBwIndex == 0))
 8009baa:	889b      	ldrh	r3, [r3, #4]
 8009bac:	2b00      	cmp	r3, #0
 8009bae:	d059      	beq.n	8009c64 <Setup0_Process+0x230>
 8009bb0:	e063      	b.n	8009c7a <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009bb2:	2a01      	cmp	r2, #1
 8009bb4:	d109      	bne.n	8009bca <Setup0_Process+0x196>
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
 8009bb6:	4a58      	ldr	r2, [pc, #352]	; (8009d18 <Setup0_Process+0x2e4>)
 8009bb8:	7958      	ldrb	r0, [r3, #5]
 8009bba:	6812      	ldr	r2, [r2, #0]
 8009bbc:	6993      	ldr	r3, [r2, #24]
 8009bbe:	4798      	blx	r3
 8009bc0:	2800      	cmp	r0, #0
 8009bc2:	d15a      	bne.n	8009c7a <Setup0_Process+0x246>
          && (pInformation->Current_Configuration != 0))
 8009bc4:	6823      	ldr	r3, [r4, #0]
 8009bc6:	7a9b      	ldrb	r3, [r3, #10]
 8009bc8:	e028      	b.n	8009c1c <Setup0_Process+0x1e8>
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8009bca:	2a02      	cmp	r2, #2
 8009bcc:	d155      	bne.n	8009c7a <Setup0_Process+0x246>
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 8009bce:	795b      	ldrb	r3, [r3, #5]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009bd0:	4854      	ldr	r0, [pc, #336]	; (8009d24 <Setup0_Process+0x2f0>)
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 8009bd2:	f003 020f 	and.w	r2, r3, #15
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
 8009bd6:	f013 0f80 	tst.w	r3, #128	; 0x80

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;
 8009bda:	f003 0170 	and.w	r1, r3, #112	; 0x70
 8009bde:	ea4f 0382 	mov.w	r3, r2, lsl #2

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009be2:	bf15      	itete	ne
 8009be4:	f103 4380 	addne.w	r3, r3, #1073741824	; 0x40000000
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009be8:	f103 4380 	addeq.w	r3, r3, #1073741824	; 0x40000000

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009bec:	f503 43b8 	addne.w	r3, r3, #23552	; 0x5c00
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009bf0:	f503 43b8 	addeq.w	r3, r3, #23552	; 0x5c00

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009bf4:	bf14      	ite	ne
 8009bf6:	681b      	ldrne	r3, [r3, #0]
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009bf8:	681b      	ldreq	r3, [r3, #0]
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009bfa:	7800      	ldrb	r0, [r0, #0]

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 8009bfc:	bf14      	ite	ne
 8009bfe:	f003 0330 	andne.w	r3, r3, #48	; 0x30
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8009c02:	f403 5340 	andeq.w	r3, r3, #12288	; 0x3000
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 8009c06:	4282      	cmp	r2, r0
 8009c08:	bf2c      	ite	cs
 8009c0a:	2200      	movcs	r2, #0
 8009c0c:	2201      	movcc	r2, #1
 8009c0e:	2900      	cmp	r1, #0
 8009c10:	bf14      	ite	ne
 8009c12:	2200      	movne	r2, #0
 8009c14:	f002 0201 	andeq.w	r2, r2, #1
 8009c18:	2a00      	cmp	r2, #0
 8009c1a:	d02e      	beq.n	8009c7a <Setup0_Process+0x246>
          && (Status != 0))
 8009c1c:	bb13      	cbnz	r3, 8009c64 <Setup0_Process+0x230>
 8009c1e:	e02c      	b.n	8009c7a <Setup0_Process+0x246>
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
 8009c20:	2d08      	cmp	r5, #8
 8009c22:	d106      	bne.n	8009c32 <Setup0_Process+0x1fe>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009c24:	781b      	ldrb	r3, [r3, #0]
 8009c26:	f013 0f7f 	tst.w	r3, #127	; 0x7f
    {
      CopyRoutine = Standard_GetConfiguration;
 8009c2a:	bf08      	it	eq
 8009c2c:	4b3e      	ldreq	r3, [pc, #248]	; (8009d28 <Setup0_Process+0x2f4>)
  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8009c2e:	d01c      	beq.n	8009c6a <Setup0_Process+0x236>
 8009c30:	e023      	b.n	8009c7a <Setup0_Process+0x246>
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
 8009c32:	2d0a      	cmp	r5, #10
 8009c34:	d121      	bne.n	8009c7a <Setup0_Process+0x246>
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8009c36:	781a      	ldrb	r2, [r3, #0]
 8009c38:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8009c3c:	2a01      	cmp	r2, #1
 8009c3e:	d11c      	bne.n	8009c7a <Setup0_Process+0x246>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
 8009c40:	7a9a      	ldrb	r2, [r3, #10]
 8009c42:	b1d2      	cbz	r2, 8009c7a <Setup0_Process+0x246>
 8009c44:	8859      	ldrh	r1, [r3, #2]
 8009c46:	b9c1      	cbnz	r1, 8009c7a <Setup0_Process+0x246>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
 8009c48:	685a      	ldr	r2, [r3, #4]
 8009c4a:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8009c4e:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8009c52:	d112      	bne.n	8009c7a <Setup0_Process+0x246>
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 8009c54:	4a30      	ldr	r2, [pc, #192]	; (8009d18 <Setup0_Process+0x2e4>)
 8009c56:	7958      	ldrb	r0, [r3, #5]
 8009c58:	6812      	ldr	r2, [r2, #0]
 8009c5a:	6993      	ldr	r3, [r2, #24]
 8009c5c:	4798      	blx	r3
    {
      CopyRoutine = Standard_GetInterface;
 8009c5e:	4b33      	ldr	r3, [pc, #204]	; (8009d2c <Setup0_Process+0x2f8>)
  else if (Request_No == GET_INTERFACE)
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 8009c60:	b118      	cbz	r0, 8009c6a <Setup0_Process+0x236>
 8009c62:	e00a      	b.n	8009c7a <Setup0_Process+0x246>
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
          && (Status != 0))
      {
        CopyRoutine = Standard_GetStatus;
 8009c64:	4b32      	ldr	r3, [pc, #200]	; (8009d30 <Setup0_Process+0x2fc>)
 8009c66:	e000      	b.n	8009c6a <Setup0_Process+0x236>
      CopyRoutine = Standard_GetInterface;
    }

  }
  
  if (CopyRoutine)
 8009c68:	b13b      	cbz	r3, 8009c7a <Setup0_Process+0x246>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
 8009c6a:	6822      	ldr	r2, [r4, #0]
 8009c6c:	2100      	movs	r1, #0
 8009c6e:	8251      	strh	r1, [r2, #18]
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
 8009c70:	6193      	str	r3, [r2, #24]
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
 8009c72:	2000      	movs	r0, #0
 8009c74:	4798      	blx	r3
    Result = USB_SUCCESS;
 8009c76:	2000      	movs	r0, #0
 8009c78:	e00a      	b.n	8009c90 <Setup0_Process+0x25c>
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
 8009c7a:	4b27      	ldr	r3, [pc, #156]	; (8009d18 <Setup0_Process+0x2e4>)
 8009c7c:	6822      	ldr	r2, [r4, #0]
 8009c7e:	681b      	ldr	r3, [r3, #0]
 8009c80:	7850      	ldrb	r0, [r2, #1]
 8009c82:	691b      	ldr	r3, [r3, #16]
 8009c84:	4798      	blx	r3
    if (Result == USB_NOT_READY)
 8009c86:	2803      	cmp	r0, #3
    {
      pInformation->ControlState = PAUSE;
 8009c88:	bf04      	itt	eq
 8009c8a:	4b21      	ldreq	r3, [pc, #132]	; (8009d10 <Setup0_Process+0x2dc>)
 8009c8c:	681b      	ldreq	r3, [r3, #0]
    Result = USB_SUCCESS;
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    if (Result == USB_NOT_READY)
 8009c8e:	d006      	beq.n	8009c9e <Setup0_Process+0x26a>
      pInformation->ControlState = PAUSE;
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
 8009c90:	4b1f      	ldr	r3, [pc, #124]	; (8009d10 <Setup0_Process+0x2dc>)
 8009c92:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009c96:	681b      	ldr	r3, [r3, #0]
 8009c98:	8a1a      	ldrh	r2, [r3, #16]
 8009c9a:	428a      	cmp	r2, r1
 8009c9c:	d101      	bne.n	8009ca2 <Setup0_Process+0x26e>
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
 8009c9e:	2209      	movs	r2, #9
 8009ca0:	e003      	b.n	8009caa <Setup0_Process+0x276>
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
 8009ca2:	2802      	cmp	r0, #2
 8009ca4:	d000      	beq.n	8009ca8 <Setup0_Process+0x274>
 8009ca6:	b912      	cbnz	r2, 8009cae <Setup0_Process+0x27a>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
 8009ca8:	2208      	movs	r2, #8
 8009caa:	721a      	strb	r2, [r3, #8]
 8009cac:	e02b      	b.n	8009d06 <Setup0_Process+0x2d2>
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
 8009cae:	f993 1000 	ldrsb.w	r1, [r3]
 8009cb2:	2900      	cmp	r1, #0
 8009cb4:	da21      	bge.n	8009cfa <Setup0_Process+0x2c6>
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
 8009cb6:	88d9      	ldrh	r1, [r3, #6]
 8009cb8:	9101      	str	r1, [sp, #4]
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8009cba:	9801      	ldr	r0, [sp, #4]
 8009cbc:	4282      	cmp	r2, r0
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
 8009cbe:	bf84      	itt	hi
 8009cc0:	9a01      	ldrhi	r2, [sp, #4]
 8009cc2:	821a      	strhhi	r2, [r3, #16]
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8009cc4:	d811      	bhi.n	8009cea <Setup0_Process+0x2b6>
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    }
    
    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
 8009cc6:	428a      	cmp	r2, r1
 8009cc8:	d20f      	bcs.n	8009cea <Setup0_Process+0x2b6>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
 8009cca:	4913      	ldr	r1, [pc, #76]	; (8009d18 <Setup0_Process+0x2e4>)
 8009ccc:	6809      	ldr	r1, [r1, #0]
 8009cce:	f891 102c 	ldrb.w	r1, [r1, #44]	; 0x2c
 8009cd2:	428a      	cmp	r2, r1
 8009cd4:	d201      	bcs.n	8009cda <Setup0_Process+0x2a6>
      {
        Data_Mul_MaxPacketSize = FALSE;
 8009cd6:	2100      	movs	r1, #0
 8009cd8:	e005      	b.n	8009ce6 <Setup0_Process+0x2b2>
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
 8009cda:	fb92 f0f1 	sdiv	r0, r2, r1
 8009cde:	fb01 2210 	mls	r2, r1, r0, r2
 8009ce2:	b912      	cbnz	r2, 8009cea <Setup0_Process+0x2b6>
      {
        Data_Mul_MaxPacketSize = TRUE;
 8009ce4:	2101      	movs	r1, #1
 8009ce6:	4a13      	ldr	r2, [pc, #76]	; (8009d34 <Setup0_Process+0x300>)
 8009ce8:	7011      	strb	r1, [r2, #0]
      }
    }   

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
 8009cea:	4a0b      	ldr	r2, [pc, #44]	; (8009d18 <Setup0_Process+0x2e4>)
 8009cec:	6812      	ldr	r2, [r2, #0]
 8009cee:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8009cf2:	829a      	strh	r2, [r3, #20]
    DataStageIn();
 8009cf4:	f7ff fc5c 	bl	80095b0 <DataStageIn>
 8009cf8:	e005      	b.n	8009d06 <Setup0_Process+0x2d2>
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
 8009cfa:	2203      	movs	r2, #3
 8009cfc:	721a      	strb	r2, [r3, #8]
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
 8009cfe:	4b0e      	ldr	r3, [pc, #56]	; (8009d38 <Setup0_Process+0x304>)
 8009d00:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8009d04:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
 8009d06:	f7ff fdf5 	bl	80098f4 <Post0_Process>
}
 8009d0a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009d0c:	40005c50 	.word	0x40005c50
 8009d10:	20003794 	.word	0x20003794
 8009d14:	20003004 	.word	0x20003004
 8009d18:	2000378c 	.word	0x2000378c
 8009d1c:	20003002 	.word	0x20003002
 8009d20:	200037a4 	.word	0x200037a4
 8009d24:	20003798 	.word	0x20003798
 8009d28:	080094bd 	.word	0x080094bd
 8009d2c:	080094e1 	.word	0x080094e1
 8009d30:	08009505 	.word	0x08009505
 8009d34:	20000c14 	.word	0x20000c14
 8009d38:	200037a2 	.word	0x200037a2

08009d3c <SetDeviceAddress>:
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(uint8_t Val)
{
 8009d3c:	b530      	push	{r4, r5, lr}
#ifdef STM32F10X_CL 
  PCD_EP_SetAddress ((uint8_t)Val);
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;
 8009d3e:	4b0f      	ldr	r3, [pc, #60]	; (8009d7c <SetDeviceAddress+0x40>)
 8009d40:	f893 c000 	ldrb.w	ip, [r3]

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 8009d44:	2300      	movs	r3, #0
 8009d46:	e012      	b.n	8009d6e <SetDeviceAddress+0x32>
 8009d48:	b2da      	uxtb	r2, r3
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
 8009d4a:	0091      	lsls	r1, r2, #2
 8009d4c:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8009d50:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 8009d54:	680d      	ldr	r5, [r1, #0]
 8009d56:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009d5a:	f042 0480 	orr.w	r4, r2, #128	; 0x80
 8009d5e:	f640 720f 	movw	r2, #3855	; 0xf0f
 8009d62:	ea05 0202 	and.w	r2, r5, r2
 8009d66:	ea44 0202 	orr.w	r2, r4, r2
 8009d6a:	600a      	str	r2, [r1, #0]
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 8009d6c:	3301      	adds	r3, #1
 8009d6e:	4563      	cmp	r3, ip
 8009d70:	d3ea      	bcc.n	8009d48 <SetDeviceAddress+0xc>
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
 8009d72:	4b03      	ldr	r3, [pc, #12]	; (8009d80 <SetDeviceAddress+0x44>)
 8009d74:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8009d78:	6018      	str	r0, [r3, #0]
#endif  /* STM32F10X_CL */  
}
 8009d7a:	bd30      	pop	{r4, r5, pc}
 8009d7c:	20003798 	.word	0x20003798
 8009d80:	40005c4c 	.word	0x40005c4c

08009d84 <In0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t In0_Process(void)
{
 8009d84:	b510      	push	{r4, lr}
  uint32_t ControlState = pInformation->ControlState;
 8009d86:	4c16      	ldr	r4, [pc, #88]	; (8009de0 <In0_Process+0x5c>)
 8009d88:	6823      	ldr	r3, [r4, #0]
 8009d8a:	7a1a      	ldrb	r2, [r3, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8009d8c:	2a02      	cmp	r2, #2
 8009d8e:	bf14      	ite	ne
 8009d90:	2100      	movne	r1, #0
 8009d92:	2101      	moveq	r1, #1
 8009d94:	2a04      	cmp	r2, #4
 8009d96:	bf08      	it	eq
 8009d98:	f041 0101 	orreq.w	r1, r1, #1
 8009d9c:	b121      	cbz	r1, 8009da8 <In0_Process+0x24>
  {
    DataStageIn();
 8009d9e:	f7ff fc07 	bl	80095b0 <DataStageIn>
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
 8009da2:	6823      	ldr	r3, [r4, #0]
 8009da4:	7a1b      	ldrb	r3, [r3, #8]
 8009da6:	e014      	b.n	8009dd2 <In0_Process+0x4e>
  }

  else if (ControlState == WAIT_STATUS_IN)
 8009da8:	2a06      	cmp	r2, #6
 8009daa:	d111      	bne.n	8009dd0 <In0_Process+0x4c>
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8009dac:	785a      	ldrb	r2, [r3, #1]
 8009dae:	2a05      	cmp	r2, #5
 8009db0:	d10a      	bne.n	8009dc8 <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 8009db2:	781a      	ldrb	r2, [r3, #0]
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8009db4:	f012 0f7f 	tst.w	r2, #127	; 0x7f
 8009db8:	d106      	bne.n	8009dc8 <In0_Process+0x44>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
 8009dba:	78d8      	ldrb	r0, [r3, #3]
 8009dbc:	f7ff ffbe 	bl	8009d3c <SetDeviceAddress>
      pUser_Standard_Requests->User_SetDeviceAddress();
 8009dc0:	4b08      	ldr	r3, [pc, #32]	; (8009de4 <In0_Process+0x60>)
 8009dc2:	681b      	ldr	r3, [r3, #0]
 8009dc4:	6a1b      	ldr	r3, [r3, #32]
 8009dc6:	4798      	blx	r3
    }
    (*pProperty->Process_Status_IN)();
 8009dc8:	4b07      	ldr	r3, [pc, #28]	; (8009de8 <In0_Process+0x64>)
 8009dca:	681b      	ldr	r3, [r3, #0]
 8009dcc:	689b      	ldr	r3, [r3, #8]
 8009dce:	4798      	blx	r3
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
 8009dd0:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
 8009dd2:	4a03      	ldr	r2, [pc, #12]	; (8009de0 <In0_Process+0x5c>)
 8009dd4:	6812      	ldr	r2, [r2, #0]
 8009dd6:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
 8009dd8:	f7ff fd8c 	bl	80098f4 <Post0_Process>
}
 8009ddc:	bd10      	pop	{r4, pc}
 8009dde:	bf00      	nop
 8009de0:	20003794 	.word	0x20003794
 8009de4:	20003790 	.word	0x20003790
 8009de8:	2000378c 	.word	0x2000378c

08009dec <NOP_Process>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
}
 8009dec:	4770      	bx	lr
	...

08009df0 <CTR_LP>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
 8009df0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint16_t wEPVal = 0;
 8009df2:	2200      	movs	r2, #0
 8009df4:	f8ad 2006 	strh.w	r2, [sp, #6]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009df8:	4f54      	ldr	r7, [pc, #336]	; (8009f4c <CTR_LP+0x15c>)
 8009dfa:	4e55      	ldr	r6, [pc, #340]	; (8009f50 <CTR_LP+0x160>)
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8009dfc:	e09d      	b.n	8009f3a <CTR_LP+0x14a>
  {
    /* extract highest priority endpoint number */
    EPindex = (uint8_t)(wIstr & ISTR_EP_ID);
    if (EPindex == 0)
 8009dfe:	f013 050f 	ands.w	r5, r3, #15
 8009e02:	d171      	bne.n	8009ee8 <CTR_LP+0xf8>

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009e04:	683a      	ldr	r2, [r7, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8009e06:	f013 0f10 	tst.w	r3, #16

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009e0a:	b292      	uxth	r2, r2
 8009e0c:	8032      	strh	r2, [r6, #0]
	    SaveTState = SaveRState & EPTX_STAT;
 8009e0e:	8831      	ldrh	r1, [r6, #0]
 8009e10:	4a50      	ldr	r2, [pc, #320]	; (8009f54 <CTR_LP+0x164>)
 8009e12:	f001 0130 	and.w	r1, r1, #48	; 0x30
 8009e16:	8011      	strh	r1, [r2, #0]
	    SaveRState &=  EPRX_STAT;	
 8009e18:	8832      	ldrh	r2, [r6, #0]

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009e1a:	4c4c      	ldr	r4, [pc, #304]	; (8009f4c <CTR_LP+0x15c>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	
 8009e1c:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8009e20:	8032      	strh	r2, [r6, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8009e22:	6839      	ldr	r1, [r7, #0]
 8009e24:	f64b 72bf 	movw	r2, #49087	; 0xbfbf
 8009e28:	ea01 0202 	and.w	r2, r1, r2
 8009e2c:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8009e30:	f082 0220 	eor.w	r2, r2, #32
 8009e34:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009e38:	f042 0280 	orr.w	r2, r2, #128	; 0x80

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8009e3c:	4d44      	ldr	r5, [pc, #272]	; (8009f50 <CTR_LP+0x160>)
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8009e3e:	603a      	str	r2, [r7, #0]

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8009e40:	d108      	bne.n	8009e54 <CTR_LP+0x64>

        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */


        _ClearEP_CTR_TX(ENDP0);
 8009e42:	6822      	ldr	r2, [r4, #0]
 8009e44:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8009e48:	ea02 0303 	and.w	r3, r2, r3
 8009e4c:	6023      	str	r3, [r4, #0]
        In0_Process();
 8009e4e:	f7ff ff99 	bl	8009d84 <In0_Process>
 8009e52:	e01e      	b.n	8009e92 <CTR_LP+0xa2>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
 8009e54:	683b      	ldr	r3, [r7, #0]
 8009e56:	b29b      	uxth	r3, r3
 8009e58:	f8ad 3006 	strh.w	r3, [sp, #6]
        
        if ((wEPVal &EP_SETUP) != 0)
 8009e5c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009e60:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009e64:	d008      	beq.n	8009e78 <CTR_LP+0x88>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
 8009e66:	6822      	ldr	r2, [r4, #0]
 8009e68:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009e6c:	ea02 0303 	and.w	r3, r2, r3
 8009e70:	6023      	str	r3, [r4, #0]
          Setup0_Process();
 8009e72:	f7ff fddf 	bl	8009a34 <Setup0_Process>
 8009e76:	e00c      	b.n	8009e92 <CTR_LP+0xa2>

		      _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
 8009e78:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009e7c:	b21b      	sxth	r3, r3
 8009e7e:	2b00      	cmp	r3, #0
 8009e80:	da5b      	bge.n	8009f3a <CTR_LP+0x14a>
        {
          _ClearEP_CTR_RX(ENDP0);
 8009e82:	6822      	ldr	r2, [r4, #0]
 8009e84:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009e88:	ea02 0303 	and.w	r3, r2, r3
 8009e8c:	6023      	str	r3, [r4, #0]
          Out0_Process();
 8009e8e:	f7ff fd53 	bl	8009938 <Out0_Process>
          /* before terminate set Tx & Rx status */
     
		     _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
 8009e92:	6822      	ldr	r2, [r4, #0]
 8009e94:	f64b 73bf 	movw	r3, #49087	; 0xbfbf
 8009e98:	ea02 0303 	and.w	r3, r2, r3
 8009e9c:	882a      	ldrh	r2, [r5, #0]
 8009e9e:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 8009ea2:	b292      	uxth	r2, r2
 8009ea4:	b10a      	cbz	r2, 8009eaa <CTR_LP+0xba>
 8009ea6:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8009eaa:	4a29      	ldr	r2, [pc, #164]	; (8009f50 <CTR_LP+0x160>)
 8009eac:	8812      	ldrh	r2, [r2, #0]
 8009eae:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8009eb2:	b292      	uxth	r2, r2
 8009eb4:	b10a      	cbz	r2, 8009eba <CTR_LP+0xca>
 8009eb6:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8009eba:	4a26      	ldr	r2, [pc, #152]	; (8009f54 <CTR_LP+0x164>)
 8009ebc:	8812      	ldrh	r2, [r2, #0]
 8009ebe:	f002 0210 	and.w	r2, r2, #16
 8009ec2:	b292      	uxth	r2, r2
 8009ec4:	b10a      	cbz	r2, 8009eca <CTR_LP+0xda>
 8009ec6:	f083 0310 	eor.w	r3, r3, #16
 8009eca:	4a22      	ldr	r2, [pc, #136]	; (8009f54 <CTR_LP+0x164>)
 8009ecc:	8812      	ldrh	r2, [r2, #0]
 8009ece:	f002 0220 	and.w	r2, r2, #32
 8009ed2:	b292      	uxth	r2, r2
 8009ed4:	b10a      	cbz	r2, 8009eda <CTR_LP+0xea>
 8009ed6:	f083 0320 	eor.w	r3, r3, #32
 8009eda:	4a1f      	ldr	r2, [pc, #124]	; (8009f58 <CTR_LP+0x168>)
 8009edc:	ea43 0202 	orr.w	r2, r3, r2
 8009ee0:	4b1a      	ldr	r3, [pc, #104]	; (8009f4c <CTR_LP+0x15c>)
 8009ee2:	b292      	uxth	r2, r2
 8009ee4:	601a      	str	r2, [r3, #0]
          return;
 8009ee6:	e02f      	b.n	8009f48 <CTR_LP+0x158>
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
 8009ee8:	00ac      	lsls	r4, r5, #2
 8009eea:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8009eee:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 8009ef2:	6823      	ldr	r3, [r4, #0]
 8009ef4:	b29b      	uxth	r3, r3
 8009ef6:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & EP_CTR_RX) != 0)
 8009efa:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009efe:	b21b      	sxth	r3, r3
 8009f00:	2b00      	cmp	r3, #0
 8009f02:	da0a      	bge.n	8009f1a <CTR_LP+0x12a>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 8009f04:	6822      	ldr	r2, [r4, #0]
 8009f06:	f640 738f 	movw	r3, #3983	; 0xf8f
 8009f0a:	ea02 0303 	and.w	r3, r2, r3

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 8009f0e:	4a13      	ldr	r2, [pc, #76]	; (8009f5c <CTR_LP+0x16c>)
      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
      if ((wEPVal & EP_CTR_RX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 8009f10:	6023      	str	r3, [r4, #0]

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 8009f12:	1e6b      	subs	r3, r5, #1
 8009f14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009f18:	4798      	blx	r3

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
 8009f1a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009f1e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8009f22:	d00a      	beq.n	8009f3a <CTR_LP+0x14a>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 8009f24:	6822      	ldr	r2, [r4, #0]
 8009f26:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8009f2a:	ea02 0303 	and.w	r3, r2, r3

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 8009f2e:	4a0c      	ldr	r2, [pc, #48]	; (8009f60 <CTR_LP+0x170>)
 8009f30:	3d01      	subs	r5, #1
      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 8009f32:	6023      	str	r3, [r4, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 8009f34:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
 8009f38:	4798      	blx	r3
  // if CTR_LP() was called from a different task
  uint8_t EPindex;
  uint16_t wIstr;

  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8009f3a:	4a0a      	ldr	r2, [pc, #40]	; (8009f64 <CTR_LP+0x174>)
 8009f3c:	6813      	ldr	r3, [r2, #0]
 8009f3e:	b29b      	uxth	r3, r3
 8009f40:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8009f44:	f47f af5b 	bne.w	8009dfe <CTR_LP+0xe>
      } /* if((wEPVal & EP_CTR_TX) != 0) */

    }/* if(EPindex == 0) else */

  }/* while(...) */
}
 8009f48:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009f4a:	bf00      	nop
 8009f4c:	40005c00 	.word	0x40005c00
 8009f50:	200037a2 	.word	0x200037a2
 8009f54:	200037a4 	.word	0x200037a4
 8009f58:	ffff8080 	.word	0xffff8080
 8009f5c:	20000028 	.word	0x20000028
 8009f60:	2000000c 	.word	0x2000000c
 8009f64:	40005c44 	.word	0x40005c44

08009f68 <UserToPMABufferCopy>:
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 8009f68:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
 8009f6c:	3201      	adds	r2, #1
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 8009f6e:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 8009f72:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 8009f74:	0852      	lsrs	r2, r2, #1
 8009f76:	e008      	b.n	8009f8a <UserToPMABufferCopy+0x22>
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 8009f78:	f810 cc01 	ldrb.w	ip, [r0, #-1]
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (uint16_t) * pbUsrBuf;
 8009f7c:	f810 3c02 	ldrb.w	r3, [r0, #-2]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 8009f80:	3a01      	subs	r2, #1
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 8009f82:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
    *pdwVal++ = temp2;
 8009f86:	f821 3c04 	strh.w	r3, [r1, #-4]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 8009f8a:	3002      	adds	r0, #2
 8009f8c:	3104      	adds	r1, #4
 8009f8e:	2a00      	cmp	r2, #0
 8009f90:	d1f2      	bne.n	8009f78 <UserToPMABufferCopy+0x10>
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
    pdwVal++;
    pbUsrBuf++;
  }
}
 8009f92:	4770      	bx	lr

08009f94 <PMAToUserBufferCopy>:
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 8009f94:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
 8009f98:	3201      	adds	r2, #1
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 8009f9a:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
 8009f9e:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
 8009fa0:	0852      	lsrs	r2, r2, #1
 8009fa2:	e004      	b.n	8009fae <PMAToUserBufferCopy+0x1a>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 8009fa4:	f851 3b04 	ldr.w	r3, [r1], #4
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 8009fa8:	3a01      	subs	r2, #1
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 8009faa:	f820 3b02 	strh.w	r3, [r0], #2
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
 8009fae:	2a00      	cmp	r2, #0
 8009fb0:	d1f8      	bne.n	8009fa4 <PMAToUserBufferCopy+0x10>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
    pbUsrBuf++;
  }
}
 8009fb2:	4770      	bx	lr

08009fb4 <SetBTABLE>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetBTABLE(uint16_t wRegValue)
{
  _SetBTABLE(wRegValue);
 8009fb4:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 8009fb8:	4a02      	ldr	r2, [pc, #8]	; (8009fc4 <SetBTABLE+0x10>)
 8009fba:	ea00 0303 	and.w	r3, r0, r3
 8009fbe:	6013      	str	r3, [r2, #0]
}
 8009fc0:	4770      	bx	lr
 8009fc2:	bf00      	nop
 8009fc4:	40005c50 	.word	0x40005c50

08009fc8 <SetEPType>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPType(uint8_t bEpNum, uint16_t wType)
{
  _SetEPType(bEpNum, wType);
 8009fc8:	0080      	lsls	r0, r0, #2
 8009fca:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009fce:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009fd2:	6803      	ldr	r3, [r0, #0]
 8009fd4:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8009fd8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009fdc:	ea43 0101 	orr.w	r1, r3, r1
 8009fe0:	b289      	uxth	r1, r1
 8009fe2:	6001      	str	r1, [r0, #0]
}
 8009fe4:	4770      	bx	lr

08009fe6 <GetEPType>:
* Output         : None.
* Return         : Endpoint Type
*******************************************************************************/
uint16_t GetEPType(uint8_t bEpNum)
{
  return(_GetEPType(bEpNum));
 8009fe6:	0080      	lsls	r0, r0, #2
 8009fe8:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009fec:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 8009ff0:	6800      	ldr	r0, [r0, #0]
 8009ff2:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
}
 8009ff6:	4770      	bx	lr

08009ff8 <SetEPTxStatus>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(uint8_t bEpNum, uint16_t wState)
{
  _SetEPTxStatus(bEpNum, wState);
 8009ff8:	0080      	lsls	r0, r0, #2
 8009ffa:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8009ffe:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a002:	6802      	ldr	r2, [r0, #0]
 800a004:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 800a008:	ea02 0303 	and.w	r3, r2, r3
 800a00c:	f001 0210 	and.w	r2, r1, #16
 800a010:	b292      	uxth	r2, r2
 800a012:	b10a      	cbz	r2, 800a018 <SetEPTxStatus+0x20>
 800a014:	f083 0310 	eor.w	r3, r3, #16
 800a018:	f001 0120 	and.w	r1, r1, #32
 800a01c:	b289      	uxth	r1, r1
 800a01e:	b109      	cbz	r1, 800a024 <SetEPTxStatus+0x2c>
 800a020:	f083 0320 	eor.w	r3, r3, #32
 800a024:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a028:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a02c:	6003      	str	r3, [r0, #0]
}
 800a02e:	4770      	bx	lr

0800a030 <SetEPTxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxValid(uint8_t bEpNum)
{
  _SetEPTxStatus(bEpNum, EP_TX_VALID);
 800a030:	0080      	lsls	r0, r0, #2
 800a032:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a036:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a03a:	6802      	ldr	r2, [r0, #0]
 800a03c:	f648 73bf 	movw	r3, #36799	; 0x8fbf
 800a040:	ea02 0303 	and.w	r3, r2, r3
 800a044:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 800a048:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a04c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a050:	6003      	str	r3, [r0, #0]
}
 800a052:	4770      	bx	lr

0800a054 <SetEPRxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(uint8_t bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
 800a054:	0080      	lsls	r0, r0, #2
 800a056:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a05a:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a05e:	6802      	ldr	r2, [r0, #0]
 800a060:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 800a064:	ea02 0303 	and.w	r3, r2, r3
 800a068:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800a06c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a070:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a074:	6003      	str	r3, [r0, #0]
}
 800a076:	4770      	bx	lr

0800a078 <Clear_Status_Out>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(uint8_t bEpNum)
{
  _ClearEP_KIND(bEpNum);
 800a078:	0080      	lsls	r0, r0, #2
 800a07a:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a07e:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a082:	6802      	ldr	r2, [r0, #0]
 800a084:	f640 630f 	movw	r3, #3599	; 0xe0f
 800a088:	ea02 0303 	and.w	r3, r2, r3
 800a08c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a090:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a094:	6003      	str	r3, [r0, #0]
}
 800a096:	4770      	bx	lr

0800a098 <ClearDTOG_RX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(uint8_t bEpNum)
{
  _ClearDTOG_RX(bEpNum);
 800a098:	0080      	lsls	r0, r0, #2
 800a09a:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a09e:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a0a2:	6803      	ldr	r3, [r0, #0]
 800a0a4:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 800a0a8:	d009      	beq.n	800a0be <ClearDTOG_RX+0x26>
 800a0aa:	6802      	ldr	r2, [r0, #0]
 800a0ac:	f640 730f 	movw	r3, #3855	; 0xf0f
 800a0b0:	ea02 0303 	and.w	r3, r2, r3
 800a0b4:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800a0b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a0bc:	6003      	str	r3, [r0, #0]
}
 800a0be:	4770      	bx	lr

0800a0c0 <ClearDTOG_TX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(uint8_t bEpNum)
{
  _ClearDTOG_TX(bEpNum);
 800a0c0:	0080      	lsls	r0, r0, #2
 800a0c2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 800a0c6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
 800a0ca:	6803      	ldr	r3, [r0, #0]
 800a0cc:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a0d0:	d009      	beq.n	800a0e6 <ClearDTOG_TX+0x26>
 800a0d2:	6802      	ldr	r2, [r0, #0]
 800a0d4:	f640 730f 	movw	r3, #3855	; 0xf0f
 800a0d8:	ea02 0303 	and.w	r3, r2, r3
 800a0dc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a0e0:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800a0e4:	6003      	str	r3, [r0, #0]
}
 800a0e6:	4770      	bx	lr

0800a0e8 <SetEPTxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPTxAddr(bEpNum, wAddr);
 800a0e8:	4b06      	ldr	r3, [pc, #24]	; (800a104 <SetEPTxAddr+0x1c>)
 800a0ea:	0849      	lsrs	r1, r1, #1
 800a0ec:	681b      	ldr	r3, [r3, #0]
 800a0ee:	0049      	lsls	r1, r1, #1
 800a0f0:	b29b      	uxth	r3, r3
 800a0f2:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a0f6:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
 800a0fa:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
 800a0fe:	0040      	lsls	r0, r0, #1
 800a100:	6001      	str	r1, [r0, #0]
}
 800a102:	4770      	bx	lr
 800a104:	40005c50 	.word	0x40005c50

0800a108 <SetEPRxAddr>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxAddr(uint8_t bEpNum, uint16_t wAddr)
{
  _SetEPRxAddr(bEpNum, wAddr);
 800a108:	4b05      	ldr	r3, [pc, #20]	; (800a120 <SetEPRxAddr+0x18>)
 800a10a:	0849      	lsrs	r1, r1, #1
 800a10c:	681b      	ldr	r3, [r3, #0]
 800a10e:	0049      	lsls	r1, r1, #1
 800a110:	b29b      	uxth	r3, r3
 800a112:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a116:	4b03      	ldr	r3, [pc, #12]	; (800a124 <SetEPRxAddr+0x1c>)
 800a118:	18c3      	adds	r3, r0, r3
 800a11a:	005b      	lsls	r3, r3, #1
 800a11c:	6019      	str	r1, [r3, #0]
}
 800a11e:	4770      	bx	lr
 800a120:	40005c50 	.word	0x40005c50
 800a124:	20003004 	.word	0x20003004

0800a128 <GetEPTxAddr>:
* Output         : None.
* Return         : Rx buffer address. 
*******************************************************************************/
uint16_t GetEPTxAddr(uint8_t bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
 800a128:	4b05      	ldr	r3, [pc, #20]	; (800a140 <GetEPTxAddr+0x18>)
 800a12a:	681b      	ldr	r3, [r3, #0]
 800a12c:	b29b      	uxth	r3, r3
 800a12e:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800a132:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800a136:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800a13a:	005b      	lsls	r3, r3, #1
 800a13c:	8818      	ldrh	r0, [r3, #0]
}
 800a13e:	4770      	bx	lr
 800a140:	40005c50 	.word	0x40005c50

0800a144 <GetEPRxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
uint16_t GetEPRxAddr(uint8_t bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
 800a144:	4b04      	ldr	r3, [pc, #16]	; (800a158 <GetEPRxAddr+0x14>)
 800a146:	681b      	ldr	r3, [r3, #0]
 800a148:	b29b      	uxth	r3, r3
 800a14a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a14e:	4b03      	ldr	r3, [pc, #12]	; (800a15c <GetEPRxAddr+0x18>)
 800a150:	18c3      	adds	r3, r0, r3
 800a152:	005b      	lsls	r3, r3, #1
 800a154:	8818      	ldrh	r0, [r3, #0]
}
 800a156:	4770      	bx	lr
 800a158:	40005c50 	.word	0x40005c50
 800a15c:	20003004 	.word	0x20003004

0800a160 <SetEPTxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPTxCount(bEpNum, wCount);
 800a160:	4b04      	ldr	r3, [pc, #16]	; (800a174 <SetEPTxCount+0x14>)
 800a162:	681b      	ldr	r3, [r3, #0]
 800a164:	b29b      	uxth	r3, r3
 800a166:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a16a:	4b03      	ldr	r3, [pc, #12]	; (800a178 <SetEPTxCount+0x18>)
 800a16c:	18c3      	adds	r3, r0, r3
 800a16e:	005b      	lsls	r3, r3, #1
 800a170:	6019      	str	r1, [r3, #0]
}
 800a172:	4770      	bx	lr
 800a174:	40005c50 	.word	0x40005c50
 800a178:	20003002 	.word	0x20003002

0800a17c <SetEPRxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(uint8_t bEpNum, uint16_t wCount)
{
  _SetEPRxCount(bEpNum, wCount);
 800a17c:	4b0d      	ldr	r3, [pc, #52]	; (800a1b4 <SetEPRxCount+0x38>)
 800a17e:	681a      	ldr	r2, [r3, #0]
 800a180:	4b0d      	ldr	r3, [pc, #52]	; (800a1b8 <SetEPRxCount+0x3c>)
 800a182:	b292      	uxth	r2, r2
 800a184:	18d3      	adds	r3, r2, r3
 800a186:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a18a:	0040      	lsls	r0, r0, #1
 800a18c:	293e      	cmp	r1, #62	; 0x3e
 800a18e:	d909      	bls.n	800a1a4 <SetEPRxCount+0x28>
 800a190:	094b      	lsrs	r3, r1, #5
 800a192:	f011 0f1f 	tst.w	r1, #31
 800a196:	d101      	bne.n	800a19c <SetEPRxCount+0x20>
 800a198:	3b01      	subs	r3, #1
 800a19a:	b29b      	uxth	r3, r3
 800a19c:	029b      	lsls	r3, r3, #10
 800a19e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a1a2:	e005      	b.n	800a1b0 <SetEPRxCount+0x34>
 800a1a4:	084b      	lsrs	r3, r1, #1
 800a1a6:	f011 0f01 	tst.w	r1, #1
 800a1aa:	bf18      	it	ne
 800a1ac:	3301      	addne	r3, #1
 800a1ae:	029b      	lsls	r3, r3, #10
 800a1b0:	6003      	str	r3, [r0, #0]
}
 800a1b2:	4770      	bx	lr
 800a1b4:	40005c50 	.word	0x40005c50
 800a1b8:	20003006 	.word	0x20003006

0800a1bc <GetEPRxCount>:
* Output         : None.
* Return         : Rx count value.
*******************************************************************************/
uint16_t GetEPRxCount(uint8_t bEpNum)
{
  return(_GetEPRxCount(bEpNum));
 800a1bc:	4b05      	ldr	r3, [pc, #20]	; (800a1d4 <GetEPRxCount+0x18>)
 800a1be:	681b      	ldr	r3, [r3, #0]
 800a1c0:	b29b      	uxth	r3, r3
 800a1c2:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800a1c6:	4b04      	ldr	r3, [pc, #16]	; (800a1d8 <GetEPRxCount+0x1c>)
 800a1c8:	18c3      	adds	r3, r0, r3
 800a1ca:	005b      	lsls	r3, r3, #1
 800a1cc:	6818      	ldr	r0, [r3, #0]
 800a1ce:	0580      	lsls	r0, r0, #22
 800a1d0:	0d80      	lsrs	r0, r0, #22
}
 800a1d2:	4770      	bx	lr
 800a1d4:	40005c50 	.word	0x40005c50
 800a1d8:	20003006 	.word	0x20003006

0800a1dc <ByteSwap>:
uint16_t ByteSwap(uint16_t wSwW)
{
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
 800a1dc:	b2c3      	uxtb	r3, r0
 800a1de:	0a00      	lsrs	r0, r0, #8
* Input          : wSwW: word to Swap.
* Output         : None.
* Return         : resulted word.
*******************************************************************************/
uint16_t ByteSwap(uint16_t wSwW)
{
 800a1e0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
  return(wRet);
}
 800a1e4:	4770      	bx	lr
	...

0800a1e8 <APP_LCD_Data>:
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 800a1e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a1ea:	4c16      	ldr	r4, [pc, #88]	; (800a244 <APP_LCD_Data+0x5c>)
// Sends data byte to LCD
// IN: data byte in <data>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
 800a1ec:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a1ee:	7820      	ldrb	r0, [r4, #0]
 800a1f0:	2501      	movs	r5, #1
 800a1f2:	fa15 f200 	lsls.w	r2, r5, r0
 800a1f6:	4e14      	ldr	r6, [pc, #80]	; (800a248 <APP_LCD_Data+0x60>)
 800a1f8:	6833      	ldr	r3, [r6, #0]
 800a1fa:	421a      	tst	r2, r3
    return -1;
 800a1fc:	bf08      	it	eq
 800a1fe:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Data(u8 data)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a202:	d01d      	beq.n	800a240 <APP_LCD_Data+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 800a204:	f640 11c4 	movw	r1, #2500	; 0x9c4
 800a208:	f7fd f8bc 	bl	8007384 <MIOS32_BOARD_J15_PollUnbusy>
 800a20c:	2800      	cmp	r0, #0
 800a20e:	da08      	bge.n	800a222 <APP_LCD_Data+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a210:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 800a212:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a216:	409d      	lsls	r5, r3
 800a218:	6833      	ldr	r3, [r6, #0]
 800a21a:	ea23 0505 	bic.w	r5, r3, r5
 800a21e:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 800a220:	e00e      	b.n	800a240 <APP_LCD_Data+0x58>
  }

  // write data
  MIOS32_BOARD_J15_DataSet(data);
 800a222:	4638      	mov	r0, r7
 800a224:	f7fd f81c 	bl	8007260 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(1);
 800a228:	4628      	mov	r0, r5
 800a22a:	f7fd f879 	bl	8007320 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a22e:	4629      	mov	r1, r5
 800a230:	7820      	ldrb	r0, [r4, #0]
 800a232:	f7fd f88d 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a236:	7820      	ldrb	r0, [r4, #0]
 800a238:	2100      	movs	r1, #0
 800a23a:	f7fd f889 	bl	8007350 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 800a23e:	2000      	movs	r0, #0
}
 800a240:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a242:	bf00      	nop
 800a244:	200007a7 	.word	0x200007a7
 800a248:	20000c18 	.word	0x20000c18

0800a24c <APP_LCD_Cmd>:
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 800a24c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a24e:	4c16      	ldr	r4, [pc, #88]	; (800a2a8 <APP_LCD_Cmd+0x5c>)
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 800a250:	4607      	mov	r7, r0
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a252:	7820      	ldrb	r0, [r4, #0]
 800a254:	2501      	movs	r5, #1
 800a256:	fa15 f200 	lsls.w	r2, r5, r0
 800a25a:	4e14      	ldr	r6, [pc, #80]	; (800a2ac <APP_LCD_Cmd+0x60>)
 800a25c:	6833      	ldr	r3, [r6, #0]
 800a25e:	421a      	tst	r2, r3
    return -1;
 800a260:	bf08      	it	eq
 800a262:	f04f 30ff 	moveq.w	r0, #4294967295
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
  // check if if display already has been disabled
  if( !(display_available & (1 << mios32_lcd_device)) )
 800a266:	d01d      	beq.n	800a2a4 <APP_LCD_Cmd+0x58>
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
 800a268:	f640 11c4 	movw	r1, #2500	; 0x9c4
 800a26c:	f7fd f88a 	bl	8007384 <MIOS32_BOARD_J15_PollUnbusy>
 800a270:	2800      	cmp	r0, #0
 800a272:	da08      	bge.n	800a286 <APP_LCD_Cmd+0x3a>
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a274:	7823      	ldrb	r3, [r4, #0]
    return -2; // timeout
 800a276:	f06f 0001 	mvn.w	r0, #1
    return -1;

  // wait until LCD unbusy, exit on error (timeout)
  if( MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, 2500) < 0 ) {
    // disable display
    display_available &= ~(1 << mios32_lcd_device);
 800a27a:	409d      	lsls	r5, r3
 800a27c:	6833      	ldr	r3, [r6, #0]
 800a27e:	ea23 0505 	bic.w	r5, r3, r5
 800a282:	6035      	str	r5, [r6, #0]
    return -2; // timeout
 800a284:	e00e      	b.n	800a2a4 <APP_LCD_Cmd+0x58>
  }

  // write command
  MIOS32_BOARD_J15_DataSet(cmd);
 800a286:	4638      	mov	r0, r7
 800a288:	f7fc ffea 	bl	8007260 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 800a28c:	2000      	movs	r0, #0
 800a28e:	f7fd f847 	bl	8007320 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a292:	4629      	mov	r1, r5
 800a294:	7820      	ldrb	r0, [r4, #0]
 800a296:	f7fd f85b 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a29a:	7820      	ldrb	r0, [r4, #0]
 800a29c:	2100      	movs	r1, #0
 800a29e:	f7fd f857 	bl	8007350 <MIOS32_BOARD_J15_E_Set>

  return 0; // no error
 800a2a2:	2000      	movs	r0, #0
}
 800a2a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a2a6:	bf00      	nop
 800a2a8:	200007a7 	.word	0x200007a7
 800a2ac:	20000c18 	.word	0x20000c18

0800a2b0 <APP_LCD_Init>:
// Initializes application specific LCD driver
// IN: <mode>: optional configuration
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
 800a2b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a2b2:	4606      	mov	r6, r0
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode
 800a2b4:	f04f 30ff 	mov.w	r0, #4294967295
// OUT: returns < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 800a2b8:	2e00      	cmp	r6, #0
 800a2ba:	d15b      	bne.n	800a374 <APP_LCD_Init+0xc4>
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 800a2bc:	2001      	movs	r0, #1
 800a2be:	f7fc ff6b 	bl	8007198 <MIOS32_BOARD_J15_PortInit>
 800a2c2:	2800      	cmp	r0, #0
    return -2; // failed to initialize J15
 800a2c4:	bfb8      	it	lt
 800a2c6:	f06f 0001 	mvnlt.w	r0, #1
{
  // currently only mode 0 supported
  if( mode != 0 )
    return -1; // unsupported mode

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
 800a2ca:	db53      	blt.n	800a374 <APP_LCD_Init+0xc4>
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 800a2cc:	4c2a      	ldr	r4, [pc, #168]	; (800a378 <APP_LCD_Init+0xc8>)
 800a2ce:	2501      	movs	r5, #1
 800a2d0:	7823      	ldrb	r3, [r4, #0]
 800a2d2:	4f2a      	ldr	r7, [pc, #168]	; (800a37c <APP_LCD_Init+0xcc>)
 800a2d4:	fa15 f303 	lsls.w	r3, r5, r3
 800a2d8:	683a      	ldr	r2, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 800a2da:	2038      	movs	r0, #56	; 0x38

  if( MIOS32_BOARD_J15_PortInit(APP_LCD_OUTPUT_MODE) < 0 )
    return -2; // failed to initialize J15

  // enable display by default
  display_available |= (1 << mios32_lcd_device);
 800a2dc:	4313      	orrs	r3, r2
 800a2de:	603b      	str	r3, [r7, #0]

  // initialize LCD
  MIOS32_BOARD_J15_DataSet(0x38);
 800a2e0:	f7fc ffbe 	bl	8007260 <MIOS32_BOARD_J15_DataSet>
  MIOS32_BOARD_J15_RS_Set(0);
 800a2e4:	4630      	mov	r0, r6
 800a2e6:	f7fd f81b 	bl	8007320 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a2ea:	4629      	mov	r1, r5
 800a2ec:	7820      	ldrb	r0, [r4, #0]
 800a2ee:	f7fd f82f 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a2f2:	4631      	mov	r1, r6
 800a2f4:	7820      	ldrb	r0, [r4, #0]
 800a2f6:	f7fd f82b 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_RW_Set(0);
 800a2fa:	4630      	mov	r0, r6
 800a2fc:	f7fd f81c 	bl	8007338 <MIOS32_BOARD_J15_RW_Set>
#ifdef MIOS32_DONT_USE_DELAY
  u32 delay;
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a300:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a304:	f7fd f8d0 	bl	80074a8 <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a308:	4629      	mov	r1, r5
 800a30a:	7820      	ldrb	r0, [r4, #0]
 800a30c:	f7fd f820 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a310:	4631      	mov	r1, r6
 800a312:	7820      	ldrb	r0, [r4, #0]
 800a314:	f7fd f81c 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a318:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a31c:	f7fd f8c4 	bl	80074a8 <MIOS32_DELAY_Wait_uS>
#endif

  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 1);
 800a320:	4629      	mov	r1, r5
 800a322:	7820      	ldrb	r0, [r4, #0]
 800a324:	f7fd f814 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
  MIOS32_BOARD_J15_E_Set(mios32_lcd_device, 0);
 800a328:	4631      	mov	r1, r6
 800a32a:	7820      	ldrb	r0, [r4, #0]
 800a32c:	f7fd f810 	bl	8007350 <MIOS32_BOARD_J15_E_Set>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a330:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a334:	f7fd f8b8 	bl	80074a8 <MIOS32_DELAY_Wait_uS>
#endif

  APP_LCD_Cmd(0x08); // Display Off
 800a338:	2008      	movs	r0, #8
 800a33a:	f7ff ff87 	bl	800a24c <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // Display On
 800a33e:	200c      	movs	r0, #12
 800a340:	f7ff ff84 	bl	800a24c <APP_LCD_Cmd>
  APP_LCD_Cmd(0x06); // Entry Mode
 800a344:	2006      	movs	r0, #6
 800a346:	f7ff ff81 	bl	800a24c <APP_LCD_Cmd>
  APP_LCD_Cmd(0x01); // Clear Display
 800a34a:	4628      	mov	r0, r5
 800a34c:	f7ff ff7e 	bl	800a24c <APP_LCD_Cmd>
#ifdef MIOS32_DONT_USE_DELAY
  for(delay=0; delay<50000; ++delay) MIOS32_BOARD_J15_RW_Set(0); // ca. 50 mS Delay
#else
  MIOS32_DELAY_Wait_uS(50000); // exact 50 mS delay
 800a350:	f24c 3050 	movw	r0, #50000	; 0xc350
 800a354:	f7fd f8a8 	bl	80074a8 <MIOS32_DELAY_Wait_uS>
  // modify cursor mapping, so that it complies with 3-line dog displays
  u8 cursor_map[] = {0x00, 0x10, 0x20, 0x30}; // offset line 0/1/2/3
  MIOS32_LCD_CursorMapSet(cursor_map);
#endif

  APP_LCD_Cmd(0x38); // experience from PIC based MIOS: without these lines
 800a358:	2038      	movs	r0, #56	; 0x38
 800a35a:	f7ff ff77 	bl	800a24c <APP_LCD_Cmd>
  APP_LCD_Cmd(0x0c); // the LCD won't work correctly after a second APP_LCD_Init
 800a35e:	200c      	movs	r0, #12
 800a360:	f7ff ff74 	bl	800a24c <APP_LCD_Cmd>

  return (display_available & (1 << mios32_lcd_device)) ? 0 : -1; // return -1 if display not available
 800a364:	7823      	ldrb	r3, [r4, #0]
 800a366:	409d      	lsls	r5, r3
 800a368:	683b      	ldr	r3, [r7, #0]
 800a36a:	421d      	tst	r5, r3
 800a36c:	bf0c      	ite	eq
 800a36e:	f04f 30ff 	moveq.w	r0, #4294967295
 800a372:	2000      	movne	r0, #0
}
 800a374:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a376:	bf00      	nop
 800a378:	200007a7 	.word	0x200007a7
 800a37c:	20000c18 	.word	0x20000c18

0800a380 <APP_LCD_Clear>:
// Clear Screen
// IN: -
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Clear(void)
{
 800a380:	b508      	push	{r3, lr}
  // -> send clear command
  return APP_LCD_Cmd(0x01);
 800a382:	2001      	movs	r0, #1
 800a384:	f7ff ff62 	bl	800a24c <APP_LCD_Cmd>
}
 800a388:	bd08      	pop	{r3, pc}
	...

0800a38c <APP_LCD_CursorSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 800a38c:	2903      	cmp	r1, #3
// Sets cursor to given position
// IN: <column> and <line>
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
 800a38e:	b508      	push	{r3, lr}
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
    return -1;
 800a390:	bf88      	it	hi
 800a392:	f04f 30ff 	movhi.w	r0, #4294967295
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_CursorSet(u16 column, u16 line)
{
  // exit with error if line is not in allowed range
  if( line >= MIOS32_LCD_MAX_MAP_LINES )
 800a396:	d807      	bhi.n	800a3a8 <APP_LCD_CursorSet+0x1c>
    return -1;

  // -> set cursor address
  return APP_LCD_Cmd(0x80 | (mios32_lcd_cursor_map[line] + column));
 800a398:	4b04      	ldr	r3, [pc, #16]	; (800a3ac <APP_LCD_CursorSet+0x20>)
 800a39a:	5c5b      	ldrb	r3, [r3, r1]
 800a39c:	1818      	adds	r0, r3, r0
 800a39e:	f060 007f 	orn	r0, r0, #127	; 0x7f
 800a3a2:	b2c0      	uxtb	r0, r0
 800a3a4:	f7ff ff52 	bl	800a24c <APP_LCD_Cmd>
}
 800a3a8:	bd08      	pop	{r3, pc}
 800a3aa:	bf00      	nop
 800a3ac:	20003780 	.word	0x20003780

0800a3b0 <APP_LCD_GCursorSet>:
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_GCursorSet(u16 x, u16 y)
{
  // n.a.
  return -1;
}
 800a3b0:	f04f 30ff 	mov.w	r0, #4294967295
 800a3b4:	4770      	bx	lr

0800a3b6 <APP_LCD_BColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BColourSet(u32 rgb)
{
  return -1; // n.a.
}
 800a3b6:	f04f 30ff 	mov.w	r0, #4294967295
 800a3ba:	4770      	bx	lr

0800a3bc <APP_LCD_FColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_FColourSet(u32 rgb)
{
  return -1; // n.a.
}
 800a3bc:	f04f 30ff 	mov.w	r0, #4294967295
 800a3c0:	4770      	bx	lr

0800a3c2 <APP_LCD_BitmapPrint>:
// Transfers a Bitmap within given boundaries to the LCD
// IN: bitmap
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BitmapPrint(mios32_lcd_bitmap_t bitmap)
{
 800a3c2:	b084      	sub	sp, #16
 800a3c4:	ab01      	add	r3, sp, #4
 800a3c6:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  return -1; // n.a.
}
 800a3ca:	f04f 30ff 	mov.w	r0, #4294967295
 800a3ce:	b004      	add	sp, #16
 800a3d0:	4770      	bx	lr
	...

0800a3d4 <__libc_init_array>:
 800a3d4:	b570      	push	{r4, r5, r6, lr}
 800a3d6:	4d0d      	ldr	r5, [pc, #52]	; (800a40c <__libc_init_array+0x38>)
 800a3d8:	4e0d      	ldr	r6, [pc, #52]	; (800a410 <__libc_init_array+0x3c>)
 800a3da:	2400      	movs	r4, #0
 800a3dc:	1b76      	subs	r6, r6, r5
 800a3de:	10b6      	asrs	r6, r6, #2
 800a3e0:	e003      	b.n	800a3ea <__libc_init_array+0x16>
 800a3e2:	f855 3b04 	ldr.w	r3, [r5], #4
 800a3e6:	4798      	blx	r3
 800a3e8:	3401      	adds	r4, #1
 800a3ea:	42b4      	cmp	r4, r6
 800a3ec:	d3f9      	bcc.n	800a3e2 <__libc_init_array+0xe>
 800a3ee:	4d09      	ldr	r5, [pc, #36]	; (800a414 <__libc_init_array+0x40>)
 800a3f0:	4e09      	ldr	r6, [pc, #36]	; (800a418 <__libc_init_array+0x44>)
 800a3f2:	f7fa fedf 	bl	80051b4 <_init>
 800a3f6:	1b76      	subs	r6, r6, r5
 800a3f8:	10b6      	asrs	r6, r6, #2
 800a3fa:	2400      	movs	r4, #0
 800a3fc:	e003      	b.n	800a406 <__libc_init_array+0x32>
 800a3fe:	f855 3b04 	ldr.w	r3, [r5], #4
 800a402:	4798      	blx	r3
 800a404:	3401      	adds	r4, #1
 800a406:	42b4      	cmp	r4, r6
 800a408:	d3f9      	bcc.n	800a3fe <__libc_init_array+0x2a>
 800a40a:	bd70      	pop	{r4, r5, r6, pc}
 800a40c:	0800b064 	.word	0x0800b064
 800a410:	0800b064 	.word	0x0800b064
 800a414:	0800b064 	.word	0x0800b064
 800a418:	0800b064 	.word	0x0800b064

0800a41c <memcpy>:
 800a41c:	2300      	movs	r3, #0
 800a41e:	e005      	b.n	800a42c <memcpy+0x10>
 800a420:	f811 c003 	ldrb.w	ip, [r1, r3]
 800a424:	3a01      	subs	r2, #1
 800a426:	f800 c003 	strb.w	ip, [r0, r3]
 800a42a:	3301      	adds	r3, #1
 800a42c:	2a00      	cmp	r2, #0
 800a42e:	d1f7      	bne.n	800a420 <memcpy+0x4>
 800a430:	4770      	bx	lr

0800a432 <memset>:
 800a432:	4603      	mov	r3, r0
 800a434:	e002      	b.n	800a43c <memset+0xa>
 800a436:	f803 1b01 	strb.w	r1, [r3], #1
 800a43a:	3a01      	subs	r2, #1
 800a43c:	2a00      	cmp	r2, #0
 800a43e:	d1fa      	bne.n	800a436 <memset+0x4>
 800a440:	4770      	bx	lr

0800a442 <strcpy>:
 800a442:	2300      	movs	r3, #0
 800a444:	5cca      	ldrb	r2, [r1, r3]
 800a446:	54c2      	strb	r2, [r0, r3]
 800a448:	3301      	adds	r3, #1
 800a44a:	2a00      	cmp	r2, #0
 800a44c:	d1fa      	bne.n	800a444 <strcpy+0x2>
 800a44e:	4770      	bx	lr

0800a450 <strlen>:
 800a450:	4603      	mov	r3, r0
 800a452:	461a      	mov	r2, r3
 800a454:	f813 1b01 	ldrb.w	r1, [r3], #1
 800a458:	2900      	cmp	r1, #0
 800a45a:	d1fa      	bne.n	800a452 <strlen+0x2>
 800a45c:	1a10      	subs	r0, r2, r0
 800a45e:	4770      	bx	lr

0800a460 <strncpy>:
 800a460:	b510      	push	{r4, lr}
 800a462:	4684      	mov	ip, r0
 800a464:	e007      	b.n	800a476 <strncpy+0x16>
 800a466:	f811 4b01 	ldrb.w	r4, [r1], #1
 800a46a:	4663      	mov	r3, ip
 800a46c:	f803 4b01 	strb.w	r4, [r3], #1
 800a470:	3a01      	subs	r2, #1
 800a472:	469c      	mov	ip, r3
 800a474:	b12c      	cbz	r4, 800a482 <strncpy+0x22>
 800a476:	2a00      	cmp	r2, #0
 800a478:	d1f5      	bne.n	800a466 <strncpy+0x6>
 800a47a:	e004      	b.n	800a486 <strncpy+0x26>
 800a47c:	f803 4b01 	strb.w	r4, [r3], #1
 800a480:	3a01      	subs	r2, #1
 800a482:	2a00      	cmp	r2, #0
 800a484:	d1fa      	bne.n	800a47c <strncpy+0x1c>
 800a486:	bd10      	pop	{r4, pc}
